; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24234.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	WinbaseIsolationAwarePrivateT_UnPgpgk
PUBLIC	IsolationAwarePrivateT_SqbjaYRiRY
PUBLIC	IsolationAwarePrivateT_SAbnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
EXTRN	GUID_NULL:BYTE
;	COMDAT IsolationAwarePrivateT_SqbjaYRiRY
_BSS	SEGMENT
IsolationAwarePrivateT_SqbjaYRiRY DD 01H DUP (?)
_BSS	ENDS
;	COMDAT IsolationAwarePrivateT_SAbnPgpgk
_BSS	SEGMENT
IsolationAwarePrivateT_SAbnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_UnPgpgk
_DATA	SEGMENT
WinbaseIsolationAwarePrivateT_UnPgpgk DQ ffffffffffffffffH
_DATA	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	??3@YAXPEAX0@Z					; operator delete
PUBLIC	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_of
PUBLIC	?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_not_of
PUBLIC	?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
PUBLIC	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
PUBLIC	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z	; std::allocator<float>::deallocate
PUBLIC	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z	; std::allocator<float>::allocate
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
PUBLIC	?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Reallocate
PUBLIC	??1TileRow@@QEAA@XZ				; TileRow::~TileRow
PUBLIC	?deallocate@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@_K@Z ; std::allocator<TileRow>::deallocate
PUBLIC	?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z ; std::allocator<TileRow>::allocate
PUBLIC	?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z ; std::vector<TileRow,std::allocator<TileRow> >::_Reallocate
PUBLIC	?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; TilePattern::setPattern
PUBLIC	?update@TilePattern@@QEAAXXZ			; TilePattern::update
PUBLIC	?setPreset@TilePattern@@QEAAXH@Z		; TilePattern::setPreset
PUBLIC	?edgeBlur@Tile@@CAMMMH@Z			; Tile::edgeBlur
PUBLIC	?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z ; Tile::corner
PUBLIC	?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z		; Tile::rotatePoint2
PUBLIC	?rotateUV@Tile@@CAXHMAEAVPoint3@@@Z		; Tile::rotateUV
PUBLIC	?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z ; Tile::uvMapping
PUBLIC	?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z ; Tile::drawTile
PUBLIC	?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ; Tile::pat_xBond
PUBLIC	?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ; Tile::pat_herring
PUBLIC	?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ; Tile::draw
PUBLIC	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
PUBLIC	?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocate
PUBLIC	??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocate
PUBLIC	??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos
PUBLIC	?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init
PUBLIC	?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
PUBLIC	??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor'
PUBLIC	??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>
PUBLIC	??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
PUBLIC	??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >
PUBLIC	??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
PUBLIC	??_C@_1BA@HLCPMHKJ@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@MGOLCOH@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA0?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1HM@KFKBNDNL@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0@ ; `string'
PUBLIC	??_C@_1HG@LGFFBGEF@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0@ ; `string'
PUBLIC	??_C@_1DI@OGPGLDJP@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?4?$AA7?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@NKHPAEJM@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA1?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5@ ; `string'
PUBLIC	??_C@_1FC@MFPKJHBG@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA1?$AA?4?$AA7?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5@ ; `string'
PUBLIC	??_C@_1CK@FBIPLABB@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FC@LEIJMHNO@?$AA0?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5?$AA?9@ ; `string'
PUBLIC	??_C@_1FC@DKDGEDND@?$AA0?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5@ ; `string'
PUBLIC	??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
PUBLIC	??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
PUBLIC	??_C@_13CGOKJPIL@?$AA?1?$AA?$AA@		; `string'
PUBLIC	??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@		; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@38d1b717
PUBLIC	__real@3dfcb924
PUBLIC	__real@3f000000
PUBLIC	__real@3f490fdb
PUBLIC	__real@3f800000
PUBLIC	__real@3f9d70a4
PUBLIC	__real@3fa9999a
PUBLIC	__real@3fb504f3
PUBLIC	__real@3fc90fdb
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@403f666666666666
PUBLIC	__real@4048f5c3
PUBLIC	__real@40490fdb
PUBLIC	__real@4096cbe4
PUBLIC	__real@40dfffc000000000
PUBLIC	__real@41fb4c0b
PUBLIC	__xmm@7fffffff7fffffff7fffffff7fffffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp_memmove:PROC
EXTRN	__imp_srand:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPEBD@Z:PROC
EXTRN	__imp_??1ios_base@std@@UEAA@XZ:PROC
EXTRN	__imp_?_Ios_base_dtor@ios_base@std@@CAXPEAV12@@Z:PROC
EXTRN	__imp_??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ:PROC
EXTRN	__imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_??5?$basic_istream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV01@AEAN@Z:PROC
EXTRN	__imp_??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QEAA@PEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z:PROC
EXTRN	__imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ:PROC
EXTRN	?smooth@@YAMMMM@Z:PROC				; smooth
EXTRN	?snoise@Perlin@@SAMM@Z:PROC			; Perlin::snoise
EXTRN	??_E?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
EXTRN	?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAAXXZ:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock
EXTRN	?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAAXXZ:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
EXTRN	?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAXAEBVlocale@2@@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue
EXTRN	?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAPEAV12@PEA_W_J@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf
EXTRN	?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAA_JXZ:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc
EXTRN	?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAHXZ:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync
EXTRN	?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAGXZ:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow
EXTRN	?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAA_JPEA_W_J@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn
EXTRN	?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAA_JPEB_W_J@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	cosf:PROC
EXTRN	fmodf:PROC
EXTRN	memcpy:PROC
EXTRN	sinf:PROC
EXTRN	sqrtf:PROC
EXTRN	__imp_?_BADOFF@std@@3_JB:QWORD
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp_??_7ios_base@std@@6B@:BYTE
EXTRN	__imp_??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	_fltused:DWORD
_BSS	SEGMENT
?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A DB 010H DUP (?) ; MaxSDK::AssetManagement::kInvalidId
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wmemcpy DD imagerel $LN4
	DD	imagerel $LN4+26
	DD	imagerel $unwind$wmemcpy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cos@@YAMM@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$?cos@@YAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fmod@@YAMMM@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$?fmod@@YAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sin@@YAMM@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$?sin@@YAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sqrt@@YAMM@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$?sqrt@@YAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$char_traits@_W@std@@SAPEA_WPEA_WPEB_W_K@Z DD imagerel $LN9
	DD	imagerel $LN9+31
	DD	imagerel $unwind$?copy@?$char_traits@_W@std@@SAPEA_WPEA_WPEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@std@@YAPEAX_K0_N@Z DD imagerel $LN12
	DD	imagerel $LN12+131
	DD	imagerel $unwind$?_Allocate@std@@YAPEAX_K0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate@std@@YAXPEAX_K1@Z DD imagerel $LN11
	DD	imagerel $LN11+110
	DD	imagerel $unwind$?_Deallocate@std@@YAXPEAX_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z DD imagerel $LN14
	DD	imagerel $LN14+110
	DD	imagerel $unwind$?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD imagerel $LN15
	DD	imagerel $LN15+124
	DD	imagerel $unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN100
	DD	imagerel $LN100+47
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z DD imagerel $LN90
	DD	imagerel $LN90+40
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@PEB_W@Z DD imagerel $LN93
	DD	imagerel $LN93+73
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@PEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN97
	DD	imagerel $LN97+50
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z DD imagerel $LN176
	DD	imagerel $LN176+141
	DD	imagerel $unwind$?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD imagerel $LN79
	DD	imagerel $LN79+78
	DD	imagerel $unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DD imagerel $LN171
	DD	imagerel $LN171+306
	DD	imagerel $unwind$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z DD imagerel $LN155
	DD	imagerel $LN155+325
	DD	imagerel $unwind$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K@Z DD imagerel $LN32
	DD	imagerel $LN32+70
	DD	imagerel $unwind$?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K0@Z DD imagerel $LN79
	DD	imagerel $LN79+171
	DD	imagerel $unwind$?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN101
	DD	imagerel $LN101+162
	DD	imagerel $unwind$?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KPEB_W_K1@Z DD imagerel $LN79
	DD	imagerel $LN79+166
	DD	imagerel $unwind$?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KPEB_W_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN102
	DD	imagerel $LN102+162
	DD	imagerel $unwind$?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KPEB_W_K1@Z DD imagerel $LN80
	DD	imagerel $LN80+140
	DD	imagerel $unwind$?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KPEB_W_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN101
	DD	imagerel $LN101+73
	DD	imagerel $unwind$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA DD imagerel ?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA
	DD	imagerel ?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z DD imagerel $LN326
	DD	imagerel $LN326+293
	DD	imagerel $unwind$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA DD imagerel ?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA+51
	DD	imagerel $unwind$?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA DD imagerel ?catch$0@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA
	DD	imagerel ?catch$0@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA+83
	DD	imagerel $unwind$?catch$0@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_N_K_N@Z DD imagerel $LN69
	DD	imagerel $LN69+142
	DD	imagerel $unwind$?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z DD imagerel $LN78
	DD	imagerel $LN78+27
	DD	imagerel $unwind$?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z DD imagerel $LN78+27
	DD	imagerel $LN78+74
	DD	imagerel $chain$0$?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z DD imagerel $LN78+74
	DD	imagerel $LN78+128
	DD	imagerel $chain$1$?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAX_K@Z DD imagerel $LN15
	DD	imagerel $LN15+29
	DD	imagerel $unwind$?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z DD imagerel $LN83
	DD	imagerel $LN83+113
	DD	imagerel $unwind$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0TileRow@@QEAA@M@Z DD imagerel $LN12
	DD	imagerel $LN12+43
	DD	imagerel $unwind$??0TileRow@@QEAA@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z DD imagerel $LN14
	DD	imagerel $LN14+114
	DD	imagerel $unwind$?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@M@std@@QEAAPEAM_K@Z DD imagerel $LN15
	DD	imagerel $LN15+128
	DD	imagerel $unwind$?allocate@?$allocator@M@std@@QEAAPEAM_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN256
	DD	imagerel $LN256+191
	DD	imagerel $unwind$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA+78
	DD	imagerel $unwind$?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAM@Z DD imagerel $LN171
	DD	imagerel $LN171+140
	DD	imagerel $unwind$?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ DD imagerel $LN66
	DD	imagerel $LN66+62
	DD	imagerel $unwind$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAXAEBM@Z DD imagerel $LN167
	DD	imagerel $LN167+140
	DD	imagerel $unwind$?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAXAEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@MV?$allocator@M@std@@@std@@IEAA_N_K@Z DD imagerel $LN78
	DD	imagerel $LN78+96
	DD	imagerel $unwind$?_Buy@?$vector@MV?$allocator@M@std@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z DD imagerel $LN132
	DD	imagerel $LN132+142
	DD	imagerel $unwind$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z@4HA DD imagerel ?catch$0@?0??_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z@4HA+40
	DD	imagerel $unwind$?catch$0@?0??_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z DD imagerel $LN95
	DD	imagerel $LN95+130
	DD	imagerel $unwind$?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IEAAXXZ DD imagerel $LN65
	DD	imagerel $LN65+52
	DD	imagerel $unwind$?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1TileRow@@QEAA@XZ DD imagerel $LN69
	DD	imagerel $LN69+70
	DD	imagerel $unwind$??1TileRow@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0TileRow@@QEAA@AEBV0@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$??0TileRow@@QEAA@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0TileRow@@QEAA@$$QEAV0@@Z DD imagerel $LN80
	DD	imagerel $LN80+86
	DD	imagerel $unwind$??0TileRow@@QEAA@$$QEAV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GTileRow@@QEAAPEAXI@Z DD imagerel $LN73
	DD	imagerel $LN73+117
	DD	imagerel $unwind$??_GTileRow@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@_K@Z DD imagerel $LN14
	DD	imagerel $LN14+111
	DD	imagerel $unwind$?deallocate@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+124
	DD	imagerel $unwind$?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD imagerel $LN175
	DD	imagerel $LN175+195
	DD	imagerel $unwind$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA DD imagerel ?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA
	DD	imagerel ?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA DD imagerel ?dtor$2@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA
	DD	imagerel ?dtor$2@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA+28
	DD	imagerel $unwind$?dtor$2@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ DD imagerel $LN35
	DD	imagerel $LN35+53
	DD	imagerel $unwind$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z DD imagerel $LN138
	DD	imagerel $LN138+178
	DD	imagerel $unwind$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z@4HA DD imagerel ?catch$0@?0??_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z@4HA+43
	DD	imagerel $unwind$?catch$0@?0??_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z DD imagerel $LN95
	DD	imagerel $LN95+130
	DD	imagerel $unwind$?_Reserve@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD imagerel $LN181
	DD	imagerel $LN181+170
	DD	imagerel $unwind$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?update@TilePattern@@QEAAXXZ DD imagerel $LN72
	DD	imagerel $LN72+36
	DD	imagerel $unwind$?update@TilePattern@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?update@TilePattern@@QEAAXXZ DD imagerel $LN72+36
	DD	imagerel $LN72+195
	DD	imagerel $chain$0$?update@TilePattern@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?update@TilePattern@@QEAAXXZ DD imagerel $LN72+195
	DD	imagerel $LN72+202
	DD	imagerel $chain$1$?update@TilePattern@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setPreset@TilePattern@@QEAAXH@Z DD imagerel $LN928
	DD	imagerel $LN928+628
	DD	imagerel $unwind$?setPreset@TilePattern@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z DD imagerel $LN90
	DD	imagerel $LN90+745
	DD	imagerel $unwind$?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z DD imagerel $LN12
	DD	imagerel $LN12+112
	DD	imagerel $unwind$?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD imagerel $LN49
	DD	imagerel $LN49+998
	DD	imagerel $unwind$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z DD imagerel $LN127
	DD	imagerel $LN127+75
	DD	imagerel $unwind$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z DD imagerel $LN127+75
	DD	imagerel $LN127+723
	DD	imagerel $chain$1$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z DD imagerel $LN127+723
	DD	imagerel $LN127+1668
	DD	imagerel $chain$2$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD imagerel $LN57
	DD	imagerel $LN57+237
	DD	imagerel $unwind$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD imagerel $LN57+237
	DD	imagerel $LN57+492
	DD	imagerel $chain$0$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD imagerel $LN57+492
	DD	imagerel $LN57+519
	DD	imagerel $chain$1$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD imagerel $LN21
	DD	imagerel $LN21+514
	DD	imagerel $unwind$?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD imagerel $LN10
	DD	imagerel $LN10+80
	DD	imagerel $unwind$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getAngle@@YAMHM@Z DD imagerel ?getAngle@@YAMHM@Z
	DD	imagerel ?getAngle@@YAMHM@Z+232
	DD	imagerel $unwind$?getAngle@@YAMHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z DD imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+208
	DD	imagerel $unwind$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z DD imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+208
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+822
	DD	imagerel $chain$8$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z DD imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+822
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+878
	DD	imagerel $chain$9$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z DD imagerel ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
	DD	imagerel ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z+636
	DD	imagerel $unwind$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z DD imagerel $LN14
	DD	imagerel $LN14+111
	DD	imagerel $unwind$?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z DD imagerel $LN15
	DD	imagerel $LN15+124
	DD	imagerel $unwind$?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z DD imagerel $LN365
	DD	imagerel $LN365+133
	DD	imagerel $unwind$?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ DD imagerel $LN74
	DD	imagerel $LN74+87
	DD	imagerel $unwind$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN138
	DD	imagerel $LN138+178
	DD	imagerel $unwind$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z@4HA DD imagerel ?catch$0@?0??_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z@4HA+43
	DD	imagerel $unwind$?catch$0@?0??_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN95
	DD	imagerel $LN95+130
	DD	imagerel $unwind$?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAXXZ DD imagerel $LN73
	DD	imagerel $LN73+76
	DD	imagerel $unwind$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z DD imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+3677
	DD	imagerel $unwind$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD imagerel ?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	imagerel ?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA+49
	DD	imagerel $unwind$?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD imagerel ?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	imagerel ?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA+49
	DD	imagerel $unwind$?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD imagerel ?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	imagerel ?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA+49
	DD	imagerel $unwind$?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD imagerel ?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	imagerel ?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD imagerel ?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	imagerel ?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA+34
	DD	imagerel $unwind$?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD imagerel $LN13
	DD	imagerel $LN13+208
	DD	imagerel $unwind$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+138
	DD	imagerel $unwind$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD imagerel $LN34
	DD	imagerel $LN34+155
	DD	imagerel $unwind$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD imagerel $LN116
	DD	imagerel $LN116+41
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD imagerel $LN116+41
	DD	imagerel $LN116+70
	DD	imagerel $chain$0$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD imagerel $LN116+70
	DD	imagerel $LN116+179
	DD	imagerel $chain$2$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD imagerel $LN116+179
	DD	imagerel $LN116+287
	DD	imagerel $chain$5$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD imagerel $LN116+287
	DD	imagerel $LN116+618
	DD	imagerel $chain$11$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD imagerel $LN116+618
	DD	imagerel $LN116+682
	DD	imagerel $chain$12$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN76
	DD	imagerel $LN76+453
	DD	imagerel $unwind$?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN57
	DD	imagerel $LN57+297
	DD	imagerel $unwind$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD imagerel $LN24
	DD	imagerel $LN24+60
	DD	imagerel $unwind$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD imagerel $LN24+60
	DD	imagerel $LN24+236
	DD	imagerel $chain$1$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD imagerel $LN24+236
	DD	imagerel $LN24+253
	DD	imagerel $chain$2$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ DD imagerel $LN22
	DD	imagerel $LN22+132
	DD	imagerel $unwind$?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+88
	DD	imagerel $unwind$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+107
	DD	imagerel $unwind$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+72
	DD	imagerel $unwind$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z DD imagerel $LN23
	DD	imagerel $LN23+62
	DD	imagerel $unwind$??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA DD imagerel ?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z DD imagerel $LN23
	DD	imagerel $LN23+62
	DD	imagerel $unwind$??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA DD imagerel ?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PEAV21@00@Z DD imagerel $LN24
	DD	imagerel $LN24+53
	DD	imagerel $unwind$??$_Umove@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PEAV21@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAPEAVTileRow@@PEAV2@00@Z DD imagerel $LN24
	DD	imagerel $LN24+53
	DD	imagerel $unwind$??$_Umove@PEAVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAPEAVTileRow@@PEAV2@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAM@?$vector@MV?$allocator@M@std@@@std@@IEAAPEAMPEAM00@Z DD imagerel $LN26
	DD	imagerel $LN26+46
	DD	imagerel $unwind$??$_Umove@PEAM@?$vector@MV?$allocator@M@std@@@std@@IEAAPEAMPEAM00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z DD imagerel $LN19
	DD	imagerel $LN19+62
	DD	imagerel $unwind$??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA DD imagerel ?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z DD imagerel $LN19
	DD	imagerel $LN19+62
	DD	imagerel $unwind$??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA DD imagerel ?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD imagerel $LN117
	DD	imagerel $LN117+226
	DD	imagerel $unwind$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+31
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD imagerel $LN130
	DD	imagerel $LN130+14
	DD	imagerel $unwind$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD imagerel $LN130+14
	DD	imagerel $LN130+184
	DD	imagerel $chain$2$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD imagerel $LN130+184
	DD	imagerel $LN130+185
	DD	imagerel $chain$3$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD imagerel $LN130+185
	DD	imagerel $LN130+220
	DD	imagerel $chain$4$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+31
	DD	imagerel $unwind$??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z DD imagerel $LN20
	DD	imagerel $LN20+49
	DD	imagerel $unwind$??$_Uninitialized_move@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z DD imagerel $LN15
	DD	imagerel $LN15+62
	DD	imagerel $unwind$??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA DD imagerel ?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z DD imagerel $LN15
	DD	imagerel $LN15+62
	DD	imagerel $unwind$??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA DD imagerel ?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA+28
	DD	imagerel $unwind$?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z DD imagerel $LN78
	DD	imagerel $LN78+69
	DD	imagerel $unwind$??$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+31
	DD	imagerel $unwind$??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z DD imagerel $LN89
	DD	imagerel $LN89+75
	DD	imagerel $unwind$??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+31
	DD	imagerel $unwind$??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move_al_unchecked@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z DD imagerel $LN10
	DD	imagerel $LN10+49
	DD	imagerel $unwind$??$_Uninitialized_move_al_unchecked@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z DD imagerel $LN76
	DD	imagerel $LN76+69
	DD	imagerel $unwind$??$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD imagerel $LN133
	DD	imagerel $LN133+146
	DD	imagerel $unwind$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA+45
	DD	imagerel $unwind$?catch$0@?0???$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z DD imagerel $LN87
	DD	imagerel $LN87+75
	DD	imagerel $unwind$??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD imagerel $LN116
	DD	imagerel $LN116+135
	DD	imagerel $unwind$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA DD imagerel ?catch$1@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA
	DD	imagerel ?catch$1@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA+45
	DD	imagerel $unwind$?catch$1@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move_al_unchecked1@MMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+49
	DD	imagerel $unwind$??$_Uninitialized_move_al_unchecked1@MMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IEAAPEAMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@1@0PEAM@Z DD imagerel $LN30
	DD	imagerel $LN30+46
	DD	imagerel $unwind$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IEAAPEAMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@1@0PEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z DD imagerel $LN74
	DD	imagerel $LN74+69
	DD	imagerel $unwind$??$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z DD imagerel $LN85
	DD	imagerel $LN85+75
	DD	imagerel $unwind$??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z DD imagerel $LN97
	DD	imagerel $LN97+89
	DD	imagerel $unwind$??$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAMPEAM@std@@YAPEAMPEAM00@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Copy_memmove@PEAMPEAM@std@@YAPEAMPEAM00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@PEAMV?$allocator@M@2@@std@@YAPEAMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@0@0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z DD imagerel $LN24
	DD	imagerel $LN24+49
	DD	imagerel $unwind$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@PEAMV?$allocator@M@2@@std@@YAPEAMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@0@0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z DD imagerel $LN93
	DD	imagerel $LN93+89
	DD	imagerel $unwind$??$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_al_unchecked@PEBMPEAMV?$allocator@M@std@@@std@@YAPEAMPEBM0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z DD imagerel $LN10
	DD	imagerel $LN10+49
	DD	imagerel $unwind$??$_Uninitialized_copy_al_unchecked@PEBMPEAMV?$allocator@M@std@@@std@@YAPEAMPEBM0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z DD imagerel $LN89
	DD	imagerel $LN89+89
	DD	imagerel $unwind$??$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_al_unchecked1@$$CBMMV?$allocator@M@std@@@std@@YAPEAMPEBM0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+49
	DD	imagerel $unwind$??$_Uninitialized_copy_al_unchecked1@$$CBMMV?$allocator@M@std@@@std@@YAPEAMPEBM0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEBMPEAM@std@@YAPEAMPEBM0PEAM@Z DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$??$_Copy_memmove@PEBMPEAM@std@@YAPEAMPEBM0PEAM@Z
pdata	ENDS
CRT$XCU	SEGMENT
?kInvalidId$initializer$@AssetManagement@MaxSDK@@3P6AXXZEA DQ FLAT:??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ; MaxSDK::AssetManagement::kInvalidId$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffff7fffffff7fffffff7fffffff
CONST	SEGMENT
__xmm@7fffffff7fffffff7fffffff7fffffff DB 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@41fb4c0b
CONST	SEGMENT
__real@41fb4c0b DD 041fb4c0br			; 31.4121
CONST	ENDS
;	COMDAT __real@40dfffc000000000
CONST	SEGMENT
__real@40dfffc000000000 DQ 040dfffc000000000r	; 32767
CONST	ENDS
;	COMDAT __real@4096cbe4
CONST	SEGMENT
__real@4096cbe4 DD 04096cbe4r			; 4.71239
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@4048f5c3
CONST	SEGMENT
__real@4048f5c3 DD 04048f5c3r			; 3.14
CONST	ENDS
;	COMDAT __real@403f666666666666
CONST	SEGMENT
__real@403f666666666666 DQ 0403f666666666666r	; 31.4
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT __real@3fb504f3
CONST	SEGMENT
__real@3fb504f3 DD 03fb504f3r			; 1.41421
CONST	ENDS
;	COMDAT __real@3fa9999a
CONST	SEGMENT
__real@3fa9999a DD 03fa9999ar			; 1.325
CONST	ENDS
;	COMDAT __real@3f9d70a4
CONST	SEGMENT
__real@3f9d70a4 DD 03f9d70a4r			; 1.23
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f490fdb
CONST	SEGMENT
__real@3f490fdb DD 03f490fdbr			; 0.785398
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dfcb924
CONST	SEGMENT
__real@3dfcb924 DD 03dfcb924r			; 0.1234
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ios_base@std@@8
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	imagerel ??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	imagerel ??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD imagerel ??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	imagerel ??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$all'
	DB	'ocator@_W@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD 01H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
	DD	098H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
	DD	imagerel ??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
	DD	imagerel ??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD imagerel ??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD 00H ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$alloca'
	DB	'tor@_W@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD 01H ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
	DD	imagerel ??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
	DD	imagerel ??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@
CONST	SEGMENT
??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@ DB ',', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13CGOKJPIL@?$AA?1?$AA?$AA@
CONST	SEGMENT
??_C@_13CGOKJPIL@?$AA?1?$AA?$AA@ DB '/', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
	DD	088H
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
	DD	098H
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DQ FLAT:??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
	DQ	FLAT:??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DQ FLAT:??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
	DQ	FLAT:??_E?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
	DQ	FLAT:?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGXZ
	DQ	FLAT:?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAGXZ
	DQ	FLAT:?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAA_JPEA_W_J@Z
	DQ	FLAT:?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAA_JPEB_W_J@Z
	DQ	FLAT:?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAPEAV12@PEA_W_J@Z
	DQ	FLAT:?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_C@_1FC@DKDGEDND@?$AA0?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5@
CONST	SEGMENT
??_C@_1FC@DKDGEDND@?$AA0?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5@ DB '0'
	DB	00H, ',', 00H, '1', 00H, ',', 00H, '.', 00H, '5', 00H, ' ', 00H
	DB	'/', 00H, ' ', 00H, '-', 00H, '.', 00H, '2', 00H, '5', 00H, ','
	DB	00H, '1', 00H, ',', 00H, '.', 00H, '5', 00H, ' ', 00H, '/', 00H
	DB	' ', 00H, '-', 00H, '.', 00H, '2', 00H, '5', 00H, ',', 00H, '1'
	DB	00H, ',', 00H, '1', 00H, ' ', 00H, '/', 00H, ' ', 00H, '-', 00H
	DB	'.', 00H, '2', 00H, '5', 00H, ',', 00H, '1', 00H, ',', 00H, '1'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@LEIJMHNO@?$AA0?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5?$AA?9@
CONST	SEGMENT
??_C@_1FC@LEIJMHNO@?$AA0?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5?$AA?9@ DB '0'
	DB	00H, ',', 00H, '1', 00H, ',', 00H, '1', 00H, ' ', 00H, '/', 00H
	DB	' ', 00H, '-', 00H, '.', 00H, '2', 00H, '5', 00H, ',', 00H, '1'
	DB	00H, ',', 00H, '.', 00H, '5', 00H, ' ', 00H, '/', 00H, ' ', 00H
	DB	'-', 00H, '.', 00H, '2', 00H, '5', 00H, ',', 00H, '1', 00H, ','
	DB	00H, '1', 00H, ' ', 00H, '/', 00H, ' ', 00H, '-', 00H, '.', 00H
	DB	'2', 00H, '5', 00H, ',', 00H, '1', 00H, ',', 00H, '.', 00H, '5'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@FBIPLABB@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@FBIPLABB@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?$AA@ DB '.'
	DB	00H, '2', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H
	DB	' ', 00H, '.', 00H, '5', 00H, ' ', 00H, '/', 00H, ' ', 00H, '0'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@MFPKJHBG@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA1?$AA?4?$AA7?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5@
CONST	SEGMENT
??_C@_1FC@MFPKJHBG@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA1?$AA?4?$AA7?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5@ DB '0'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H, ','
	DB	00H, ' ', 00H, '.', 00H, '5', 00H, ' ', 00H, '/', 00H, ' ', 00H
	DB	'1', 00H, '.', 00H, '7', 00H, '5', 00H, ',', 00H, ' ', 00H, '1'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '.', 00H, '5'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@NKHPAEJM@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA1?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5@
CONST	SEGMENT
??_C@_1EG@NKHPAEJM@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA1?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5@ DB '0'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '.', 00H, '5'
	DB	00H, ' ', 00H, '/', 00H, ' ', 00H, '1', 00H, '.', 00H, '2', 00H
	DB	'5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '.', 00H
	DB	'5', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@OGPGLDJP@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?4?$AA7?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@OGPGLDJP@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?4?$AA7?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?$AA@ DB '0'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	',', 00H, ' ', 00H, '.', 00H, '5', 00H, ' ', 00H, '/', 00H, ' '
	DB	00H, '.', 00H, '7', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '.', 00H, '5'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1HG@LGFFBGEF@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0@
CONST	SEGMENT
??_C@_1HG@LGFFBGEF@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0@ DB '.'
	DB	00H, '2', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H
	DB	' ', 00H, '.', 00H, '5', 00H, ' ', 00H, '/', 00H, ' ', 00H, '-'
	DB	00H, '.', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H
	DB	' ', 00H, '1', 00H, ' ', 00H, '/', 00H, ' ', 00H, '-', 00H, '.'
	DB	00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H
	DB	'1', 00H, ' ', 00H, '/', 00H, ' ', 00H, '-', 00H, '.', 00H, '5'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	' ', 00H, '/', 00H, ' ', 00H, '-', 00H, '.', 00H, '5', 00H, ','
	DB	00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HM@KFKBNDNL@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0@
CONST	SEGMENT
??_C@_1HM@KFKBNDNL@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0@ DB '.'
	DB	00H, '2', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H
	DB	' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '.', 00H, '5', 00H, ' '
	DB	00H, '/', 00H, ' ', 00H, '-', 00H, '.', 00H, '5', 00H, ',', 00H
	DB	' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H, ' ', 00H, '/'
	DB	00H, ' ', 00H, '-', 00H, '.', 00H, '5', 00H, ',', 00H, ' ', 00H
	DB	'1', 00H, ',', 00H, ' ', 00H, '1', 00H, ' ', 00H, '/', 00H, ' '
	DB	00H, '-', 00H, '.', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	',', 00H, ' ', 00H, '1', 00H, ' ', 00H, '/', 00H, ' ', 00H, '-'
	DB	00H, '.', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H
	DB	' ', 00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@MGOLCOH@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA0?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@MGOLCOH@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA0?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?$AA@ DB '0'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	' ', 00H, '/', 00H, ' ', 00H, '0', 00H, '.', 00H, '5', 00H, ','
	DB	00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@HLCPMHKJ@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@HLCPMHKJ@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?$AA@ DB '0'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
_DATA	SEGMENT
?kTriObjNormalXTCID@@3VClass_ID@@B DD 0730a33d7H	; kTriObjNormalXTCID
	DD	027246c55H
?pat_herring_dir@@3PAEA DB 00H				; pat_herring_dir
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	ORG $+8
?pat_herring_x@@3PAMA DD 03f800000r		; 1	; pat_herring_x
	DD	03f800000r			; 1
	DD	040200000r			; 2.5
	DD	040600000r			; 3.5
	DD	000000000r			; 0
	DD	03fc00000r			; 1.5
	DD	040200000r			; 2.5
	DD	040800000r			; 4
	DD	03f000000r			; 0.5
	DD	03fc00000r			; 1.5
	DD	040400000r			; 3
	DD	040400000r			; 3
	DD	03f000000r			; 0.5
	DD	040000000r			; 2
	DD	040000000r			; 2
	DD	040600000r			; 3.5
?pat_herring_y@@3PAMA DD 03f000000r		; 0.5	; pat_herring_y
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03fc00000r			; 1.5
	DD	040000000r			; 2
	DD	03f800000r			; 1
	DD	03fc00000r			; 1.5
	DD	040400000r			; 3
	DD	040000000r			; 2
	DD	040200000r			; 2.5
	DD	040200000r			; 2.5
	DD	040400000r			; 3
	DD	040600000r			; 3.5
	DD	040600000r			; 3.5
	DD	040800000r			; 4
?pat_herring_id@@3PAEA DB 01H				; pat_herring_id
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	02H
	DB	01H
	DB	04H
	DB	03H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	04H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEBMPEAM@std@@YAPEAMPEBM0PEAM@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_al_unchecked1@$$CBMMV?$allocator@M@std@@@std@@YAPEAMPEBM0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z DD imagerel ??$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z DD 011111H
	DD	02209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_al_unchecked@PEBMPEAMV?$allocator@M@std@@@std@@YAPEAMPEBM0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z DD imagerel ??$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z DD 011111H
	DD	02209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@PEAMV?$allocator@M@2@@std@@YAPEAMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@0@0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAMPEAM@std@@YAPEAMPEAM00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z DD imagerel ??$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z DD 011111H
	DD	02209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z DD imagerel ??$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IEAAPEAMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@1@0PEAM@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move_al_unchecked1@MMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD imagerel ??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z+28
	DD	00H
	DD	imagerel ??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z+127
	DD	0ffffffffH
	DD	imagerel ?catch$1@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$1@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA+13
	DD	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$1@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 011719H
	DD	0820eH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD imagerel ??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z+46
	DD	00H
	DD	imagerel ??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z+129
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 062019H
	DD	0d3420H
	DD	0e00e7212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z DD imagerel ??$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move_al_unchecked@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z DD imagerel ??$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z DD imagerel ??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z
	DD	0ffffffffH
	DD	imagerel ??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z+26
	DD	00H
	DD	imagerel ??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z+57
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z DD 011211H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z DD imagerel ??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z
	DD	0ffffffffH
	DD	imagerel ??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z+26
	DD	00H
	DD	imagerel ??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z+57
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z DD 011211H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 060021H
	DD	086400H
	DD	075400H
	DD	063400H
	DD	imagerel $LN130
	DD	imagerel $LN130+14
	DD	imagerel $unwind$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 021H
	DD	imagerel $LN130
	DD	imagerel $LN130+14
	DD	imagerel $unwind$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 061621H
	DD	086416H
	DD	07540dH
	DD	063405H
	DD	imagerel $LN130
	DD	imagerel $LN130+14
	DD	imagerel $unwind$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 020e01H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD imagerel ??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 082b11H
	DD	0b642bH
	DD	0a5426H
	DD	093421H
	DD	0700f5213H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z DD imagerel ??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z
	DD	0ffffffffH
	DD	imagerel ??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z+26
	DD	00H
	DD	imagerel ??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z+57
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z DD 011211H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z DD imagerel ??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z
	DD	0ffffffffH
	DD	imagerel ??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z+26
	DD	00H
	DD	imagerel ??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z+57
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z DD 011211H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAM@?$vector@MV?$allocator@M@std@@@std@@IEAAPEAMPEAM00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAPEAVTileRow@@PEAV2@00@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PEAV21@00@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z DD imagerel ??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z
	DD	0ffffffffH
	DD	imagerel ??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z+26
	DD	00H
	DD	imagerel ??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z+57
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z DD 011211H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z DD imagerel ??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z
	DD	0ffffffffH
	DD	imagerel ??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z+26
	DD	00H
	DD	imagerel ??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z+57
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z DD 011211H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ DD imagerel ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD imagerel ??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD 041419H
	DD	093414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD imagerel ??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
	DD	0ffffffffH
	DD	imagerel ??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z+39
	DD	00H
	DD	imagerel ??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z+45
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD 041819H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD 021H
	DD	imagerel $LN24
	DD	imagerel $LN24+60
	DD	imagerel $unwind$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD 041121H
	DD	077411H
	DD	066405H
	DD	imagerel $LN24
	DD	imagerel $LN24+60
	DD	imagerel $unwind$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD 061001H
	DD	095410H
	DD	083410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 052b01H
	DD	02642bH
	DD	033406H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD 080021H
	DD	04f400H
	DD	05d400H
	DD	0c7400H
	DD	0a5400H
	DD	imagerel $LN116
	DD	imagerel $LN116+41
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD 0c1f21H
	DD	04f41fH
	DD	05d41aH
	DD	06c40eH
	DD	0b6405H
	DD	0c7400H
	DD	0a5400H
	DD	imagerel $LN116
	DD	imagerel $LN116+41
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD 040721H
	DD	0c7407H
	DD	0a5400H
	DD	imagerel $LN116
	DD	imagerel $LN116+41
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD 020021H
	DD	0a5400H
	DD	imagerel $LN116
	DD	imagerel $LN116+41
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD 020521H
	DD	0a5405H
	DD	imagerel $LN116
	DD	imagerel $LN116+41
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD 030801H
	DD	0e0046208H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD imagerel ??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ+32
	DD	00H
	DD	imagerel ??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ+38
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD 021319H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD imagerel ??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z+45
	DD	00H
	DD	imagerel ??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z+136
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD 061d11H
	DD	0a641dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD imagerel ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ+79
	DD	00H
	DD	imagerel ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ+98
	DD	02H
	DD	imagerel ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ+107
	DD	00H
	DD	imagerel ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ+117
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD 041819H
	DD	0a3418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD imagerel ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z+99
	DD	00H
	DD	imagerel ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z+109
	DD	01H
	DD	imagerel ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z+131
	DD	02H
	DD	imagerel ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z+184
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD 0ffffffffH
	DD	imagerel ?dtor$3@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
	DD	01H
	DD	imagerel ?dtor$1@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
	DD	02H
	DD	imagerel ?dtor$2@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
	DD	028H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD 082211H
	DD	0d6422H
	DD	0c541dH
	DD	0b3418H
	DD	07006720aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z DD imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
	DD	0ffffffffH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+73
	DD	00H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+142
	DD	01H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+195
	DD	02H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+214
	DD	01H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+345
	DD	03H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+395
	DD	04H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+419
	DD	03H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+600
	DD	05H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+633
	DD	06H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+711
	DD	07H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+756
	DD	09H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+820
	DD	0aH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+853
	DD	0bH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+924
	DD	0cH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+964
	DD	0eH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1011
	DD	0fH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1017
	DD	010H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1089
	DD	011H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1112
	DD	012H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1172
	DD	013H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1218
	DD	015H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1582
	DD	010H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1631
	DD	016H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1653
	DD	018H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1853
	DD	016H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1864
	DD	010H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2132
	DD	01aH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2161
	DD	010H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2292
	DD	01cH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2327
	DD	010H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2666
	DD	0eH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2713
	DD	09H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2781
	DD	03H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2849
	DD	01H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2963
	DD	03H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2998
	DD	015H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+3026
	DD	018H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+3061
	DD	010H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+3117
	DD	01H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+3311
	DD	00H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+3466
	DD	0ffffffffH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+3524
	DD	00H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+3593
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$4@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	05H
	DD	imagerel ?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	06H
	DD	imagerel ?dtor$12@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	06H
	DD	imagerel ?dtor$11@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$5@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	09H
	DD	imagerel ?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0aH
	DD	imagerel ?dtor$14@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0bH
	DD	imagerel ?dtor$16@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0bH
	DD	imagerel ?dtor$15@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	09H
	DD	imagerel ?dtor$6@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0eH
	DD	imagerel ?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0eH
	DD	imagerel ?dtor$7@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	010H
	DD	imagerel ?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	011H
	DD	imagerel ?dtor$19@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	012H
	DD	imagerel ?dtor$21@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	012H
	DD	imagerel ?dtor$20@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	010H
	DD	imagerel ?dtor$8@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	010H
	DD	imagerel ?dtor$22@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	016H
	DD	imagerel ?dtor$23@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	016H
	DD	imagerel ?dtor$24@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	010H
	DD	imagerel ?dtor$25@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	010H
	DD	imagerel ?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	01aH
	DD	imagerel ?dtor$27@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	010H
	DD	imagerel ?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	01cH
	DD	imagerel ?dtor$29@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0eH
	DD	imagerel ?dtor$30@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	09H
	DD	imagerel ?dtor$31@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$32@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z DD 019930522H
	DD	021H
	DD	imagerel $stateUnwindMap$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
	DD	00H
	DD	00H
	DD	02cH
	DD	imagerel $ip2state$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
	DD	01d0H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z DD 0c3411H
	DD	03e6834H
	DD	07f0120H
	DD	0e00ff011H
	DD	0c00bd00dH
	DD	060087009H
	DD	050063007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z DD imagerel ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z
	DD	0ffffffffH
	DD	imagerel ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z+50
	DD	00H
	DD	imagerel ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z+89
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z
	DD	01H
	DD	imagerel $tryMap$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z
	DD	05H
	DD	imagerel $ip2state$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z DD 051c19H
	DD	0e00f8213H
	DD	0600c700dH
	DD	0300bH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ DD imagerel ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z DD imagerel ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
	DD	0ffffffffH
	DD	imagerel ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z+139
	DD	00H
	DD	imagerel ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z+407
	DD	0ffffffffH
	DD	imagerel ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z+543
	DD	00H
	DD	imagerel ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z+571
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z DD 0c2411H
	DD	0126424H
	DD	0115420H
	DD	010341cH
	DD	0f00c9210H
	DD	0d008e00aH
	DD	07004c006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z DD 021H
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+208
	DD	imagerel $unwind$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z DD 0106e21H
	DD	04d86eH
	DD	05c865H
	DD	06b83fH
	DD	07a839H
	DD	089833H
	DD	098819H
	DD	01ff410H
	DD	01ed408H
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+208
	DD	imagerel $unwind$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z DD 0118501H
	DD	0b6885H
	DD	02f866H
	DD	03e84fH
	DD	0a7827H
	DD	0203413H
	DD	0180113H
	DD	0c00ae00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getAngle@@YAMHM@Z DD 030a01H
	DD	02680aH
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD 0c5101H
	DD	058851H
	DD	06783bH
	DD	076826H
	DD	0136412H
	DD	0123412H
	DD	0700bf212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD 021H
	DD	imagerel $LN57
	DD	imagerel $LN57+237
	DD	imagerel $unwind$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD 020621H
	DD	076806H
	DD	imagerel $LN57
	DD	imagerel $LN57+237
	DD	imagerel $unwind$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD 081501H
	DD	0155415H
	DD	0143415H
	DD	0e00ef215H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z DD 021H
	DD	imagerel $LN127
	DD	imagerel $LN127+75
	DD	imagerel $unwind$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z DD 040a21H
	DD	07a80aH
	DD	089805H
	DD	imagerel $LN127
	DD	imagerel $LN127+75
	DD	imagerel $unwind$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z DD 0154b01H
	DD	06b84bH
	DD	098846H
	DD	0a783eH
	DD	0b6836H
	DD	01fc423H
	DD	01e7423H
	DD	01d6423H
	DD	01c3423H
	DD	0180123H
	DD	0e016f018H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD 0198e01H
	DD	03e88eH
	DD	04d888H
	DD	05c861H
	DD	06b856H
	DD	07a83eH
	DD	089839H
	DD	098834H
	DD	0a782cH
	DD	0b6824H
	DD	01b6413H
	DD	01a3413H
	DD	0180113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z DD 081f01H
	DD	02881fH
	DD	037815H
	DD	04680cH
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z DD 0134501H
	DD	05b845H
	DD	06a840H
	DD	079836H
	DD	08882dH
	DD	097828H
	DD	0a6823H
	DD	0197417H
	DD	0183417H
	DD	0160117H
	DD	0500cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setPreset@TilePattern@@QEAAXH@Z DD imagerel ?setPreset@TilePattern@@QEAAXH@Z
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+53
	DD	00H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+55
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+102
	DD	00H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+107
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+154
	DD	01H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+159
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+206
	DD	02H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+211
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+258
	DD	03H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+263
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+310
	DD	04H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+315
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+362
	DD	05H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+367
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+414
	DD	06H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+419
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+466
	DD	07H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+468
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+515
	DD	08H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+517
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+588
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setPreset@TilePattern@@QEAAXH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$3@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$4@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$5@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$6@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$7@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$8@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$9@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?setPreset@TilePattern@@QEAAXH@Z DD 019930522H
	DD	0aH
	DD	imagerel $stateUnwindMap$?setPreset@TilePattern@@QEAAXH@Z
	DD	00H
	DD	00H
	DD	016H
	DD	imagerel $ip2state$?setPreset@TilePattern@@QEAAXH@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setPreset@TilePattern@@QEAAXH@Z DD 041e11H
	DD	0c341eH
	DD	0500a9211H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?setPreset@TilePattern@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?update@TilePattern@@QEAAXXZ DD 021H
	DD	imagerel $LN72
	DD	imagerel $LN72+36
	DD	imagerel $unwind$?update@TilePattern@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?update@TilePattern@@QEAAXXZ DD 020521H
	DD	023405H
	DD	imagerel $LN72
	DD	imagerel $LN72+36
	DD	imagerel $unwind$?update@TilePattern@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?update@TilePattern@@QEAAXXZ DD 030601H
	DD	036406H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD imagerel ?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z+34
	DD	00H
	DD	imagerel ?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z+100
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 061c11H
	DD	0f641cH
	DD	0c3418H
	DD	07008920cH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z DD imagerel ?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z
	DD	0ffffffffH
	DD	imagerel ?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z+50
	DD	00H
	DD	imagerel ?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z+89
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z
	DD	01H
	DD	imagerel $tryMap$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z
	DD	05H
	DD	imagerel $ip2state$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z DD 051c19H
	DD	0e00f8213H
	DD	0600c700dH
	DD	0300bH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ DD imagerel ?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD imagerel ?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
	DD	0ffffffffH
	DD	imagerel ?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z+86
	DD	00H
	DD	imagerel ?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z+115
	DD	0ffffffffH
	DD	imagerel ?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z+150
	DD	02H
	DD	imagerel ?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z+179
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD 041411H
	DD	0a3414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GTileRow@@QEAAPEAXI@Z DD imagerel ??_GTileRow@@QEAAPEAXI@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GTileRow@@QEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???_GTileRow@@QEAAPEAXI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_GTileRow@@QEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_GTileRow@@QEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_GTileRow@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GTileRow@@QEAAPEAXI@Z DD 061d19H
	DD	0a641dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_GTileRow@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0TileRow@@QEAA@$$QEAV0@@Z DD imagerel ??0TileRow@@QEAA@$$QEAV0@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0TileRow@@QEAA@$$QEAV0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0TileRow@@QEAA@$$QEAV0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0TileRow@@QEAA@$$QEAV0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0TileRow@@QEAA@$$QEAV0@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??0TileRow@@QEAA@$$QEAV0@@Z
	DD	00H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0TileRow@@QEAA@$$QEAV0@@Z DD 011111H
	DD	02209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0TileRow@@QEAA@$$QEAV0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0TileRow@@QEAA@AEBV0@@Z DD imagerel ??0TileRow@@QEAA@AEBV0@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0TileRow@@QEAA@AEBV0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0TileRow@@QEAA@AEBV0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0TileRow@@QEAA@AEBV0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0TileRow@@QEAA@AEBV0@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??0TileRow@@QEAA@AEBV0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0TileRow@@QEAA@AEBV0@@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0TileRow@@QEAA@AEBV0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1TileRow@@QEAA@XZ DD imagerel ??1TileRow@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1TileRow@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???1TileRow@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1TileRow@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1TileRow@@QEAA@XZ
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1TileRow@@QEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1TileRow@@QEAA@XZ DD 021319H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1TileRow@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z DD imagerel ?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z
	DD	0ffffffffH
	DD	imagerel ?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z+51
	DD	00H
	DD	imagerel ?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z+71
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z
	DD	01H
	DD	imagerel $tryMap$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z
	DD	05H
	DD	imagerel $ip2state$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z DD 062019H
	DD	0d3420H
	DD	0e00e5212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@MV?$allocator@M@std@@@std@@IEAA_N_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAXAEBM@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ DD imagerel ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAM@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD imagerel ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
	DD	0ffffffffH
	DD	imagerel ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z+133
	DD	00H
	DD	imagerel ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z+166
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA+14
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
	DD	01H
	DD	imagerel $tryMap$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
	DD	05H
	DD	imagerel $ip2state$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD 082319H
	DD	0b7423H
	DD	0a641eH
	DD	093419H
	DD	0e007520bH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@M@std@@QEAAPEAM_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0TileRow@@QEAA@M@Z DD imagerel ??0TileRow@@QEAA@M@Z
	DD	0ffffffffH
	DD	imagerel ??0TileRow@@QEAA@M@Z+31
	DD	00H
	DD	imagerel ??0TileRow@@QEAA@M@Z+35
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0TileRow@@QEAA@M@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0TileRow@@QEAA@M@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0TileRow@@QEAA@M@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0TileRow@@QEAA@M@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0TileRow@@QEAA@M@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0TileRow@@QEAA@M@Z DD 011111H
	DD	02209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0TileRow@@QEAA@M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z DD imagerel ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z DD 021H
	DD	imagerel $LN78
	DD	imagerel $LN78+27
	DD	imagerel $unwind$?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z DD 020521H
	DD	066405H
	DD	imagerel $LN78
	DD	imagerel $LN78+27
	DD	imagerel $unwind$?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_N_K_N@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z DD imagerel ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z
	DD	0ffffffffH
	DD	imagerel ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z+119
	DD	00H
	DD	imagerel ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z+139
	DD	0ffffffffH
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA
	DD	00H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA+13
	DD	01H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA+21
	DD	02H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA+37
	DD	00H
	DD	imagerel ?catch$0@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA+14
	DD	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$1$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z DD 00H
	DD	00H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$1$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z
	DD	02H
	DD	imagerel $tryMap$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z
	DD	08H
	DD	imagerel $ip2state$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z
	DD	028H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z DD 062519H
	DD	0d3425H
	DD	0e0135217H
	DD	060107011H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DD imagerel ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
	DD	0ffffffffH
	DD	imagerel ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z+55
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
	DD	028H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KPEB_W_K1@Z DD 020501H
	DD	017405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z DD 032001H
	DD	03420H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KPEB_W_K1@Z DD 040a01H
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z DD 031c01H
	DD	0341cH
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD imagerel ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z DD imagerel ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@PEB_W@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate@std@@YAXPEAX_K1@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@std@@YAPEAX_K0_N@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$char_traits@_W@std@@SAPEA_WPEA_WPEB_W_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sqrt@@YAMM@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sin@@YAMM@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fmod@@YAMMM@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cos@@YAMM@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wmemcpy DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 081901H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	070153219H
xdata	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor', COMDAT
	movsxd	rax, DWORD PTR [rcx-4]
	sub	rcx, rax
	jmp	??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z PROC ; std::forward<std::vector<float,std::allocator<float> > >, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@V?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z ENDP ; std::forward<std::vector<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PEBMPEAM@std@@YAPEAMPEBM0PEAM@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEBMPEAM@std@@YAPEAMPEBM0PEAM@Z PROC	; std::_Copy_memmove<float const * __ptr64,float * __ptr64>, COMDAT

; 2301 : 	{	// implement copy-like function as memmove

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	rbx, rcx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]

; 2308 : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEBMPEAM@std@@YAPEAMPEBM0PEAM@Z ENDP	; std::_Copy_memmove<float const * __ptr64,float * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked1@$$CBMMV?$allocator@M@std@@@std@@YAPEAMPEBM0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$ = 72
__formal$ = 80
__formal$ = 88
??$_Uninitialized_copy_al_unchecked1@$$CBMMV?$allocator@M@std@@@std@@YAPEAMPEBM0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<float const ,float,std::allocator<float> >, COMDAT

; 239  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	rbx, rcx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 241  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy_al_unchecked1@$$CBMMV?$allocator@M@std@@@std@@YAPEAMPEBM0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<float const ,float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@$$CBMM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@AEBQEBMAEBQEAM@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
__formal$ = 16
__formal$ = 24
??$_Ptr_copy_cat@$$CBMM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@AEBQEBMAEBQEAM@Z PROC ; std::_Ptr_copy_cat<float const ,float>, COMDAT

; 793  : 	return {};

	mov	rax, rcx

; 794  : 	}

	ret	0
??$_Ptr_copy_cat@$$CBMM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@AEBQEBMAEBQEAM@Z ENDP ; std::_Ptr_copy_cat<float const ,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z
_TEXT	SEGMENT
$T1 = 0
this$ = 32
$T2 = 40
_Ptr$ = 40
<_Args_0>$ = 48
??$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z PROC ; std::allocator<TileRow>::construct<TileRow,TileRow>, COMDAT

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

$LN89:

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN88@construct
	sub	rsp, 24
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR $T2[rsp], rdx
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rdx+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	ecx, ecx
	mov	QWORD PTR [rdx+8], rcx

; 486  : 		_Mylast(),

	mov	QWORD PTR [rdx+16], rcx

; 487  : 		_Myend()

	mov	QWORD PTR [rdx+24], rcx

; 870  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rdx+8], rax

; 871  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [r8+16]
	mov	QWORD PTR [rdx+16], rax

; 872  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [r8+24]
	mov	QWORD PTR [rdx+24], rax

; 873  : 
; 874  : 		_Right._Myfirst() = pointer();

	mov	QWORD PTR [r8+8], rcx

; 875  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [r8+16], rcx

; 876  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [r8+24], rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	add	rsp, 24
$LN88@construct:
	ret	0
??$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z ENDP ; std::allocator<TileRow>::construct<TileRow,TileRow>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
$T2 = 40
_Ptr$ = 40
<_Args_0>$ = 48
?dtor$0@?0???$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z@4HA PROC ; `std::allocator<TileRow>::construct<TileRow,TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z@4HA ENDP ; `std::allocator<TileRow>::construct<TileRow,TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
$T2 = 40
_Ptr$ = 40
<_Args_0>$ = 48
?dtor$0@?0???$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z@4HA PROC ; `std::allocator<TileRow>::construct<TileRow,TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct@VTileRow@@V1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z@4HA ENDP ; `std::allocator<TileRow>::construct<TileRow,TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AEAU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YA$$QEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YA$$QEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@AEAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<float> > & __ptr64>, COMDAT

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	rax, rcx

; 1293 : 	}

	ret	0
??$move@AEAU?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YA$$QEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@AEAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<float> > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PEBMPEAMV?$allocator@M@std@@@std@@YAPEAMPEBM0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
??$_Uninitialized_copy_al_unchecked@PEBMPEAMV?$allocator@M@std@@@std@@YAPEAMPEBM0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<float const * __ptr64,float * __ptr64,std::allocator<float> >, COMDAT

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	rbx, rcx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 252  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy_al_unchecked@PEBMPEAMV?$allocator@M@std@@@std@@YAPEAMPEBM0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<float const * __ptr64,float * __ptr64,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@YAPEBMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Iter$ = 8
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@YAPEBMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<float> > >, COMDAT

; 272  : 	return (_Iter._Unchecked());

	mov	rax, rcx

; 273  : 	}

	ret	0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@YAPEBMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z
_TEXT	SEGMENT
$T1 = 0
_Al$ = 32
$T2 = 40
_Ptr$ = 40
<_Args_0>$ = 48
??$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z PROC ; std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

$LN93:

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN92@construct
	sub	rsp, 24
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR $T2[rsp], rdx
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rdx+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	ecx, ecx
	mov	QWORD PTR [rdx+8], rcx

; 486  : 		_Mylast(),

	mov	QWORD PTR [rdx+16], rcx

; 487  : 		_Myend()

	mov	QWORD PTR [rdx+24], rcx

; 870  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rdx+8], rax

; 871  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [r8+16]
	mov	QWORD PTR [rdx+16], rax

; 872  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [r8+24]
	mov	QWORD PTR [rdx+24], rax

; 873  : 
; 874  : 		_Right._Myfirst() = pointer();

	mov	QWORD PTR [r8+8], rcx

; 875  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [r8+16], rcx

; 876  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [r8+24], rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	add	rsp, 24
$LN92@construct:
	ret	0
??$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z ENDP ; std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Al$ = 32
$T2 = 40
_Ptr$ = 40
<_Args_0>$ = 48
?dtor$0@?0???$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z@4HA PROC ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z@4HA ENDP ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Al$ = 32
$T2 = 40
_Ptr$ = 40
<_Args_0>$ = 48
?dtor$0@?0???$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z@4HA PROC ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct@VTileRow@@V1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@$$QEAV3@@Z@4HA ENDP ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@VTileRow@@@std@@YA$$QEAVTileRow@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@VTileRow@@@std@@YA$$QEAVTileRow@@AEAV1@@Z PROC ; std::forward<TileRow>, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@VTileRow@@@std@@YA$$QEAVTileRow@@AEAV1@@Z ENDP ; std::forward<TileRow>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z PROC ; std::forward<std::allocator<float> >, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@V?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z ENDP ; std::forward<std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@PEAMV?$allocator@M@2@@std@@YAPEAMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@0@0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@PEAMV?$allocator@M@2@@std@@YAPEAMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@0@0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float> > >,float * __ptr64,std::allocator<float> >, COMDAT

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	rbx, rcx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 265  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@PEAMV?$allocator@M@2@@std@@YAPEAMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@0@0PEAMAEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float> > >,float * __ptr64,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@M@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$_Wrap_alloc@V?$allocator@M@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
_Val1$ = 24
??$?0U?$_Wrap_alloc@V?$allocator@M@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$_Wrap_alloc@V?$allocator@M@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1><std::_Wrap_alloc<std::allocator<float> > >, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	rax, rcx
	ret	0
??$?0U?$_Wrap_alloc@V?$allocator@M@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$_Wrap_alloc@V?$allocator@M@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1><std::_Wrap_alloc<std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YA$$QEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YA$$QEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@AEAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<float> > >, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@@std@@YA$$QEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@AEAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PEAMPEAM@std@@YAPEAMPEAM00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAMPEAM@std@@YAPEAMPEAM00@Z PROC	; std::_Copy_memmove<float * __ptr64,float * __ptr64>, COMDAT

; 2301 : 	{	// implement copy-like function as memmove

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	rbx, rcx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]

; 2308 : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAMPEAM@std@@YAPEAMPEAM00@Z ENDP	; std::_Copy_memmove<float * __ptr64,float * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z
_TEXT	SEGMENT
$T1 = 0
this$ = 32
$T2 = 40
_Ptr$ = 40
<_Args_0>$ = 48
??$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow>, COMDAT

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

$LN97:

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN96@construct
	sub	rsp, 24
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR $T2[rsp], rdx
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rdx+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	ecx, ecx
	mov	QWORD PTR [rdx+8], rcx

; 486  : 		_Mylast(),

	mov	QWORD PTR [rdx+16], rcx

; 487  : 		_Myend()

	mov	QWORD PTR [rdx+24], rcx

; 870  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rdx+8], rax

; 871  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [r8+16]
	mov	QWORD PTR [rdx+16], rax

; 872  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [r8+24]
	mov	QWORD PTR [rdx+24], rax

; 873  : 
; 874  : 		_Right._Myfirst() = pointer();

	mov	QWORD PTR [r8+8], rcx

; 875  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [r8+16], rcx

; 876  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [r8+24], rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	add	rsp, 24
$LN96@construct:
	ret	0
??$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
$T2 = 40
_Ptr$ = 40
<_Args_0>$ = 48
?dtor$0@?0???$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z@4HA PROC ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z@4HA ENDP ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
$T2 = 40
_Ptr$ = 40
<_Args_0>$ = 48
?dtor$0@?0???$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z@4HA PROC ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct@VTileRow@@V1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@$$QEAV2@@Z@4HA ENDP ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 743  : 		{	// destroy object at _Ptr

$LN85:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	r8, QWORD PTR [rdx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 743  : 		{	// destroy object at _Ptr

	mov	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	r8, 8
	jb	SHORT $LN11@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN11@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	ecx, ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rcx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN78@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rax], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN78@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rbx], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
??$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z PROC ; std::allocator<TileRow>::destroy<TileRow>, COMDAT

; 743  : 		{	// destroy object at _Ptr

$LN74:
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	lea	rbx, QWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rdx, QWORD PTR [rbx]
	test	rdx, rdx
	je	SHORT $LN12@destroy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	sar	r8, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN12@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z ENDP ; std::allocator<TileRow>::destroy<TileRow>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
?dtor$0@?0???$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z@4HA PROC ; `std::allocator<TileRow>::destroy<TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR _Ptr$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z@4HA ENDP ; `std::allocator<TileRow>::destroy<TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
?dtor$0@?0???$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z@4HA PROC ; `std::allocator<TileRow>::destroy<TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR _Ptr$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$destroy@VTileRow@@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@@Z@4HA ENDP ; `std::allocator<TileRow>::destroy<TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@M@std@@@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAA@$$QEAV?$allocator@M@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0V?$allocator@M@std@@@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAA@$$QEAV?$allocator@M@1@@Z PROC ; std::_Wrap_alloc<std::allocator<float> >::_Wrap_alloc<std::allocator<float> ><std::allocator<float> >, COMDAT

; 953  : 		}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@M@std@@@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAA@$$QEAV?$allocator@M@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<float> >::_Wrap_alloc<std::allocator<float> ><std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IEAAPEAMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@1@0PEAM@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Ptr$ = 72
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IEAAPEAMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@1@0PEAM@Z PROC ; std::vector<float,std::allocator<float> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float> > > >, COMDAT

; 1651 : 		{	// copy initializing [_First, _Last), using allocator

$LN30:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	sub	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1651 : 		{	// copy initializing [_First, _Last), using allocator

	mov	rdi, r9
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	QWORD PTR __imp_memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1654 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@@?$vector@MV?$allocator@M@std@@@std@@IEAAPEAMV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@1@0PEAM@Z ENDP ; std::vector<float,std::allocator<float> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QEBAPEBMXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QEBAPEBMXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float> > >::_Unchecked, COMDAT

; 61   : 		return (_Ptr);

	mov	rax, QWORD PTR [rcx]

; 62   : 		}

	ret	0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QEBAPEBMXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QEAA@PEAMPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QEAA@PEAMPEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float> > >, COMDAT

; 46   : 		: _Ptr(_Parg)

	mov	QWORD PTR [rcx], rdx

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@std@@QEAA@PEAMPEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@M@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAA@$$QEAU?$_Wrap_alloc@V?$allocator@M@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$ = 16
??$?0U?$_Wrap_alloc@V?$allocator@M@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAA@$$QEAU?$_Wrap_alloc@V?$allocator@M@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > ><std::_Wrap_alloc<std::allocator<float> >,void>, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 529  : 		}

	mov	rax, rcx
	ret	0
??$?0U?$_Wrap_alloc@V?$allocator@M@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAA@$$QEAU?$_Wrap_alloc@V?$allocator@M@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > ><std::_Wrap_alloc<std::allocator<float> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@MMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$ = 72
__formal$ = 80
__formal$ = 88
??$_Uninitialized_move_al_unchecked1@MMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<float,float,std::allocator<float> >, COMDAT

; 292  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	rbx, rcx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 294  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move_al_unchecked1@MMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<float,float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@AEBQEAM0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
__formal$ = 16
__formal$ = 24
??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@AEBQEAM0@Z PROC ; std::_Ptr_move_cat<float,float>, COMDAT

; 810  : 	return {};

	mov	rax, rcx

; 811  : 	}

	ret	0
??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@AEBQEAM0@Z ENDP ; std::_Ptr_move_cat<float,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_Next$ = 40
$T2 = 48
$T3 = 56
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
__formal$ = 112
__formal$ = 120
??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >, COMDAT

; 273  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

$LN116:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	sub	rsp, 72					; 00000048H
	mov	QWORD PTR $T2[rsp], -2

; 274  : 	_FwdIt _Next = _Dest;

	mov	QWORD PTR _Next$[rsp], r8

; 275  : 
; 276  : 	_TRY_BEGIN

	xor	r9d, r9d
	npad	1
$LL4@Uninitiali:

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	rcx, rdx
	je	SHORT $LN3@Uninitiali
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T3[rsp], r8
	test	r8, r8
	je	SHORT $LN25@Uninitiali
	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r8], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r8+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	QWORD PTR [r8+8], r9

; 486  : 		_Mylast(),

	mov	QWORD PTR [r8+16], r9

; 487  : 		_Myend()

	mov	QWORD PTR [r8+24], r9

; 870  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [r8+8], rax

; 871  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [r8+16], rax

; 872  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [r8+24], rax

; 873  : 
; 874  : 		_Right._Myfirst() = pointer();

	mov	QWORD PTR [rcx+8], r9

; 875  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [rcx+16], r9

; 876  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [rcx+24], r9
$LN25@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	add	r8, 32					; 00000020H
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 32					; 00000020H
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);

	mov	rax, r8

; 285  : 	}

	add	rsp, 72					; 00000048H
	ret	0
$LN115@Uninitiali:
??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Next$ = 40
$T2 = 48
$T3 = 56
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
__formal$ = 112
__formal$ = 120
?dtor$0@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA PROC ; `std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >'::`1'::dtor$0
	mov	rcx, QWORD PTR $T3[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA ENDP ; `std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >'::`1'::dtor$0
$T1 = 32
_Next$ = 40
$T2 = 48
$T3 = 56
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
__formal$ = 112
__formal$ = 120
?catch$1@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA PROC ; `std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >'::`1'::catch$1

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T1[rbp]
	mov	r8, QWORD PTR _Al$[rbp]
	mov	rdx, QWORD PTR _Dest$[rbp]
	mov	rcx, QWORD PTR _Next$[rbp]
	call	??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$1@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA ENDP ; `std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Next$ = 40
$T2 = 48
$T3 = 56
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
__formal$ = 112
__formal$ = 120
?dtor$0@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA PROC ; `std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >'::`1'::dtor$0
	mov	rcx, QWORD PTR $T3[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA ENDP ; `std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Next$ = 40
$T2 = 48
$T3 = 56
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
__formal$ = 112
__formal$ = 120
?catch$1@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA PROC ; `std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >'::`1'::catch$1

; 279  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T1[rbp]
	mov	r8, QWORD PTR _Al$[rbp]
	mov	rdx, QWORD PTR _Dest$[rbp]
	mov	rcx, QWORD PTR _Next$[rbp]
	call	??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 281  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$1@?0???$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA ENDP ; `std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@VTileRow@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@AEBQEAVTileRow@@0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
??$_Ptr_move_cat@VTileRow@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@AEBQEAVTileRow@@0@Z PROC ; std::_Ptr_move_cat<TileRow,TileRow>, COMDAT

; 810  : 	return {};

	xor	eax, eax

; 811  : 	}

	ret	0
??$_Ptr_move_cat@VTileRow@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@AEBQEAVTileRow@@0@Z ENDP ; std::_Ptr_move_cat<TileRow,TileRow>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AEAVTileRow@@@std@@YA$$QEAVTileRow@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAVTileRow@@@std@@YA$$QEAVTileRow@@AEAV1@@Z PROC ; std::move<TileRow & __ptr64>, COMDAT

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	rax, rcx

; 1293 : 	}

	ret	0
??$move@AEAVTileRow@@@std@@YA$$QEAVTileRow@@AEAV1@@Z ENDP ; std::move<TileRow & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 863  : 		{	// destroy object at _Ptr

$LN87:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	r8, QWORD PTR [rdx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 863  : 		{	// destroy object at _Ptr

	mov	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	r8, 8
	jb	SHORT $LN13@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN13@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	ecx, ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rcx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN80@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rax], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN80@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rbx], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QEAA@$$QEAU?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QEAA@$$QEAU?$integral_constant@_N$00@1@@Z PROC ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >, COMDAT

; 554  : 		constexpr _Any_tag(_Ty&&) _NOEXCEPT {}

	mov	rax, rcx
	ret	0
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QEAA@$$QEAU?$integral_constant@_N$00@1@@Z ENDP ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_Next$ = 40
$T2 = 48
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
__formal$ = 128
__formal$ = 136
??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 273  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

$LN133:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T2[rsp], -2
	mov	QWORD PTR [rsp+104], rbx
	mov	rbx, r8
	mov	rsi, rdx
	mov	rdi, rcx

; 274  : 	_FwdIt _Next = _Dest;

	mov	QWORD PTR _Next$[rsp], rbx

; 275  : 
; 276  : 	_TRY_BEGIN

	xor	r14d, r14d
$LL4@Uninitiali:

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	cmp	rdi, rsi
	je	SHORT $LN3@Uninitiali
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rbx, rbx
	je	SHORT $LN25@Uninitiali
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	QWORD PTR [rbx+16], r14

; 497  : 		_Myres(0)

	mov	QWORD PTR [rbx+24], r14

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], r14

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN119@Uninitiali
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN120@Uninitiali
$LN119@Uninitiali:
	mov	rax, rbx
$LN120@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rax], r14w
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	rdx, rdi
	mov	rcx, rbx
	call	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN25@Uninitiali:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	add	rbx, 32					; 00000020H
	mov	QWORD PTR _Dest$[rsp], rbx
	add	rdi, 32					; 00000020H
	mov	QWORD PTR _First$[rsp], rdi
	jmp	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;
; 282  : 	_CATCH_END
; 283  : 
; 284  : 	return (_Dest);

	mov	rax, rbx

; 285  : 	}

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN132@Uninitiali:
??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Next$ = 40
$T2 = 48
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
__formal$ = 128
__formal$ = 136
?catch$0@?0???$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA PROC ; `std::_Uninitialized_move_al_unchecked1<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >'::`1'::catch$0

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T1[rbp]
	mov	r8, QWORD PTR _Al$[rbp]
	mov	rdx, QWORD PTR _Dest$[rbp]
	mov	rcx, QWORD PTR _Next$[rbp]
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);
; 281  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA ENDP ; `std::_Uninitialized_move_al_unchecked1<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Next$ = 40
$T2 = 48
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
__formal$ = 128
__formal$ = 136
?catch$0@?0???$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA PROC ; `std::_Uninitialized_move_al_unchecked1<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >'::`1'::catch$0

; 279  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T1[rbp]
	mov	r8, QWORD PTR _Al$[rbp]
	mov	rdx, QWORD PTR _Dest$[rbp]
	mov	rcx, QWORD PTR _Next$[rbp]
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 281  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z@4HA ENDP ; `std::_Uninitialized_move_al_unchecked1<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@AEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
??$_Ptr_move_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@AEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z PROC ; std::_Ptr_move_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 810  : 	return {};

	xor	eax, eax

; 811  : 	}

	ret	0
??$_Ptr_move_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@AEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ENDP ; std::_Ptr_move_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z PROC ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & __ptr64>, COMDAT

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	rax, rcx

; 1293 : 	}

	ret	0
??$move@AEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z
_TEXT	SEGMENT
$T1 = 32
_Al$ = 64
_Ptr$ = 72
??$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z PROC ; std::allocator_traits<std::allocator<TileRow> >::destroy<TileRow>, COMDAT

; 863  : 		{	// destroy object at _Ptr

$LN76:
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	lea	rbx, QWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rdx, QWORD PTR [rbx]
	test	rdx, rdx
	je	SHORT $LN14@destroy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	sar	r8, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN14@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z ENDP ; std::allocator_traits<std::allocator<TileRow> >::destroy<TileRow>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Al$ = 64
_Ptr$ = 72
?dtor$0@?0???$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z@4HA PROC ; `std::allocator_traits<std::allocator<TileRow> >::destroy<TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR _Ptr$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z@4HA ENDP ; `std::allocator_traits<std::allocator<TileRow> >::destroy<TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Al$ = 64
_Ptr$ = 72
?dtor$0@?0???$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z@4HA PROC ; `std::allocator_traits<std::allocator<TileRow> >::destroy<TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR _Ptr$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$destroy@VTileRow@@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@@Z@4HA ENDP ; `std::allocator_traits<std::allocator<TileRow> >::destroy<TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PEA_WAEAPEA_W@?$allocator@_W@std@@QEAAXPEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEA_WAEAPEA_W@?$allocator@_W@std@@QEAAXPEAPEA_WAEAPEA_W@Z PROC ; std::allocator<wchar_t>::construct<wchar_t * __ptr64,wchar_t * __ptr64 & __ptr64>, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN3@construct:

; 738  : 		}

	ret	0
??$construct@PEA_WAEAPEA_W@?$allocator@_W@std@@QEAAXPEAPEA_WAEAPEA_W@Z ENDP ; std::allocator<wchar_t>::construct<wchar_t * __ptr64,wchar_t * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PEAMPEAM@std@@YAAEAPEAMAEAPEAMPEAM@Z
_TEXT	SEGMENT
_Dest$ = 8
_Src$ = 16
??$_Rechecked@PEAMPEAM@std@@YAAEAPEAMAEAPEAMPEAM@Z PROC	; std::_Rechecked<float * __ptr64,float * __ptr64>, COMDAT

; 458  : 	_Dest = _Src;

	mov	QWORD PTR [rcx], rdx

; 459  : 	return (_Dest);

	mov	rax, rcx

; 460  : 	}

	ret	0
??$_Rechecked@PEAMPEAM@std@@YAAEAPEAMAEAPEAMPEAM@Z ENDP	; std::_Rechecked<float * __ptr64,float * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
??$_Uninitialized_move_al_unchecked@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<float * __ptr64,float * __ptr64,std::allocator<float> >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	rbx, rcx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 306  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move_al_unchecked@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<float * __ptr64,float * __ptr64,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAM@std@@YAPEAMPEAM@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAM@std@@YAPEAMPEAM@Z PROC		; std::_Unchecked<float * __ptr64>, COMDAT

; 428  : 	return (_Src);

	mov	rax, rcx

; 429  : 	}

	ret	0
??$_Unchecked@PEAM@std@@YAPEAMPEAM@Z ENDP		; std::_Unchecked<float * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PEAVTileRow@@PEAV1@@std@@YAAEAPEAVTileRow@@AEAPEAV1@PEAV1@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Src$ = 16
??$_Rechecked@PEAVTileRow@@PEAV1@@std@@YAAEAPEAVTileRow@@AEAPEAV1@PEAV1@@Z PROC ; std::_Rechecked<TileRow * __ptr64,TileRow * __ptr64>, COMDAT

; 458  : 	_Dest = _Src;

	mov	QWORD PTR [rcx], rdx

; 459  : 	return (_Dest);

	mov	rax, rcx

; 460  : 	}

	ret	0
??$_Rechecked@PEAVTileRow@@PEAV1@@std@@YAAEAPEAVTileRow@@AEAPEAV1@PEAV1@@Z ENDP ; std::_Rechecked<TileRow * __ptr64,TileRow * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = 48
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

$LN8:
	sub	rsp, 72					; 00000048H

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	movzx	eax, BYTE PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	xor	r10d, r10d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	BYTE PTR [rsp+40], al
	mov	BYTE PTR [rsp+32], r10b
	call	??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

	add	rsp, 72					; 00000048H
	ret	0
??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAVTileRow@@@std@@YAPEAVTileRow@@PEAV1@@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAVTileRow@@@std@@YAPEAVTileRow@@PEAV1@@Z PROC ; std::_Unchecked<TileRow * __ptr64>, COMDAT

; 428  : 	return (_Src);

	mov	rax, rcx

; 429  : 	}

	ret	0
??$_Unchecked@PEAVTileRow@@@std@@YAPEAVTileRow@@PEAV1@@Z ENDP ; std::_Unchecked<TileRow * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 1002 : 		{	// destroy object at _Ptr

$LN89:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	r8, QWORD PTR [rdx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1002 : 		{	// destroy object at _Ptr

	mov	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	r8, 8
	jb	SHORT $LN15@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN15@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	ecx, ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rcx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN82@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rax], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN82@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rbx], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@@std@@YAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAPEAV10@PEAV10@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Src$ = 16
??$_Rechecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@@std@@YAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAPEAV10@PEAV10@@Z PROC ; std::_Rechecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>, COMDAT

; 458  : 	_Dest = _Src;

	mov	QWORD PTR [rcx], rdx

; 459  : 	return (_Dest);

	mov	rax, rcx

; 460  : 	}

	ret	0
??$_Rechecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@@std@@YAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAPEAV10@PEAV10@@Z ENDP ; std::_Rechecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = 48
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

$LN8:
	sub	rsp, 72					; 00000048H

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	movzx	eax, BYTE PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	xor	r10d, r10d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	BYTE PTR [rsp+40], al
	mov	BYTE PTR [rsp+32], r10b
	call	??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

	add	rsp, 72					; 00000048H
	ret	0
??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@@Z PROC ; std::_Unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>, COMDAT

; 428  : 	return (_Src);

	mov	rax, rcx

; 429  : 	}

	ret	0
??$_Unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@@Z ENDP ; std::_Unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AEBV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0AEBV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> const & __ptr64>, COMDAT

; 953  : 		}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEA_W@?$allocator@_W@std@@QEAAXPEAPEA_W@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$destroy@PEA_W@?$allocator@_W@std@@QEAAXPEAPEA_W@Z PROC ; std::allocator<wchar_t>::destroy<wchar_t * __ptr64>, COMDAT

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	0
??$destroy@PEA_W@?$allocator@_W@std@@QEAAXPEAPEA_W@Z ENDP ; std::allocator<wchar_t>::destroy<wchar_t * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
??$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z PROC ; std::_Wrap_alloc<std::allocator<TileRow> >::destroy<TileRow>, COMDAT

; 1002 : 		{	// destroy object at _Ptr

$LN78:
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	lea	rbx, QWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rdx, QWORD PTR [rbx]
	test	rdx, rdx
	je	SHORT $LN16@destroy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	sar	r8, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN16@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z ENDP ; std::_Wrap_alloc<std::allocator<TileRow> >::destroy<TileRow>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
?dtor$0@?0???$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z@4HA PROC ; `std::_Wrap_alloc<std::allocator<TileRow> >::destroy<TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR _Ptr$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z@4HA ENDP ; `std::_Wrap_alloc<std::allocator<TileRow> >::destroy<TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
?dtor$0@?0???$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z@4HA PROC ; `std::_Wrap_alloc<std::allocator<TileRow> >::destroy<TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR _Ptr$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$destroy@VTileRow@@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@@Z@4HA ENDP ; `std::_Wrap_alloc<std::allocator<TileRow> >::destroy<TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@MM@?$allocator@M@std@@QEAAXPEAM$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@MM@?$allocator@M@std@@QEAAXPEAM$$QEAM@Z PROC ; std::allocator<float>::construct<float,float>, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN3@construct:

; 738  : 		}

	ret	0
??$construct@MM@?$allocator@M@std@@QEAAXPEAM$$QEAM@Z ENDP ; std::allocator<float>::construct<float,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@MAEBM@?$allocator@M@std@@QEAAXPEAMAEBM@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@MAEBM@?$allocator@M@std@@QEAAXPEAMAEBM@Z PROC ; std::allocator<float>::construct<float,float const & __ptr64>, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN3@construct:

; 738  : 		}

	ret	0
??$construct@MAEBM@?$allocator@M@std@@QEAAXPEAMAEBM@Z ENDP ; std::allocator<float>::construct<float,float const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@MAEAM@?$allocator@M@std@@QEAAXPEAMAEAM@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@MAEAM@?$allocator@M@std@@QEAAXPEAMAEAM@Z PROC ; std::allocator<float>::construct<float,float & __ptr64>, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN3@construct:

; 738  : 		}

	ret	0
??$construct@MAEAM@?$allocator@M@std@@QEAAXPEAMAEAM@Z ENDP ; std::allocator<float>::construct<float,float & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z PROC ; std::allocator<TileRow>::construct<TileRow,TileRow const & __ptr64>, COMDAT

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

$LN15:
	mov	QWORD PTR [rsp+16], rdx
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	mov	r9, rdx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T2[rsp], rdx
	test	rdx, rdx
	je	SHORT $LN14@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rdx+4], eax
	lea	rdx, QWORD PTR [r8+8]
	lea	rcx, QWORD PTR [r9+8]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
$LN14@construct:

; 738  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z ENDP ; std::allocator<TileRow>::construct<TileRow,TileRow const & __ptr64>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA PROC ; `std::allocator<TileRow>::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA ENDP ; `std::allocator<TileRow>::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$0
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA PROC ; `std::allocator<TileRow>::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA ENDP ; `std::allocator<TileRow>::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA PROC ; `std::allocator<TileRow>::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA ENDP ; `std::allocator<TileRow>::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA PROC ; `std::allocator<TileRow>::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA ENDP ; `std::allocator<TileRow>::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z PROC ; std::allocator<TileRow>::construct<TileRow,TileRow & __ptr64>, COMDAT

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

$LN15:
	mov	QWORD PTR [rsp+16], rdx
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	mov	r9, rdx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T2[rsp], rdx
	test	rdx, rdx
	je	SHORT $LN14@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rdx+4], eax
	lea	rdx, QWORD PTR [r8+8]
	lea	rcx, QWORD PTR [r9+8]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
$LN14@construct:

; 738  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z ENDP ; std::allocator<TileRow>::construct<TileRow,TileRow & __ptr64>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA PROC ; `std::allocator<TileRow>::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA ENDP ; `std::allocator<TileRow>::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$0
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA PROC ; `std::allocator<TileRow>::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA ENDP ; `std::allocator<TileRow>::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA PROC ; `std::allocator<TileRow>::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA ENDP ; `std::allocator<TileRow>::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA PROC ; `std::allocator<TileRow>::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA ENDP ; `std::allocator<TileRow>::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QEAV21@@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	mov	rax, rdx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	ecx, ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdx+16], rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rdx], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	rdx, r8
	mov	rcx, rax
	jmp	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	ret	0
??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QEAV21@@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AEAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QEAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QEAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AEAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > & __ptr64>, COMDAT

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	rax, rcx

; 1293 : 	}

	ret	0
??$move@AEAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QEAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AEAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PEA_WAEAPEA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@PEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Al$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEA_WAEAPEA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@PEAPEA_WAEAPEA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t * __ptr64,wchar_t * __ptr64 & __ptr64>, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN7@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@PEA_WAEAPEA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@PEAPEA_WAEAPEA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t * __ptr64,wchar_t * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z PROC	; std::forward<wchar_t * __ptr64 & __ptr64>, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z ENDP	; std::forward<wchar_t * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
??$_Uninitialized_move@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z PROC ; std::_Uninitialized_move<float * __ptr64,float * __ptr64,std::allocator<float> >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	rbx, rcx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	QWORD PTR __imp_memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 319  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMPEAM00AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z ENDP ; std::_Uninitialized_move<float * __ptr64,float * __ptr64,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = 64
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$ = 88
??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z PROC ; std::_Uninitialized_move<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN18:
	sub	rsp, 56					; 00000038H

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	movzx	eax, BYTE PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	xor	r10d, r10d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	BYTE PTR [rsp+40], al
	mov	BYTE PTR [rsp+32], r10b
	call	??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,
; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$ = 64
__formal$ = 72
??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>, COMDAT

; 1099 : 	{	// destroy [_First, _Last), no special optimization

$LN130:

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	$LN128@Destroy_ra
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rsp+48], rbx

; 1099 : 	{	// destroy [_First, _Last), no special optimization

	mov	rdi, rdx
	mov	QWORD PTR [rsp+56], rbp

; 1100 : 	for (; _First != _Last; ++_First)

	lea	rbx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+64], rsi
	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	xor	esi, esi
$LL4@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	rax, QWORD PTR [rbx]
	cmp	rax, 8
	jb	SHORT $LN84@Destroy_ra
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	rcx, QWORD PTR [rbx-24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbp
	ja	$LN115@Destroy_ra

; 95   : 	const size_t _User_size = _Count * _Sz;

	add	rax, rax

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN79@Destroy_ra

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	jne	SHORT $LN116@Destroy_ra

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jae	SHORT $LN117@Destroy_ra

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jb	SHORT $LN118@Destroy_ra

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	ja	SHORT $LN119@Destroy_ra

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN79@Destroy_ra:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
$LN84@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx], 7

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx], 8

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx-8], rsi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN102@Destroy_ra
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rbx-24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN103@Destroy_ra
$LN102@Destroy_ra:
	lea	rax, QWORD PTR [rbx-24]
$LN103@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1100 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rax], si
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1100 : 	for (; _First != _Last; ++_First)

	lea	rax, QWORD PTR [rbx-24]
	cmp	rax, rdi
	jne	SHORT $LL4@Destroy_ra
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+64]

; 1101 : 		_Al.destroy(_Unfancy(_First));
; 1102 : 	}

	add	rsp, 32					; 00000020H
	pop	rdi
$LN128@Destroy_ra:
	ret	0
$LN119@Destroy_ra:

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN118@Destroy_ra:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN117@Destroy_ra:

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN116@Destroy_ra:

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN115@Destroy_ra:

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN129@Destroy_ra:
??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = 64
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$ = 88
??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN18:
	sub	rsp, 56					; 00000038H

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	movzx	eax, BYTE PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	xor	r10d, r10d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	BYTE PTR [rsp+40], al
	mov	BYTE PTR [rsp+32], r10b
	call	??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,
; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
_Val1$ = 24
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const & __ptr64>, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 497  : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z PROC ; std::forward<std::allocator<wchar_t> const & __ptr64>, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z ENDP ; std::forward<std::allocator<wchar_t> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@PEAPEA_W@Z
_TEXT	SEGMENT
_Al$ = 8
_Ptr$ = 16
??$destroy@PEA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@PEAPEA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t * __ptr64>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PEA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@PEAPEA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@M@std@@PEAM@std@@YAXPEAM0AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
__formal$ = 24
__formal$ = 32
??$_Destroy_range1@V?$allocator@M@std@@PEAM@std@@YAXPEAM0AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<float>,float * __ptr64>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@M@std@@PEAM@std@@YAXPEAM0AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<float>,float * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Al$ = 80
__formal$ = 88
??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>, COMDAT

; 1099 : 	{	// destroy [_First, _Last), no special optimization

$LN117:

; 1100 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	$LN116@Destroy_ra

; 1099 : 	{	// destroy [_First, _Last), no special optimization

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+88], rsi
	mov	rdi, rdx
	mov	rbx, rcx

; 1100 : 	for (; _First != _Last; ++_First)

	mov	rbp, 4611686018427387903		; 3fffffffffffffffH
	xor	esi, esi
	npad	3
$LL4@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN23@Destroy_ra

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR [rbx+24]
	sub	rax, rcx
	sar	rax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rbp
	ja	SHORT $LN106@Destroy_ra

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rax*4]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN71@Destroy_ra

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	jne	SHORT $LN107@Destroy_ra

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jae	SHORT $LN108@Destroy_ra

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jb	SHORT $LN109@Destroy_ra

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	ja	SHORT $LN110@Destroy_ra

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN71@Destroy_ra:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	QWORD PTR [rbx+8], rsi

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+16], rsi

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+24], rsi
$LN23@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1100 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	mov	QWORD PTR _First$[rsp], rbx
	cmp	rbx, rdi
	je	SHORT $LN114@Destroy_ra
	jmp	SHORT $LL4@Destroy_ra
$LN110@Destroy_ra:

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN109@Destroy_ra:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN108@Destroy_ra:

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN107@Destroy_ra:

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN106@Destroy_ra:

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN114@Destroy_ra:

; 1101 : 		_Al.destroy(_Unfancy(_First));
; 1102 : 	}

	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
$LN116@Destroy_ra:
	ret	0
$LN115@Destroy_ra:
??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Al$ = 80
__formal$ = 88
?dtor$0@?0???$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z@4HA PROC ; `std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z@4HA ENDP ; `std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Al$ = 80
__formal$ = 88
?dtor$0@?0???$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z@4HA PROC ; `std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z@4HA ENDP ; `std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
_Val1$ = 24
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 497  : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	rax, rcx
	ret	0
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QEAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QEAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AEAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QEAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AEAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@MM@?$allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@PEAM$$QEAM@Z
_TEXT	SEGMENT
_Al$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@MM@?$allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@PEAM$$QEAM@Z PROC ; std::allocator_traits<std::allocator<float> >::construct<float,float>, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN7@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@MM@?$allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@PEAM$$QEAM@Z ENDP ; std::allocator_traits<std::allocator<float> >::construct<float,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@MAEBM@?$allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@PEAMAEBM@Z
_TEXT	SEGMENT
_Al$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@MAEBM@?$allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@PEAMAEBM@Z PROC ; std::allocator_traits<std::allocator<float> >::construct<float,float const & __ptr64>, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN7@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@MAEBM@?$allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@PEAMAEBM@Z ENDP ; std::allocator_traits<std::allocator<float> >::construct<float,float const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AEBM@std@@YAAEBMAEBM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBM@std@@YAAEBMAEBM@Z PROC			; std::forward<float const & __ptr64>, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@AEBM@std@@YAAEBMAEBM@Z ENDP			; std::forward<float const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@MAEAM@?$allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@PEAMAEAM@Z
_TEXT	SEGMENT
_Al$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@MAEAM@?$allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@PEAMAEAM@Z PROC ; std::allocator_traits<std::allocator<float> >::construct<float,float & __ptr64>, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN7@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	ret	0
??$construct@MAEAM@?$allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@PEAMAEAM@Z ENDP ; std::allocator_traits<std::allocator<float> >::construct<float,float & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AEAM@std@@YAAEAMAEAM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAM@std@@YAAEAMAEAM@Z PROC			; std::forward<float & __ptr64>, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@AEAM@std@@YAAEAMAEAM@Z ENDP			; std::forward<float & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z
_TEXT	SEGMENT
$T1 = 32
_Al$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z PROC ; std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

$LN19:
	mov	QWORD PTR [rsp+16], rdx
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	mov	r9, rdx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T2[rsp], rdx
	test	rdx, rdx
	je	SHORT $LN18@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rdx+4], eax
	lea	rdx, QWORD PTR [r8+8]
	lea	rcx, QWORD PTR [r9+8]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
$LN18@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z ENDP ; std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Al$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA PROC ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA ENDP ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$0
$T1 = 32
_Al$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA PROC ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA ENDP ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Al$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA PROC ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA ENDP ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Al$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA PROC ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEBV3@@Z@4HA ENDP ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AEBVTileRow@@@std@@YAAEBVTileRow@@AEBV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBVTileRow@@@std@@YAAEBVTileRow@@AEBV1@@Z PROC ; std::forward<TileRow const & __ptr64>, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@AEBVTileRow@@@std@@YAAEBVTileRow@@AEBV1@@Z ENDP ; std::forward<TileRow const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z
_TEXT	SEGMENT
$T1 = 32
_Al$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z PROC ; std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

$LN19:
	mov	QWORD PTR [rsp+16], rdx
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	mov	r9, rdx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T2[rsp], rdx
	test	rdx, rdx
	je	SHORT $LN18@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rdx+4], eax
	lea	rdx, QWORD PTR [r8+8]
	lea	rcx, QWORD PTR [r9+8]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
$LN18@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z ENDP ; std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Al$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA PROC ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA ENDP ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$0
$T1 = 32
_Al$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA PROC ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA ENDP ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Al$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA PROC ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA ENDP ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Al$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA PROC ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@PEAVTileRow@@AEAV3@@Z@4HA ENDP ; `std::allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AEAVTileRow@@@std@@YAAEAVTileRow@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAVTileRow@@@std@@YAAEAVTileRow@@AEAV1@@Z PROC ; std::forward<TileRow & __ptr64>, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@AEAVTileRow@@@std@@YAAEAVTileRow@@AEAV1@@Z ENDP ; std::forward<TileRow & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QEAV31@@Z
_TEXT	SEGMENT
_Al$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QEAV31@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	mov	rax, rdx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN7@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	ecx, ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdx+16], rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rdx], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	rdx, r8
	mov	rcx, rax
	jmp	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	ret	0
??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QEAV31@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PEA_WAEAPEA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAAXPEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEA_WAEAPEA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAAXPEAPEA_WAEAPEA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t * __ptr64,wchar_t * __ptr64 & __ptr64>, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN11@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN11@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	0
??$construct@PEA_WAEAPEA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAAXPEAPEA_WAEAPEA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t * __ptr64,wchar_t * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PEAM@?$vector@MV?$allocator@M@std@@@std@@IEAAPEAMPEAM00@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Ptr$ = 72
??$_Umove@PEAM@?$vector@MV?$allocator@M@std@@@std@@IEAAPEAMPEAM00@Z PROC ; std::vector<float,std::allocator<float> >::_Umove<float * __ptr64>, COMDAT

; 1658 : 		{	// move initializing [_First, _Last), using allocator

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	sub	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	mov	rdi, r9
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	QWORD PTR __imp_memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Umove@PEAM@?$vector@MV?$allocator@M@std@@@std@@IEAAPEAMPEAM00@Z ENDP ; std::vector<float,std::allocator<float> >::_Umove<float * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PEAVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAPEAVTileRow@@PEAV2@00@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAPEAVTileRow@@PEAV2@00@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Umove<TileRow * __ptr64>, COMDAT

; 1658 : 		{	// move initializing [_First, _Last), using allocator

$LN24:
	push	rbx
	sub	rsp, 48					; 00000030H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	movzx	eax, BYTE PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	mov	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	BYTE PTR [rsp+40], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	mov	r10, r9
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	BYTE PTR [rsp+32], dl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	mov	r11, r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	r9, rcx
	mov	rdx, r11
	mov	r8, r10
	mov	rcx, rbx
	call	??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$_Umove@PEAVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAPEAVTileRow@@PEAV2@00@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Umove<TileRow * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
$T1 = 32
??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T1[rsp]
	jmp	??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PEAV21@00@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PEAV21@00@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>, COMDAT

; 1658 : 		{	// move initializing [_First, _Last), using allocator

$LN24:
	push	rbx
	sub	rsp, 48					; 00000030H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	movzx	eax, BYTE PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	mov	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	BYTE PTR [rsp+40], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	mov	r10, r9
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	BYTE PTR [rsp+32], dl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	mov	r11, r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	mov	r9, rcx
	mov	rdx, r11
	mov	r8, r10
	mov	rcx, rbx
	call	??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$_Umove@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@PEAV21@00@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0AEBV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$ = 16
??$?0AEBV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t> const & __ptr64,void>, COMDAT

; 496  : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 497  : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax

; 598  : 		}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t> const & __ptr64,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 740  : 	return (_Ptr);

	mov	rax, rcx

; 741  : 	}

	ret	0
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAAXPEAPEA_W@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$destroy@PEA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAAXPEAPEA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t * __ptr64>, COMDAT

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	0
??$destroy@PEA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAAXPEAPEA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z PROC	; std::addressof<wchar_t * __ptr64>, COMDAT

; 725  : 	return (__builtin_addressof(_Val));

	mov	rax, rcx

; 726  : 	}

	ret	0
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z ENDP	; std::addressof<wchar_t * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 497  : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAA@$$QEAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAA@$$QEAV?$allocator@_W@1@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> >, COMDAT

; 953  : 		}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@_W@std@@@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAA@$$QEAV?$allocator@_W@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> ><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@M@std@@PEAM@std@@YAXPEAM0AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@M@std@@PEAM@std@@YAXPEAM0AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<float>,float * __ptr64>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@M@std@@PEAM@std@@YAXPEAM0AEAU?$_Wrap_alloc@V?$allocator@M@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<float>,float * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1><>, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
$T1 = 32
??$_Destroy_range@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<TileRow>,TileRow * __ptr64>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T1[rsp]
	jmp	??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>
??$_Destroy_range@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<TileRow>,TileRow * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1><>, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

	mov	rax, QWORD PTR [rcx+8]
	add	rax, QWORD PTR [rcx]

; 69   : 		}

	ret	0
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

	xor	eax, eax
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], 0
	mov	QWORD PTR [rcx+16], rax

; 44   : 		}

	mov	rax, rcx
	ret	0
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@$$QEAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$ = 16
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@$$QEAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>, COMDAT

; 496  : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 497  : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax

; 598  : 		}

	mov	rax, rcx
	ret	0
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@$$QEAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@MM@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAXPEAM$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@MM@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAXPEAM$$QEAM@Z PROC ; std::_Wrap_alloc<std::allocator<float> >::construct<float,float>, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN11@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN11@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	0
??$construct@MM@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAXPEAM$$QEAM@Z ENDP ; std::_Wrap_alloc<std::allocator<float> >::construct<float,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QEAMAEAM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@M@std@@YA$$QEAMAEAM@Z PROC			; std::forward<float>, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@M@std@@YA$$QEAMAEAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@M@std@@YAPEAMAEAM@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@M@std@@YAPEAMAEAM@Z PROC			; std::addressof<float>, COMDAT

; 725  : 	return (__builtin_addressof(_Val));

	mov	rax, rcx

; 726  : 	}

	ret	0
??$addressof@M@std@@YAPEAMAEAM@Z ENDP			; std::addressof<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@MAEBM@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAXPEAMAEBM@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@MAEBM@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAXPEAMAEBM@Z PROC ; std::_Wrap_alloc<std::allocator<float> >::construct<float,float const & __ptr64>, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN11@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN11@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	0
??$construct@MAEBM@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAXPEAMAEBM@Z ENDP ; std::_Wrap_alloc<std::allocator<float> >::construct<float,float const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@MAEAM@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAXPEAMAEAM@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@MAEAM@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAXPEAMAEAM@Z PROC ; std::_Wrap_alloc<std::allocator<float> >::construct<float,float & __ptr64>, COMDAT

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN11@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN11@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	ret	0
??$construct@MAEAM@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAXPEAMAEAM@Z ENDP ; std::_Wrap_alloc<std::allocator<float> >::construct<float,float & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@M@std@@YAPEAMPEAM@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@M@std@@YAPEAMPEAM@Z PROC			; std::_Unfancy<float>, COMDAT

; 740  : 	return (_Ptr);

	mov	rax, rcx

; 741  : 	}

	ret	0
??$_Unfancy@M@std@@YAPEAMPEAM@Z ENDP			; std::_Unfancy<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBM@std@@YAPEBMAEBM@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBM@std@@YAPEBMAEBM@Z PROC		; std::addressof<float const >, COMDAT

; 725  : 	return (__builtin_addressof(_Val));

	mov	rax, rcx

; 726  : 	}

	ret	0
??$addressof@$$CBM@std@@YAPEBMAEBM@Z ENDP		; std::addressof<float const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z PROC ; std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>, COMDAT

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

$LN23:
	mov	QWORD PTR [rsp+16], rdx
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	mov	r9, rdx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T2[rsp], rdx
	test	rdx, rdx
	je	SHORT $LN22@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rdx+4], eax
	lea	rdx, QWORD PTR [r8+8]
	lea	rcx, QWORD PTR [r9+8]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
$LN22@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA PROC ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA ENDP ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$0
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA PROC ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA ENDP ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA PROC ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA ENDP ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA PROC ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$construct@VTileRow@@AEBV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEBV2@@Z@4HA ENDP ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow const & __ptr64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>, COMDAT

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

$LN23:
	mov	QWORD PTR [rsp+16], rdx
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	mov	r9, rdx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T2[rsp], rdx
	test	rdx, rdx
	je	SHORT $LN22@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rdx+4], eax
	lea	rdx, QWORD PTR [r8+8]
	lea	rcx, QWORD PTR [r9+8]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
$LN22@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA PROC ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA ENDP ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$0
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA PROC ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA ENDP ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA PROC ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA ENDP ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
$T2 = 88
?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA PROC ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$construct@VTileRow@@AEAV1@@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@AEAV2@@Z@4HA ENDP ; `std::_Wrap_alloc<std::allocator<TileRow> >::construct<TileRow,TileRow & __ptr64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@VTileRow@@@std@@YAPEAVTileRow@@PEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@VTileRow@@@std@@YAPEAVTileRow@@PEAV1@@Z PROC ; std::_Unfancy<TileRow>, COMDAT

; 740  : 	return (_Ptr);

	mov	rax, rcx

; 741  : 	}

	ret	0
??$_Unfancy@VTileRow@@@std@@YAPEAVTileRow@@PEAV1@@Z ENDP ; std::_Unfancy<TileRow>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBVTileRow@@@std@@YAPEBVTileRow@@AEBV1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBVTileRow@@@std@@YAPEBVTileRow@@AEBV1@@Z PROC ; std::addressof<TileRow const >, COMDAT

; 725  : 	return (__builtin_addressof(_Val));

	mov	rax, rcx

; 726  : 	}

	ret	0
??$addressof@$$CBVTileRow@@@std@@YAPEBVTileRow@@AEBV1@@Z ENDP ; std::addressof<TileRow const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QEAV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	mov	rax, rdx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdx, rdx
	je	SHORT $LN11@construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	ecx, ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdx+16], rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rdx], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	rdx, r8
	mov	rcx, rax
	jmp	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN11@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	ret	0
??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QEAV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z PROC ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1277 : 	}

	ret	0
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ENDP ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@@Z PROC ; std::_Unfancy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 740  : 	return (_Ptr);

	mov	rax, rcx

; 741  : 	}

	ret	0
??$_Unfancy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@@Z ENDP ; std::_Unfancy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 725  : 	return (__builtin_addressof(_Val));

	mov	rax, rcx

; 726  : 	}

	ret	0
??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
this$ = 64
??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor', COMDAT
$LN8:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	lea	rbx, QWORD PTR [rcx+152]
	mov	rcx, rbx
	call	??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	mov	QWORD PTR this$[rsp], rbx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 39   : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
	mov	QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 523  : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7ios_base@std@@6B@
	mov	QWORD PTR [rbx], rax

; 524  : 		_Ios_base_dtor(this);

	mov	rcx, rbx
	call	QWORD PTR __imp_?_Ios_base_dtor@ios_base@std@@CAXPEAV12@@Z
	npad	1
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor'
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 64
?dtor$0@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$0@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 64
?dtor$0@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$0@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
;	COMDAT ??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
this$ = 64
__flags$ = 72
??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor', COMDAT
$LN12:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	ebx, edx
	lea	rdi, QWORD PTR [rcx-152]
	call	??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR [rdi+152]
	mov	QWORD PTR this$[rsp], rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 39   : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
	mov	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 523  : 		{	// destroy the object

	mov	r8, QWORD PTR __imp_??_7ios_base@std@@6B@
	mov	QWORD PTR [rcx], r8

; 524  : 		_Ios_base_dtor(this);

	call	QWORD PTR __imp_?_Ios_base_dtor@ios_base@std@@CAXPEAV12@@Z
	npad	1
	test	bl, 1
	je	SHORT $LN11@scalar
	mov	edx, 248				; 000000f8H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN11@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 64
__flags$ = 72
?dtor$0@?0???_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$0@?0???_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 64
__flags$ = 72
?dtor$0@?0???_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$0@?0???_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor', COMDAT
$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	ebx, edx
	mov	rdi, rcx

; 75   : 		{	// destroy the object

	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR [rcx], rax

; 76   : 		_Tidy();

	call	?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
	npad	1

; 77   : 		}

	mov	rcx, rdi
	call	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
	npad	1
	test	bl, 1
	je	SHORT $LN7@scalar
	mov	edx, 120				; 00000078H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN7@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
?dtor$0@?0???_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z@4HA PROC ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z@4HA ENDP ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
?dtor$0@?0???_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z@4HA PROC ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z@4HA ENDP ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAHH@Z
_TEXT	SEGMENT
this$ = 8
_Mode$ = 16
?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAHH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getstate, COMDAT

; 355  : 		_Strstate _State = (_Strstate)0;
; 356  : 		if (!(_Mode & ios_base::in))
; 357  : 			_State |= _Noread;
; 358  : 		if (!(_Mode & ios_base::out))

	mov	eax, edx
	lea	ecx, DWORD PTR [rdx*4]
	not	ecx
	and	ecx, 4
	mov	r8d, ecx
	or	r8d, 2
	and	al, 2

; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)

	mov	eax, edx
	cmovne	r8d, ecx
	mov	ecx, r8d
	or	ecx, 8
	and	al, 8
	cmove	ecx, r8d
	mov	eax, ecx
	or	eax, 16

; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)

	and	dl, 4
	cmove	eax, ecx

; 363  : 			_State |= _Atend;
; 364  : 		return (_State);
; 365  : 		}

	ret	0
?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAHH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT

; 337  : 		{	// discard any allocated buffer and clear pointers

$LN22:
	push	rbx
	sub	rsp, 32					; 00000020H

; 338  : 		if (_Mystate & _Allocated)

	test	BYTE PTR [rcx+112], 1
	mov	rbx, rcx
	je	SHORT $LN2@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	rax, QWORD PTR [rcx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 339  : 			_Al.deallocate(_Mysb::eback(),

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN4@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	rax, QWORD PTR [rbx+88]
	movsxd	rdx, DWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 339  : 			_Al.deallocate(_Mysb::eback(),

	jmp	SHORT $LN20@Tidy
$LN4@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

	mov	rax, QWORD PTR [rbx+80]
	movsxd	rdx, DWORD PTR [rax]
	mov	rax, QWORD PTR [rbx+56]
	mov	rcx, QWORD PTR [rax]
$LN20@Tidy:

; 222  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [rbx+24]

; 242  : 		return (*_IGnext + *_IGcount);

	lea	r8, QWORD PTR [rcx+rdx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 339  : 			_Al.deallocate(_Mysb::eback(),

	lea	rcx, QWORD PTR [rbx+116]
	mov	rdx, QWORD PTR [rax]
	sub	r8, rdx
	sar	r8, 1
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN2@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR [rbx+24]
	xor	ecx, ecx
	mov	QWORD PTR [rax], rcx

; 254  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], rcx

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], ecx

; 294  : 		*_IPfirst = _First;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rax], rcx

; 295  : 		*_IPnext = _First;

	mov	rax, QWORD PTR [rbx+64]
	mov	QWORD PTR [rax], rcx

; 296  : 		*_IPcount = (int)(_Last - _First);

	mov	rax, QWORD PTR [rbx+88]
	mov	DWORD PTR [rax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 345  : 		_Mystate &= ~_Allocated;

	and	DWORD PTR [rbx+112], -2
	mov	QWORD PTR [rbx+104], rcx

; 346  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
_State$ = 72
?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init, COMDAT

; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state

$LN24:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	r14
	sub	rsp, 32					; 00000020H

; 311  : 		_Seekhigh = 0;

	mov	QWORD PTR [rcx+104], 0
	mov	r14, r8

; 312  : 		_Mystate = _State;

	mov	DWORD PTR [rcx+112], r9d
	mov	rbp, rdx
	mov	rbx, rcx

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))

	test	r8, r8
	je	$LN2@Init
	and	r9d, 6
	cmp	r9b, 6
	je	$LN2@Init

; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);

	mov	QWORD PTR [rsp+48], rsi
	add	rcx, 116				; 00000074H
	mov	rdx, r8
	mov	QWORD PTR [rsp+56], rdi
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	rsi, QWORD PTR [r14+r14]
	mov	rdx, rbp
	mov	r8, rsi
	mov	rcx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);

	mov	rdi, rax
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	call	memcpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 321  : 			if (!(_Mystate & _Noread))

	test	BYTE PTR [rbx+112], 4
	lea	rcx, QWORD PTR [rsi+rdi]
	mov	QWORD PTR [rbx+104], rcx
	jne	SHORT $LN3@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	rcx, QWORD PTR [rbx+24]
	mov	QWORD PTR [rcx], rdi

; 254  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], rdi

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], r14d
$LN3@Init:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 324  : 			if (!(_Mystate & _Constant))

	mov	eax, DWORD PTR [rbx+112]
	test	al, 2
	jne	SHORT $LN5@Init

; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,

	lea	rcx, QWORD PTR [rsi+rdi]
	test	al, 24
	jne	SHORT $LN8@Init
	mov	rcx, rdi
$LN8@Init:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 301  : 		*_IPfirst = _First;

	mov	rax, QWORD PTR [rbx+32]

; 302  : 		*_IPnext = _Next;
; 303  : 		*_IPcount = (int)(_Last - _Next);

	sub	rsi, rcx
	add	rsi, rdi
	sar	rsi, 1
	mov	QWORD PTR [rax], rdi
	mov	rax, QWORD PTR [rbx+64]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR [rbx+88]
	mov	DWORD PTR [rax], esi

; 227  : 		return (*_IGnext);

	mov	rax, QWORD PTR [rbx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 329  : 				if (_Mysb::gptr() == 0)

	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN5@Init
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR [rax], rdi

; 254  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rbx+56]

; 255  : 		*_IGcount = (int)(_Last - _Next);

	sar	rdi, 1
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], edi
$LN5@Init:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 332  : 			_Mystate |= _Allocated;

	or	DWORD PTR [rbx+112], 1
	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+48]
$LN2@Init:

; 333  : 			}
; 334  : 		}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Ptr$ = 24
_Mode$ = 32
?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos, COMDAT

; 276  : 		{	// change position to _Pos, according to _Mode

$LN57:
	mov	QWORD PTR [rsp+8], rbx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

	mov	r10, QWORD PTR [r8+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

	mov	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	rdx, QWORD PTR [rcx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

	mov	r11, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

	add	r10, QWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

	mov	rax, QWORD PTR [rdx]
	test	rax, rax
	je	SHORT $LN2@seekpos
	cmp	QWORD PTR [rcx+104], rax
	jae	SHORT $LN2@seekpos

; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

	mov	QWORD PTR [rcx+104], rax
$LN2@seekpos:

; 280  : 
; 281  : 		if (_Off == _BADOFF)

	mov	rax, QWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	rcx, QWORD PTR [rax]
	cmp	r10, rcx
	je	$LN11@seekpos

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

	test	r9b, 1
	je	$LN5@seekpos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	rax, QWORD PTR [r11+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	je	SHORT $LN5@seekpos

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	r10, r10
	js	$LN10@seekpos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [r11+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR [r11+104]
	sub	rax, rdx
	sar	rax, 1
	cmp	r10, rax
	jg	$LN10@seekpos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	mov	rax, QWORD PTR [r11+80]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

	sub	rdx, r8
	sar	rdx, 1
	add	edx, r10d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	sub	DWORD PTR [rax], edx

; 248  : 		*_IGnext += _Off;

	mov	rcx, QWORD PTR [r11+56]
	movsxd	rax, edx
	add	rax, rax
	add	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

	test	r9b, 2
	je	SHORT $LN11@seekpos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	r8, QWORD PTR [r11+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

	mov	rdx, QWORD PTR [r8]
	test	rdx, rdx
	je	SHORT $LN11@seekpos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	rax, QWORD PTR [r11+88]
	movsxd	rcx, DWORD PTR [rax]

; 227  : 		return (*_IGnext);

	mov	rax, QWORD PTR [r11+56]

; 260  : 		return (*_IPnext + *_IPcount);

	lea	rdx, QWORD PTR [rdx+rcx*2]

; 227  : 		return (*_IGnext);

	mov	rcx, QWORD PTR [rax]

; 302  : 		*_IPnext = _Next;

	mov	QWORD PTR [r8], rcx

; 303  : 		*_IPcount = (int)(_Last - _Next);

	sub	rdx, rcx
	mov	rax, QWORD PTR [r11+88]
	sar	rdx, 1
	mov	DWORD PTR [rax], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 293  : 				_Off = _BADOFF;

	jmp	SHORT $LN11@seekpos
$LN5@seekpos:

; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

	test	r9b, 2
	je	SHORT $LN10@seekpos
	mov	r8, QWORD PTR [rdx]
	test	r8, r8
	je	SHORT $LN10@seekpos

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	r10, r10
	js	SHORT $LN10@seekpos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [r11+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR [r11+104]
	sub	rax, rdx
	sar	rax, 1
	cmp	r10, rax
	jg	SHORT $LN10@seekpos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 288  : 		*_IPcount -= _Off;

	mov	rax, QWORD PTR [r11+88]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

	sub	rdx, r8
	sar	rdx, 1
	add	edx, r10d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 288  : 		*_IPcount -= _Off;

	sub	DWORD PTR [rax], edx

; 289  : 		*_IPnext += _Off;

	mov	rcx, QWORD PTR [r11+64]
	movsxd	rax, edx
	add	rax, rax
	add	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 300  : 			else

	jmp	SHORT $LN11@seekpos
$LN10@seekpos:

; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

	mov	r10, rcx
$LN11@seekpos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

	xor	eax, eax
	mov	QWORD PTR [rbx], r10
	mov	QWORD PTR [rbx+8], 0
	mov	QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 305  : 		return (streampos(_Off));

	mov	rax, rbx

; 306  : 		}

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
this$ = 16
__$ReturnUdt$ = 24
_Off$ = 32
_Way$ = 40
_Which$ = 48
?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff, COMDAT

; 227  : 		{	// change position by _Off, according to _Way, _Mode

$LN76:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	rdi, QWORD PTR [rcx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 227  : 		{	// change position by _Off, according to _Way, _Mode

	mov	r11, rdx
	mov	r10, rcx

; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

	mov	rax, QWORD PTR [rdi]
	test	rax, rax
	je	SHORT $LN2@seekoff
	cmp	QWORD PTR [rcx+104], rax
	jae	SHORT $LN2@seekoff

; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

	mov	QWORD PTR [rcx+104], rax
$LN2@seekoff:

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

	mov	ebx, DWORD PTR _Which$[rsp]
	mov	QWORD PTR [rsp+16], rsi
	test	bl, 1
	je	$LN3@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	rax, QWORD PTR [rcx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

	mov	rsi, QWORD PTR [rax]
	test	rsi, rsi
	je	$LN3@seekoff

; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)

	mov	rdi, QWORD PTR __imp_?_BADOFF@std@@3_JB
	cmp	r9d, 2
	jne	SHORT $LN5@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [rcx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

	mov	rcx, QWORD PTR [rcx+104]
	sub	rcx, QWORD PTR [rax]
	sar	rcx, 1
	add	r8, rcx

; 235  : 			else if (_Way == ios_base::cur

	jmp	SHORT $LN9@seekoff
$LN5@seekoff:

; 236  : 				&& (_Which & ios_base::out) == 0)

	cmp	r9d, 1
	jne	SHORT $LN7@seekoff
	test	bl, 2
	jne	SHORT $LN74@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [rcx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

	mov	rcx, rsi
	sub	rcx, QWORD PTR [rax]
	sar	rcx, 1
	add	r8, rcx
	jmp	SHORT $LN9@seekoff
$LN7@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

	test	r9d, r9d
	je	SHORT $LN9@seekoff
$LN74@seekoff:

; 239  : 				_Off = _BADOFF;

	mov	r8, QWORD PTR [rdi]
$LN9@seekoff:

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	r8, r8
	js	SHORT $LN10@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [r10+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR [r10+104]
	sub	rax, rdx
	sar	rax, 1
	cmp	r8, rax
	jg	SHORT $LN10@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	mov	rax, QWORD PTR [r10+80]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

	sub	rdx, rsi
	sar	rdx, 1
	add	edx, r8d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	sub	DWORD PTR [rax], edx

; 248  : 		*_IGnext += _Off;

	mov	rcx, QWORD PTR [r10+56]
	movsxd	rax, edx
	add	rax, rax
	add	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

	test	bl, 2
	je	$LN22@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	r9, QWORD PTR [r10+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

	mov	rdx, QWORD PTR [r9]
	test	rdx, rdx
	je	$LN22@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	rax, QWORD PTR [r10+88]
	movsxd	rcx, DWORD PTR [rax]

; 227  : 		return (*_IGnext);

	mov	rax, QWORD PTR [r10+56]

; 260  : 		return (*_IPnext + *_IPcount);

	lea	rdx, QWORD PTR [rdx+rcx*2]

; 227  : 		return (*_IGnext);

	mov	rcx, QWORD PTR [rax]

; 302  : 		*_IPnext = _Next;

	mov	QWORD PTR [r9], rcx

; 303  : 		*_IPcount = (int)(_Last - _Next);

	sub	rdx, rcx
	mov	rax, QWORD PTR [r10+88]
	sar	rdx, 1
	mov	DWORD PTR [rax], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 248  : 			else

	jmp	$LN22@seekoff
$LN10@seekoff:

; 249  : 				_Off = _BADOFF;

	mov	r8, QWORD PTR [rdi]
	jmp	$LN22@seekoff
$LN3@seekoff:

; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

	test	bl, 2
	je	$LN13@seekoff
	mov	rdi, QWORD PTR [rdi]
	test	rdi, rdi
	je	SHORT $LN13@seekoff

; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)

	mov	rbx, QWORD PTR __imp_?_BADOFF@std@@3_JB
	cmp	r9d, 2
	jne	SHORT $LN15@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [rcx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

	mov	rcx, QWORD PTR [rcx+104]
	sub	rcx, QWORD PTR [rax]
	sar	rcx, 1
	add	r8, rcx
	jmp	SHORT $LN19@seekoff
$LN15@seekoff:

; 255  : 			else if (_Way == ios_base::cur)

	cmp	r9d, 1
	jne	SHORT $LN17@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [rcx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

	mov	rcx, rdi
	sub	rcx, QWORD PTR [rax]
	sar	rcx, 1
	add	r8, rcx
	jmp	SHORT $LN19@seekoff
$LN17@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

	test	r9d, r9d
	je	SHORT $LN19@seekoff

; 258  : 				_Off = _BADOFF;

	mov	r8, QWORD PTR [rbx]
$LN19@seekoff:

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	r8, r8
	js	SHORT $LN20@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [r10+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR [r10+104]
	sub	rax, rdx
	sar	rax, 1
	cmp	r8, rax
	jg	SHORT $LN20@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 288  : 		*_IPcount -= _Off;

	mov	rax, QWORD PTR [r10+88]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 261  : 				_Mysb::pbump((int)(_Mysb::eback()

	sub	rdx, rdi
	sar	rdx, 1
	add	edx, r8d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 288  : 		*_IPcount -= _Off;

	sub	DWORD PTR [rax], edx

; 289  : 		*_IPnext += _Off;

	mov	rcx, QWORD PTR [r10+64]
	movsxd	rax, edx
	add	rax, rax
	add	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 263  : 			else

	jmp	SHORT $LN22@seekoff
$LN20@seekoff:

; 264  : 				_Off = _BADOFF;

	mov	r8, QWORD PTR [rbx]
	jmp	SHORT $LN22@seekoff
$LN13@seekoff:

; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)

	test	r8, r8
	je	SHORT $LN22@seekoff

; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

	mov	rax, QWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	r8, QWORD PTR [rax]
$LN22@seekoff:
	mov	rsi, QWORD PTR [rsp+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 272  : 		}

	mov	rbx, QWORD PTR [rsp+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

	mov	QWORD PTR [r11], r8
	mov	QWORD PTR [r11+8], 0
	mov	QWORD PTR [r11+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 271  : 		return (pos_type(_Off));

	mov	rax, r11

; 272  : 		}

	pop	rdi
	ret	0
?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGXZ
_TEXT	SEGMENT
this$ = 8
?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGXZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	r10, QWORD PTR [rcx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 207  : 		{	// get an element from stream, but don't point past it

	mov	r8, rcx

; 208  : 		if (_Mysb::gptr() == 0)

	mov	r9, QWORD PTR [r10]
	test	r9, r9
	je	SHORT $LN8@underflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

	mov	r11, QWORD PTR [rcx+80]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())

	movsxd	rcx, DWORD PTR [r11]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

	lea	rdx, QWORD PTR [r9+rcx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())

	cmp	r9, rdx
	jae	SHORT $LN4@underflow

; 211  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

	movzx	eax, WORD PTR [r9]

; 221  : 			}
; 222  : 		}

	ret	0
$LN4@underflow:

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

	test	BYTE PTR [r8+112], 4
	jne	SHORT $LN8@underflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	rax, QWORD PTR [r8+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN8@underflow
	cmp	rcx, r9
	ja	SHORT $LN6@underflow
	cmp	QWORD PTR [r8+104], r9
	jbe	SHORT $LN8@underflow
$LN6@underflow:

; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())

	cmp	QWORD PTR [r8+104], rcx
	jae	SHORT $LN9@underflow

; 218  : 				_Seekhigh = _Mysb::pptr();

	mov	QWORD PTR [r8+104], rcx
$LN9@underflow:

; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);

	mov	rax, QWORD PTR [r8+104]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 255  : 		*_IGcount = (int)(_Last - _Next);

	sub	rax, QWORD PTR [r10]
	sar	rax, 1
	mov	DWORD PTR [r11], eax

; 227  : 		return (*_IGnext);

	mov	rax, QWORD PTR [r8+56]
	mov	rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 220  : 			return (_Traits::to_int_type(*_Mysb::gptr()));

	movzx	eax, WORD PTR [rcx]

; 221  : 			}
; 222  : 		}

	ret	0
$LN8@underflow:

; 214  : 			return (_Traits::eof());	// can't read, fail

	mov	eax, 65535				; 0000ffffH

; 221  : 			}
; 222  : 		}

	ret	0
?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGXZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
_TEXT	SEGMENT
this$ = 8
_Meta$ = 16
?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	rax, QWORD PTR [rcx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	mov	r9d, 65535				; 0000ffffH
	mov	r8, QWORD PTR [rax]
	test	r8, r8
	je	SHORT $LN4@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [rcx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	cmp	r8, QWORD PTR [rax]
	jbe	SHORT $LN4@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 375  : 		return (_Left == _Right);

	cmp	r9w, dx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	je	SHORT $LN2@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 351  : 		return (_Left == _Right);

	cmp	dx, WORD PTR [r8-2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	je	SHORT $LN2@pbackfail
	test	BYTE PTR [rcx+112], 2
	jne	SHORT $LN4@pbackfail
$LN2@pbackfail:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	mov	rax, QWORD PTR [rcx+80]
	inc	DWORD PTR [rax]

; 248  : 		*_IGnext += _Off;

	mov	rax, QWORD PTR [rcx+56]
	add	QWORD PTR [rax], -2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 375  : 		return (_Left == _Right);

	cmp	r9w, dx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

	je	SHORT $LN37@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	rax, QWORD PTR [rcx+56]
	mov	rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 381  : 		return (_Meta != eof() ? _Meta : !eof());

	movzx	eax, dx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

	mov	WORD PTR [rcx], dx

; 204  : 		}

	ret	0
$LN37@pbackfail:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 381  : 		return (_Meta != eof() ? _Meta : !eof());

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 204  : 		}

	ret	0
$LN4@pbackfail:

; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail

	movzx	eax, r9w

; 204  : 		}

	ret	0
?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
_TEXT	SEGMENT
this$ = 80
_Meta$ = 88
?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow, COMDAT

; 120  : 		{	// put an element to stream

$LN116:
	push	rbx
	push	r14
	sub	rsp, 56					; 00000038H

; 121  : 		if (_Mystate & _Constant)

	mov	eax, DWORD PTR [rcx+112]
	movzx	r14d, dx
	mov	rbx, rcx
	test	al, 2
	je	SHORT $LN4@overflow

; 122  : 			return (_Traits::eof());	// array nonmutable, fail

	mov	eax, 65535				; 0000ffffH

; 186  : 			}
; 187  : 		}

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rbx
	ret	0
$LN4@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 375  : 		return (_Left == _Right);

	mov	r8d, 65535				; 0000ffffH
	mov	QWORD PTR [rsp+80], rbp
	cmp	r8w, r14w
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	jne	SHORT $LN6@overflow

; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

	xor	ebp, ebp
	movzx	eax, bp
	mov	rbp, QWORD PTR [rsp+80]

; 186  : 			}
; 187  : 		}

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rbx
	ret	0
$LN6@overflow:

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

	test	al, 8
	je	SHORT $LN7@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	r10, QWORD PTR [rcx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

	mov	rdx, QWORD PTR [r10]
	test	rdx, rdx
	je	SHORT $LN7@overflow
	mov	r9, QWORD PTR [rcx+104]
	cmp	rdx, r9
	jae	SHORT $LN7@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	rax, QWORD PTR [rcx+88]
	movsxd	rcx, DWORD PTR [rax]

; 302  : 		*_IPnext = _Next;

	mov	QWORD PTR [r10], r9

; 303  : 		*_IPcount = (int)(_Last - _Next);

	mov	rax, QWORD PTR [rbx+88]

; 260  : 		return (*_IPnext + *_IPcount);

	lea	rdx, QWORD PTR [rdx+rcx*2]

; 303  : 		*_IPcount = (int)(_Last - _Next);

	sub	rdx, r9
	sar	rdx, 1
	mov	DWORD PTR [rax], edx
$LN7@overflow:

; 237  : 		return (*_IPnext);

	mov	rax, QWORD PTR [rbx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

	mov	rdx, QWORD PTR [rax]
	test	rdx, rdx
	je	SHORT $LN8@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	rax, QWORD PTR [rbx+88]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

	movsxd	rcx, DWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	lea	rax, QWORD PTR [rdx+rcx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

	cmp	rdx, rax
	jae	SHORT $LN8@overflow

; 132  : 			{	// room in buffer, store it
; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	rcx, rbx
	call	QWORD PTR __imp_?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ
	mov	rbp, QWORD PTR [rsp+80]
	mov	WORD PTR [rax], r14w

; 134  : 			return (_Meta);

	movzx	eax, r14w

; 186  : 			}
; 187  : 		}

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rbx
	ret	0
$LN8@overflow:

; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

	xor	ebp, ebp
	mov	QWORD PTR [rsp+96], rdi
	test	rdx, rdx
	jne	SHORT $LN20@overflow
	mov	edi, ebp
	jmp	SHORT $LN21@overflow
$LN20@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	rax, QWORD PTR [rbx+88]
	movsxd	rdi, DWORD PTR [rax]

; 222  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [rbx+24]

; 260  : 		return (*_IPnext + *_IPcount);

	add	rdi, rdi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

	sub	rdi, QWORD PTR [rax]
	add	rdi, rdx
	sar	rdi, 1
$LN21@overflow:

; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE

	mov	rax, rdi
	shr	rax, 1
	cmp	rax, 32					; 00000020H
	jae	SHORT $LN22@overflow
	mov	eax, 32					; 00000020H
	jmp	SHORT $LL2@overflow
$LN22@overflow:

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

	test	rax, rax
	je	SHORT $LN112@overflow
$LL2@overflow:
	mov	ecx, 2147483647				; 7fffffffH
	sub	rcx, rax
	cmp	rcx, rdi
	jae	SHORT $LN107@overflow

; 145  : 				_Inc /= 2;	// increment causes overflow, halve it

	shr	rax, 1

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

	jne	SHORT $LL2@overflow
$LN107@overflow:

; 146  : 			if (_Inc == 0)

	test	rax, rax
	jne	SHORT $LN10@overflow
$LN112@overflow:
	mov	rdi, QWORD PTR [rsp+96]

; 147  : 				return (_Traits::eof());	// buffer can't grow, fail

	movzx	eax, r8w
	mov	rbp, QWORD PTR [rsp+80]

; 186  : 			}
; 187  : 		}

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rbx
	ret	0
$LN10@overflow:
	mov	QWORD PTR [rsp+88], rsi

; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);

	lea	rcx, QWORD PTR [rbx+116]
	mov	QWORD PTR [rsp+48], r12
	lea	r12, QWORD PTR [rax+rdi]
	mov	rdx, r12
	mov	QWORD PTR [rsp+40], r13
	mov	QWORD PTR [rsp+32], r15
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	rcx, QWORD PTR [rbx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);

	mov	rsi, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	r15, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 154  : 			if (0 < _Oldsize)

	test	rdi, rdi
	je	SHORT $LN114@overflow
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	r8, QWORD PTR [rdi+rdi]
	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 157  : 			if (_Oldsize == 0)

	test	rdi, rdi
	jne	SHORT $LN12@overflow
$LN114@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 294  : 		*_IPfirst = _First;

	mov	rax, QWORD PTR [rbx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 159  : 				_Seekhigh = _Newptr;

	mov	QWORD PTR [rbx+104], rsi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 294  : 		*_IPfirst = _First;

	mov	QWORD PTR [rax], rsi

; 295  : 		*_IPnext = _First;

	mov	rax, QWORD PTR [rbx+64]
	mov	QWORD PTR [rax], rsi

; 296  : 		*_IPcount = (int)(_Last - _First);

	mov	rax, QWORD PTR [rbx+88]
	mov	DWORD PTR [rax], r12d

; 253  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR [rbx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 161  : 				if (_Mystate & _Noread)

	test	BYTE PTR [rbx+112], 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	QWORD PTR [rax], rsi

; 254  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rbx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 161  : 				if (_Mystate & _Noread)

	je	SHORT $LN14@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 254  : 		*_IGnext = _Next;

	mov	QWORD PTR [rax], rbp

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	rax, QWORD PTR [rbx+80]
	sar	rsi, 1
	mov	DWORD PTR [rax], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 163  : 				else

	jmp	$LN17@overflow
$LN14@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 254  : 		*_IGnext = _Next;

	mov	QWORD PTR [rax], rsi

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 166  : 			else

	jmp	$LN17@overflow
$LN12@overflow:

; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);

	mov	rax, QWORD PTR [rbx+104]
	sub	rax, r15
	sar	rax, 1
	lea	rax, QWORD PTR [rsi+rax*2]
	mov	QWORD PTR [rbx+104], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	rax, QWORD PTR [rbx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

	mov	rcx, QWORD PTR [rax]
	sub	rcx, r15
	sar	rcx, 1
	lea	rdx, QWORD PTR [rsi+rcx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 232  : 		return (*_IPfirst);

	mov	rcx, QWORD PTR [rbx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

	mov	rax, QWORD PTR [rcx]
	sub	rax, r15
	sar	rax, 1
	lea	rax, QWORD PTR [rsi+rax*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 301  : 		*_IPfirst = _First;

	mov	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

	lea	rcx, QWORD PTR [r12+r12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 302  : 		*_IPnext = _Next;

	mov	rax, QWORD PTR [rbx+64]

; 303  : 		*_IPcount = (int)(_Last - _Next);

	sub	rcx, rdx
	add	rcx, rsi
	sar	rcx, 1
	mov	QWORD PTR [rax], rdx
	mov	rax, QWORD PTR [rbx+88]
	mov	DWORD PTR [rax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 172  : 				if (_Mystate & _Noread)

	test	BYTE PTR [rbx+112], 4
	je	SHORT $LN16@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR [rax], rsi

; 254  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rbx+56]

; 255  : 		*_IGcount = (int)(_Last - _Next);

	sar	rsi, 1
	mov	QWORD PTR [rax], rbp
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 174  : 				else

	jmp	SHORT $LN17@overflow
$LN16@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	rax, QWORD PTR [rbx+64]
	mov	r10, QWORD PTR [rax]

; 227  : 		return (*_IGnext);

	mov	rax, QWORD PTR [rbx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 175  : 					_Mysb::setg(_Newptr,

	mov	rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR [rbx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 175  : 					_Mysb::setg(_Newptr,

	sub	rcx, r15
	sar	rcx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	QWORD PTR [rax], rsi

; 254  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rbx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 175  : 					_Mysb::setg(_Newptr,

	lea	r9, QWORD PTR [rsi+rcx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 255  : 		*_IGcount = (int)(_Last - _Next);

	sub	r10, r9
	add	r10, 2
	sar	r10, 1
	mov	QWORD PTR [rax], r9
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], r10d
$LN17@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 180  : 			if (_Mystate & _Allocated)

	test	BYTE PTR [rbx+112], 1
	mov	r12, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+88]
	je	SHORT $LN18@overflow

; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);

	mov	r8, rdi
	lea	rcx, QWORD PTR [rbx+116]
	mov	rdx, r15
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN18@overflow:

; 182  : 			_Mystate |= _Allocated;

	or	DWORD PTR [rbx+112], 1

; 183  : 
; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	rcx, rbx
	call	QWORD PTR __imp_?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ
	mov	r15, QWORD PTR [rsp+32]
	mov	r13, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+80]
	mov	WORD PTR [rax], r14w

; 185  : 			return (_Meta);

	movzx	eax, r14w

; 186  : 			}
; 187  : 		}

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rbx
	ret	0
?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 75   : 		{	// destroy the object

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR [rcx], rax

; 76   : 		_Tidy();

	call	?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
	npad	1

; 77   : 		}

	mov	rcx, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Str$ = 72
_Mode$ = 80
??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 34   : 	explicit basic_stringbuf(const _Mystr& _Str,

$LN34:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rsi
	mov	ebx, r8d
	mov	rdi, rdx
	mov	rsi, rcx

; 35   : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 36   : 		{	// construct character buffer from string, mode

	call	QWORD PTR __imp_??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR [rsi], rax
	lea	r9d, DWORD PTR [rbx*4]
	not	r9d
	and	r9d, 4

; 358  : 		if (!(_Mode & ios_base::out))

	mov	eax, ebx
	mov	ecx, r9d
	or	ecx, 2
	and	al, 2
	cmovne	ecx, r9d

; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)

	mov	eax, ebx
	mov	edx, ecx
	or	edx, 8
	and	al, 8
	cmove	edx, ecx
	mov	r9d, edx
	or	r9d, 16

; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)

	and	bl, 4
	cmove	r9d, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1765 : 		return (this->_Mysize());

	mov	r8, QWORD PTR [rdi+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rdi+24], 8
	jb	SHORT $LN31@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN31@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 37   : 		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));

	mov	rdx, rdi
	mov	rcx, rsi
	call	?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init
	npad	1

; 38   : 		}

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Str$ = 72
_Mode$ = 80
?dtor$0@?0???0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Str$ = 72
_Mode$ = 80
?dtor$0@?0???0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
this$ = 72
??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 635  : 		{	// destroy the object

$LN16:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+80], rbx
	mov	rdi, rcx
	mov	rax, QWORD PTR [rcx-152]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR [rdx+rcx-152], rax
	mov	rax, QWORD PTR [rcx-152]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	r8d, DWORD PTR [rdx-152]
	mov	DWORD PTR [rdx+rcx-156], r8d

; 636  : 		}

	lea	rbx, QWORD PTR [rcx-128]
	mov	QWORD PTR this$[rsp], rbx

; 75   : 		{	// destroy the object

	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR [rbx], rax

; 76   : 		_Tidy();

	mov	rcx, rbx
	call	?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
	npad	1

; 77   : 		}

	mov	rcx, rbx
	call	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
	npad	1

; 636  : 		}

	lea	rcx, QWORD PTR [rdi-120]
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 72
?dtor$0@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
$T1 = 32
this$ = 64
this$ = 72
?dtor$1@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
$T1 = 32
this$ = 64
this$ = 72
?dtor$2@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$2@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 72
?dtor$0@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 72
?dtor$1@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 72
?dtor$2@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$2@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 598  : 		{	// construct character buffer from NTCS

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T2[rsp], -2
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rbp
	mov	QWORD PTR [rsp+104], rsi
	mov	esi, r8d
	mov	rbp, rdx
	mov	rdi, rcx
	mov	DWORD PTR $T1[rsp], 0
	test	r9d, r9d
	je	SHORT $LN2@basic_stri
	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR [rcx], rax
	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR [rcx+16], rax
	lea	r9, QWORD PTR [rcx+152]
	mov	QWORD PTR this$[rsp], r9
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 534  : 		{	// default constructor

	mov	rax, QWORD PTR __imp_??_7ios_base@std@@6B@
	mov	QWORD PTR [r9], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 184  : 		{	// default constructor, do nothing

	mov	rax, QWORD PTR __imp_??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
	mov	QWORD PTR [r9], rax
	mov	DWORD PTR $T1[rsp], 1
$LN2@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 596  : 		: _Mybase(&_Stringbuffer),

	xor	r8d, r8d
	lea	rdx, QWORD PTR [rcx+24]
	call	QWORD PTR __imp_??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QEAA@PEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
	npad	1

; 598  : 		{	// construct character buffer from NTCS

	mov	rax, QWORD PTR [rdi]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR [rdx+rdi], rax
	mov	rax, QWORD PTR [rdi]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	r8d, DWORD PTR [rdx-152]
	mov	DWORD PTR [rdx+rdi-4], r8d

; 597  : 			_Stringbuffer(_Str, _Mode)

	mov	r8d, esi
	mov	rdx, rbp
	lea	rcx, QWORD PTR [rdi+24]
	call	??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1

; 599  : 		}

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$3@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$3
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$3@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$3
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$1@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$2@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$2@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$3@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$3
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$3@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$1@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$2@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$2@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
_TEXT	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z PROC ; parsePattern, COMDAT

; 524  : static int parsePattern(std::wstring str, TilePattern* pat) {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-760]
	sub	rsp, 1016				; 000003f8H
	mov	QWORD PTR $T10[rbp-256], -2
	vmovaps	XMMWORD PTR [rsp+992], xmm6
	mov	rbx, rdx
	mov	r14, rcx
	mov	QWORD PTR str$1$[rbp-256], rcx
	xor	r12d, r12d
	mov	r15d, r12d
	mov	DWORD PTR $T1[rsp], r12d

; 525  : 	pat->rows.clear();

	lea	rsi, QWORD PTR [rdx+32]
	mov	QWORD PTR this$1$[rbp-256], rsi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T19[rbp-256]
	mov	r8, rsi
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	call	??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	rax, QWORD PTR [rsi]
	mov	QWORD PTR [rsi+8], rax
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 526  : 	pat->heights.clear();

	lea	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR this$1$[rbp-256], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	rax, QWORD PTR [rbx+8]
	mov	QWORD PTR [rbx+16], rax
	vpxor	xmm0, xmm0, xmm0
	vmovdqu	XMMWORD PTR rowStrings$[rsp], xmm0

; 487  : 		_Myend()

	mov	QWORD PTR rowStrings$[rsp+16], r12
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	QWORD PTR $T3[rsp+16], r12

; 497  : 		_Myres(0)

	mov	QWORD PTR $T3[rsp+24], r12

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rsp+16], r12
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T3[rsp], r12w
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [r12+1]
	lea	rdx, OFFSET FLAT:??_C@_13CGOKJPIL@?$AA?1?$AA?$AA@
	lea	rcx, QWORD PTR $T3[rsp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 529  : 	tokenize(str, rowStrings, L"/");

	lea	r8, QWORD PTR $T3[rsp]
	lea	rdx, QWORD PTR rowStrings$[rsp]
	mov	rcx, r14
	call	?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z ; tokenize
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	r8, QWORD PTR $T3[rsp+24]
	cmp	r8, 8
	jb	SHORT $LN182@parsePatte

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN182@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T3[rsp+16], r12
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T3[rsp], r12w
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 531  : 	for (int i=0; i<rowStrings.size(); i++) {		

	mov	DWORD PTR i$1$[rbp-256], r12d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rcx, QWORD PTR rowStrings$[rsp+8]
	mov	rax, rcx
	mov	rsi, QWORD PTR rowStrings$[rsp]
	sub	rax, rsi
	sar	rax, 5
	mov	QWORD PTR tv6005[rbp-256], rax
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 531  : 	for (int i=0; i<rowStrings.size(); i++) {		

	test	rax, rax
	je	$LN3@parsePatte
	mov	rdi, r12
	movzx	ebx, BYTE PTR $T14[rbp-256]
$LN2369@parsePatte:
	lea	r14, OFFSET FLAT:??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	r13, 9223372036854775807		; 7fffffffffffffffH
	vpxor	xmm0, xmm0, xmm0
	vmovdqu	XMMWORD PTR row$4[rsp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 487  : 		_Myend()

	mov	QWORD PTR row$4[rsp+16], r12
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	QWORD PTR $T5[rbp-240], r12

; 497  : 		_Myres(0)

	mov	QWORD PTR $T5[rbp-232], r12

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-232], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rbp-240], r12
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T5[rsp], r12w
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@
	lea	rcx, QWORD PTR $T5[rsp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	shl	rdi, 5
	lea	rcx, QWORD PTR [rsi+rdi]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 533  : 		tokenize(rowStrings[i], row, L",");

	lea	r8, QWORD PTR $T5[rsp]
	lea	rdx, QWORD PTR row$4[rsp]
	call	?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z ; tokenize
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	rax, QWORD PTR $T5[rbp-232]
	cmp	rax, 8
	jb	SHORT $LN457@parsePatte

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	rcx, QWORD PTR $T5[rsp]

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, r13
	ja	$LN2344@parsePatte

; 95   : 	const size_t _User_size = _Count * _Sz;

	add	rax, rax

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN452@parsePatte

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	jne	$LN2345@parsePatte

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jae	$LN2346@parsePatte

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jb	$LN2347@parsePatte

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	ja	$LN2348@parsePatte

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN452@parsePatte:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
$LN457@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-232], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T5[rbp-240], r12
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T5[rsp], r12w
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rax, QWORD PTR row$4[rsp+8]
	mov	r13, rax
	mov	r12, QWORD PTR row$4[rsp]
	sub	r13, r12
	sar	r13, 5
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 535  : 		if (row.size() < 3)

	cmp	r13, 3
	jb	$LN2349@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 598  : 		{	// construct character buffer from NTCS

	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR s0$12[rbp-256], rax
	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR s0$12[rbp-240], rax
	lea	rcx, QWORD PTR s0$12[rbp-104]
	call	QWORD PTR __imp_??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IEAA@XZ
	npad	1
	or	r15d, 1
	mov	DWORD PTR $T1[rsp], r15d

; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	enum
; 350  : 		{	// constant for minimum buffer size
; 351  : 		_MINSIZE = 32};
; 352  : 
; 353  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 354  : 		{	// convert open mode to stream state bits
; 355  : 		_Strstate _State = (_Strstate)0;
; 356  : 		if (!(_Mode & ios_base::in))
; 357  : 			_State |= _Noread;
; 358  : 		if (!(_Mode & ios_base::out))
; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)
; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)
; 363  : 			_State |= _Atend;
; 364  : 		return (_State);
; 365  : 		}
; 366  : 
; 367  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 368  : 	_Strstate _Mystate;	// the stream state
; 369  : 	allocator_type _Al;	// the allocator object
; 370  : 	};
; 371  : 
; 372  : 	// basic_stringbuf TEMPLATE OPERATORS
; 373  : template<class _Elem,
; 374  : 	class _Traits,
; 375  : 	class _Alloc> inline
; 376  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 377  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 378  : 	{	// swap _Left and _Right basic_stringbufs
; 379  : 	_Left.swap(_Right);
; 380  : 	}
; 381  : 
; 382  : 		// TEMPLATE CLASS basic_istringstream
; 383  : template<class _Elem,
; 384  : 	class _Traits,
; 385  : 	class _Alloc>
; 386  : 	class basic_istringstream
; 387  : 		: public basic_istream<_Elem, _Traits>
; 388  : 	{	// input stream associated with a character array
; 389  : public:
; 390  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 391  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 392  : 	typedef _Alloc allocator_type;
; 393  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 394  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 395  : 
; 396  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 397  : 		: _Mybase(&_Stringbuffer),
; 398  : 			_Stringbuffer(_Mode | ios_base::in)
; 399  : 		{	// construct empty readable character buffer
; 400  : 		}
; 401  : 
; 402  : 	explicit basic_istringstream(const _Mystr& _Str,
; 403  : 		ios_base::openmode _Mode = ios_base::in)
; 404  : 		: _Mybase(&_Stringbuffer),
; 405  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 406  : 		{	// construct readable character buffer from NTCS
; 407  : 		}
; 408  : 
; 409  : 	basic_istringstream(_Myt&& _Right)
; 410  : 		: _Mybase(&_Stringbuffer)
; 411  : 		{	// construct by moving _Right
; 412  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 413  : 		}
; 414  : 
; 415  : 	_Myt& operator=(_Myt&& _Right)
; 416  : 		{	// move from _Right
; 417  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	void _Assign_rv(_Myt&& _Right)
; 422  : 		{	// assign by moving _Right
; 423  : 		if (this != &_Right)
; 424  : 			{	// different, worth moving
; 425  : 			_Stringbuffer.str(_Mystr());
; 426  : 			this->swap(_Right);
; 427  : 			}
; 428  : 		}
; 429  : 
; 430  : 	void swap(_Myt& _Right)
; 431  : 		{	// swap with _Right
; 432  : 		if (this != &_Right)
; 433  : 			{	// different, swap base and buffer
; 434  : 			_Mybase::swap(_Right);
; 435  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 436  : 			}
; 437  : 		}
; 438  : 
; 439  : 	basic_istringstream(const _Myt&) = delete;
; 440  : 	_Myt& operator=(const _Myt&) = delete;
; 441  : 
; 442  : 	virtual ~basic_istringstream() _NOEXCEPT
; 443  : 		{	// destroy the object
; 444  : 		}
; 445  : 
; 446  : 	_Mysb *rdbuf() const
; 447  : 		{	// return pointer to file buffer
; 448  : 		return ((_Mysb *)&_Stringbuffer);
; 449  : 		}
; 450  : 
; 451  : 	_Mystr str() const
; 452  : 		{	// return string copy of character array
; 453  : 		return (_Stringbuffer.str());
; 454  : 		}
; 455  : 
; 456  : 	void str(const _Mystr& _Newstr)
; 457  : 		{	// replace character array from string
; 458  : 		_Stringbuffer.str(_Newstr);
; 459  : 		}
; 460  : 
; 461  : private:
; 462  : 	_Mysb _Stringbuffer;	// the string buffer
; 463  : 	};
; 464  : 
; 465  : 	// basic_istringstream TEMPLATE OPERATORS
; 466  : template<class _Elem,
; 467  : 	class _Traits,
; 468  : 	class _Alloc> inline
; 469  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 470  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 471  : 	{	// swap _Left and _Right basic_istringstreams
; 472  : 	_Left.swap(_Right);
; 473  : 	}
; 474  : 
; 475  : 		// TEMPLATE CLASS basic_ostringstream
; 476  : template<class _Elem,
; 477  : 	class _Traits,
; 478  : 	class _Alloc>
; 479  : 	class basic_ostringstream
; 480  : 		: public basic_ostream<_Elem, _Traits>
; 481  : 	{	// output stream associated with a character array
; 482  : public:
; 483  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 484  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 485  : 	typedef _Alloc allocator_type;
; 486  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 487  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 488  : 
; 489  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 490  : 		: _Mybase(&_Stringbuffer),
; 491  : 			_Stringbuffer(_Mode | ios_base::out)
; 492  : 		{	// construct empty writable character buffer
; 493  : 		}
; 494  : 
; 495  : 	explicit basic_ostringstream(const _Mystr& _Str,
; 496  : 		ios_base::openmode _Mode = ios_base::out)
; 497  : 		: _Mybase(&_Stringbuffer),
; 498  : 			_Stringbuffer(_Str, _Mode | ios_base::out)
; 499  : 		{	// construct writable character buffer from NTCS
; 500  : 		}
; 501  : 
; 502  : 	basic_ostringstream(_Myt&& _Right)
; 503  : 		: _Mybase(&_Stringbuffer)
; 504  : 		{	// construct by moving _Right
; 505  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 506  : 		}
; 507  : 
; 508  : 	_Myt& operator=(_Myt&& _Right)
; 509  : 		{	// move from _Right
; 510  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 511  : 		return (*this);
; 512  : 		}
; 513  : 
; 514  : 	void _Assign_rv(_Myt&& _Right)
; 515  : 		{	// assign by moving _Right
; 516  : 		if (this != &_Right)
; 517  : 			{	// different, worth moving
; 518  : 			_Stringbuffer.str(_Mystr());
; 519  : 			this->swap(_Right);
; 520  : 			}
; 521  : 		}
; 522  : 
; 523  : 	void swap(_Myt& _Right)
; 524  : 		{	// swap with _Right
; 525  : 		if (this != &_Right)
; 526  : 			{	// different, swap base and buffer
; 527  : 			_Mybase::swap(_Right);
; 528  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 529  : 			}
; 530  : 		}
; 531  : 
; 532  : 	basic_ostringstream(const _Myt&) = delete;
; 533  : 	_Myt& operator=(const _Myt&) = delete;
; 534  : 
; 535  : 	virtual ~basic_ostringstream() _NOEXCEPT
; 536  : 		{	// destroy the object
; 537  : 		}
; 538  : 
; 539  : 	_Mysb *rdbuf() const
; 540  : 		{	// return pointer to buffer
; 541  : 		return ((_Mysb *)&_Stringbuffer);
; 542  : 		}
; 543  : 
; 544  : 	_Mystr str() const
; 545  : 		{	// return string copy of character array
; 546  : 		return (_Stringbuffer.str());
; 547  : 		}
; 548  : 
; 549  : 	void str(const _Mystr& _Newstr)
; 550  : 		{	// replace character array from string
; 551  : 		_Stringbuffer.str(_Newstr);
; 552  : 		}
; 553  : 
; 554  : private:
; 555  : 	_Mysb _Stringbuffer;	// the string buffer
; 556  : 	};
; 557  : 
; 558  : 	// basic_ostringstream TEMPLATE OPERATORS
; 559  : template<class _Elem,
; 560  : 	class _Traits,
; 561  : 	class _Alloc> inline
; 562  : 	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
; 563  : 		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
; 564  : 	{	// swap _Left and _Right basic_ostringstreams
; 565  : 	_Left.swap(_Right);
; 566  : 	}
; 567  : 
; 568  : 		// TEMPLATE CLASS basic_stringstream
; 569  : template<class _Elem,
; 570  : 	class _Traits,
; 571  : 	class _Alloc>
; 572  : 	class basic_stringstream
; 573  : 		: public basic_iostream<_Elem, _Traits>
; 574  : 	{	// input/output stream associated with a character array
; 575  : public:
; 576  : 	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
; 577  : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 578  : 	typedef _Elem char_type;
; 579  : 	typedef _Traits traits_type;
; 580  : 	typedef _Alloc allocator_type;
; 581  : 	typedef typename _Traits::int_type int_type;
; 582  : 	typedef typename _Traits::pos_type pos_type;
; 583  : 	typedef typename _Traits::off_type off_type;
; 584  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 585  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 586  : 
; 587  : 	explicit basic_stringstream(ios_base::openmode _Mode =
; 588  : 		ios_base::in | ios_base::out)
; 589  : 		: _Mybase(&_Stringbuffer),
; 590  : 			_Stringbuffer(_Mode)
; 591  : 		{	// construct empty character buffer
; 592  : 		}
; 593  : 
; 594  : 	explicit basic_stringstream(const _Mystr& _Str,
; 595  : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 596  : 		: _Mybase(&_Stringbuffer),

	xor	r8d, r8d
	lea	rdx, QWORD PTR s0$12[rbp-232]
	lea	rcx, QWORD PTR s0$12[rbp-256]
	call	QWORD PTR __imp_??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QEAA@PEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
	npad	1

; 598  : 		{	// construct character buffer from NTCS

	mov	rax, QWORD PTR s0$12[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rsi, OFFSET FLAT:??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR s0$12[rbp+rcx-256], rsi
	mov	rax, QWORD PTR s0$12[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-152]
	mov	DWORD PTR s0$12[rbp+rcx-260], edx

; 597  : 			_Stringbuffer(_Str, _Mode)

	lea	rax, QWORD PTR s0$12[rbp-232]
	mov	QWORD PTR this$[rbp-256], rax

; 36   : 		{	// construct character buffer from string, mode

	lea	rcx, QWORD PTR s0$12[rbp-232]
	call	QWORD PTR __imp_??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAA@XZ
	npad	1
	mov	QWORD PTR s0$12[rbp-232], r14
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [r12+24], 8
	jb	SHORT $LN792@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rdx, QWORD PTR [r12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN793@parsePatte
$LN792@parsePatte:
	mov	rdx, r12
$LN793@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 37   : 		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));

	xor	r9d, r9d
	mov	r8, QWORD PTR [r12+16]
	lea	rcx, QWORD PTR s0$12[rbp-232]
	call	?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 540  : 		s0 >> offset;

	lea	rdx, QWORD PTR offset$6[rbp-256]
	lea	rcx, QWORD PTR s0$12[rbp-256]
	call	QWORD PTR __imp_??5?$basic_istream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV01@AEAN@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	lea	rdi, QWORD PTR [r12+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 598  : 		{	// construct character buffer from NTCS

	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR s1$11[rbp-256], rax
	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR s1$11[rbp-240], rax
	lea	rcx, QWORD PTR s1$11[rbp-104]
	call	QWORD PTR __imp_??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IEAA@XZ
	npad	1
	or	r15d, 2
	mov	DWORD PTR $T1[rsp], r15d

; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	enum
; 350  : 		{	// constant for minimum buffer size
; 351  : 		_MINSIZE = 32};
; 352  : 
; 353  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 354  : 		{	// convert open mode to stream state bits
; 355  : 		_Strstate _State = (_Strstate)0;
; 356  : 		if (!(_Mode & ios_base::in))
; 357  : 			_State |= _Noread;
; 358  : 		if (!(_Mode & ios_base::out))
; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)
; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)
; 363  : 			_State |= _Atend;
; 364  : 		return (_State);
; 365  : 		}
; 366  : 
; 367  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 368  : 	_Strstate _Mystate;	// the stream state
; 369  : 	allocator_type _Al;	// the allocator object
; 370  : 	};
; 371  : 
; 372  : 	// basic_stringbuf TEMPLATE OPERATORS
; 373  : template<class _Elem,
; 374  : 	class _Traits,
; 375  : 	class _Alloc> inline
; 376  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 377  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 378  : 	{	// swap _Left and _Right basic_stringbufs
; 379  : 	_Left.swap(_Right);
; 380  : 	}
; 381  : 
; 382  : 		// TEMPLATE CLASS basic_istringstream
; 383  : template<class _Elem,
; 384  : 	class _Traits,
; 385  : 	class _Alloc>
; 386  : 	class basic_istringstream
; 387  : 		: public basic_istream<_Elem, _Traits>
; 388  : 	{	// input stream associated with a character array
; 389  : public:
; 390  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 391  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 392  : 	typedef _Alloc allocator_type;
; 393  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 394  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 395  : 
; 396  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 397  : 		: _Mybase(&_Stringbuffer),
; 398  : 			_Stringbuffer(_Mode | ios_base::in)
; 399  : 		{	// construct empty readable character buffer
; 400  : 		}
; 401  : 
; 402  : 	explicit basic_istringstream(const _Mystr& _Str,
; 403  : 		ios_base::openmode _Mode = ios_base::in)
; 404  : 		: _Mybase(&_Stringbuffer),
; 405  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 406  : 		{	// construct readable character buffer from NTCS
; 407  : 		}
; 408  : 
; 409  : 	basic_istringstream(_Myt&& _Right)
; 410  : 		: _Mybase(&_Stringbuffer)
; 411  : 		{	// construct by moving _Right
; 412  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 413  : 		}
; 414  : 
; 415  : 	_Myt& operator=(_Myt&& _Right)
; 416  : 		{	// move from _Right
; 417  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	void _Assign_rv(_Myt&& _Right)
; 422  : 		{	// assign by moving _Right
; 423  : 		if (this != &_Right)
; 424  : 			{	// different, worth moving
; 425  : 			_Stringbuffer.str(_Mystr());
; 426  : 			this->swap(_Right);
; 427  : 			}
; 428  : 		}
; 429  : 
; 430  : 	void swap(_Myt& _Right)
; 431  : 		{	// swap with _Right
; 432  : 		if (this != &_Right)
; 433  : 			{	// different, swap base and buffer
; 434  : 			_Mybase::swap(_Right);
; 435  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 436  : 			}
; 437  : 		}
; 438  : 
; 439  : 	basic_istringstream(const _Myt&) = delete;
; 440  : 	_Myt& operator=(const _Myt&) = delete;
; 441  : 
; 442  : 	virtual ~basic_istringstream() _NOEXCEPT
; 443  : 		{	// destroy the object
; 444  : 		}
; 445  : 
; 446  : 	_Mysb *rdbuf() const
; 447  : 		{	// return pointer to file buffer
; 448  : 		return ((_Mysb *)&_Stringbuffer);
; 449  : 		}
; 450  : 
; 451  : 	_Mystr str() const
; 452  : 		{	// return string copy of character array
; 453  : 		return (_Stringbuffer.str());
; 454  : 		}
; 455  : 
; 456  : 	void str(const _Mystr& _Newstr)
; 457  : 		{	// replace character array from string
; 458  : 		_Stringbuffer.str(_Newstr);
; 459  : 		}
; 460  : 
; 461  : private:
; 462  : 	_Mysb _Stringbuffer;	// the string buffer
; 463  : 	};
; 464  : 
; 465  : 	// basic_istringstream TEMPLATE OPERATORS
; 466  : template<class _Elem,
; 467  : 	class _Traits,
; 468  : 	class _Alloc> inline
; 469  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 470  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 471  : 	{	// swap _Left and _Right basic_istringstreams
; 472  : 	_Left.swap(_Right);
; 473  : 	}
; 474  : 
; 475  : 		// TEMPLATE CLASS basic_ostringstream
; 476  : template<class _Elem,
; 477  : 	class _Traits,
; 478  : 	class _Alloc>
; 479  : 	class basic_ostringstream
; 480  : 		: public basic_ostream<_Elem, _Traits>
; 481  : 	{	// output stream associated with a character array
; 482  : public:
; 483  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 484  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 485  : 	typedef _Alloc allocator_type;
; 486  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 487  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 488  : 
; 489  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 490  : 		: _Mybase(&_Stringbuffer),
; 491  : 			_Stringbuffer(_Mode | ios_base::out)
; 492  : 		{	// construct empty writable character buffer
; 493  : 		}
; 494  : 
; 495  : 	explicit basic_ostringstream(const _Mystr& _Str,
; 496  : 		ios_base::openmode _Mode = ios_base::out)
; 497  : 		: _Mybase(&_Stringbuffer),
; 498  : 			_Stringbuffer(_Str, _Mode | ios_base::out)
; 499  : 		{	// construct writable character buffer from NTCS
; 500  : 		}
; 501  : 
; 502  : 	basic_ostringstream(_Myt&& _Right)
; 503  : 		: _Mybase(&_Stringbuffer)
; 504  : 		{	// construct by moving _Right
; 505  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 506  : 		}
; 507  : 
; 508  : 	_Myt& operator=(_Myt&& _Right)
; 509  : 		{	// move from _Right
; 510  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 511  : 		return (*this);
; 512  : 		}
; 513  : 
; 514  : 	void _Assign_rv(_Myt&& _Right)
; 515  : 		{	// assign by moving _Right
; 516  : 		if (this != &_Right)
; 517  : 			{	// different, worth moving
; 518  : 			_Stringbuffer.str(_Mystr());
; 519  : 			this->swap(_Right);
; 520  : 			}
; 521  : 		}
; 522  : 
; 523  : 	void swap(_Myt& _Right)
; 524  : 		{	// swap with _Right
; 525  : 		if (this != &_Right)
; 526  : 			{	// different, swap base and buffer
; 527  : 			_Mybase::swap(_Right);
; 528  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 529  : 			}
; 530  : 		}
; 531  : 
; 532  : 	basic_ostringstream(const _Myt&) = delete;
; 533  : 	_Myt& operator=(const _Myt&) = delete;
; 534  : 
; 535  : 	virtual ~basic_ostringstream() _NOEXCEPT
; 536  : 		{	// destroy the object
; 537  : 		}
; 538  : 
; 539  : 	_Mysb *rdbuf() const
; 540  : 		{	// return pointer to buffer
; 541  : 		return ((_Mysb *)&_Stringbuffer);
; 542  : 		}
; 543  : 
; 544  : 	_Mystr str() const
; 545  : 		{	// return string copy of character array
; 546  : 		return (_Stringbuffer.str());
; 547  : 		}
; 548  : 
; 549  : 	void str(const _Mystr& _Newstr)
; 550  : 		{	// replace character array from string
; 551  : 		_Stringbuffer.str(_Newstr);
; 552  : 		}
; 553  : 
; 554  : private:
; 555  : 	_Mysb _Stringbuffer;	// the string buffer
; 556  : 	};
; 557  : 
; 558  : 	// basic_ostringstream TEMPLATE OPERATORS
; 559  : template<class _Elem,
; 560  : 	class _Traits,
; 561  : 	class _Alloc> inline
; 562  : 	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
; 563  : 		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
; 564  : 	{	// swap _Left and _Right basic_ostringstreams
; 565  : 	_Left.swap(_Right);
; 566  : 	}
; 567  : 
; 568  : 		// TEMPLATE CLASS basic_stringstream
; 569  : template<class _Elem,
; 570  : 	class _Traits,
; 571  : 	class _Alloc>
; 572  : 	class basic_stringstream
; 573  : 		: public basic_iostream<_Elem, _Traits>
; 574  : 	{	// input/output stream associated with a character array
; 575  : public:
; 576  : 	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
; 577  : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 578  : 	typedef _Elem char_type;
; 579  : 	typedef _Traits traits_type;
; 580  : 	typedef _Alloc allocator_type;
; 581  : 	typedef typename _Traits::int_type int_type;
; 582  : 	typedef typename _Traits::pos_type pos_type;
; 583  : 	typedef typename _Traits::off_type off_type;
; 584  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 585  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 586  : 
; 587  : 	explicit basic_stringstream(ios_base::openmode _Mode =
; 588  : 		ios_base::in | ios_base::out)
; 589  : 		: _Mybase(&_Stringbuffer),
; 590  : 			_Stringbuffer(_Mode)
; 591  : 		{	// construct empty character buffer
; 592  : 		}
; 593  : 
; 594  : 	explicit basic_stringstream(const _Mystr& _Str,
; 595  : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 596  : 		: _Mybase(&_Stringbuffer),

	xor	r8d, r8d
	lea	rdx, QWORD PTR s1$11[rbp-232]
	lea	rcx, QWORD PTR s1$11[rbp-256]
	call	QWORD PTR __imp_??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QEAA@PEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
	npad	1

; 598  : 		{	// construct character buffer from NTCS

	mov	rax, QWORD PTR s1$11[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	QWORD PTR s1$11[rbp+rcx-256], rsi
	mov	rax, QWORD PTR s1$11[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-152]
	mov	DWORD PTR s1$11[rbp+rcx-260], edx

; 597  : 			_Stringbuffer(_Str, _Mode)

	lea	rax, QWORD PTR s1$11[rbp-232]
	mov	QWORD PTR this$[rbp-256], rax

; 36   : 		{	// construct character buffer from string, mode

	lea	rcx, QWORD PTR s1$11[rbp-232]
	call	QWORD PTR __imp_??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAA@XZ
	npad	1
	mov	QWORD PTR s1$11[rbp-232], r14
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1765 : 		return (this->_Mysize());

	mov	r8, QWORD PTR [rdi+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rdi+24], 8
	jb	SHORT $LN841@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN841@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 37   : 		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));

	xor	r9d, r9d
	mov	rdx, rdi
	lea	rcx, QWORD PTR s1$11[rbp-232]
	call	?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 542  : 		s1 >> height;

	lea	rdx, QWORD PTR height$8[rbp-256]
	lea	rcx, QWORD PTR s1$11[rbp-256]
	call	QWORD PTR __imp_??5?$basic_istream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV01@AEAN@Z
	vmovsd	xmm6, QWORD PTR offset$6[rbp-256]

; 543  : 
; 544  : 		TileRow r = TileRow(offset);

	vcvtpd2ps xmm6, xmm6
	vpxor	xmm0, xmm0, xmm0
	vmovdqu	XMMWORD PTR r$2[rsp+8], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 487  : 		_Myend()

	xor	r8d, r8d
	mov	r14d, r8d
	mov	QWORD PTR r$2[rsp+24], r8
; File g:\dropbox\github\berconmaps\src\tile.h

; 57   : 	TileRow(float offset) {this->offset = offset;}

	vmovss	DWORD PTR r$2[rsp], xmm6
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 546  : 		for (int j=2; j<row.size(); j++) {

	mov	esi, 2
	mov	DWORD PTR j$1$[rbp-256], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 37   : 		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));

	mov	r15, QWORD PTR r$2[rsp+8]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 546  : 		for (int j=2; j<row.size(); j++) {

	cmp	r13, rsi
	jbe	$LN6@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 37   : 		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));

	add	r12, 64					; 00000040H
	mov	rdi, QWORD PTR r$2[rsp+16]
	npad	5
$LL7@parsePatte:

; 598  : 		{	// construct character buffer from NTCS

	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR sn$9[rbp-256], rax
	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR sn$9[rbp-240], rax
	lea	rcx, QWORD PTR sn$9[rbp-104]
	call	QWORD PTR __imp_??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IEAA@XZ
	npad	1
	or	DWORD PTR $T1[rsp], 4

; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	enum
; 350  : 		{	// constant for minimum buffer size
; 351  : 		_MINSIZE = 32};
; 352  : 
; 353  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 354  : 		{	// convert open mode to stream state bits
; 355  : 		_Strstate _State = (_Strstate)0;
; 356  : 		if (!(_Mode & ios_base::in))
; 357  : 			_State |= _Noread;
; 358  : 		if (!(_Mode & ios_base::out))
; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)
; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)
; 363  : 			_State |= _Atend;
; 364  : 		return (_State);
; 365  : 		}
; 366  : 
; 367  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 368  : 	_Strstate _Mystate;	// the stream state
; 369  : 	allocator_type _Al;	// the allocator object
; 370  : 	};
; 371  : 
; 372  : 	// basic_stringbuf TEMPLATE OPERATORS
; 373  : template<class _Elem,
; 374  : 	class _Traits,
; 375  : 	class _Alloc> inline
; 376  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 377  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 378  : 	{	// swap _Left and _Right basic_stringbufs
; 379  : 	_Left.swap(_Right);
; 380  : 	}
; 381  : 
; 382  : 		// TEMPLATE CLASS basic_istringstream
; 383  : template<class _Elem,
; 384  : 	class _Traits,
; 385  : 	class _Alloc>
; 386  : 	class basic_istringstream
; 387  : 		: public basic_istream<_Elem, _Traits>
; 388  : 	{	// input stream associated with a character array
; 389  : public:
; 390  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 391  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 392  : 	typedef _Alloc allocator_type;
; 393  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 394  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 395  : 
; 396  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 397  : 		: _Mybase(&_Stringbuffer),
; 398  : 			_Stringbuffer(_Mode | ios_base::in)
; 399  : 		{	// construct empty readable character buffer
; 400  : 		}
; 401  : 
; 402  : 	explicit basic_istringstream(const _Mystr& _Str,
; 403  : 		ios_base::openmode _Mode = ios_base::in)
; 404  : 		: _Mybase(&_Stringbuffer),
; 405  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 406  : 		{	// construct readable character buffer from NTCS
; 407  : 		}
; 408  : 
; 409  : 	basic_istringstream(_Myt&& _Right)
; 410  : 		: _Mybase(&_Stringbuffer)
; 411  : 		{	// construct by moving _Right
; 412  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 413  : 		}
; 414  : 
; 415  : 	_Myt& operator=(_Myt&& _Right)
; 416  : 		{	// move from _Right
; 417  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	void _Assign_rv(_Myt&& _Right)
; 422  : 		{	// assign by moving _Right
; 423  : 		if (this != &_Right)
; 424  : 			{	// different, worth moving
; 425  : 			_Stringbuffer.str(_Mystr());
; 426  : 			this->swap(_Right);
; 427  : 			}
; 428  : 		}
; 429  : 
; 430  : 	void swap(_Myt& _Right)
; 431  : 		{	// swap with _Right
; 432  : 		if (this != &_Right)
; 433  : 			{	// different, swap base and buffer
; 434  : 			_Mybase::swap(_Right);
; 435  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 436  : 			}
; 437  : 		}
; 438  : 
; 439  : 	basic_istringstream(const _Myt&) = delete;
; 440  : 	_Myt& operator=(const _Myt&) = delete;
; 441  : 
; 442  : 	virtual ~basic_istringstream() _NOEXCEPT
; 443  : 		{	// destroy the object
; 444  : 		}
; 445  : 
; 446  : 	_Mysb *rdbuf() const
; 447  : 		{	// return pointer to file buffer
; 448  : 		return ((_Mysb *)&_Stringbuffer);
; 449  : 		}
; 450  : 
; 451  : 	_Mystr str() const
; 452  : 		{	// return string copy of character array
; 453  : 		return (_Stringbuffer.str());
; 454  : 		}
; 455  : 
; 456  : 	void str(const _Mystr& _Newstr)
; 457  : 		{	// replace character array from string
; 458  : 		_Stringbuffer.str(_Newstr);
; 459  : 		}
; 460  : 
; 461  : private:
; 462  : 	_Mysb _Stringbuffer;	// the string buffer
; 463  : 	};
; 464  : 
; 465  : 	// basic_istringstream TEMPLATE OPERATORS
; 466  : template<class _Elem,
; 467  : 	class _Traits,
; 468  : 	class _Alloc> inline
; 469  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 470  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 471  : 	{	// swap _Left and _Right basic_istringstreams
; 472  : 	_Left.swap(_Right);
; 473  : 	}
; 474  : 
; 475  : 		// TEMPLATE CLASS basic_ostringstream
; 476  : template<class _Elem,
; 477  : 	class _Traits,
; 478  : 	class _Alloc>
; 479  : 	class basic_ostringstream
; 480  : 		: public basic_ostream<_Elem, _Traits>
; 481  : 	{	// output stream associated with a character array
; 482  : public:
; 483  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 484  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 485  : 	typedef _Alloc allocator_type;
; 486  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 487  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 488  : 
; 489  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 490  : 		: _Mybase(&_Stringbuffer),
; 491  : 			_Stringbuffer(_Mode | ios_base::out)
; 492  : 		{	// construct empty writable character buffer
; 493  : 		}
; 494  : 
; 495  : 	explicit basic_ostringstream(const _Mystr& _Str,
; 496  : 		ios_base::openmode _Mode = ios_base::out)
; 497  : 		: _Mybase(&_Stringbuffer),
; 498  : 			_Stringbuffer(_Str, _Mode | ios_base::out)
; 499  : 		{	// construct writable character buffer from NTCS
; 500  : 		}
; 501  : 
; 502  : 	basic_ostringstream(_Myt&& _Right)
; 503  : 		: _Mybase(&_Stringbuffer)
; 504  : 		{	// construct by moving _Right
; 505  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 506  : 		}
; 507  : 
; 508  : 	_Myt& operator=(_Myt&& _Right)
; 509  : 		{	// move from _Right
; 510  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 511  : 		return (*this);
; 512  : 		}
; 513  : 
; 514  : 	void _Assign_rv(_Myt&& _Right)
; 515  : 		{	// assign by moving _Right
; 516  : 		if (this != &_Right)
; 517  : 			{	// different, worth moving
; 518  : 			_Stringbuffer.str(_Mystr());
; 519  : 			this->swap(_Right);
; 520  : 			}
; 521  : 		}
; 522  : 
; 523  : 	void swap(_Myt& _Right)
; 524  : 		{	// swap with _Right
; 525  : 		if (this != &_Right)
; 526  : 			{	// different, swap base and buffer
; 527  : 			_Mybase::swap(_Right);
; 528  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 529  : 			}
; 530  : 		}
; 531  : 
; 532  : 	basic_ostringstream(const _Myt&) = delete;
; 533  : 	_Myt& operator=(const _Myt&) = delete;
; 534  : 
; 535  : 	virtual ~basic_ostringstream() _NOEXCEPT
; 536  : 		{	// destroy the object
; 537  : 		}
; 538  : 
; 539  : 	_Mysb *rdbuf() const
; 540  : 		{	// return pointer to buffer
; 541  : 		return ((_Mysb *)&_Stringbuffer);
; 542  : 		}
; 543  : 
; 544  : 	_Mystr str() const
; 545  : 		{	// return string copy of character array
; 546  : 		return (_Stringbuffer.str());
; 547  : 		}
; 548  : 
; 549  : 	void str(const _Mystr& _Newstr)
; 550  : 		{	// replace character array from string
; 551  : 		_Stringbuffer.str(_Newstr);
; 552  : 		}
; 553  : 
; 554  : private:
; 555  : 	_Mysb _Stringbuffer;	// the string buffer
; 556  : 	};
; 557  : 
; 558  : 	// basic_ostringstream TEMPLATE OPERATORS
; 559  : template<class _Elem,
; 560  : 	class _Traits,
; 561  : 	class _Alloc> inline
; 562  : 	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
; 563  : 		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
; 564  : 	{	// swap _Left and _Right basic_ostringstreams
; 565  : 	_Left.swap(_Right);
; 566  : 	}
; 567  : 
; 568  : 		// TEMPLATE CLASS basic_stringstream
; 569  : template<class _Elem,
; 570  : 	class _Traits,
; 571  : 	class _Alloc>
; 572  : 	class basic_stringstream
; 573  : 		: public basic_iostream<_Elem, _Traits>
; 574  : 	{	// input/output stream associated with a character array
; 575  : public:
; 576  : 	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
; 577  : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 578  : 	typedef _Elem char_type;
; 579  : 	typedef _Traits traits_type;
; 580  : 	typedef _Alloc allocator_type;
; 581  : 	typedef typename _Traits::int_type int_type;
; 582  : 	typedef typename _Traits::pos_type pos_type;
; 583  : 	typedef typename _Traits::off_type off_type;
; 584  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 585  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 586  : 
; 587  : 	explicit basic_stringstream(ios_base::openmode _Mode =
; 588  : 		ios_base::in | ios_base::out)
; 589  : 		: _Mybase(&_Stringbuffer),
; 590  : 			_Stringbuffer(_Mode)
; 591  : 		{	// construct empty character buffer
; 592  : 		}
; 593  : 
; 594  : 	explicit basic_stringstream(const _Mystr& _Str,
; 595  : 		ios_base::openmode _Mode = ios_base::in | ios_base::out)
; 596  : 		: _Mybase(&_Stringbuffer),

	xor	r8d, r8d
	lea	rdx, QWORD PTR sn$9[rbp-232]
	lea	rcx, QWORD PTR sn$9[rbp-256]
	call	QWORD PTR __imp_??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QEAA@PEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
	npad	1

; 598  : 		{	// construct character buffer from NTCS

	mov	rax, QWORD PTR sn$9[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR sn$9[rbp+rcx-256], rax
	mov	rax, QWORD PTR sn$9[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-152]
	mov	DWORD PTR sn$9[rbp+rcx-260], edx

; 597  : 			_Stringbuffer(_Str, _Mode)

	lea	rax, QWORD PTR sn$9[rbp-232]
	mov	QWORD PTR this$[rbp-256], rax

; 36   : 		{	// construct character buffer from string, mode

	lea	rcx, QWORD PTR sn$9[rbp-232]
	call	QWORD PTR __imp_??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR sn$9[rbp-232], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [r12+24], 8
	jb	SHORT $LN913@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rdx, QWORD PTR [r12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN914@parsePatte
$LN913@parsePatte:
	mov	rdx, r12
$LN914@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 37   : 		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));

	xor	r9d, r9d
	mov	r8, QWORD PTR [r12+16]
	lea	rcx, QWORD PTR sn$9[rbp-232]
	call	?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 548  : 			sn >> width;

	lea	rdx, QWORD PTR width$7[rbp-256]
	lea	rcx, QWORD PTR sn$9[rbp-256]
	call	QWORD PTR __imp_??5?$basic_istream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV01@AEAN@Z
	vmovsd	xmm6, QWORD PTR width$7[rbp-256]

; 549  : 
; 550  : 			r.tiles.push_back(width);

	vcvtpd2ps xmm6, xmm6
	vmovss	DWORD PTR $T21[rbp-256], xmm6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	lea	rax, QWORD PTR $T21[rbp-256]
	cmp	rax, rdi
	jae	$LN918@parsePatte
	lea	rax, QWORD PTR $T21[rbp-256]
	cmp	r15, rax
	ja	$LN918@parsePatte

; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	lea	rsi, QWORD PTR $T21[rbp-256]
	sub	rsi, r15
	sar	rsi, 2

; 1280 : 			if (this->_Mylast() == this->_Myend())

	cmp	rdi, r14
	jne	SHORT $LN968@parsePatte

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	rax, r14
	sub	rax, rdi
	sar	rax, 2

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	rax, 1
	jae	SHORT $LN968@parsePatte

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	rdi, r15
	sar	rdi, 2

; 1629 : 			if (max_size() - size() < _Count)

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	mov	rax, rcx
	sub	rax, rdi
	cmp	rax, 1
	jb	$LN2332@parsePatte

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	lea	rdx, QWORD PTR [rdi+1]

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r14, r15
	sar	r14, 2

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r14
	shr	rax, 1
	sub	rcx, rax
	add	rax, r14
	xor	r8d, r8d
	cmp	rcx, r14
	cmovae	r8, rax
	cmp	r8, rdx
	cmovae	rdx, r8

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	lea	rcx, QWORD PTR r$2[rsp+8]
	call	?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Reallocate
	mov	r14, QWORD PTR r$2[rsp+24]
	mov	rdi, QWORD PTR r$2[rsp+16]
	mov	r15, QWORD PTR r$2[rsp+8]
$LN968@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdi, rdi
	je	SHORT $LN1102@parsePatte
	mov	eax, DWORD PTR [r15+rsi*4]
	mov	DWORD PTR [rdi], eax
$LN1102@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1285 : 			++this->_Mylast();

	add	rdi, 4
	mov	QWORD PTR r$2[rsp+16], rdi

; 1287 : 		else

	mov	esi, DWORD PTR j$1$[rbp-256]
	jmp	$LN919@parsePatte
$LN918@parsePatte:

; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

	cmp	rdi, r14
	jne	SHORT $LN1127@parsePatte

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	rax, r14
	sub	rax, rdi
	sar	rax, 2

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	rax, 1
	jae	SHORT $LN1127@parsePatte

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	rdi, r15
	sar	rdi, 2

; 1629 : 			if (max_size() - size() < _Count)

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	mov	rax, rcx
	sub	rax, rdi
	cmp	rax, 1
	jb	$LN2333@parsePatte

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	lea	rdx, QWORD PTR [rdi+1]

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r14, r15
	sar	r14, 2

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r14
	shr	rax, 1
	sub	rcx, rax
	add	rax, r14
	xor	r8d, r8d
	cmp	rcx, r14
	cmovae	r8, rax
	cmp	r8, rdx
	cmovae	rdx, r8

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	lea	rcx, QWORD PTR r$2[rsp+8]
	call	?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Reallocate
	mov	r14, QWORD PTR r$2[rsp+24]
	mov	rdi, QWORD PTR r$2[rsp+16]
	mov	r15, QWORD PTR r$2[rsp+8]
$LN1127@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rdi, rdi
	je	SHORT $LN1254@parsePatte
	vmovss	DWORD PTR [rdi], xmm6
$LN1254@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	rdi, 4
	mov	QWORD PTR r$2[rsp+16], rdi
$LN919@parsePatte:
	lea	rax, QWORD PTR sn$9[rbp-104]
	mov	QWORD PTR this$[rbp-256], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 635  : 		{	// destroy the object

	mov	rax, QWORD PTR sn$9[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR sn$9[rbp+rcx-256], rax
	mov	rax, QWORD PTR sn$9[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-152]
	mov	DWORD PTR sn$9[rbp+rcx-260], edx

; 636  : 		}

	lea	rax, QWORD PTR sn$9[rbp-232]
	mov	QWORD PTR this$24[rbp-256], rax

; 75   : 		{	// destroy the object

	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR sn$9[rbp-232], rax

; 338  : 		if (_Mystate & _Allocated)

	test	BYTE PTR sn$9[rbp-120], 1
	je	$LN1299@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	rax, QWORD PTR sn$9[rbp-168]
	mov	rdx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 339  : 			_Al.deallocate(_Mysb::eback(),

	test	rdx, rdx
	je	SHORT $LN1278@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	rax, QWORD PTR sn$9[rbp-144]
	movsxd	rcx, DWORD PTR [rax]
	lea	rdx, QWORD PTR [rdx+rcx*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 339  : 			_Al.deallocate(_Mysb::eback(),

	jmp	SHORT $LN1279@parsePatte
$LN1278@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

	mov	rax, QWORD PTR sn$9[rbp-152]
	movsxd	rdx, DWORD PTR [rax]
	mov	rax, QWORD PTR sn$9[rbp-176]
	mov	rcx, QWORD PTR [rax]
	lea	rdx, QWORD PTR [rcx+rdx*2]
$LN1279@parsePatte:

; 222  : 		return (*_IGfirst);

	mov	rax, QWORD PTR sn$9[rbp-208]
	mov	rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 339  : 			_Al.deallocate(_Mysb::eback(),

	sub	rdx, rcx
	sar	rdx, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdx, rax
	ja	$LN2334@parsePatte

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [rdx+rdx]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN1294@parsePatte

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	jne	$LN2335@parsePatte

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jae	$LN2336@parsePatte

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jb	$LN2337@parsePatte

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	ja	$LN2338@parsePatte

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN1294@parsePatte:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
$LN1299@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR sn$9[rbp-208]
	xor	ecx, ecx
	mov	QWORD PTR [rax], rcx

; 254  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR sn$9[rbp-176]
	mov	QWORD PTR [rax], rcx

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	rax, QWORD PTR sn$9[rbp-152]
	mov	DWORD PTR [rax], ecx

; 294  : 		*_IPfirst = _First;

	mov	rax, QWORD PTR sn$9[rbp-200]
	mov	QWORD PTR [rax], rcx

; 295  : 		*_IPnext = _First;

	mov	rax, QWORD PTR sn$9[rbp-168]
	mov	QWORD PTR [rax], rcx

; 296  : 		*_IPcount = (int)(_Last - _First);

	mov	rax, QWORD PTR sn$9[rbp-144]
	mov	DWORD PTR [rax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 344  : 		_Seekhigh = 0;

	mov	QWORD PTR sn$9[rbp-128], rcx

; 345  : 		_Mystate &= ~_Allocated;

	and	DWORD PTR sn$9[rbp-120], -2

; 77   : 		}

	lea	rcx, QWORD PTR sn$9[rbp-232]
	call	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
	npad	1

; 636  : 		}

	lea	rcx, QWORD PTR sn$9[rbp-224]
	call	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
	lea	rax, QWORD PTR sn$9[rbp-104]
	mov	QWORD PTR this$[rbp-256], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 39   : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
	mov	QWORD PTR sn$9[rbp-104], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 523  : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7ios_base@std@@6B@
	mov	QWORD PTR sn$9[rbp-104], rax

; 524  : 		_Ios_base_dtor(this);

	lea	rcx, QWORD PTR sn$9[rbp-104]
	call	QWORD PTR __imp_?_Ios_base_dtor@ios_base@std@@CAXPEAV12@@Z
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 546  : 		for (int j=2; j<row.size(); j++) {

	inc	esi
	mov	DWORD PTR j$1$[rbp-256], esi
	add	r12, 32					; 00000020H
	movsxd	rax, esi
	cmp	rax, r13
	jb	$LL7@parsePatte
	vmovss	xmm6, DWORD PTR r$2[rsp]
	mov	r12, QWORD PTR row$4[rsp]
	xor	r8d, r8d
$LN6@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rsi, QWORD PTR this$1$[rbp-256]
	mov	rdx, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	lea	rax, QWORD PTR r$2[rsp]
	cmp	rax, rdx
	jae	$LN1315@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	lea	rax, QWORD PTR r$2[rsp]
	cmp	rcx, rax
	ja	$LN1315@parsePatte

; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	lea	rdi, QWORD PTR r$2[rsp]
	sub	rdi, rcx

; 1280 : 			if (this->_Mylast() == this->_Myend())

	mov	r9, QWORD PTR [rsi+16]
	cmp	rdx, r9
	jne	SHORT $LN1365@parsePatte

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	rax, r9
	sub	rax, rdx
	sar	rax, 5

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	rax, 1
	jae	SHORT $LN1365@parsePatte

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	rdx, rcx
	sar	rdx, 5

; 1629 : 			if (max_size() - size() < _Count)

	mov	r10, 576460752303423487			; 07ffffffffffffffH
	mov	rax, r10
	sub	rax, rdx
	cmp	rax, 1
	jb	$LN2350@parsePatte

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	inc	rdx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r9, rcx
	sar	r9, 5

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r9
	shr	rax, 1
	mov	rcx, r10
	sub	rcx, rax
	add	rax, r9
	cmp	rcx, r9
	cmovae	r8, rax
	cmp	r8, rdx
	cmovae	rdx, r8

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	rcx, rsi
	call	?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z ; std::vector<TileRow,std::allocator<TileRow> >::_Reallocate
$LN1365@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR $T16[rbp-256], rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

	and	rdi, -32				; ffffffffffffffe0H
	add	rdi, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T23[rbp-256], rcx
	test	rcx, rcx
	je	SHORT $LN1499@parsePatte
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdi+4]
	mov	DWORD PTR [rcx+4], eax
	lea	rdx, QWORD PTR [rdi+8]
	add	rcx, 8
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
$LN1499@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1287 : 		else

	jmp	$LN2368@parsePatte
$LN1315@parsePatte:

; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

	mov	r9, QWORD PTR [rsi+16]
	cmp	rdx, r9
	jne	SHORT $LN1528@parsePatte

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	rax, r9
	sub	rax, rdx
	sar	rax, 5

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	rax, 1
	jae	SHORT $LN1528@parsePatte

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rcx, QWORD PTR [rsi]
	sub	rdx, rcx
	sar	rdx, 5

; 1629 : 			if (max_size() - size() < _Count)

	mov	r10, 576460752303423487			; 07ffffffffffffffH
	mov	rax, r10
	sub	rax, rdx
	cmp	rax, 1
	jb	$LN2351@parsePatte

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	inc	rdx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r9, rcx
	sar	r9, 5

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r9
	shr	rax, 1
	mov	rcx, r10
	sub	rcx, rax
	add	rax, r9
	cmp	rcx, r9
	cmovae	r8, rax
	cmp	r8, rdx
	cmovae	rdx, r8

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	rcx, rsi
	call	?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z ; std::vector<TileRow,std::allocator<TileRow> >::_Reallocate
$LN1528@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR $T15[rbp-256], rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T22[rbp-256], rcx
	test	rcx, rcx
	je	SHORT $LN1655@parsePatte
	vmovss	DWORD PTR [rcx], xmm6
	vmovss	xmm0, DWORD PTR r$2[rsp+4]
	vmovss	DWORD PTR [rcx+4], xmm0
	add	rcx, 8
	lea	rdx, QWORD PTR r$2[rsp+8]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
$LN1655@parsePatte:
$LN2368@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	QWORD PTR [rsi+8], 32			; 00000020H
	vmovsd	xmm6, QWORD PTR height$8[rbp-256]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 554  : 		pat->heights.push_back((float)height);

	vcvtpd2ps xmm6, xmm6
	vmovss	DWORD PTR $T20[rbp-256], xmm6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rsi, QWORD PTR this$1$[rbp-256]
	mov	rdx, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	lea	rax, QWORD PTR $T20[rbp-256]
	cmp	rax, rdx
	jae	$LN1672@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	lea	rax, QWORD PTR $T20[rbp-256]
	cmp	rcx, rax
	ja	$LN1672@parsePatte

; 899  : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	lea	rdi, QWORD PTR $T20[rbp-256]
	sub	rdi, rcx
	sar	rdi, 2

; 900  : 			if (this->_Mylast() == this->_Myend())

	mov	r9, QWORD PTR [rsi+16]
	cmp	rdx, r9
	jne	SHORT $LN1722@parsePatte

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	rax, r9
	sub	rax, rdx
	sar	rax, 2

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	rax, 1
	jae	SHORT $LN1722@parsePatte

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	rdx, rcx
	sar	rdx, 2

; 1629 : 			if (max_size() - size() < _Count)

	mov	r8, 4611686018427387903			; 3fffffffffffffffH
	mov	rax, r8
	sub	rax, rdx
	cmp	rax, 1
	jb	$LN2352@parsePatte

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	inc	rdx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r9, rcx
	sar	r9, 2

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r9
	shr	rax, 1
	mov	rcx, r8
	sub	rcx, rax
	add	rax, r9
	xor	r8d, r8d
	cmp	rcx, r9
	cmovae	r8, rax
	cmp	r8, rdx
	cmovae	rdx, r8

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	rcx, rsi
	call	?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Reallocate
$LN1722@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 903  : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

	mov	rax, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rcx, rcx
	je	$LN2012@parsePatte
	mov	eax, DWORD PTR [rax+rdi*4]
	mov	DWORD PTR [rcx], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 907  : 		else

	jmp	SHORT $LN2012@parsePatte
$LN1672@parsePatte:

; 908  : 			{	// push back a non-element
; 909  : 			if (this->_Mylast() == this->_Myend())

	mov	r9, QWORD PTR [rsi+16]
	cmp	rdx, r9
	jne	SHORT $LN1883@parsePatte

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	rax, r9
	sub	rax, rdx
	sar	rax, 2

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	rax, 1
	jae	SHORT $LN1883@parsePatte

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rcx, QWORD PTR [rsi]
	sub	rdx, rcx
	sar	rdx, 2

; 1629 : 			if (max_size() - size() < _Count)

	mov	r8, 4611686018427387903			; 3fffffffffffffffH
	mov	rax, r8
	sub	rax, rdx
	cmp	rax, 1
	jb	$LN2353@parsePatte

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	inc	rdx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r9, rcx
	sar	r9, 2

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r9
	shr	rax, 1
	mov	rcx, r8
	sub	rcx, rax
	add	rax, r9
	xor	r8d, r8d
	cmp	rcx, r9
	cmovae	r8, rax
	cmp	r8, rdx
	cmovae	rdx, r8

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	rcx, rsi
	call	?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Reallocate
$LN1883@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rsi+8]
	test	rax, rax
	je	SHORT $LN2012@parsePatte
	vmovss	DWORD PTR [rax], xmm6
$LN2012@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 914  : 			++this->_Mylast();

	add	QWORD PTR [rsi+8], 4

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r15, r15
	je	SHORT $LN2030@parsePatte

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sub	r14, r15
	sar	r14, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	r8, r14
	mov	rdx, r15
	lea	rcx, QWORD PTR r$2[rsp+8]
	call	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
	vpxor	xmm0, xmm0, xmm0
	vmovdqu	XMMWORD PTR r$2[rsp+8], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR r$2[rsp+24], 0
$LN2030@parsePatte:
	lea	rcx, QWORD PTR s1$11[rbp-104]
	call	??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	rax, QWORD PTR s1$11[rbp-104]
	mov	QWORD PTR this$[rbp-256], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 39   : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
	mov	QWORD PTR s1$11[rbp-104], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 523  : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7ios_base@std@@6B@
	mov	QWORD PTR s1$11[rbp-104], rax

; 524  : 		_Ios_base_dtor(this);

	lea	rcx, QWORD PTR s1$11[rbp-104]
	call	QWORD PTR __imp_?_Ios_base_dtor@ios_base@std@@CAXPEAV12@@Z
	npad	1
	lea	rcx, QWORD PTR s0$12[rbp-104]
	call	??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	lea	rax, QWORD PTR s0$12[rbp-104]
	mov	QWORD PTR this$[rbp-256], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 39   : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
	mov	QWORD PTR s0$12[rbp-104], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 523  : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7ios_base@std@@6B@
	mov	QWORD PTR s0$12[rbp-104], rax

; 524  : 		_Ios_base_dtor(this);

	lea	rcx, QWORD PTR s0$12[rbp-104]
	call	QWORD PTR __imp_?_Ios_base_dtor@ios_base@std@@CAXPEAV12@@Z
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, bl
	lea	r8, QWORD PTR row$4[rsp]
	mov	rdx, QWORD PTR row$4[rsp+8]
	mov	rcx, r12
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	r8, QWORD PTR row$4[rsp+16]
	sub	r8, r12
	sar	r8, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, r12
	lea	rcx, QWORD PTR row$4[rsp]
	call	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
	vpxor	xmm0, xmm0, xmm0
	vmovdqu	XMMWORD PTR row$4[rsp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR row$4[rsp+16], 0
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 531  : 	for (int i=0; i<rowStrings.size(); i++) {		

	mov	r12d, DWORD PTR i$1$[rbp-256]
	inc	r12d
	mov	DWORD PTR i$1$[rbp-256], r12d
	movsxd	rdi, r12d
	mov	rsi, QWORD PTR rowStrings$[rsp]
	xor	r12d, r12d
	cmp	rdi, QWORD PTR tv6005[rbp-256]
	jae	$LN2363@parsePatte
	mov	r15d, DWORD PTR $T1[rsp]
	jmp	$LN2369@parsePatte
$LN2348@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2347@parsePatte:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2346@parsePatte:

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2345@parsePatte:

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2344@parsePatte:

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN2332@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN2333@parsePatte:
	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	npad	1
$LN2338@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2337@parsePatte:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2336@parsePatte:

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2335@parsePatte:

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2334@parsePatte:

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN2350@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN2351@parsePatte:
	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN2352@parsePatte:
	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN2353@parsePatte:
	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	npad	1
$LN2363@parsePatte:

; 1629 : 			if (max_size() - size() < _Count)

	mov	r14, QWORD PTR str$1$[rbp-256]
	mov	rcx, QWORD PTR rowStrings$[rsp+8]
	jmp	$LN3@parsePatte
$LN2349@parsePatte:

; 1637 : 		if (this->_Myfirst() != pointer())

	test	r12, r12
	je	$LN2366@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T18[rbp-256]
	lea	r8, QWORD PTR row$4[rsp]
	mov	rdx, rax
	mov	rcx, r12
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR row$4[rsp+16]
	sub	rax, r12
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rdi, 576460752303423487			; 07ffffffffffffffH
	cmp	rax, rdi
	jbe	SHORT $LN554@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN554@parsePatte:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN555@parsePatte

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	r12b, 31
	je	SHORT $LN556@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN556@parsePatte:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [r12-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, r12
	jb	SHORT $LN557@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN557@parsePatte:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	r12, rax
	cmp	r12, 8
	jae	SHORT $LN558@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN558@parsePatte:

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	r12, 39					; 00000027H
	jbe	SHORT $LN559@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN559@parsePatte:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	r12, rax
$LN555@parsePatte:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, r12
	call	??3@YAXPEAX@Z				; operator delete
	vpxor	xmm0, xmm0, xmm0
	vmovdqu	XMMWORD PTR row$4[rsp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1645 : 			this->_Myend() = pointer();

	xor	ebx, ebx
	mov	QWORD PTR row$4[rsp+16], rbx
	jmp	SHORT $LN499@parsePatte
$LN2366@parsePatte:
	xor	ebx, ebx
	mov	rdi, 576460752303423487			; 07ffffffffffffffH
$LN499@parsePatte:

; 1637 : 		if (this->_Myfirst() != pointer())

	test	rsi, rsi
	je	$LN586@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T17[rbp-256]
	lea	r8, QWORD PTR rowStrings$[rsp]
	mov	rdx, QWORD PTR rowStrings$[rsp+8]
	mov	rcx, rsi
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rax, QWORD PTR rowStrings$[rsp+16]
	sub	rax, rsi
	sar	rax, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, rdi
	jbe	SHORT $LN641@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN641@parsePatte:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	rax, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN642@parsePatte

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	sil, 31
	je	SHORT $LN643@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN643@parsePatte:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rsi-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rsi
	jb	SHORT $LN644@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN644@parsePatte:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rsi, rax
	cmp	rsi, 8
	jae	SHORT $LN645@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN645@parsePatte:

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rsi, 39					; 00000027H
	jbe	SHORT $LN646@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN646@parsePatte:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rsi, rax
$LN642@parsePatte:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rsi
	call	??3@YAXPEAX@Z				; operator delete
	vpxor	xmm0, xmm0, xmm0
	vmovdqu	XMMWORD PTR rowStrings$[rsp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR rowStrings$[rsp+16], rbx
$LN586@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	r14, QWORD PTR str$1$[rbp-256]
	mov	r8, QWORD PTR [r14+24]
	cmp	r8, 8
	jb	SHORT $LN675@parsePatte

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, QWORD PTR [r14]
	mov	rcx, r14
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN675@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [r14+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [r14+16], rbx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [r14+24], 8
	jb	SHORT $LN743@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	r14, QWORD PTR [r14]
$LN743@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [r14], bx
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 536  : 			return FALSE;	

	xor	eax, eax
	jmp	SHORT $LN1@parsePatte
$LN3@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	rsi, rsi
	je	SHORT $LN2182@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T13[rbp-256]
	lea	r8, QWORD PTR rowStrings$[rsp]
	mov	rdx, rcx
	mov	rcx, rsi
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	r8, QWORD PTR rowStrings$[rsp+16]
	sub	r8, rsi
	sar	r8, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, rsi
	lea	rcx, QWORD PTR rowStrings$[rsp]
	call	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
	vpxor	xmm0, xmm0, xmm0
	vmovdqu	XMMWORD PTR rowStrings$[rsp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR rowStrings$[rsp+16], r12
$LN2182@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	r8, QWORD PTR [r14+24]
	cmp	r8, 8
	jb	SHORT $LN2257@parsePatte

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, QWORD PTR [r14]
	mov	rcx, r14
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN2257@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [r14+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [r14+16], r12

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [r14+24], 8
	jb	SHORT $LN2325@parsePatte
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	r14, QWORD PTR [r14]
$LN2325@parsePatte:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [r14], r12w
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 557  : 	return TRUE;

	mov	eax, 1
$LN1@parsePatte:

; 558  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+992]
	add	rsp, 1016				; 000003f8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN2367@parsePatte:
?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z ENDP ; parsePattern
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$0@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$0
	mov	rcx, QWORD PTR str$[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$0
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$1@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$1
	lea	rcx, QWORD PTR rowStrings$[rdx]
	jmp	??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$1@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$1
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$2@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$2
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$2@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$2
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$3@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$3
	lea	rcx, QWORD PTR row$4[rdx]
	jmp	??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$3@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$3
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$4@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$4
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$4@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$4
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$9
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN760@dtor$9
	and	DWORD PTR $T1[rbp], -2
	lea	rcx, QWORD PTR s0$12[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN760@dtor$9:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$9
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$10
	lea	rcx, QWORD PTR s0$12[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$10
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$12@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$12
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$12@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$12
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$11@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$11
	lea	rcx, QWORD PTR s0$12[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$11@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$11
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$5@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$5
	lea	rcx, QWORD PTR s0$12[rdx]
	jmp	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
?dtor$5@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$5
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$13
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN808@dtor$13
	and	DWORD PTR $T1[rbp], -3
	lea	rcx, QWORD PTR s1$11[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN808@dtor$13:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$13
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$14@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$14
	lea	rcx, QWORD PTR s1$11[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$14@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$14
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$16@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$16
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$16@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$16
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$15@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$15
	lea	rcx, QWORD PTR s1$11[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$15@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$15
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$6@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$6
	lea	rcx, QWORD PTR s1$11[rdx]
	jmp	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
?dtor$6@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$6
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$17
	lea	rcx, QWORD PTR r$2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$17
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$7@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$7
	lea	rcx, QWORD PTR r$2[rdx]
	jmp	??1TileRow@@QEAA@XZ
?dtor$7@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$7
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$18
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN881@dtor$18
	and	DWORD PTR $T1[rbp], -5
	lea	rcx, QWORD PTR sn$9[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN881@dtor$18:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$18
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$19@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$19
	lea	rcx, QWORD PTR sn$9[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$19@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$19
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$21@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$21
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$21@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$21
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$20@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$20
	lea	rcx, QWORD PTR sn$9[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$20@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$20
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$8@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$8
	lea	rcx, QWORD PTR sn$9[rdx]
	jmp	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
?dtor$8@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$8
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$22@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$22
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$22@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$22
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$23@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$23
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$23@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$23
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$24@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$24
	mov	rcx, QWORD PTR this$24[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$24@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$24
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$25@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$25
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$25@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$25
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$26
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR $T16[rbp]
	mov	rcx, QWORD PTR $T23[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$26
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$27@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$27
	mov	rcx, QWORD PTR $T23[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$27@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$27
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$28
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR $T15[rbp]
	mov	rcx, QWORD PTR $T22[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$28
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$29@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$29
	mov	rcx, QWORD PTR $T22[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$29@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$29
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$30@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$30
	lea	rcx, QWORD PTR r$2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$30@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$30
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$31@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$31
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$31@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$31
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$32@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$32
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$32@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$32
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$0@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$0
	mov	rcx, QWORD PTR str$[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$1@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$1
	lea	rcx, QWORD PTR rowStrings$[rdx]
	jmp	??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$1@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$2@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$2
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$2@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$3@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$3
	lea	rcx, QWORD PTR row$4[rdx]
	jmp	??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$3@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$4@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$4
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$4@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$9
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN760@dtor$9
	and	DWORD PTR $T1[rbp], -2
	lea	rcx, QWORD PTR s0$12[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN760@dtor$9:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$10
	lea	rcx, QWORD PTR s0$12[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$12@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$12
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$12@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$11@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$11
	lea	rcx, QWORD PTR s0$12[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$11@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$5@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$5
	lea	rcx, QWORD PTR s0$12[rdx]
	jmp	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
?dtor$5@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$13
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN808@dtor$13
	and	DWORD PTR $T1[rbp], -3
	lea	rcx, QWORD PTR s1$11[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN808@dtor$13:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$14@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$14
	lea	rcx, QWORD PTR s1$11[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$14@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$16@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$16
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$16@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$15@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$15
	lea	rcx, QWORD PTR s1$11[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$15@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$6@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$6
	lea	rcx, QWORD PTR s1$11[rdx]
	jmp	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
?dtor$6@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$17
	lea	rcx, QWORD PTR r$2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$7@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$7
	lea	rcx, QWORD PTR r$2[rdx]
	jmp	??1TileRow@@QEAA@XZ
?dtor$7@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$18
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN881@dtor$18
	and	DWORD PTR $T1[rbp], -5
	lea	rcx, QWORD PTR sn$9[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN881@dtor$18:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$19@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$19
	lea	rcx, QWORD PTR sn$9[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$19@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$21@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$21
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$21@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$20@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$20
	lea	rcx, QWORD PTR sn$9[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$20@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$8@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$8
	lea	rcx, QWORD PTR sn$9[rdx]
	jmp	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
?dtor$8@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$22@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$22
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$22@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$23@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$23
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$23@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$23
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$24@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$24
	mov	rcx, QWORD PTR this$24[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$24@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$24
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$25@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$25
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$25@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$25
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$26
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR $T16[rbp]
	mov	rcx, QWORD PTR $T23[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$27@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$27
	mov	rcx, QWORD PTR $T23[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$27@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$28
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR $T15[rbp]
	mov	rcx, QWORD PTR $T22[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$28
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$29@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$29
	mov	rcx, QWORD PTR $T22[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$29@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$29
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$30@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$30
	lea	rcx, QWORD PTR r$2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$30@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$30
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$31@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$31
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$31@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$31
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
r$2 = 40
$T3 = 40
rowStrings$ = 72
row$4 = 96
$T5 = 120
str$1$ = 152
offset$6 = 160
width$7 = 168
this$1$ = 176
height$8 = 184
this$1$ = 192
tv6005 = 200
sn$9 = 208
$T10 = 464
s1$11 = 480
s0$12 = 736
str$ = 1088
$T13 = 1096
$T14 = 1096
this$ = 1096
this$ = 1096
$T15 = 1096
$T16 = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
this$ = 1096
$T17 = 1096
$T18 = 1096
$T19 = 1096
$T20 = 1096
$T21 = 1096
pat$ = 1096
j$1$ = 1104
$T22 = 1104
$T23 = 1104
this$24 = 1104
i$1$ = 1112
?dtor$32@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$32
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$32@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$32
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Orphan_range, COMDAT

; 1794 : 		}

	ret	0
?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBAXXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlen, COMDAT

; 1764 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBAXXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAXXZ
_TEXT	SEGMENT
$T1 = 48
this$ = 48
?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAXXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy, COMDAT

; 1636 : 		{	// free all storage

$LN73:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T1[rsp]
	mov	r8, rbx
	mov	rdx, QWORD PTR [rbx+8]
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rdx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	sar	r8, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	call	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAXXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reserve, COMDAT

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

$LN95:
	sub	rsp, 40					; 00000028H

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	r10, QWORD PTR [rcx+16]

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	mov	r9, rcx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, r10
	sub	rax, r8
	sar	rax, 5

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	rax, rdx
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rcx, QWORD PTR [rcx]

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	r11, 576460752303423487			; 07ffffffffffffffH

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	r8, rcx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	rax, r11

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	r8, 5

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	sub	rax, r8
	cmp	rax, rdx
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Reserve:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r10, rcx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	add	rdx, r8

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	r10, 5
	xor	ecx, ecx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r10
	shr	rax, 1
	sub	r11, rax
	add	rax, r10
	cmp	r11, r10
	cmovae	rcx, rax
	cmp	rcx, rdx
	cmovae	rdx, rcx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	rcx, r9

; 1632 : 			}
; 1633 : 		}

	add	rsp, 40					; 00000028H

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocate
$LN2@Reserve:

; 1632 : 			}
; 1633 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN94@Reserve:
?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 112
this$ = 112
_Count$ = 120
$T3 = 128
_Ptr$ = 136
?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocate, COMDAT

; 1601 : 		{	// move to array of exactly _Count elements

$LN138:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 72					; 00000048H
	mov	QWORD PTR $T1[rsp], -2
	mov	rsi, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocate
	mov	r14, rax
	mov	QWORD PTR _Ptr$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	movzx	r8d, BYTE PTR $T3[rsp]
	mov	BYTE PTR [rsp+40], r8b
	mov	BYTE PTR [rsp+32], al
	mov	r9, rbx
	mov	r8, r14
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninitialized_move_al_unchecked1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx]
	mov	rdi, rdx
	sub	rdi, rcx

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	rcx, rcx
	je	SHORT $LN3@Reallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T2[rsp]
	mov	r8, rbx
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rdx, QWORD PTR [rbx]
	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	sar	r8, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	shl	rsi, 5
	add	rsi, r14
	mov	QWORD PTR [rbx+16], rsi

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	and	rdi, -32				; ffffffffffffffe0H
	add	rdi, r14
	mov	QWORD PTR [rbx+8], rdi

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	QWORD PTR [rbx], r14

; 1623 : 		}

	add	rsp, 72					; 00000048H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN137@Reallocate:
?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocate
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 112
this$ = 112
_Count$ = 120
$T3 = 128
_Ptr$ = 136
?catch$0@?0??_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocate'::`1'::catch$0

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocate'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 112
this$ = 112
_Count$ = 120
$T3 = 128
_Ptr$ = 136
?catch$0@?0??_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocate'::`1'::catch$0

; 1606 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1608 : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocate'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBA_NPEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBA_NPEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Inside, COMDAT

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	rdx, QWORD PTR [rcx+8]
	jae	SHORT $LN3@Inside
	cmp	QWORD PTR [rcx], rdx
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1598 : 		}

	ret	0
$LN3@Inside:

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	xor	al, al

; 1598 : 		}

	ret	0
?_Inside@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBA_NPEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBA_K_K@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Grow_to, COMDAT

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	r9, QWORD PTR [rcx+16]

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	r8, 576460752303423487			; 07ffffffffffffffH

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r9, QWORD PTR [rcx]
	sar	r9, 5

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r9
	shr	rax, 1
	sub	r8, rax
	lea	rcx, QWORD PTR [rax+r9]
	xor	eax, eax
	cmp	r8, r9
	cmovae	rax, rcx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	rax, rdx
	cmovb	rax, rdx

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	ret	0
?_Grow_to@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEBA_K_K@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
_TEXT	SEGMENT
$T1 = 8
this$ = 8
_First$ = 16
_Last$ = 24
?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Destroy, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1580 : 		{	// destroy [_First, _Last) using allocator

	mov	rax, r8
	mov	r10, rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	r8, rcx
	mov	rdx, rax
	mov	rcx, r10
	jmp	??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAAEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAAEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@_K@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::operator[], COMDAT

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	shl	rdx, 5
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1243 : 		}

	ret	0
??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAAEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@_K@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::max_size, COMDAT

; 1185 : 		return (this->_Getal().max_size());

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::size, COMDAT

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 1181 : 		}

	ret	0
?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Unused_capacity, COMDAT

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	sar	rax, 5

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::capacity, COMDAT

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 1044 : 		}

	ret	0
?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
this$ = 64
??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 975  : 		{	// destroy the object

$LN74:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T2[rsp]
	mov	r8, rbx
	mov	rdx, QWORD PTR [rbx+8]
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * __ptr64>
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rdx, QWORD PTR [rbx]
	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	sar	r8, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 976  : 		_Tidy();
; 977  : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::push_back, COMDAT

; 896  : 		{	// insert by moving into element at end

$LN365:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	rax, QWORD PTR [rcx+8]

; 896  : 		{	// insert by moving into element at end

	mov	rdi, rdx
	mov	rbx, rcx

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	rdx, rax
	jae	SHORT $LN2@push_back
	mov	rcx, QWORD PTR [rcx]
	cmp	rcx, rdx
	ja	SHORT $LN2@push_back

; 897  : 		if (_Inside(_STD addressof(_Val)))
; 898  : 			{	// push back an element
; 899  : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());
; 900  : 			if (this->_Mylast() == this->_Myend())

	sub	rdi, rcx
	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN4@push_back

; 901  : 				_Reserve(1);

	mov	edx, 1
	mov	rcx, rbx
	call	?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reserve
$LN4@push_back:

; 902  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 903  : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

	and	rdi, -32				; ffffffffffffffe0H
	add	rdi, QWORD PTR [rbx]

; 904  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 905  : 			++this->_Mylast();
; 906  : 			}
; 907  : 		else

	jmp	SHORT $LN5@push_back
$LN2@push_back:

; 908  : 			{	// push back a non-element
; 909  : 			if (this->_Mylast() == this->_Myend())

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN5@push_back

; 910  : 				_Reserve(1);

	mov	edx, 1
	mov	rcx, rbx
	call	?_Reserve@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN253@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rax

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	rdx, rdi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rcx], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN253@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 914  : 			++this->_Mylast();

	add	QWORD PTR [rbx+8], 32			; 00000020H

; 915  : 			}
; 916  : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 708  : 		}

	mov	rax, rcx
	ret	0
??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_second, COMDAT

; 320  : 		return (_Myval2);

	mov	rax, rcx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_second, COMDAT

; 315  : 		return (_Myval2);

	mov	rax, rcx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_first, COMDAT

; 300  : 		return (*this);

	mov	rax, rcx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_first, COMDAT

; 295  : 		return (*this);

	mov	rax, rcx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 489  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myend, COMDAT

; 668  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myend, COMDAT

; 663  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Mylast, COMDAT

; 658  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Mylast, COMDAT

; 653  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myfirst, COMDAT

; 648  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myfirst, COMDAT

; 643  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Get_data, COMDAT

; 638  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Get_data, COMDAT

; 633  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Getal, COMDAT

; 628  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Getal, COMDAT

; 623  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Orphan_all, COMDAT

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAA@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 521  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEBA_KU_Nil@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEBA_KU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::max_size, COMDAT

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1009 : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEBA_KU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
_Count$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::deallocate, COMDAT

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	jmp	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::allocate, COMDAT

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 937  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Wrap_alloc<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z
_TEXT	SEGMENT
_Al$ = 8
?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEBA_KXZ PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::max_size, COMDAT

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEBA_KXZ ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocate, COMDAT

; 724  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 51   : 	if (_Count == 0)

	test	rdx, rdx
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	eax, eax
$LN3@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	rdx, rax
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	rdx, 5

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	rcx, QWORD PTR [rdx+39]

; 66   : 		if (_Block_size <= _User_size)

	cmp	rcx, rdx
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	rax, rax
	jne	SHORT $LN9@allocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	mov	rcx, rdx
	call	??2@YAPEAX_K@Z				; operator new

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	rax, rax
	jne	SHORT $LN3@allocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN14@allocate:
?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate, COMDAT

; 719  : 		{	// deallocate object at _Ptr

$LN14:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN4@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	r8, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN7@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN13@deallocate:
?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
_TEXT	SEGMENT
$T1 = 40
str$ = 128
tokens$ = 136
delimiters$ = 144
?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z PROC ; tokenize, COMDAT

; 513  : static void tokenize(const std::wstring& str, std::vector<std::wstring>& tokens, const std::wstring& delimiters) {

	mov	rax, rsp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	QWORD PTR [rax-88], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	r14, r8
	mov	rbx, rdx
	mov	rbp, rcx

; 514  : 	std::wstring::size_type lastPos = str.find_first_not_of(delimiters, 0);

	xor	r8d, r8d
	mov	rdx, r14
	call	?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_not_of
	mov	rdi, rax

; 515  : 	std::wstring::size_type pos = str.find_first_of(delimiters, lastPos);

	mov	r8, rax
	mov	rdx, r14
	mov	rcx, rbp
	call	?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_of
	mov	r12, 576460752303423487			; 07ffffffffffffffH
	xor	r15d, r15d
	mov	r13, 9223372036854775807		; 7fffffffffffffffH
$LN662@tokenize:
	mov	rsi, rax

; 516  : 	
; 517  : 	while (std::wstring::npos != pos || std::wstring::npos != lastPos) {

	cmp	rax, -1
	jne	SHORT $LN4@tokenize
	cmp	rdi, rax
	je	$LN3@tokenize
$LN4@tokenize:

; 518  : 		tokens.push_back(str.substr(lastPos, pos - lastPos));

	mov	r9, rsi
	sub	r9, rdi
	mov	r8, rdi
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbp
	call	?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
	mov	rdi, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	rdi, rax
	jae	SHORT $LN8@tokenize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	r8, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	r8, rdi
	ja	SHORT $LN8@tokenize

; 899  : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	sub	rdi, r8

; 900  : 			if (this->_Mylast() == this->_Myend())

	mov	r9, QWORD PTR [rbx+16]
	cmp	rax, r9
	jne	SHORT $LN58@tokenize

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	rcx, r9
	sub	rcx, rax
	sar	rcx, 5

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	rcx, 1
	jae	SHORT $LN58@tokenize

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	rax, r8
	sar	rax, 5

; 1629 : 			if (max_size() - size() < _Count)

	mov	rcx, r12
	sub	rcx, rax
	cmp	rcx, 1
	jb	$LN647@tokenize

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	lea	rdx, QWORD PTR [rax+1]

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r9, r8
	sar	r9, 5

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r9
	shr	rax, 1
	mov	rcx, r12
	sub	rcx, rax
	add	rax, r9
	mov	r8, r15
	cmp	rcx, r9
	cmovae	r8, rax
	cmp	r8, rdx
	cmovae	rdx, r8

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	rcx, rbx
	call	?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocate
$LN58@tokenize:

; 903  : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

	and	rdi, -32				; ffffffffffffffe0H
	add	rdi, QWORD PTR [rbx]

; 904  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 905  : 			++this->_Mylast();
; 906  : 			}
; 907  : 		else

	jmp	SHORT $LN315@tokenize
$LN8@tokenize:

; 908  : 			{	// push back a non-element
; 909  : 			if (this->_Mylast() == this->_Myend())

	mov	r9, QWORD PTR [rbx+16]
	cmp	rax, r9
	jne	SHORT $LN315@tokenize

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	rcx, r9
	sub	rcx, rax
	sar	rcx, 5

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	rcx, 1
	jae	SHORT $LN315@tokenize

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	r8, QWORD PTR [rbx]
	sub	rax, r8
	sar	rax, 5

; 1629 : 			if (max_size() - size() < _Count)

	mov	rcx, r12
	sub	rcx, rax
	cmp	rcx, 1
	jb	$LN648@tokenize

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	lea	rdx, QWORD PTR [rax+1]

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r9, r8
	sar	r9, 5

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r9
	shr	rax, 1
	mov	rcx, r12
	sub	rcx, rax
	add	rax, r9
	mov	r8, r15
	cmp	rcx, r9
	cmovae	r8, rax
	cmp	r8, rdx
	cmovae	rdx, r8

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	rcx, rbx
	call	?_Reallocate@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Reallocate
$LN315@tokenize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN444@tokenize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], r15
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rcx], r15w
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	rdx, rdi
	call	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
$LN444@tokenize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 914  : 			++this->_Mylast();

	add	QWORD PTR [rbx+8], 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	rax, QWORD PTR $T1[rsp+24]
	cmp	rax, 8
	jb	SHORT $LN620@tokenize

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	rcx, QWORD PTR $T1[rsp]

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	rax, r13
	ja	$LN649@tokenize

; 95   : 	const size_t _User_size = _Count * _Sz;

	add	rax, rax

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN615@tokenize

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	jne	$LN650@tokenize

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jae	SHORT $LN651@tokenize

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jb	SHORT $LN652@tokenize

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	ja	SHORT $LN653@tokenize

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN615@tokenize:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPEAX@Z				; operator delete
$LN620@tokenize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T1[rsp+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T1[rsp+16], r15
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T1[rsp], r15w
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 519  : 		lastPos = str.find_first_not_of(delimiters, pos);

	mov	r8, rsi
	mov	rdx, r14
	mov	rcx, rbp
	call	?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_not_of
	mov	rdi, rax

; 520  : 		pos = str.find_first_of(delimiters, lastPos);

	mov	r8, rax
	mov	rdx, r14
	mov	rcx, rbp
	call	?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_of

; 521  : 	}

	jmp	$LN662@tokenize
$LN647@tokenize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN648@tokenize:
	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	npad	1
$LN653@tokenize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN652@tokenize:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN651@tokenize:

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN650@tokenize:

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN649@tokenize:

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@tokenize:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 522  : }

	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN659@tokenize:
?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z ENDP ; tokenize
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
str$ = 128
tokens$ = 136
delimiters$ = 144
?dtor$0@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA PROC ; `tokenize'::`1'::dtor$0
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA ENDP ; `tokenize'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
str$ = 128
tokens$ = 136
delimiters$ = 144
?dtor$0@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA PROC ; `tokenize'::`1'::dtor$0
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA ENDP ; `tokenize'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
_TEXT	SEGMENT
low$ = 240
high$ = 248
id$ = 256
pos$ = 264
total$ = 272
arr$ = 280
tv734 = 288
size$ = 288
var$ = 296
rand$ = 304
?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z PROC ; rowcol, COMDAT

; 325  : static int rowcol(float& low, float& high, int& id, float pos, float total, std::vector<float>& arr, float size, float var, float rand) {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	sub	rsp, 192				; 000000c0H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	r14, QWORD PTR arr$[rsp]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 325  : static int rowcol(float& low, float& high, int& id, float pos, float total, std::vector<float>& arr, float size, float var, float rand) {

	mov	rbp, rcx
	vmovaps	XMMWORD PTR [rsp+160], xmm7
	mov	r12, r8

; 326  : 	int num = arr.size();
; 327  : 	float h = total * size;

	vmovss	xmm7, DWORD PTR size$[rsp]
	vmulss	xmm2, xmm7, DWORD PTR total$[rsp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rax, QWORD PTR [r14]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 325  : static int rowcol(float& low, float& high, int& id, float pos, float total, std::vector<float>& arr, float size, float var, float rand) {

	mov	rsi, rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rdi, QWORD PTR [r14+8]
	sub	rdi, rax
	vmovaps	XMMWORD PTR [rsp+48], xmm14
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 328  : 	float y = pos / h;

	vdivss	xmm1, xmm3, xmm2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	rdi, 2
	vxorps	xmm14, xmm14, xmm14
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 329  : 	float yi = (float)FASTFLOOR(y); // group ID

	vcomiss	xmm14, xmm1
	vmovaps	XMMWORD PTR [rsp+32], xmm15
	vmovaps	xmm15, xmm3
	vcvttss2si ecx, xmm1
	jbe	SHORT $LN15@rowcol
	dec	ecx
$LN15@rowcol:
	vxorps	xmm4, xmm4, xmm4
	vcvtsi2ss xmm4, xmm4, ecx

; 330  : 	y = pos - yi * h; // pos within group
; 331  : 
; 332  : 	float sumY = 0.f;
; 333  : 	float tileHeight = 0.f;
; 334  : 	int cur = 0;	

	xor	ebx, ebx
	vmovaps	XMMWORD PTR [rsp+176], xmm6
	vmulss	xmm5, xmm4, xmm2
	vsubss	xmm1, xmm15, xmm5
	vmovaps	xmm3, xmm14

; 335  : 	while (cur < num) {		

	test	edi, edi
	jle	$LN6@rowcol
	movsxd	rdx, edi
	mov	ecx, ebx
	npad	1
$LL2@rowcol:

; 336  : 		tileHeight = arr[cur] * size;

	vmulss	xmm6, xmm7, DWORD PTR [rax]

; 337  : 		if (y < sumY + tileHeight)

	vaddss	xmm0, xmm6, xmm3
	vcomiss	xmm0, xmm1
	ja	SHORT $LN102@rowcol

; 338  : 			break;		
; 339  : 		sumY += tileHeight;
; 340  : 		cur++;

	inc	ebx
	inc	rcx
	add	rax, 4
	vmovaps	xmm3, xmm0
	cmp	rcx, rdx
	jl	SHORT $LL2@rowcol
$LN102@rowcol:

; 341  : 	}
; 342  : 	if (cur < 0 || cur >= num) // Necessary due floating point error

	test	ebx, ebx
	js	$LN6@rowcol
	cmp	ebx, edi
	jge	$LN6@rowcol

; 344  : 
; 345  : 	id = yi * num + cur;
; 346  : 
; 347  : 	// Variance
; 348  : 	// ----------- To determine max var
; 349  : 	// ----------- If we rose
; 350  : 	// ----------- eTop -> neTop
; 351  : 	//    x
; 352  : 	// ----------- eBot -> neBot
; 353  : 	// ----------- If we droped
; 354  : 	// ----------- To determine max var
; 355  : 
; 356  : 	float eBot = yi * h + sumY;	
; 357  : 	float eTop = eBot + tileHeight;
; 358  : 
; 359  : 	if (var > 0.0001f) {

	mov	QWORD PTR [rsp+240], r13
	mov	QWORD PTR [rsp+248], r15
	vmovaps	XMMWORD PTR [rsp+144], xmm8
	vmovss	xmm8, DWORD PTR var$[rsp]
	vcomiss	xmm8, DWORD PTR __real@38d1b717
	vmovaps	XMMWORD PTR [rsp+128], xmm9
	vmovaps	XMMWORD PTR [rsp+112], xmm10
	vmovaps	XMMWORD PTR [rsp+96], xmm11
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, edi
	vxorps	xmm1, xmm1, xmm1
	vmulss	xmm2, xmm0, xmm4
	vcvtsi2ss xmm1, xmm1, ebx
	vaddss	xmm2, xmm2, xmm1
	vcvttss2si eax, xmm2
	vaddss	xmm9, xmm5, xmm3
	vmovaps	XMMWORD PTR [rsp+80], xmm12
	mov	DWORD PTR [r8], eax
	vmovaps	XMMWORD PTR [rsp+64], xmm13
	vaddss	xmm10, xmm9, xmm6
	jbe	$LN7@rowcol
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	rcx, QWORD PTR [r14]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 33   : 	if (n-1 < 0) return m-1;

	lea	eax, DWORD PTR [rbx-1]
	test	eax, eax
	lea	r15d, DWORD PTR [rdi-1]
	mov	r13d, r15d
	cmovns	r13d, eax

; 360  : 		float n;
; 361  : 		
; 362  : 		float bTileHeight = arr[STEPDOWN(cur, num)]*size;

	movsxd	rax, r13d

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm9, xmm9
	vmulsd	xmm1, xmm0, QWORD PTR __real@403f666666666666
	vmovss	xmm0, DWORD PTR rand$[rsp]

; 360  : 		float n;
; 361  : 		
; 362  : 		float bTileHeight = arr[STEPDOWN(cur, num)]*size;

	vmulss	xmm11, xmm7, DWORD PTR [rcx+rax*4]

; 26   : 	return (n + 1) % m;

	lea	eax, DWORD PTR [rbx+1]
	cdq
	idiv	edi

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0

; 26   : 	return (n + 1) % m;

	movsxd	rax, edx

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vaddsd	xmm1, xmm1, xmm0
	vcvtsd2ss xmm0, xmm1, xmm1

; 26   : 	return (n + 1) % m;

	mov	DWORD PTR tv734[rsp], eax

; 363  : 		float tTileHeight = arr[STEPUP(cur, num)]*size;

	vmulss	xmm13, xmm7, DWORD PTR [rcx+rax*4]

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 364  : 
; 365  : 		n = noise(eBot, rand);
; 366  : 		float neBot = eBot + (n>0 ? tileHeight : bTileHeight) * n * var;		

	vcomiss	xmm0, xmm14
	jbe	SHORT $LN16@rowcol
	vmovaps	xmm1, xmm6
	jmp	SHORT $LN17@rowcol
$LN16@rowcol:
	vmovaps	xmm1, xmm11
$LN17@rowcol:
	vmulss	xmm0, xmm1, xmm0
	vmulss	xmm1, xmm0, xmm8
	vmovss	xmm0, DWORD PTR rand$[rsp]

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vcvtss2sd xmm2, xmm10, xmm10
	vmulsd	xmm3, xmm2, QWORD PTR __real@403f666666666666

; 364  : 
; 365  : 		n = noise(eBot, rand);
; 366  : 		float neBot = eBot + (n>0 ? tileHeight : bTileHeight) * n * var;		

	vaddss	xmm12, xmm1, xmm9

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vaddsd	xmm1, xmm3, xmm0
	vcvtsd2ss xmm0, xmm1, xmm1
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 367  : 		n = noise(eTop, rand);
; 368  : 		float neTop = eTop + (n<0 ? tileHeight : tTileHeight) * n * var;

	vcomiss	xmm14, xmm0
	ja	SHORT $LN19@rowcol
	vmovaps	xmm6, xmm13
$LN19@rowcol:

; 369  : 
; 370  : 		if (pos < neBot) { // We droped one cur down

	vcomiss	xmm12, xmm15
	vmulss	xmm0, xmm6, xmm0
	vmulss	xmm1, xmm0, xmm8
	vaddss	xmm6, xmm1, xmm10
	jbe	SHORT $LN9@rowcol

; 371  : 			id--;

	dec	DWORD PTR [r12]
	vmovss	xmm1, DWORD PTR rand$[rsp]

; 372  : 			cur = STEPDOWN(cur, num);
; 373  : 			low = eBot-bTileHeight;

	vsubss	xmm0, xmm9, xmm11
	vmovss	DWORD PTR [rbp], xmm0

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm2, xmm0, QWORD PTR __real@403f666666666666
	vcvtss2sd xmm1, xmm1, xmm1
	vaddsd	xmm2, xmm2, xmm1
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 374  : 			n = noise(low, rand);
; 375  : 			low += (n>0 ? bTileHeight : arr[STEPDOWN(cur, num)]*size) * n * var;

	vcomiss	xmm0, xmm14
	ja	SHORT $LN21@rowcol

; 33   : 	if (n-1 < 0) return m-1;

	lea	eax, DWORD PTR [r13-1]
	test	eax, eax
	cmovns	r15d, eax

; 374  : 			n = noise(low, rand);
; 375  : 			low += (n>0 ? bTileHeight : arr[STEPDOWN(cur, num)]*size) * n * var;

	mov	rax, QWORD PTR [r14]
	movsxd	rcx, r15d
	vmulss	xmm11, xmm7, DWORD PTR [rax+rcx*4]
$LN21@rowcol:
	vmulss	xmm0, xmm11, xmm0
	vmulss	xmm1, xmm0, xmm8
	vaddss	xmm2, xmm1, DWORD PTR [rbp]
	vmovss	DWORD PTR [rbp], xmm2

; 376  : 			high = neBot;				

	vmovss	DWORD PTR [rsi], xmm12
	mov	ebx, r13d
	jmp	$LN8@rowcol
$LN9@rowcol:

; 377  : 
; 378  : 		} else if (pos > neTop) { // We rose one cur up

	vcomiss	xmm15, xmm6
	jbe	SHORT $LN11@rowcol

; 379  : 			id++;

	inc	DWORD PTR [r12]
	vmovss	xmm1, DWORD PTR rand$[rsp]

; 380  : 			cur = STEPUP(cur, num);

	mov	ebx, DWORD PTR tv734[rsp]

; 381  : 			high = eTop+tTileHeight;

	vaddss	xmm0, xmm13, xmm10
	vmovss	DWORD PTR [rsi], xmm0

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm2, xmm0, QWORD PTR __real@403f666666666666
	vcvtss2sd xmm1, xmm1, xmm1
	vaddsd	xmm2, xmm2, xmm1
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 382  : 			n = noise(high, rand);
; 383  : 			high += (n<0 ? tTileHeight : arr[STEPUP(cur, num)]*size) * n * var;

	vcomiss	xmm14, xmm0
	ja	SHORT $LN23@rowcol

; 26   : 	return (n + 1) % m;

	lea	eax, DWORD PTR [rbx+1]
	cdq
	idiv	edi

; 382  : 			n = noise(high, rand);
; 383  : 			high += (n<0 ? tTileHeight : arr[STEPUP(cur, num)]*size) * n * var;

	mov	rax, QWORD PTR [r14]
	movsxd	rcx, edx
	vmulss	xmm13, xmm7, DWORD PTR [rax+rcx*4]
$LN23@rowcol:
	vmulss	xmm0, xmm13, xmm0
	vmulss	xmm1, xmm0, xmm8
	vaddss	xmm2, xmm1, DWORD PTR [rsi]
	vmovss	DWORD PTR [rsi], xmm2

; 384  : 			low = neTop;		

	vmovss	DWORD PTR [rbp], xmm6

; 385  : 
; 386  : 		} else { // Still in the same cur

	jmp	SHORT $LN8@rowcol
$LN11@rowcol:

; 387  : 			low = neBot;

	vmovss	DWORD PTR [rbp], xmm12

; 388  : 			high = neTop;				

	vmovss	DWORD PTR [rsi], xmm6

; 389  : 		}
; 390  : 	} else {

	jmp	SHORT $LN8@rowcol
$LN7@rowcol:

; 391  : 		low = eBot;

	vmovss	DWORD PTR [rbp], xmm9

; 392  : 		high = eTop;

	vmovss	DWORD PTR [rsi], xmm10
$LN8@rowcol:

; 393  : 	}
; 394  : 
; 395  : 	return cur;

	vmovaps	xmm13, XMMWORD PTR [rsp+64]
	mov	eax, ebx
	vmovaps	xmm12, XMMWORD PTR [rsp+80]
	vmovaps	xmm11, XMMWORD PTR [rsp+96]
	vmovaps	xmm10, XMMWORD PTR [rsp+112]
	vmovaps	xmm9, XMMWORD PTR [rsp+128]
	vmovaps	xmm8, XMMWORD PTR [rsp+144]
	mov	r15, QWORD PTR [rsp+248]
	mov	r13, QWORD PTR [rsp+240]
	jmp	SHORT $LN1@rowcol
$LN6@rowcol:

; 343  : 		return -1;

	or	eax, -1
$LN1@rowcol:
	vmovaps	xmm6, XMMWORD PTR [rsp+176]

; 396  : }

	mov	rbx, QWORD PTR [rsp+256]
	vmovaps	xmm7, XMMWORD PTR [rsp+160]
	vmovaps	xmm14, XMMWORD PTR [rsp+48]
	vmovaps	xmm15, XMMWORD PTR [rsp+32]
	add	rsp, 192				; 000000c0H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z ENDP ; rowcol
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?offsetEdges@@YAXQEAMMM@Z
_TEXT	SEGMENT
edges$ = 8
x$ = 16
y$ = 24
?offsetEdges@@YAXQEAMMM@Z PROC				; offsetEdges, COMDAT

; 261  : 	edges[0] += x;

	vaddss	xmm0, xmm1, DWORD PTR [rcx]
	vmovss	DWORD PTR [rcx], xmm0

; 262  : 	edges[2] += x;

	vaddss	xmm0, xmm1, DWORD PTR [rcx+8]
	vmovss	DWORD PTR [rcx+8], xmm0

; 263  : 	edges[3] += y;

	vaddss	xmm0, xmm2, DWORD PTR [rcx+12]
	vmovss	DWORD PTR [rcx+12], xmm0

; 264  : 	edges[1] += y;

	vaddss	xmm0, xmm2, DWORD PTR [rcx+4]
	vmovss	DWORD PTR [rcx+4], xmm0

; 265  : }

	ret	0
?offsetEdges@@YAXQEAMMM@Z ENDP				; offsetEdges
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?getAngle@@YAMHM@Z
_TEXT	SEGMENT
type$ = 64
amount$ = 72
?getAngle@@YAMHM@Z PROC					; getAngle, COMDAT

; 121  : inline static float getAngle(int type, float amount) {

	sub	rsp, 56					; 00000038H
	vmovaps	XMMWORD PTR [rsp+32], xmm6
	vmovaps	xmm6, xmm1

; 122  : 	switch (type) {

	test	ecx, ecx
	je	$LN6@getAngle
	sub	ecx, 1
	je	$LN7@getAngle
	cmp	ecx, 1
	jne	SHORT $LN4@getAngle

; 128  : 			return 0.f;
; 129  : 		case 2: // 90
; 130  : 			switch (rand() % 4) {

	call	QWORD PTR __imp_rand
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN17@getAngle
	dec	eax
	or	eax, -4
	inc	eax
$LN17@getAngle:
	test	eax, eax
	je	$LN6@getAngle
	sub	eax, 1
	je	SHORT $LN11@getAngle
	sub	eax, 1
	je	SHORT $LN12@getAngle
	cmp	eax, 1
	jne	SHORT $LN4@getAngle

; 135  : 				case 2:
; 136  : 					return (float)pi;
; 137  : 				case 3:
; 138  : 					return (float)pi*1.5f;

	vmovss	xmm0, DWORD PTR __real@4096cbe4

; 142  : 	}
; 143  : 	return 0.f;
; 144  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 56					; 00000038H
	ret	0
$LN11@getAngle:

; 131  : 				case 0:
; 132  : 					return 0.f;
; 133  : 				case 1: 
; 134  : 					return (float)pi*.5f;

	vmovss	xmm0, DWORD PTR __real@3fc90fdb

; 142  : 	}
; 143  : 	return 0.f;
; 144  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 56					; 00000038H
	ret	0
$LN4@getAngle:

; 139  : 			}			
; 140  : 		default: // Amount	
; 141  : 			return UFRAND() * amount;

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm1, xmm0, QWORD PTR __real@40dfffc000000000
	vaddsd	xmm2, xmm1, xmm1
	vsubsd	xmm3, xmm2, QWORD PTR __real@3ff0000000000000
	vcvtss2sd xmm0, xmm6, xmm6
	vmulsd	xmm1, xmm3, xmm0
	vcvtsd2ss xmm0, xmm1, xmm1

; 142  : 	}
; 143  : 	return 0.f;
; 144  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 56					; 00000038H
	ret	0
$LN7@getAngle:

; 123  : 		case 0:
; 124  : 			return 0.f;
; 125  : 		case 1: // 180
; 126  : 			if (rand() % 2)

	call	QWORD PTR __imp_rand
	and	eax, -2147483647			; ffffffff80000001H
	jge	SHORT $LN16@getAngle
	dec	eax
	or	eax, -2
	inc	eax
$LN16@getAngle:
	test	eax, eax
	je	SHORT $LN6@getAngle
$LN12@getAngle:

; 127  : 				return (float)pi;

	vmovss	xmm0, DWORD PTR __real@40490fdb

; 142  : 	}
; 143  : 	return 0.f;
; 144  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 56					; 00000038H
	ret	0
$LN6@getAngle:
	vxorps	xmm0, xmm0, xmm0
	vmovaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 56					; 00000038H
	ret	0
?getAngle@@YAMHM@Z ENDP					; getAngle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?STEPDOWN@@YAHHH@Z
_TEXT	SEGMENT
n$ = 8
m$ = 16
?STEPDOWN@@YAHHH@Z PROC					; STEPDOWN, COMDAT

; 33   : 	if (n-1 < 0) return m-1;

	lea	eax, DWORD PTR [rcx-1]
	test	eax, eax
	jns	SHORT $LN2@STEPDOWN
	lea	eax, DWORD PTR [rdx-1]
$LN2@STEPDOWN:

; 34   : 	return n-1;
; 35   : }

	ret	0
?STEPDOWN@@YAHHH@Z ENDP					; STEPDOWN
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?rotate270@@YAXAEAM0@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
?rotate270@@YAXAEAM0@Z PROC				; rotate270, COMDAT

; 30   : inline static void rotate270(float& x, float& y) { float temp = x; x = y; y = -temp; }

	vmovss	xmm0, DWORD PTR [rcx]
	mov	eax, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	DWORD PTR [rcx], eax
	vmovss	DWORD PTR [rdx], xmm0
	ret	0
?rotate270@@YAXAEAM0@Z ENDP				; rotate270
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?rotate90@@YAXAEAM0@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
?rotate90@@YAXAEAM0@Z PROC				; rotate90, COMDAT

; 29   : inline static void rotate90(float& x, float& y)  { float temp = y; y = x; x = -temp; }

	vmovss	xmm0, DWORD PTR [rdx]
	mov	eax, DWORD PTR [rcx]
	vxorps	xmm0, xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	DWORD PTR [rdx], eax
	vmovss	DWORD PTR [rcx], xmm0
	ret	0
?rotate90@@YAXAEAM0@Z ENDP				; rotate90
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?STEPUP@@YAHHH@Z
_TEXT	SEGMENT
n$ = 8
m$ = 16
?STEPUP@@YAHHH@Z PROC					; STEPUP, COMDAT

; 25   : inline static int STEPUP(int n, int m) {

	mov	r8d, edx

; 26   : 	return (n + 1) % m;

	lea	eax, DWORD PTR [rcx+1]
	cdq
	idiv	r8d
	mov	eax, edx

; 27   : }

	ret	0
?STEPUP@@YAHHH@Z ENDP					; STEPUP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?noise@@YAMMM@Z
_TEXT	SEGMENT
x$ = 8
rand$ = 16
?noise@@YAMMM@Z PROC					; noise, COMDAT

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm2, xmm0, xmm0
	vmulsd	xmm3, xmm2, QWORD PTR __real@403f666666666666
	vcvtss2sd xmm0, xmm1, xmm1
	vaddsd	xmm1, xmm3, xmm0
	vcvtsd2ss xmm0, xmm1, xmm1
	jmp	?snoise@Perlin@@SAMM@Z			; Perlin::snoise
?noise@@YAMMM@Z ENDP					; noise
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?generateID@@YAHHH@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
?generateID@@YAHHH@Z PROC				; generateID, COMDAT

; 21   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	lea	eax, DWORD PTR [rdx-101]
	imul	eax, eax, 1000				; 000003e8H
	add	eax, ecx
	ret	0
?generateID@@YAHHH@Z ENDP				; generateID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$ = 64
p$ = 72
t$ = 80
?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z PROC ; Tile::draw, COMDAT

; 507  : TilePoint Tile::draw(Point3 p, TileParam& t) {	

$LN10:
	push	rbx
	sub	rsp, 48					; 00000030H

; 508  : 	if (t.tilingType == 1)

	cmp	DWORD PTR [r8], 1
	mov	rbx, rcx
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR [rdx]
	vmovss	xmm1, DWORD PTR [rdx+4]
	vmovss	DWORD PTR $T1[rsp], xmm0
	vmovss	xmm0, DWORD PTR [rdx+8]
	vmovss	DWORD PTR $T1[rsp+8], xmm0
	vmovss	DWORD PTR $T1[rsp+4], xmm1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 509  : 		return pat_herring(p, t);

	lea	rdx, QWORD PTR $T1[rsp]
	jne	SHORT $LN2@draw
	call	?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ; Tile::pat_herring

; 510  : 	return pat_xBond(p, t);

	mov	rax, rbx

; 511  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN2@draw:

; 510  : 	return pat_xBond(p, t);

	call	?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ; Tile::pat_xBond
	mov	rax, rbx

; 511  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ENDP ; Tile::draw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
_TEXT	SEGMENT
edges$ = 48
$T1 = 64
__$ReturnUdt$ = 144
p$ = 152
t$ = 160
?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z PROC ; Tile::pat_herring, COMDAT

; 457  : TilePoint Tile::pat_herring(Point3 p, TileParam& t) {

$LN21:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 128				; 00000080H

; 458  : 	float s = t.tileWidth * 2.f;	

	vmovss	xmm4, DWORD PTR [r8+8]

; 459  : 	float h = t.tileWidth * .5f;

	vmulss	xmm5, xmm4, DWORD PTR __real@3f000000
	vmovaps	XMMWORD PTR [rsp+112], xmm6
	mov	rbx, r8

; 460  : 	float x = p.x / s;

	vmovss	xmm6, DWORD PTR [rdx]
	vaddss	xmm2, xmm4, xmm4
	vdivss	xmm1, xmm6, xmm2
	vmovaps	XMMWORD PTR [rsp+96], xmm7
	mov	rdi, rcx

; 461  : 	float y = p.y / s;

	vmovss	xmm7, DWORD PTR [rdx+4]
	vxorps	xmm3, xmm3, xmm3

; 462  : 	int xi = FASTFLOOR(x);

	vcomiss	xmm3, xmm1
	vmovaps	XMMWORD PTR [rsp+80], xmm8
	vdivss	xmm0, xmm7, xmm2
	vcvttss2si r9d, xmm1
	jbe	SHORT $LN6@pat_herrin
	dec	r9d
$LN6@pat_herrin:

; 463  : 	int yi = FASTFLOOR(y);

	vcomiss	xmm3, xmm0
	vcvttss2si r8d, xmm0
	jbe	SHORT $LN8@pat_herrin
	dec	r8d
$LN8@pat_herrin:
	vxorps	xmm0, xmm0, xmm0

; 464  : 	x = xi * s;

	vcvtsi2ss xmm0, xmm0, r9d
	vmulss	xmm3, xmm0, xmm2
	vxorps	xmm1, xmm1, xmm1

; 465  : 	y = yi * s;

	vcvtsi2ss xmm1, xmm1, r8d
	vmulss	xmm8, xmm1, xmm2

; 467  : 	int y_id = (int)((p.y - y) / h) % 4;	

	vsubss	xmm0, xmm7, xmm8
	vdivss	xmm2, xmm0, xmm5
	vcvttss2si ecx, xmm2
	and	ecx, -2147483645			; ffffffff80000003H
	jge	SHORT $LN18@pat_herrin
	dec	ecx
	or	ecx, -4
	inc	ecx
$LN18@pat_herrin:

; 466  : 	int x_id = (int)((p.x - x) / h) % 4;

	vsubss	xmm0, xmm6, xmm3
	vdivss	xmm1, xmm0, xmm5
	vcvttss2si eax, xmm1
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN17@pat_herrin
	dec	eax
	or	eax, -4
	inc	eax
$LN17@pat_herrin:

; 468  : 	int id = x_id + 4 * y_id;

	lea	eax, DWORD PTR [rax+rcx*4]

; 469  : 
; 470  : 	//Point3 center = Point3(pat_herring_x[id]*h+x, pat_herring_y[id]*h+y, p.z);
; 471  : 
; 472  : 	float edges[4];
; 473  : 
; 474  : 	if (!pat_herring_dir[id]) {

	movsxd	rcx, eax
	lea	rsi, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR ?pat_herring_dir@@3PAEA[rcx+rsi]

; 475  : 		edges[0] = (pat_herring_x[id]-1.f) * h + x;

	vmovss	xmm0, DWORD PTR ?pat_herring_x@@3PAMA[rsi+rcx*4]
	test	al, al
	jne	SHORT $LN2@pat_herrin
	vsubss	xmm1, xmm0, DWORD PTR __real@3f800000
	vmulss	xmm2, xmm1, xmm5
	vaddss	xmm3, xmm2, xmm3

; 476  : 		edges[2] = edges[0] + t.tileWidth;

	vaddss	xmm0, xmm4, xmm3
	vmovss	DWORD PTR edges$[rsp+8], xmm0

; 477  : 		edges[3] = (pat_herring_y[id]-.5f) * h + y;

	vmovss	xmm0, DWORD PTR ?pat_herring_y@@3PAMA[rsi+rcx*4]
	vsubss	xmm1, xmm0, DWORD PTR __real@3f000000
	vmulss	xmm2, xmm1, xmm5
	vmovss	DWORD PTR edges$[rsp], xmm3
	vaddss	xmm3, xmm2, xmm8

; 478  : 		edges[1] = edges[3] + h;

	vaddss	xmm0, xmm3, xmm5

; 479  : 	} else {

	jmp	SHORT $LN19@pat_herrin
$LN2@pat_herrin:

; 480  : 		edges[0] = (pat_herring_x[id]-.5f) * h + x;

	vsubss	xmm1, xmm0, DWORD PTR __real@3f000000
	vmulss	xmm2, xmm1, xmm5
	vaddss	xmm3, xmm2, xmm3

; 481  : 		edges[2] = edges[0] + h;

	vaddss	xmm0, xmm3, xmm5
	vmovss	DWORD PTR edges$[rsp+8], xmm0

; 482  : 		edges[3] = (pat_herring_y[id]-1.f) * h + y;

	vmovss	xmm0, DWORD PTR ?pat_herring_y@@3PAMA[rsi+rcx*4]
	vsubss	xmm1, xmm0, DWORD PTR __real@3f800000
	vmulss	xmm2, xmm1, xmm5
	vmovss	DWORD PTR edges$[rsp], xmm3
	vaddss	xmm3, xmm2, xmm8

; 483  : 		edges[1] = edges[3] + t.tileWidth;	

	vaddss	xmm0, xmm4, xmm3
$LN19@pat_herrin:

; 484  : 	}
; 485  : 
; 486  : 	int tid = generateID(xi*4 + (pat_herring_dir[id] ? 0 : pat_herring_id[id]),

	xor	r10d, r10d
	vmovss	DWORD PTR edges$[rsp+4], xmm0
	vmovss	DWORD PTR edges$[rsp+12], xmm3
	test	al, al
	je	SHORT $LN9@pat_herrin
	movzx	r11d, BYTE PTR ?pat_herring_id@@3PAEA[rcx+rsi]
	jmp	SHORT $LN10@pat_herrin
$LN9@pat_herrin:
	mov	r11d, r10d
$LN10@pat_herrin:
	test	al, al
	jne	SHORT $LN12@pat_herrin
	movzx	r10d, BYTE PTR ?pat_herring_id@@3PAEA[rcx+rsi]
$LN12@pat_herrin:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR [rdx+8]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 489  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	movzx	edx, al
	lea	eax, DWORD PTR [r8*4-101]
	add	eax, r11d
	mov	DWORD PTR [rsp+40], edx

; 21   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	imul	ecx, eax, 250				; 000000faH

; 489  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	lea	r8, QWORD PTR edges$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T1[rsp], xmm6
	vmovss	DWORD PTR $T1[rsp+4], xmm7
	vmovss	DWORD PTR $T1[rsp+8], xmm0
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 489  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	add	ecx, r9d
	mov	r9, rbx

; 21   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	lea	eax, DWORD PTR [r10+rcx*4]

; 489  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	mov	rcx, rdi
	mov	DWORD PTR [rsp+32], eax
	call	?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z ; Tile::drawTile

; 490  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+112]
	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+16]
	mov	rax, rdi
	mov	rsi, QWORD PTR [r11+24]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm7, XMMWORD PTR [rsp+96]
	mov	rsp, r11
	pop	rdi
	ret	0
?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ENDP ; Tile::pat_herring
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
_TEXT	SEGMENT
edges$ = 80
$T1 = 96
__$ReturnUdt$ = 160
p$ = 168
id$ = 176
t$ = 176
id2$ = 184
?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z PROC ; Tile::pat_xBond, COMDAT

; 398  : TilePoint Tile::pat_xBond(Point3 p, TileParam& t) {

$LN57:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 128				; 00000080H

; 399  : 	TilePattern* pat = t.pattern;

	mov	rbp, QWORD PTR [r8+112]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	xor	edi, edi
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 398  : TilePoint Tile::pat_xBond(Point3 p, TileParam& t) {

	mov	rsi, r8
	mov	r14, rdx
	mov	rbx, rcx

; 401  : 	if (!pat) return TilePoint();

	test	rbp, rbp
	jne	SHORT $LN2@pat_xBond
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	mov	QWORD PTR [rcx], rdi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File g:\dropbox\github\berconmaps\src\tile.h

; 164  : 	TilePoint() {d = -1.f;}	

	mov	DWORD PTR [rcx+24], -1082130432		; bf800000H
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 401  : 	if (!pat) return TilePoint();

	jmp	$LN55@pat_xBond
$LN2@pat_xBond:

; 402  : 
; 403  : 	float edges[4];
; 404  : 	int id = 0;
; 405  : 	int id2 = 0;
; 406  : 	
; 407  : 	// Tile top and bottom
; 408  : 	float rand = 3.14f;
; 409  : 	int row = rowcol(edges[3], edges[1], id, p.y, pat->totalHeight, pat->heights, t.tileHeight, t.tileHeightVar, rand);

	vmovss	xmm1, DWORD PTR [r8+20]
	vmovss	xmm0, DWORD PTR __real@4048f5c3
	vmovss	xmm3, DWORD PTR [rdx+4]
	vmovss	DWORD PTR [rsp+64], xmm0
	vmovss	xmm0, DWORD PTR [r8+4]
	vmovss	DWORD PTR [rsp+56], xmm1
	vmovss	xmm1, DWORD PTR [rbp]
	vmovss	DWORD PTR [rsp+48], xmm0
	lea	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR id$[rsp], edi
	mov	QWORD PTR [rsp+40], rax
	lea	r8, QWORD PTR id$[rsp]
	lea	rdx, QWORD PTR edges$[rsp+4]
	mov	DWORD PTR id2$[rsp], edi
	lea	rcx, QWORD PTR edges$[rsp+12]
	vmovss	DWORD PTR [rsp+32], xmm1
	call	?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z ; rowcol

; 410  : 	if (row == -1) return TilePoint();

	cmp	eax, -1
	jne	SHORT $LN3@pat_xBond
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	mov	QWORD PTR [rbx], rdi
	mov	QWORD PTR [rbx+8], rdi
	mov	QWORD PTR [rbx+16], rdi
; File g:\dropbox\github\berconmaps\src\tile.h

; 164  : 	TilePoint() {d = -1.f;}	

	mov	DWORD PTR [rbx+24], -1082130432		; bf800000H
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 410  : 	if (row == -1) return TilePoint();

	jmp	$LN55@pat_xBond
$LN3@pat_xBond:

; 411  : 
; 412  : 	// Tile sides
; 413  : 	rand = edges[3] * 1.325f + 31.41213f;

	vmovss	xmm0, DWORD PTR edges$[rsp+12]
	vmulss	xmm1, xmm0, DWORD PTR __real@3fa9999a

; 414  : 	float offset = pat->rows[row].offset * t.tileWidth;

	mov	rdx, QWORD PTR [rbp+32]
	vaddss	xmm2, xmm1, DWORD PTR __real@41fb4c0b
	vmovss	xmm1, DWORD PTR [rsi+8]

; 415  : 	if (offset < 0) offset *= -id;

	mov	ebp, DWORD PTR id$[rsp]
	movsxd	rcx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	shl	rcx, 5
	vmovaps	XMMWORD PTR [rsp+112], xmm6
	vxorps	xmm0, xmm0, xmm0
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 414  : 	float offset = pat->rows[row].offset * t.tileWidth;

	vmulss	xmm6, xmm1, DWORD PTR [rcx+rdx]

; 415  : 	if (offset < 0) offset *= -id;

	vcomiss	xmm0, xmm6
	jbe	SHORT $LN4@pat_xBond
	mov	eax, ebp
	neg	eax
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vmulss	xmm6, xmm6, xmm0
$LN4@pat_xBond:

; 416  : 
; 417  : 	row = rowcol(edges[0], edges[2], id2, p.x + offset, pat->rows[row].totalWidth, pat->rows[row].tiles, t.tileWidth, t.tileWidthVar, rand);		

	vmovss	xmm0, DWORD PTR [rsi+24]
	vaddss	xmm3, xmm6, DWORD PTR [r14]
	vmovss	DWORD PTR [rsp+64], xmm2
	vmovss	DWORD PTR [rsp+56], xmm0
	vmovss	xmm0, DWORD PTR [rcx+rdx+4]
	lea	rax, QWORD PTR [rdx+8]
	add	rax, rcx
	lea	rdx, QWORD PTR edges$[rsp+8]
	vmovss	DWORD PTR [rsp+48], xmm1
	mov	QWORD PTR [rsp+40], rax
	lea	rcx, QWORD PTR edges$[rsp]
	lea	r8, QWORD PTR id2$[rsp]
	vmovss	DWORD PTR [rsp+32], xmm0
	call	?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z ; rowcol

; 418  : 	if (row == -1) return TilePoint();

	cmp	eax, -1
	jne	SHORT $LN5@pat_xBond
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	mov	QWORD PTR [rbx], rdi
	mov	QWORD PTR [rbx+8], rdi
	mov	QWORD PTR [rbx+16], rdi
; File g:\dropbox\github\berconmaps\src\tile.h

; 164  : 	TilePoint() {d = -1.f;}	

	mov	DWORD PTR [rbx+24], -1082130432		; bf800000H
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 418  : 	if (row == -1) return TilePoint();

	jmp	SHORT $LN54@pat_xBond
$LN5@pat_xBond:

; 419  : 
; 420  : 	edges[0] -= offset;

	vmovss	xmm0, DWORD PTR edges$[rsp]

; 421  : 	edges[2] -= offset;

	vmovss	xmm2, DWORD PTR edges$[rsp+8]
	vsubss	xmm1, xmm0, xmm6
	vsubss	xmm0, xmm2, xmm6
	vmovss	DWORD PTR edges$[rsp+8], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR [r14]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 423  : 	id = generateID(id2, id);

	lea	eax, DWORD PTR [rbp-101]

; 426  : 	return drawTile(p, edges, t, id);	

	mov	DWORD PTR [rsp+40], edi

; 21   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	imul	ecx, eax, 1000				; 000003e8H

; 426  : 	return drawTile(p, edges, t, id);	

	lea	r8, QWORD PTR edges$[rsp]
	vmovss	DWORD PTR edges$[rsp], xmm1
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm1, DWORD PTR [r14+4]
	vmovss	DWORD PTR $T1[rsp], xmm0
	vmovss	xmm0, DWORD PTR [r14+8]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 21   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	add	ecx, DWORD PTR id2$[rsp]

; 426  : 	return drawTile(p, edges, t, id);	

	lea	rdx, QWORD PTR $T1[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9, rsi
	mov	rcx, rbx
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T1[rsp+4], xmm1
	vmovss	DWORD PTR $T1[rsp+8], xmm0
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 426  : 	return drawTile(p, edges, t, id);	

	call	?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z ; Tile::drawTile
$LN54@pat_xBond:
	vmovaps	xmm6, XMMWORD PTR [rsp+112]
$LN55@pat_xBond:

; 427  : }

	lea	r11, QWORD PTR [rsp+128]
	mov	rax, rbx
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ENDP ; Tile::pat_xBond
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
tp$ = 64
__$ReturnUdt$ = 224
p$ = 232
edges$ = 240
t$ = 248
id$ = 256
dir$ = 264
?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z PROC ; Tile::drawTile, COMDAT

; 267  : TilePoint Tile::drawTile(Point3 p, float edges[4], TileParam& t, int id, int dir) {

$LN127:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	mov	QWORD PTR [rax+32], r12
	push	rbp
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-79]
	sub	rsp, 192				; 000000c0H

; 268  : 	float hEdgeW = t.edgeWidth * .5f;
; 269  : 	float hEdgeH = t.edgeHeight * .5f;
; 270  : 			
; 271  : 	float randomSeed = (float)id * 1.23f + 0.1234f;

	mov	r12d, DWORD PTR id$[rbp-137]
	mov	rsi, r9

; 272  : 	if (dir) {

	mov	r15d, DWORD PTR dir$[rbp-137]
	mov	rdi, r8
	vmovaps	XMMWORD PTR [rax-40], xmm6
	mov	r14, rdx
	vmovaps	XMMWORD PTR [rax-56], xmm7
	mov	rbx, rcx
	vmovaps	XMMWORD PTR [rax-72], xmm8
	vmovaps	XMMWORD PTR [rax-120], xmm11
	vmovaps	XMMWORD PTR [rax-88], xmm9
	vmovaps	XMMWORD PTR [rax-104], xmm10
	vmovss	xmm11, DWORD PTR __real@3f000000
	vmulss	xmm6, xmm11, DWORD PTR [r9+16]
	vmulss	xmm7, xmm11, DWORD PTR [r9+12]

; 273  : 		edges[0] += t.eH_var ? hEdgeH * (1.f + noise(edges[0], randomSeed) * t.edgeHeightVar) : hEdgeH;

	vmovss	xmm10, DWORD PTR __real@3f800000
	vmovsd	xmm9, QWORD PTR __real@403f666666666666
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, r12d
	vmulss	xmm0, xmm1, DWORD PTR __real@3f9d70a4
	vaddss	xmm8, xmm0, DWORD PTR __real@3dfcb924
	test	r15d, r15d
	je	$LN2@drawTile
	cmp	BYTE PTR [r9+37], 0
	je	SHORT $LN17@drawTile
	vmovss	xmm0, DWORD PTR [r8]

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm2, xmm0, xmm9
	vcvtss2sd xmm1, xmm8, xmm8
	vaddsd	xmm2, xmm2, xmm1
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 273  : 		edges[0] += t.eH_var ? hEdgeH * (1.f + noise(edges[0], randomSeed) * t.edgeHeightVar) : hEdgeH;

	vmulss	xmm0, xmm0, DWORD PTR [rsi+28]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm2, xmm1, xmm7
	jmp	SHORT $LN18@drawTile
$LN17@drawTile:
	vmovaps	xmm2, xmm7
$LN18@drawTile:
	vaddss	xmm0, xmm2, DWORD PTR [rdi]
	vmovss	DWORD PTR [rdi], xmm0

; 274  : 		edges[2] -= t.eH_var ? hEdgeH * (1.f + noise(edges[2], randomSeed) * t.edgeHeightVar) : hEdgeH;

	cmp	BYTE PTR [rsi+37], 0
	je	SHORT $LN19@drawTile
	vmovss	xmm0, DWORD PTR [rdi+8]

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm2, xmm0, xmm9
	vcvtss2sd xmm1, xmm8, xmm8
	vaddsd	xmm2, xmm2, xmm1
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 274  : 		edges[2] -= t.eH_var ? hEdgeH * (1.f + noise(edges[2], randomSeed) * t.edgeHeightVar) : hEdgeH;

	vmulss	xmm0, xmm0, DWORD PTR [rsi+28]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm7, xmm1, xmm7
$LN19@drawTile:
	vmovss	xmm0, DWORD PTR [rdi+8]
	vsubss	xmm1, xmm0, xmm7
	vmovss	DWORD PTR [rdi+8], xmm1

; 275  : 		edges[3] += t.eW_var ? hEdgeW * (1.f + noise(edges[3], randomSeed) * t.edgeWidthVar) : hEdgeW;

	cmp	BYTE PTR [rsi+36], 0
	je	SHORT $LN21@drawTile
	vmovss	xmm0, DWORD PTR [rdi+12]

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm2, xmm0, xmm9
	vcvtss2sd xmm1, xmm8, xmm8
	vaddsd	xmm2, xmm2, xmm1
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 275  : 		edges[3] += t.eW_var ? hEdgeW * (1.f + noise(edges[3], randomSeed) * t.edgeWidthVar) : hEdgeW;

	vmulss	xmm0, xmm0, DWORD PTR [rsi+32]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm2, xmm1, xmm6
	jmp	SHORT $LN22@drawTile
$LN21@drawTile:
	vmovaps	xmm2, xmm6
$LN22@drawTile:
	vaddss	xmm0, xmm2, DWORD PTR [rdi+12]
	vmovss	DWORD PTR [rdi+12], xmm0

; 276  : 		edges[1] -= t.eW_var ? hEdgeW * (1.f + noise(edges[1], randomSeed) * t.edgeWidthVar) : hEdgeW;

	cmp	BYTE PTR [rsi+36], 0
	je	SHORT $LN23@drawTile
	vmovss	xmm0, DWORD PTR [rdi+4]

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm2, xmm0, xmm9
	vcvtss2sd xmm1, xmm8, xmm8
	vaddsd	xmm2, xmm2, xmm1
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 276  : 		edges[1] -= t.eW_var ? hEdgeW * (1.f + noise(edges[1], randomSeed) * t.edgeWidthVar) : hEdgeW;

	vmulss	xmm0, xmm0, DWORD PTR [rsi+32]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm6, xmm1, xmm6
$LN23@drawTile:
	vmovss	xmm0, DWORD PTR [rdi+4]
	vsubss	xmm1, xmm0, xmm6

; 277  : 	} else {

	jmp	$LN124@drawTile
$LN2@drawTile:

; 278  : 		edges[0] += t.eW_var ? hEdgeW * (1.f + noise(edges[0], randomSeed) * t.edgeWidthVar) : hEdgeW;

	cmp	BYTE PTR [r9+36], 0
	je	SHORT $LN25@drawTile
	vmovss	xmm0, DWORD PTR [r8]

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm2, xmm0, xmm9
	vcvtss2sd xmm1, xmm8, xmm8
	vaddsd	xmm2, xmm2, xmm1
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 278  : 		edges[0] += t.eW_var ? hEdgeW * (1.f + noise(edges[0], randomSeed) * t.edgeWidthVar) : hEdgeW;

	vmulss	xmm0, xmm0, DWORD PTR [rsi+32]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm2, xmm1, xmm6
	jmp	SHORT $LN26@drawTile
$LN25@drawTile:
	vmovaps	xmm2, xmm6
$LN26@drawTile:
	vaddss	xmm0, xmm2, DWORD PTR [rdi]
	vmovss	DWORD PTR [rdi], xmm0

; 279  : 		edges[2] -= t.eW_var ? hEdgeW * (1.f + noise(edges[2], randomSeed) * t.edgeWidthVar) : hEdgeW;

	cmp	BYTE PTR [rsi+36], 0
	je	SHORT $LN27@drawTile
	vmovss	xmm0, DWORD PTR [rdi+8]

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm2, xmm0, xmm9
	vcvtss2sd xmm1, xmm8, xmm8
	vaddsd	xmm2, xmm2, xmm1
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 279  : 		edges[2] -= t.eW_var ? hEdgeW * (1.f + noise(edges[2], randomSeed) * t.edgeWidthVar) : hEdgeW;

	vmulss	xmm0, xmm0, DWORD PTR [rsi+32]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm6, xmm1, xmm6
$LN27@drawTile:
	vmovss	xmm0, DWORD PTR [rdi+8]
	vsubss	xmm1, xmm0, xmm6
	vmovss	DWORD PTR [rdi+8], xmm1

; 280  : 		edges[3] += t.eH_var ? hEdgeH * (1.f + noise(edges[3], randomSeed) * t.edgeHeightVar) : hEdgeH;

	cmp	BYTE PTR [rsi+37], 0
	je	SHORT $LN29@drawTile
	vmovss	xmm0, DWORD PTR [rdi+12]

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm2, xmm0, xmm9
	vcvtss2sd xmm1, xmm8, xmm8
	vaddsd	xmm2, xmm2, xmm1
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 280  : 		edges[3] += t.eH_var ? hEdgeH * (1.f + noise(edges[3], randomSeed) * t.edgeHeightVar) : hEdgeH;

	vmulss	xmm0, xmm0, DWORD PTR [rsi+28]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm2, xmm1, xmm7
	jmp	SHORT $LN30@drawTile
$LN29@drawTile:
	vmovaps	xmm2, xmm7
$LN30@drawTile:
	vaddss	xmm0, xmm2, DWORD PTR [rdi+12]
	vmovss	DWORD PTR [rdi+12], xmm0

; 281  : 		edges[1] -= t.eH_var ? hEdgeH * (1.f + noise(edges[1], randomSeed) * t.edgeHeightVar) : hEdgeH;

	cmp	BYTE PTR [rsi+37], 0
	je	SHORT $LN31@drawTile
	vmovss	xmm0, DWORD PTR [rdi+4]

; 23   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm2, xmm0, xmm9
	vcvtss2sd xmm1, xmm8, xmm8
	vaddsd	xmm2, xmm2, xmm1
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 281  : 		edges[1] -= t.eH_var ? hEdgeH * (1.f + noise(edges[1], randomSeed) * t.edgeHeightVar) : hEdgeH;

	vmulss	xmm0, xmm0, DWORD PTR [rsi+28]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm7, xmm1, xmm7
$LN31@drawTile:
	vmovss	xmm0, DWORD PTR [rdi+4]
	vsubss	xmm1, xmm0, xmm7
$LN124@drawTile:
	vmovaps	xmm10, XMMWORD PTR [rsp+112]
	vmovaps	xmm9, XMMWORD PTR [rsp+128]
	vmovss	DWORD PTR [rdi+4], xmm1

; 282  : 	}
; 283  : 
; 284  : 	if (p.x < edges[0]) return TilePoint();

	vmovss	xmm0, DWORD PTR [r14]
	vmovss	xmm1, DWORD PTR [rdi]
	vcomiss	xmm1, xmm0
	ja	$LN9@drawTile

; 285  : 	if (p.x > edges[2]) return TilePoint();

	vmovss	xmm4, DWORD PTR [rdi+8]
	vcomiss	xmm0, xmm4
	ja	$LN9@drawTile

; 286  : 	if (p.y < edges[3]) return TilePoint();

	vmovss	xmm2, DWORD PTR [r14+4]
	vmovss	xmm3, DWORD PTR [rdi+12]
	vcomiss	xmm3, xmm2
	ja	$LN9@drawTile

; 287  : 	if (p.y > edges[1]) return TilePoint();

	vmovss	xmm5, DWORD PTR [rdi+4]
	vcomiss	xmm2, xmm5
	ja	$LN9@drawTile

; 288  : 
; 289  : 	float width = edges[2] - edges[0];

	vsubss	xmm6, xmm4, xmm1
	vxorps	xmm7, xmm7, xmm7

; 290  : 	float height = edges[1] - edges[3];
; 291  : 	if (width < 0 || height < 0) return TilePoint();

	vcomiss	xmm7, xmm6
	vsubss	xmm4, xmm5, xmm3
	ja	$LN9@drawTile
	vcomiss	xmm7, xmm4
	ja	$LN9@drawTile

; 292  : 
; 293  : 	TilePoint tp = corner(p.x - edges[0], p.y - edges[3], width, height, t);	

	vsubss	xmm2, xmm2, xmm3
	vmovaps	xmm3, xmm6
	vsubss	xmm1, xmm0, xmm1
	mov	QWORD PTR [rsp+40], rsi
	lea	rcx, QWORD PTR tp$[rbp-137]
	vmovss	DWORD PTR [rsp+32], xmm4
	call	?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z ; Tile::corner

; 294  : 	if (tp.d < 0) return tp; // On edge

	vmovss	xmm6, DWORD PTR tp$[rbp-113]
	vcomiss	xmm7, xmm6
	jbe	SHORT $LN10@drawTile
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovups	xmm0, XMMWORD PTR tp$[rbp-137]
	vmovss	xmm1, DWORD PTR tp$[rbp-117]
	mov	eax, DWORD PTR tp$[rbp-109]
	vmovups	XMMWORD PTR [rbx], xmm0
	vmovss	xmm0, DWORD PTR tp$[rbp-121]
	vmovss	DWORD PTR [rbx+16], xmm0
	vmovss	DWORD PTR [rbx+20], xmm1
	vmovss	DWORD PTR [rbx+24], xmm6
	mov	DWORD PTR [rbx+28], eax
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 294  : 	if (tp.d < 0) return tp; // On edge

	jmp	$LN125@drawTile
$LN10@drawTile:

; 295  : 
; 296  : 	//if (t.tileID || t.mapUV)
; 297  : 		tp.id = id;
; 298  : 
; 299  : 	if (t.center || (t.mapUV && dir))

	cmp	DWORD PTR [rsi+104], 0
	vmovss	xmm8, DWORD PTR __xmm@80000000800000008000000080000000
	mov	DWORD PTR tp$[rbp-109], r12d
	jne	SHORT $LN12@drawTile
	cmp	DWORD PTR [rsi+60], 0
	je	SHORT $LN11@drawTile
	test	r15d, r15d
	je	$LN123@drawTile
$LN12@drawTile:

; 300  : 		tp.center = Point3(edges[0] + (edges[2] - edges[0]) * .5f,

	vmovss	xmm0, DWORD PTR [rdi+8]
	vsubss	xmm1, xmm0, DWORD PTR [rdi]
	vmovss	xmm0, DWORD PTR [rdi+4]
	vmulss	xmm2, xmm1, xmm11
	vsubss	xmm1, xmm0, DWORD PTR [rdi+12]
	vaddss	xmm5, xmm2, DWORD PTR [rdi]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR [r14+8]
	vmovss	DWORD PTR $T2[rbp-129], xmm0
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 300  : 		tp.center = Point3(edges[0] + (edges[2] - edges[0]) * .5f,

	mov	eax, DWORD PTR $T2[rbp-129]
	vmulss	xmm2, xmm1, xmm11
	vaddss	xmm3, xmm2, DWORD PTR [rdi+12]
	vunpcklps xmm0, xmm5, xmm3
	vmovsd	QWORD PTR tp$[rbp-137], xmm0
	mov	DWORD PTR tp$[rbp-129], eax
$LN11@drawTile:

; 301  : 		                   edges[3] + (edges[1] - edges[3]) * .5f, p.z);
; 302  : 
; 303  : 	if (dir) {

	test	r15d, r15d
	je	$LN123@drawTile

; 304  : 		offsetEdges(edges, -tp.center.x, -tp.center.y);

	vmovss	xmm5, DWORD PTR tp$[rbp-137]
	vmovss	xmm4, DWORD PTR tp$[rbp-133]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 261  :    x -= a.x;   y -= a.y;   z -= a.z;

	vmovss	xmm7, DWORD PTR tp$[rbp-129]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 304  : 		offsetEdges(edges, -tp.center.x, -tp.center.y);

	vxorps	xmm0, xmm5, xmm8

; 261  : 	edges[0] += x;

	vaddss	xmm3, xmm0, DWORD PTR [rdi]

; 262  : 	edges[2] += x;

	vaddss	xmm0, xmm0, DWORD PTR [rdi+8]
	vmovss	DWORD PTR [rdi+8], xmm0

; 304  : 		offsetEdges(edges, -tp.center.x, -tp.center.y);

	vxorps	xmm2, xmm4, xmm8

; 264  : 	edges[1] += y;

	vaddss	xmm0, xmm2, DWORD PTR [rdi+4]
	vaddss	xmm1, xmm2, DWORD PTR [rdi+12]
	vmovss	DWORD PTR [rdi+4], xmm0

; 29   : inline static void rotate90(float& x, float& y)  { float temp = y; y = x; x = -temp; }

	vmovss	DWORD PTR [rdi+12], xmm3
	vxorps	xmm0, xmm1, xmm8
	vmovss	DWORD PTR [rdi], xmm0
	vmovss	xmm0, DWORD PTR [rdi+4]
	mov	eax, DWORD PTR [rdi+8]
	mov	DWORD PTR [rdi+4], eax
	vxorps	xmm0, xmm0, xmm8
	vmovss	DWORD PTR [rdi+8], xmm0

; 261  : 	edges[0] += x;

	vaddss	xmm1, xmm5, DWORD PTR [rdi]

; 262  : 	edges[2] += x;

	vaddss	xmm0, xmm5, DWORD PTR [rdi+8]
	vmovss	DWORD PTR [rdi+8], xmm0

; 264  : 	edges[1] += y;

	vaddss	xmm0, xmm4, DWORD PTR [rdi+4]
	vmovss	DWORD PTR [rdi], xmm1
	vaddss	xmm1, xmm4, DWORD PTR [rdi+12]
	vmovss	DWORD PTR [rdi+4], xmm0
	vmovss	DWORD PTR [rdi+12], xmm1
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 261  :    x -= a.x;   y -= a.y;   z -= a.z;

	vmovss	xmm0, DWORD PTR [r14+4]
	vmovss	xmm1, DWORD PTR [r14]
	vsubss	xmm2, xmm1, xmm5
	vsubss	xmm1, xmm0, xmm4
	vmovss	xmm0, DWORD PTR [r14+8]
	vsubss	xmm0, xmm0, xmm7
	vmovss	DWORD PTR [r14+8], xmm0
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 29   : inline static void rotate90(float& x, float& y)  { float temp = y; y = x; x = -temp; }

	vmovss	DWORD PTR [r14+4], xmm2
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vsubss	xmm0, xmm5, xmm1
	vmovss	DWORD PTR [r14], xmm0
	vaddss	xmm1, xmm4, DWORD PTR [r14+4]
	vaddss	xmm0, xmm7, DWORD PTR [r14+8]
	vmovss	DWORD PTR [r14+4], xmm1
	vmovss	DWORD PTR [r14+8], xmm0
	jmp	SHORT $LN13@drawTile
$LN123@drawTile:
	vmovss	xmm7, DWORD PTR tp$[rbp-129]
	vmovss	xmm4, DWORD PTR tp$[rbp-133]
	vmovss	xmm5, DWORD PTR tp$[rbp-137]
$LN13@drawTile:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 311  : 	if (t.mapUV)

	cmp	DWORD PTR [rsi+60], 0
	je	SHORT $LN14@drawTile
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR [r14]
	vmovss	xmm1, DWORD PTR [r14+4]
	vmovss	DWORD PTR $T1[rbp-137], xmm0
	vmovss	xmm0, DWORD PTR [r14+8]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 312  : 		uvMapping(tp, p, edges, t, dir);

	mov	r9, rsi
	mov	DWORD PTR [rsp+32], r15d
	mov	r8, rdi
	lea	rdx, QWORD PTR $T1[rbp-137]
	lea	rcx, QWORD PTR tp$[rbp-137]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T1[rbp-129], xmm0
	vmovss	DWORD PTR $T1[rbp-133], xmm1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 312  : 		uvMapping(tp, p, edges, t, dir);

	call	?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z ; Tile::uvMapping
	vmovss	xmm4, DWORD PTR tp$[rbp-133]
	vmovss	xmm5, DWORD PTR tp$[rbp-137]
	mov	r12d, DWORD PTR tp$[rbp-109]
	vmovss	xmm6, DWORD PTR tp$[rbp-113]
	vmovss	xmm7, DWORD PTR tp$[rbp-129]
$LN14@drawTile:

; 313  : 
; 314  : 	if (dir) {

	test	r15d, r15d
	je	$LN15@drawTile

; 315  : 		offsetEdges(edges, -tp.center.x, -tp.center.y);

	vxorps	xmm0, xmm5, xmm8

; 261  : 	edges[0] += x;

	vaddss	xmm3, xmm0, DWORD PTR [rdi]

; 262  : 	edges[2] += x;

	vaddss	xmm0, xmm0, DWORD PTR [rdi+8]
	vmovss	DWORD PTR [rdi+8], xmm0
	vmovss	DWORD PTR [rdi], xmm3

; 315  : 		offsetEdges(edges, -tp.center.x, -tp.center.y);

	vxorps	xmm2, xmm4, xmm8

; 264  : 	edges[1] += y;

	vaddss	xmm0, xmm2, DWORD PTR [rdi+4]
	vaddss	xmm1, xmm2, DWORD PTR [rdi+12]
	vmovss	DWORD PTR [rdi+4], xmm0
	vmovss	DWORD PTR [rdi+12], xmm1

; 30   : inline static void rotate270(float& x, float& y) { float temp = x; x = y; y = -temp; }

	mov	eax, DWORD PTR [rdi+12]
	mov	DWORD PTR [rdi], eax
	vxorps	xmm0, xmm3, xmm8
	vmovss	DWORD PTR [rdi+12], xmm0
	vmovss	xmm0, DWORD PTR [rdi+8]
	mov	eax, DWORD PTR [rdi+4]
	mov	DWORD PTR [rdi+8], eax
	vxorps	xmm0, xmm0, xmm8
	vmovss	DWORD PTR [rdi+4], xmm0

; 261  : 	edges[0] += x;

	vaddss	xmm1, xmm5, DWORD PTR [rdi]

; 262  : 	edges[2] += x;

	vaddss	xmm0, xmm5, DWORD PTR [rdi+8]
	vmovss	DWORD PTR [rdi], xmm1

; 263  : 	edges[3] += y;

	vaddss	xmm1, xmm4, DWORD PTR [rdi+12]
	vmovss	DWORD PTR [rdi+8], xmm0

; 264  : 	edges[1] += y;

	vaddss	xmm0, xmm4, DWORD PTR [rdi+4]
	vmovss	DWORD PTR [rdi+12], xmm1
	vmovss	DWORD PTR [rdi+4], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 261  :    x -= a.x;   y -= a.y;   z -= a.z;

	vmovss	xmm1, DWORD PTR [r14]
	vmovss	xmm0, DWORD PTR [r14+4]
	vsubss	xmm2, xmm1, xmm5
	vsubss	xmm1, xmm0, xmm4
	vmovss	xmm0, DWORD PTR [r14+8]
	vmovss	DWORD PTR [r14+4], xmm1
	vmovss	DWORD PTR [r14], xmm2
	vsubss	xmm1, xmm0, xmm7
	vmovss	DWORD PTR [r14+8], xmm1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 30   : inline static void rotate270(float& x, float& y) { float temp = x; x = y; y = -temp; }

	mov	eax, DWORD PTR [r14+4]
	mov	DWORD PTR [r14], eax
	vxorps	xmm0, xmm2, xmm8
	vmovss	DWORD PTR [r14+4], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vaddss	xmm1, xmm5, DWORD PTR [r14]
	vaddss	xmm0, xmm4, DWORD PTR [r14+4]
	vmovss	DWORD PTR [r14], xmm1
	vaddss	xmm1, xmm7, DWORD PTR [r14+8]
	vmovss	DWORD PTR [r14+8], xmm1
	vmovss	DWORD PTR [r14+4], xmm0
$LN15@drawTile:

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR tp$[rbp-125]
	vmovss	xmm1, DWORD PTR tp$[rbp-121]
	vmovss	DWORD PTR [rbx], xmm5
	vmovss	DWORD PTR [rbx+4], xmm4
	vmovss	DWORD PTR [rbx+8], xmm7
	vmovss	DWORD PTR [rbx+12], xmm0
	vmovss	xmm0, DWORD PTR tp$[rbp-117]
	vmovss	DWORD PTR [rbx+20], xmm0
	vmovss	DWORD PTR [rbx+16], xmm1
	vmovss	DWORD PTR [rbx+24], xmm6
	mov	DWORD PTR [rbx+28], r12d
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 322  : 	return tp;	

	jmp	SHORT $LN125@drawTile
$LN9@drawTile:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	xor	eax, eax
	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rax
	mov	QWORD PTR [rbx+16], rax
; File g:\dropbox\github\berconmaps\src\tile.h

; 164  : 	TilePoint() {d = -1.f;}	

	mov	DWORD PTR [rbx+24], -1082130432		; bf800000H
$LN125@drawTile:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 323  : }

	lea	r11, QWORD PTR [rsp+192]
	mov	rax, rbx
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rdi, QWORD PTR [r11+48]
	mov	r12, QWORD PTR [r11+56]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm11, XMMWORD PTR [r11-96]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rbp
	ret	0
?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z ENDP ; Tile::drawTile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
_TEXT	SEGMENT
uvw$ = 32
tp$ = 208
p$ = 216
edges$ = 224
t$ = 232
dir$ = 240
?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z PROC ; Tile::uvMapping, COMDAT

; 162  : void Tile::uvMapping(TilePoint& tp, Point3 p, float edges[4], TileParam& t, int dir) {

$LN49:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 163  : 	float w = edges[2] - edges[0];

	vmovss	xmm0, DWORD PTR [r8+8]

; 164  : 	float h = edges[1] - edges[3];

	vmovss	xmm1, DWORD PTR [r8+4]
	vmovaps	XMMWORD PTR [rax-24], xmm6
	mov	rsi, rcx
	vmovaps	XMMWORD PTR [rax-40], xmm7
	mov	rbx, r9
	vmovaps	XMMWORD PTR [rax-56], xmm8
	vmovaps	XMMWORD PTR [rax-72], xmm9
	vmovaps	XMMWORD PTR [rax-88], xmm10
	vsubss	xmm10, xmm0, DWORD PTR [r8]

; 165  : 		
; 166  : 	// Center uvw
; 167  : 	Point3 uvw;
; 168  : 	uvw.x = p.x - edges[0] - w * .5f;

	vmovss	xmm0, DWORD PTR [rdx]
	vsubss	xmm2, xmm0, DWORD PTR [r8]

; 169  : 	uvw.y = p.y - edges[3] - h * .5f;

	vmovss	xmm0, DWORD PTR [rdx+4]
	vmovaps	XMMWORD PTR [rax-104], xmm11
	vsubss	xmm11, xmm1, DWORD PTR [r8+12]
	vmovaps	XMMWORD PTR [rax-120], xmm12
	vmovss	xmm12, DWORD PTR __real@3f000000
	vmulss	xmm1, xmm10, xmm12
	vsubss	xmm8, xmm2, xmm1
	vsubss	xmm2, xmm0, DWORD PTR [r8+12]

; 170  : 	uvw.z = p.z;

	vmovss	xmm0, DWORD PTR [rdx+8]

; 171  : 
; 172  : 	// Prime randomness
; 173  : 	srand(tp.id*(tp.id*tp.id*15731 + 789221));

	mov	edx, DWORD PTR [rcx+28]
	mov	eax, edx
	vmovaps	XMMWORD PTR [rsp+64], xmm13
	vmovaps	XMMWORD PTR [rsp+48], xmm14
	imul	eax, edx
	vmulss	xmm1, xmm11, xmm12
	vsubss	xmm7, xmm2, xmm1
	vmovss	DWORD PTR uvw$[rsp], xmm8
	vmovss	DWORD PTR uvw$[rsp+4], xmm7
	imul	ecx, eax, 15731				; 00003d73H
	vmovss	DWORD PTR uvw$[rsp+8], xmm0
	add	ecx, 789221				; 000c0ae5H
	imul	ecx, edx
	call	QWORD PTR __imp_srand

; 174  : 
; 175  : 	// Angle
; 176  : 	float angle = getAngle(t.rotUV, t.randRot);

	vmovss	xmm1, DWORD PTR [rbx+88]
	mov	ecx, DWORD PTR [rbx+84]
	call	?getAngle@@YAMHM@Z			; getAngle

; 177  : 
; 178  : 	// Random scale
; 179  : 	float scaleX = 0, scaleY = 0;			//avoid error C4701
; 180  : 	switch (t.autoScale) {

	mov	edi, DWORD PTR [rbx+56]
	mov	ecx, edi
	vxorps	xmm14, xmm14, xmm14
	vmovaps	xmm13, xmm0
	vmovaps	xmm6, xmm14
	vmovaps	xmm9, xmm14
	sub	ecx, 1
	je	SHORT $LN4@uvMapping
	sub	ecx, 1
	je	SHORT $LN4@uvMapping
	sub	ecx, 1
	je	SHORT $LN6@uvMapping
	sub	ecx, 1
	je	SHORT $LN7@uvMapping
	cmp	ecx, 1
	jne	SHORT $LN2@uvMapping

; 195  : 		case 5: { // UV Norm. Keep aspect
; 196  : 			float s = MAX(t.tileMaxWidth, t.tileMaxHeight);		
; 197  : 			scaleX = s;
; 198  : 			scaleY = s;

	vmovss	xmm0, DWORD PTR [rbx+124]
	vmaxss	xmm6, xmm0, DWORD PTR [rbx+120]
	vmovaps	xmm9, xmm6
	jmp	SHORT $LN2@uvMapping
$LN7@uvMapping:

; 191  : 		case 4: { // UV Norm.
; 192  : 			scaleX = t.tileMaxWidth;

	vmovss	xmm6, DWORD PTR [rbx+124]

; 193  : 			scaleY = t.tileMaxHeight;

	vmovss	xmm9, DWORD PTR [rbx+120]

; 194  : 			break; }

	jmp	SHORT $LN2@uvMapping
$LN6@uvMapping:
	vmaxss	xmm6, xmm10, xmm11

; 183  : 			break; }		
; 184  : 		case 2: { // UV Fit
; 185  : 			scaleX = w; scaleY = h; // Same as UV, but with additiona scaling below
; 186  : 			break; }
; 187  : 		case 3: { // UV Fit Keep aspect
; 188  : 			float s = MAX(w, h);		
; 189  : 			scaleX = s; scaleY = s;

	vmovaps	xmm9, xmm6

; 190  : 			break; }

	jmp	SHORT $LN2@uvMapping
$LN4@uvMapping:

; 181  : 		case 1: { // UV
; 182  : 			scaleX = w; scaleY = h;

	vmovaps	xmm9, xmm11
	vmovaps	xmm6, xmm10
$LN2@uvMapping:
	vmovss	xmm10, DWORD PTR __xmm@80000000800000008000000080000000
	lea	eax, DWORD PTR [rdi-2]
	cmp	eax, 1
	ja	SHORT $LN9@uvMapping

; 199  : 			break; }		
; 200  : 	}
; 201  : 
; 202  : 	// Calculate scaling required to fit UVs tightly around the tile
; 203  : 	if ((t.autoScale == 2 || t.autoScale == 3) && t.rotUV) { // Scale based on rotation so whole tile stays inside 0..1 space

	cmp	DWORD PTR [rbx+84], 0
	je	SHORT $LN9@uvMapping

; 204  : 		float scale = 2.f * SQRTHALF * cos(fmod(angle > 0 ? -angle : angle, HALFPI) + QUATPI);

	vandps	xmm0, xmm13, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 154  : 	return (_CSTD fmodf(_Xx, _Yx));

	vmovss	xmm1, DWORD PTR __real@3fc90fdb
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 204  : 		float scale = 2.f * SQRTHALF * cos(fmod(angle > 0 ? -angle : angle, HALFPI) + QUATPI);

	vxorps	xmm0, xmm0, xmm10
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 154  : 	return (_CSTD fmodf(_Xx, _Yx));

	call	fmodf
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 204  : 		float scale = 2.f * SQRTHALF * cos(fmod(angle > 0 ? -angle : angle, HALFPI) + QUATPI);

	vaddss	xmm0, xmm0, DWORD PTR __real@3f490fdb
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 88   : 	return (_CSTD cosf(_Xx));

	call	cosf
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 204  : 		float scale = 2.f * SQRTHALF * cos(fmod(angle > 0 ? -angle : angle, HALFPI) + QUATPI);

	vmulss	xmm1, xmm0, DWORD PTR __real@3fb504f3

; 205  : 		scaleX *= scale;

	vmulss	xmm6, xmm6, xmm1

; 206  : 		scaleY *= scale;

	vmulss	xmm9, xmm9, xmm1
$LN9@uvMapping:

; 207  : 	}	
; 208  : 
; 209  : 	// Apply auto scale
; 210  : 	if (t.autoScale) {

	test	edi, edi
	je	SHORT $LN11@uvMapping

; 211  : 		uvw.x /= scaleX;

	vdivss	xmm8, xmm8, xmm6

; 212  : 		uvw.y /= scaleY;

	vdivss	xmm7, xmm7, xmm9
	vmovss	DWORD PTR uvw$[rsp], xmm8
	vmovss	DWORD PTR uvw$[rsp+4], xmm7
$LN11@uvMapping:

; 213  : 	}
; 214  : 
; 215  : 	// Flip
; 216  : 	if (t.flipX) if (rand() % 2) uvw.x = -uvw.x;

	cmp	DWORD PTR [rbx+92], 0
	je	SHORT $LN13@uvMapping
	call	QWORD PTR __imp_rand
	and	eax, -2147483647			; ffffffff80000001H
	jge	SHORT $LN47@uvMapping
	dec	eax
	or	eax, -2
	inc	eax
$LN47@uvMapping:
	test	eax, eax
	je	SHORT $LN13@uvMapping
	vxorps	xmm8, xmm8, xmm10
	vmovss	DWORD PTR uvw$[rsp], xmm8
$LN13@uvMapping:

; 217  : 	if (t.flipY) if (rand() % 2) uvw.y = -uvw.y;

	cmp	DWORD PTR [rbx+96], 0
	je	SHORT $LN15@uvMapping
	call	QWORD PTR __imp_rand
	and	eax, -2147483647			; ffffffff80000001H
	jge	SHORT $LN46@uvMapping
	dec	eax
	or	eax, -2
	inc	eax
$LN46@uvMapping:
	test	eax, eax
	je	SHORT $LN15@uvMapping
	vxorps	xmm7, xmm7, xmm10
	vmovss	DWORD PTR uvw$[rsp+4], xmm7
$LN15@uvMapping:

; 218  : 	
; 219  : 	// Random scale
; 220  : 	if (t.randScale) {

	cmp	BYTE PTR [rbx+128], 0
	vmovsd	xmm6, QWORD PTR __real@40dfffc000000000
	vmovsd	xmm9, QWORD PTR __real@3ff0000000000000
	je	$LN16@uvMapping

; 221  : 		if (t.lock) {

	cmp	DWORD PTR [rbx+80], 0
	je	SHORT $LN17@uvMapping

; 222  : 			float s = 1.f + SFRAND() * t.randSX;

	call	QWORD PTR __imp_rand
	vmovss	xmm1, DWORD PTR [rbx+72]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm2, xmm0, xmm6
	vcvtss2sd xmm1, xmm1, xmm1
	vmulsd	xmm2, xmm1, xmm2
	vaddsd	xmm0, xmm2, xmm9
	vcvtsd2ss xmm10, xmm0, xmm0

; 223  : 			scaleX = s;
; 224  : 			scaleY = s;

	vmovaps	xmm1, xmm10

; 225  : 		} else {

	jmp	SHORT $LN18@uvMapping
$LN17@uvMapping:

; 226  : 			scaleX = 1.f + SFRAND() * t.randSX;

	call	QWORD PTR __imp_rand
	vmovss	xmm1, DWORD PTR [rbx+72]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm2, xmm0, xmm6
	vcvtss2sd xmm1, xmm1, xmm1
	vmulsd	xmm2, xmm1, xmm2
	vaddsd	xmm0, xmm2, xmm9
	vcvtsd2ss xmm10, xmm0, xmm0

; 227  : 			scaleY = 1.f + SFRAND() * t.randSY;

	call	QWORD PTR __imp_rand
	vmovss	xmm1, DWORD PTR [rbx+76]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm2, xmm0, xmm6
	vcvtss2sd xmm1, xmm1, xmm1
	vmulsd	xmm2, xmm1, xmm2
	vaddsd	xmm0, xmm2, xmm9
	vcvtsd2ss xmm1, xmm0, xmm0
$LN18@uvMapping:

; 228  : 		}
; 229  : 
; 230  : 		if (scaleX < 0) scaleX = 0.f;
; 231  : 		if (scaleY < 0) scaleY = 0.f;
; 232  : 
; 233  : 		uvw.x /= scaleX;	 

	vmaxss	xmm0, xmm14, xmm10
	vdivss	xmm8, xmm8, xmm0
	vmaxss	xmm0, xmm14, xmm1

; 234  : 		uvw.y /= scaleY;

	vdivss	xmm7, xmm7, xmm0
	vmovss	DWORD PTR uvw$[rsp+4], xmm7
	vmovss	DWORD PTR uvw$[rsp], xmm8
$LN16@uvMapping:

; 235  : 	}
; 236  : 
; 237  : 	// Offset
; 238  : 	if (t.randOffset) {

	cmp	BYTE PTR [rbx+129], 0
	je	SHORT $LN21@uvMapping

; 239  : 		uvw.x += UFRAND() * t.randX;

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm1, xmm0, xmm6
	vmovss	xmm0, DWORD PTR [rbx+64]
	vaddsd	xmm2, xmm1, xmm1
	vsubsd	xmm3, xmm2, xmm9
	vcvtss2sd xmm1, xmm8, xmm8
	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm4, xmm3, xmm0
	vaddsd	xmm2, xmm4, xmm1
	vcvtsd2ss xmm8, xmm2, xmm2
	vmovss	DWORD PTR uvw$[rsp], xmm8

; 240  : 		uvw.y += UFRAND() * t.randY;

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm1, xmm0, xmm6
	vmovss	xmm0, DWORD PTR [rbx+68]
	vaddsd	xmm2, xmm1, xmm1
	vsubsd	xmm3, xmm2, xmm9
	vcvtss2sd xmm1, xmm7, xmm7
	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm4, xmm3, xmm0
	vaddsd	xmm2, xmm4, xmm1
	vcvtsd2ss xmm7, xmm2, xmm2
	vmovss	DWORD PTR uvw$[rsp+4], xmm7
$LN21@uvMapping:

; 241  : 	}
; 242  : 
; 243  : 	// Rotate
; 244  : 	if (t.rotUV)

	cmp	DWORD PTR [rbx+84], 0
	je	SHORT $LN22@uvMapping
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 88   : 	return (_CSTD cosf(_Xx));

	vmovaps	xmm0, xmm13
	call	cosf
	vmovaps	xmm6, xmm0

; 295  : 	return (_CSTD sinf(_Xx));

	vmovaps	xmm0, xmm13
	call	sinf
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 116  : 	float rotY = (sin(angle)*d.x + cos(angle)*d.y);

	vmulss	xmm2, xmm0, xmm8
	vmulss	xmm0, xmm0, xmm7
	vmulss	xmm1, xmm6, xmm7
	vaddss	xmm4, xmm2, xmm1
	vmulss	xmm3, xmm6, xmm8
	vsubss	xmm8, xmm3, xmm0
	vmovss	DWORD PTR uvw$[rsp], xmm8

; 117  : 	d.x = rotX;
; 118  : 	d.y = rotY;

	vmovss	DWORD PTR uvw$[rsp+4], xmm4
	vmovaps	xmm7, xmm4
$LN22@uvMapping:

; 245  : 		rotatePoint2(uvw, angle);
; 246  : 
; 247  : 	// Offset to 0..1
; 248  : 	if (t.autoScale) {

	cmp	DWORD PTR [rbx+56], 0
	je	SHORT $LN23@uvMapping

; 249  : 		uvw.x += .5f;

	vaddss	xmm0, xmm8, xmm12

; 250  : 		uvw.y += .5f;

	vaddss	xmm1, xmm7, xmm12
	vmovss	DWORD PTR uvw$[rsp], xmm0
	vmovss	DWORD PTR uvw$[rsp+4], xmm1
$LN23@uvMapping:

; 251  : 	}
; 252  : 
; 253  : 	// Return
; 254  : 	tp.uvw = uvw;

	vmovsd	xmm0, QWORD PTR uvw$[rsp]
	mov	eax, DWORD PTR uvw$[rsp+8]

; 255  : }

	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+16]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm9, XMMWORD PTR [r11-64]
	vmovaps	xmm10, XMMWORD PTR [r11-80]
	vmovaps	xmm11, XMMWORD PTR [r11-96]
	vmovaps	xmm12, XMMWORD PTR [r11-112]
	vmovaps	xmm13, XMMWORD PTR [r11-128]
	vmovaps	xmm14, XMMWORD PTR [rsp+48]
	vmovsd	QWORD PTR [rsi+12], xmm0
	mov	DWORD PTR [rsi+20], eax
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z ENDP ; Tile::uvMapping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?rotateUV@Tile@@CAXHMAEAVPoint3@@@Z
_TEXT	SEGMENT
rotUV$ = 8
var$ = 16
d$ = 24
?rotateUV@Tile@@CAXHMAEAVPoint3@@@Z PROC		; Tile::rotateUV, COMDAT

; 111  : 
; 112  : }

	ret	0
?rotateUV@Tile@@CAXHMAEAVPoint3@@@Z ENDP		; Tile::rotateUV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z
_TEXT	SEGMENT
d$ = 96
angle$ = 104
?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z PROC		; Tile::rotatePoint2, COMDAT

; 114  : void Tile::rotatePoint2(Point3& d, float angle) {

$LN12:
	push	rbx
	sub	rsp, 80					; 00000050H
	vmovaps	XMMWORD PTR [rsp+64], xmm6
	mov	rbx, rcx
	vmovaps	XMMWORD PTR [rsp+48], xmm7
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 88   : 	return (_CSTD cosf(_Xx));

	vmovaps	xmm0, xmm1
	vmovaps	XMMWORD PTR [rsp+32], xmm8
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 114  : void Tile::rotatePoint2(Point3& d, float angle) {

	vmovaps	xmm6, xmm1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 88   : 	return (_CSTD cosf(_Xx));

	call	cosf
	vmovaps	xmm8, xmm0

; 295  : 	return (_CSTD sinf(_Xx));

	vmovaps	xmm0, xmm6
	call	sinf
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 116  : 	float rotY = (sin(angle)*d.x + cos(angle)*d.y);

	vmulss	xmm1, xmm8, DWORD PTR [rbx+4]
	vmulss	xmm2, xmm0, DWORD PTR [rbx]
	vmulss	xmm3, xmm8, DWORD PTR [rbx]
	vmulss	xmm0, xmm0, DWORD PTR [rbx+4]

; 117  : 	d.x = rotX;
; 118  : 	d.y = rotY;
; 119  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+64]
	vmovaps	xmm7, XMMWORD PTR [rsp+48]
	vmovaps	xmm8, XMMWORD PTR [rsp+32]
	vaddss	xmm4, xmm2, xmm1
	vsubss	xmm1, xmm3, xmm0
	vmovss	DWORD PTR [rbx], xmm1
	vmovss	DWORD PTR [rbx+4], xmm4
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z ENDP		; Tile::rotatePoint2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
$T4 = 48
__$ReturnUdt$ = 192
rX$ = 200
rY$ = 208
w$ = 216
h$ = 224
t$ = 232
?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z PROC ; Tile::corner, COMDAT

; 49   : TilePoint Tile::corner(float rX, float rY, float w, float h, TileParam& t) {	

$LN90:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rdi
	push	rbp
	lea	rbp, QWORD PTR [rax-79]
	sub	rsp, 176				; 000000b0H

; 50   : 	// Evaluate	maps
; 51   : 	if (t.tileRound) {

	mov	rdi, QWORD PTR t$[rbp-105]
	mov	rbx, rcx
	vmovaps	XMMWORD PTR [rax-24], xmm6
	vmovaps	XMMWORD PTR [rax-40], xmm7
	vmovaps	XMMWORD PTR [rax-56], xmm8
	cmp	DWORD PTR [rdi+40], 0
	vmovaps	XMMWORD PTR [rax-72], xmm9
	vmovss	xmm9, DWORD PTR h$[rbp-105]
	vmovaps	XMMWORD PTR [rax-88], xmm10
	vmovaps	XMMWORD PTR [rax-104], xmm11
	vxorps	xmm11, xmm11, xmm11
	vmovaps	xmm10, xmm3
	vmovaps	xmm7, xmm2
	vmovaps	xmm8, xmm1
	je	$LN14@corner

; 52   : 		bool inCorner = false;
; 53   : 		float cX=0.0f, cY=0.0f;
; 54   : 		// Detect corner
; 55   : 		if (rX < t.tileCrnrRad) { 

	vmovss	xmm6, DWORD PTR [rdi+52]
	xor	al, al
	vcomiss	xmm6, xmm8
	vmovaps	xmm2, xmm11
	vmovaps	xmm1, xmm11
	jbe	SHORT $LN3@corner

; 56   : 			if (rY < t.tileCrnrRad) { // Bottom left

	vcomiss	xmm6, xmm7
	jbe	SHORT $LN5@corner

; 57   : 				cX = t.tileCrnrRad - rX;

	vsubss	xmm2, xmm6, xmm8

; 58   : 				cY = t.tileCrnrRad - rY; 				

	vsubss	xmm1, xmm6, xmm7

; 59   : 				inCorner = true;

	jmp	SHORT $LN83@corner
$LN5@corner:

; 60   : 			} else if (rY > h - t.tileCrnrRad) { // Top left

	vsubss	xmm0, xmm9, xmm6
	vcomiss	xmm7, xmm0
	jbe	SHORT $LN11@corner

; 61   : 				cX = t.tileCrnrRad - rX;
; 62   : 				cY = h - rY - t.tileCrnrRad; 				

	vsubss	xmm0, xmm9, xmm7
	vsubss	xmm1, xmm0, xmm6
	vsubss	xmm2, xmm6, xmm8

; 63   : 				inCorner = true;
; 64   : 			}

	jmp	SHORT $LN83@corner
$LN3@corner:

; 65   : 		} else if (rX > w - t.tileCrnrRad) {

	vsubss	xmm0, xmm10, xmm6
	vcomiss	xmm8, xmm0
	jbe	SHORT $LN11@corner

; 66   : 			if (rY < t.tileCrnrRad) { // Bottom right

	vcomiss	xmm6, xmm7
	jbe	SHORT $LN9@corner

; 67   : 				cX = w - rX - t.tileCrnrRad;
; 68   : 				cY = t.tileCrnrRad - rY; 				

	vsubss	xmm1, xmm6, xmm7

; 69   : 				inCorner = true;

	jmp	SHORT $LN84@corner
$LN9@corner:

; 70   : 			} else if (rY > h - t.tileCrnrRad) { // Top right

	vsubss	xmm0, xmm9, xmm6
	vcomiss	xmm7, xmm0
	jbe	SHORT $LN11@corner

; 72   : 				cY = h - rY - t.tileCrnrRad;

	vsubss	xmm1, xmm9, xmm7
	vsubss	xmm1, xmm1, xmm6
$LN84@corner:

; 71   : 				cX = w - rX - t.tileCrnrRad;

	vsubss	xmm0, xmm10, xmm8
	vsubss	xmm2, xmm0, xmm6
$LN83@corner:

; 73   : 				inCorner = true;

	mov	al, 1
$LN11@corner:

; 74   : 			}
; 75   : 		}
; 76   : 		float d = cY*cY + cX*cX;

	vmulss	xmm1, xmm1, xmm1
	vmulss	xmm0, xmm2, xmm2
	vaddss	xmm3, xmm1, xmm0

; 77   : 		if (inCorner) {

	test	al, al
	je	$LN14@corner

; 78   : 			if (d > t.tileCrnrRad*t.tileCrnrRad)

	vmulss	xmm0, xmm6, xmm6
	vcomiss	xmm3, xmm0
	jbe	SHORT $LN13@corner
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File g:\dropbox\github\berconmaps\src\tile.h

; 164  : 	TilePoint() {d = -1.f;}	

	mov	DWORD PTR [rcx+24], -1082130432		; bf800000H
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 79   : 				return TilePoint();

	jmp	$LN85@corner
$LN13@corner:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 305  : 	return (_CSTD sqrtf(_Xx));

	vmovaps	xmm0, xmm3
	call	sqrtf
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 82   : 			if (t.tileBlur > 0 && d <t. tileBlurRad)

	mov	ecx, DWORD PTR [rdi+44]
	vsubss	xmm3, xmm6, xmm0
	test	ecx, ecx
	jle	SHORT $LN14@corner
	vmovss	xmm0, DWORD PTR [rdi+48]
	vcomiss	xmm0, xmm3
	jbe	SHORT $LN14@corner

; 39   : 	switch (type) {		

	sub	ecx, 1
	je	SHORT $LN37@corner
	sub	ecx, 1
	je	SHORT $LN38@corner
	cmp	ecx, 1
	je	SHORT $LN39@corner

; 45   : 		default: return 1.f;

	vmovss	xmm3, DWORD PTR __real@3f800000
	jmp	SHORT $LN34@corner
$LN39@corner:

; 44   : 		case 3: return smooth(d, 0.f, r); // Smooth					

	vmovaps	xmm2, xmm0
	vmovaps	xmm0, xmm3
	vmovaps	xmm1, xmm11
	call	?smooth@@YAMMMM@Z			; smooth
	vmovaps	xmm3, xmm0
	jmp	SHORT $LN34@corner
$LN38@corner:

; 41   : 		case 2: // Cubic
; 42   : 			d = 1.f - (d/r);

	vmovss	xmm2, DWORD PTR __real@3f800000
	vdivss	xmm0, xmm3, xmm0
	vsubss	xmm0, xmm2, xmm0

; 43   : 			return sqrt(1-d*d);

	vmulss	xmm1, xmm0, xmm0
	vsubss	xmm0, xmm2, xmm1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 305  : 	return (_CSTD sqrtf(_Xx));

	call	sqrtf
	vmovaps	xmm3, xmm0
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 43   : 			return sqrt(1-d*d);

	jmp	SHORT $LN34@corner
$LN37@corner:

; 40   : 		case 1: return d/r; // Linear

	vdivss	xmm3, xmm3, xmm0
$LN34@corner:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	xor	eax, eax
	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rax
	mov	QWORD PTR [rbx+16], rax
; File g:\dropbox\github\berconmaps\src\tile.h

; 167  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	vmovss	DWORD PTR [rbx+24], xmm3
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 83   : 				return TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(d, t.tileBlurRad, t.tileBlur));

	jmp	$LN86@corner
$LN14@corner:

; 84   : 		}
; 85   : 	} 
; 86   : 	if (t.tileBlur) {		

	mov	r8d, DWORD PTR [rdi+44]
	test	r8d, r8d
	je	$LN22@corner

; 87   : 		bool inCorner = false;
; 88   : 		float dX = rX;
; 89   : 		float dY = rY;
; 90   : 		// Distance to vertical walls
; 91   : 		if (rX < t.tileBlurRad) {

	vmovss	xmm4, DWORD PTR [rdi+48]
	xor	al, al
	vcomiss	xmm4, xmm8
	vmovaps	xmm5, xmm8
	vmovaps	xmm3, xmm7
	ja	SHORT $LN87@corner

; 92   : 			inCorner = true;
; 93   : 		} else if (rX > w - t.tileBlurRad) {

	vsubss	xmm0, xmm10, xmm4
	vcomiss	xmm8, xmm0
	jbe	SHORT $LN18@corner

; 94   : 			dX = w - rX;

	vsubss	xmm5, xmm10, xmm8
$LN87@corner:

; 95   : 			inCorner = true;

	mov	al, 1
$LN18@corner:

; 96   : 		}
; 97   : 		// Distance to horizontal walls
; 98   : 		if (rY < t.tileBlurRad) {

	vcomiss	xmm4, xmm7
	ja	SHORT $LN82@corner

; 99   : 			inCorner = true;
; 100  : 		} else if (rY > h - t.tileBlurRad) {

	vsubss	xmm0, xmm9, xmm4
	vcomiss	xmm7, xmm0
	jbe	SHORT $LN21@corner

; 101  : 			dY = h - rY;

	vsubss	xmm3, xmm9, xmm7

; 102  : 			inCorner = true;
; 103  : 		}
; 104  : 		if (inCorner)

	jmp	SHORT $LN82@corner
$LN21@corner:
	test	al, al
	je	$LN22@corner
$LN82@corner:

; 105  : 			return dX<dY?TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dX, t.tileBlurRad, t.tileBlur)):TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dY, t.tileBlurRad, t.tileBlur));

	vcomiss	xmm3, xmm5
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T2[rbp-97], xmm11
; File g:\dropbox\github\berconmaps\src\tile.h

; 167  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	mov	eax, DWORD PTR $T2[rbp-97]
	mov	DWORD PTR $T4[rbp-85], eax
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	vmovss	DWORD PTR $T4[rbp-105], xmm11
	vmovss	DWORD PTR $T4[rbp-101], xmm11
	vmovss	DWORD PTR $T4[rbp-97], xmm11
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 105  : 			return dX<dY?TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dX, t.tileBlurRad, t.tileBlur)):TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dY, t.tileBlurRad, t.tileBlur));

	jbe	SHORT $LN24@corner
	vdivss	xmm3, xmm8, xmm10
	vdivss	xmm2, xmm7, xmm9
; File g:\dropbox\github\berconmaps\src\tile.h

; 167  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	vunpcklps xmm2, xmm3, xmm2
	vmovsd	QWORD PTR $T4[rbp-93], xmm2
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 105  : 			return dX<dY?TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dX, t.tileBlurRad, t.tileBlur)):TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dY, t.tileBlurRad, t.tileBlur));

	vmovaps	xmm0, xmm5
	jmp	SHORT $LN88@corner
$LN24@corner:
	vdivss	xmm2, xmm8, xmm10
	vdivss	xmm1, xmm7, xmm9
; File g:\dropbox\github\berconmaps\src\tile.h

; 167  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	vunpcklps xmm1, xmm2, xmm1
	vmovsd	QWORD PTR $T3[rbp-93], xmm1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 105  : 			return dX<dY?TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dX, t.tileBlurRad, t.tileBlur)):TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dY, t.tileBlurRad, t.tileBlur));

	vmovaps	xmm0, xmm3
$LN88@corner:
	vmovaps	xmm1, xmm4
	call	?edgeBlur@Tile@@CAMMMH@Z		; Tile::edgeBlur
	lea	rcx, QWORD PTR $T3[rbp-105]
	vmovss	DWORD PTR $T3[rbp-81], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rbx+12], eax
	mov	eax, DWORD PTR [rcx+16]
	mov	DWORD PTR [rbx+16], eax
	mov	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR [rbx+20], eax
	mov	eax, DWORD PTR [rcx+24]
	mov	DWORD PTR [rbx+24], eax
	mov	eax, DWORD PTR [rcx+28]
	mov	DWORD PTR [rbx+28], eax
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 105  : 			return dX<dY?TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dX, t.tileBlurRad, t.tileBlur)):TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dY, t.tileBlurRad, t.tileBlur));

	jmp	SHORT $LN85@corner
$LN22@corner:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	xor	eax, eax
	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rax
	mov	QWORD PTR [rbx+16], rax
; File g:\dropbox\github\berconmaps\src\tile.h

; 167  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	mov	DWORD PTR [rbx+24], 1065353216		; 3f800000H
$LN86@corner:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 107  : 	return TilePoint(Point3(rX/w, rY/h, 0.f), 1.f);

	vdivss	xmm0, xmm7, xmm9
	vdivss	xmm1, xmm8, xmm10
; File g:\dropbox\github\berconmaps\src\tile.h

; 167  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	vunpcklps xmm0, xmm1, xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T1[rbp-97], xmm11
; File g:\dropbox\github\berconmaps\src\tile.h

; 167  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	mov	eax, DWORD PTR $T1[rbp-97]
	vmovsd	QWORD PTR [rbx+12], xmm0
	mov	DWORD PTR [rbx+20], eax
$LN85@corner:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 108  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rax, rbx
	mov	rbx, QWORD PTR [r11+16]
	mov	rdi, QWORD PTR [r11+24]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm9, XMMWORD PTR [r11-64]
	vmovaps	xmm10, XMMWORD PTR [r11-80]
	vmovaps	xmm11, XMMWORD PTR [r11-96]
	mov	rsp, r11
	pop	rbp
	ret	0
?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z ENDP ; Tile::corner
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?edgeBlur@Tile@@CAMMMH@Z
_TEXT	SEGMENT
d$ = 8
r$ = 16
type$ = 24
?edgeBlur@Tile@@CAMMMH@Z PROC				; Tile::edgeBlur, COMDAT

; 39   : 	switch (type) {		

	sub	r8d, 1
	je	SHORT $LN4@edgeBlur
	sub	r8d, 1
	je	SHORT $LN5@edgeBlur
	cmp	r8d, 1
	je	SHORT $LN6@edgeBlur

; 45   : 		default: return 1.f;

	vmovss	xmm0, DWORD PTR __real@3f800000

; 46   : 	}	
; 47   : }

	ret	0
$LN6@edgeBlur:

; 44   : 		case 3: return smooth(d, 0.f, r); // Smooth					

	vmovaps	xmm2, xmm1
	vxorps	xmm1, xmm1, xmm1
	jmp	?smooth@@YAMMMM@Z			; smooth
$LN5@edgeBlur:

; 41   : 		case 2: // Cubic
; 42   : 			d = 1.f - (d/r);

	vmovss	xmm2, DWORD PTR __real@3f800000
	vdivss	xmm0, xmm0, xmm1
	vsubss	xmm0, xmm2, xmm0

; 43   : 			return sqrt(1-d*d);

	vmulss	xmm1, xmm0, xmm0
	vsubss	xmm0, xmm2, xmm1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath

; 305  : 	return (_CSTD sqrtf(_Xx));

	jmp	sqrtf
$LN4@edgeBlur:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 40   : 		case 1: return d/r; // Linear

	vdivss	xmm0, xmm0, xmm1

; 46   : 	}	
; 47   : }

	ret	0
?edgeBlur@Tile@@CAMMMH@Z ENDP				; Tile::edgeBlur
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
;	COMDAT ??0TilePoint@@QEAA@$$QEAV0@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0TilePoint@@QEAA@$$QEAV0@@Z PROC			; TilePoint::TilePoint, COMDAT

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rcx+12], eax
	mov	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [rcx+16], eax
	mov	eax, DWORD PTR [rdx+20]
	mov	DWORD PTR [rcx+20], eax
	mov	eax, DWORD PTR [rdx+24]
	mov	DWORD PTR [rcx+24], eax
	mov	eax, DWORD PTR [rdx+28]
	mov	DWORD PTR [rcx+28], eax
	mov	rax, rcx
	ret	0
??0TilePoint@@QEAA@$$QEAV0@@Z ENDP			; TilePoint::TilePoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
;	COMDAT ??0TilePoint@@QEAA@VPoint3@@M@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
??0TilePoint@@QEAA@VPoint3@@M@Z PROC			; TilePoint::TilePoint, COMDAT
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File g:\dropbox\github\berconmaps\src\tile.h

; 167  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	vmovsd	xmm0, QWORD PTR [rdx]
	vmovsd	QWORD PTR [rcx+12], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+20], eax
	mov	rax, rcx
	vmovss	DWORD PTR [rcx+24], xmm2
	ret	0
??0TilePoint@@QEAA@VPoint3@@M@Z ENDP			; TilePoint::TilePoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
;	COMDAT ??0TilePoint@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0TilePoint@@QEAA@XZ PROC				; TilePoint::TilePoint, COMDAT
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File g:\dropbox\github\berconmaps\src\tile.h

; 164  : 	TilePoint() {d = -1.f;}	

	mov	rax, rcx
	mov	DWORD PTR [rcx+24], -1082130432		; bf800000H
	ret	0
??0TilePoint@@QEAA@XZ ENDP				; TilePoint::TilePoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?setPreset@TilePattern@@QEAAXH@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?setPreset@TilePattern@@QEAAXH@Z PROC			; TilePattern::setPreset, COMDAT

; 492  : void TilePattern::setPreset(int preset) {

$LN928:

; 493  : 	switch (preset) {

	cmp	edx, 9
	ja	$LN926@setPreset
	push	rbp
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H
	mov	QWORD PTR $T1[rbp-80], -2
	mov	QWORD PTR [rsp+96], rbx

; 492  : void TilePattern::setPreset(int preset) {

	mov	rbx, rcx

; 493  : 	switch (preset) {

	movsxd	rax, edx
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	edx, DWORD PTR $LN925@setPreset[rcx+rax*4]
	add	rdx, rcx
	jmp	rdx
$LN4@setPreset:

; 494  : 		case 0: setPattern(L"0, 1, 1"); break; // Stack

	lea	rax, QWORD PTR $T11[rbp-80]
	mov	QWORD PTR $T21[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T11[rbp-56], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax
	mov	QWORD PTR $T11[rbp-64], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T11[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+7]
	lea	rdx, OFFSET FLAT:??_C@_1BA@HLCPMHKJ@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?$AA@
	lea	rcx, QWORD PTR $T11[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 494  : 		case 0: setPattern(L"0, 1, 1"); break; // Stack

	jmp	$LN927@setPreset
$LN5@setPreset:

; 495  : 		case 1: setPattern(L"0, 1, 1 / 0.5, 1, 1"); break; // Stretcher

	lea	rax, QWORD PTR $T10[rbp-80]
	mov	QWORD PTR $T20[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T10[rbp-56], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax
	mov	QWORD PTR $T10[rbp-64], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T10[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+19]
	lea	rdx, OFFSET FLAT:??_C@_1CI@MGOLCOH@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA0?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?$AA@
	lea	rcx, QWORD PTR $T10[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 495  : 		case 1: setPattern(L"0, 1, 1 / 0.5, 1, 1"); break; // Stretcher

	jmp	$LN927@setPreset
$LN6@setPreset:

; 496  : 		case 2: setPattern(L".25, 1, 1, .5 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1"); break; // Flemish Strecher

	lea	rax, QWORD PTR $T9[rbp-80]
	mov	QWORD PTR $T19[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T9[rbp-56], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax
	mov	QWORD PTR $T9[rbp-64], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T9[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+61]
	lea	rdx, OFFSET FLAT:??_C@_1HM@KFKBNDNL@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0@
	lea	rcx, QWORD PTR $T9[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 496  : 		case 2: setPattern(L".25, 1, 1, .5 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1"); break; // Flemish Strecher

	jmp	$LN927@setPreset
$LN7@setPreset:

; 497  : 		case 3: setPattern(L".25, 1, .5 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1"); break; // Common

	lea	rax, QWORD PTR $T8[rbp-80]
	mov	QWORD PTR $T18[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-56], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax
	mov	QWORD PTR $T8[rbp-64], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T8[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+58]
	lea	rdx, OFFSET FLAT:??_C@_1HG@LGFFBGEF@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA5?$AA?0?$AA?5?$AA1?$AA?0@
	lea	rcx, QWORD PTR $T8[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 497  : 		case 3: setPattern(L".25, 1, .5 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1"); break; // Common

	jmp	$LN927@setPreset
$LN8@setPreset:

; 498  : 		case 4: setPattern(L"0, 1, 1, .5 / .75, 1, 1, .5"); break; // Flemish

	lea	rax, QWORD PTR $T7[rbp-80]
	mov	QWORD PTR $T17[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T7[rbp-56], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax
	mov	QWORD PTR $T7[rbp-64], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T7[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+27]
	lea	rdx, OFFSET FLAT:??_C@_1DI@OGPGLDJP@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?4?$AA7?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?$AA@
	lea	rcx, QWORD PTR $T7[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 498  : 		case 4: setPattern(L"0, 1, 1, .5 / .75, 1, 1, .5"); break; // Flemish

	jmp	$LN927@setPreset
$LN9@setPreset:

; 499  : 		case 5: setPattern(L"0, 1, 1, 1, .5 / 1.25, 1, 1, 1, .5"); break; // Monk Bond

	lea	rax, QWORD PTR $T6[rbp-80]
	mov	QWORD PTR $T16[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T6[rbp-56], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax
	mov	QWORD PTR $T6[rbp-64], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T6[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+34]
	lea	rdx, OFFSET FLAT:??_C@_1EG@NKHPAEJM@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA1?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5@
	lea	rcx, QWORD PTR $T6[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 499  : 		case 5: setPattern(L"0, 1, 1, 1, .5 / 1.25, 1, 1, 1, .5"); break; // Monk Bond

	jmp	$LN927@setPreset
$LN10@setPreset:

; 500  : 		case 6: setPattern(L"0, 1, 1, 1, 1, .5 / 1.75, 1, 1, 1, 1, .5"); break; // Flemish Garden Wall

	lea	rax, QWORD PTR $T5[rbp-80]
	mov	QWORD PTR $T15[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-56], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax
	mov	QWORD PTR $T5[rbp-64], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T5[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+40]
	lea	rdx, OFFSET FLAT:??_C@_1FC@MFPKJHBG@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA1?$AA?4?$AA7?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5@
	lea	rcx, QWORD PTR $T5[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 500  : 		case 6: setPattern(L"0, 1, 1, 1, 1, .5 / 1.75, 1, 1, 1, 1, .5"); break; // Flemish Garden Wall

	jmp	$LN927@setPreset
$LN11@setPreset:

; 501  : 		case 7: setPattern(L".25, 1, .5 / 0, 1, 1"); break; // English

	lea	rax, QWORD PTR $T4[rbp-80]
	mov	QWORD PTR $T14[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-56], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax
	mov	QWORD PTR $T4[rbp-64], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T4[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+20]
	lea	rdx, OFFSET FLAT:??_C@_1CK@FBIPLABB@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?$AA@
	lea	rcx, QWORD PTR $T4[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 501  : 		case 7: setPattern(L".25, 1, .5 / 0, 1, 1"); break; // English

	jmp	SHORT $LN927@setPreset
$LN12@setPreset:

; 502  : 		case 8: setPattern(L"0,1,1 / -.25,1,.5 / -.25,1,1 / -.25,1,.5"); break; // English Cross

	lea	rax, QWORD PTR $T3[rbp-80]
	mov	QWORD PTR $T13[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rbp-56], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax
	mov	QWORD PTR $T3[rbp-64], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T3[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+40]
	lea	rdx, OFFSET FLAT:??_C@_1FC@LEIJMHNO@?$AA0?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5?$AA?9@
	lea	rcx, QWORD PTR $T3[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 502  : 		case 8: setPattern(L"0,1,1 / -.25,1,.5 / -.25,1,1 / -.25,1,.5"); break; // English Cross

	jmp	SHORT $LN927@setPreset
$LN13@setPreset:

; 503  : 		case 9: setPattern(L"0,1,.5 / -.25,1,.5 / -.25,1,1 / -.25,1,1"); break; // Double English Cross

	lea	rax, QWORD PTR $T2[rbp-80]
	mov	QWORD PTR $T12[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T2[rbp-56], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax
	mov	QWORD PTR $T2[rbp-64], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T2[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+40]
	lea	rdx, OFFSET FLAT:??_C@_1FC@DKDGEDND@?$AA0?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5@
	lea	rcx, QWORD PTR $T2[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
$LN927@setPreset:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 503  : 		case 9: setPattern(L"0,1,.5 / -.25,1,.5 / -.25,1,1 / -.25,1,1"); break; // Double English Cross

	lea	rdx, QWORD PTR $T2[rbp-80]
	mov	rcx, rbx
	call	?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; TilePattern::setPattern
$LN2@setPreset:

; 504  : 	}
; 505  : }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rbp
$LN926@setPreset:
	ret	0
	npad	1
$LN925@setPreset:
	DD	$LN4@setPreset
	DD	$LN5@setPreset
	DD	$LN6@setPreset
	DD	$LN7@setPreset
	DD	$LN8@setPreset
	DD	$LN9@setPreset
	DD	$LN10@setPreset
	DD	$LN11@setPreset
	DD	$LN12@setPreset
	DD	$LN13@setPreset
?setPreset@TilePattern@@QEAAXH@Z ENDP			; TilePattern::setPreset
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$0@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$0
	mov	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$0
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$1@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$1
	mov	rcx, QWORD PTR $T20[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$1
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$2@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$2
	mov	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$2@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$2
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$3@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$3
	mov	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$3@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$3
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$4@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$4
	mov	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$4@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$4
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$5@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$5
	mov	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$5@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$5
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$6@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$6
	mov	rcx, QWORD PTR $T15[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$6@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$6
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$7@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$7
	mov	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$7@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$7
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$8@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$8
	mov	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$8@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$8
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$9@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$9
	mov	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$9@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$0@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$0
	mov	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$1@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$1
	mov	rcx, QWORD PTR $T20[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$2@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$2
	mov	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$2@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$3@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$3
	mov	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$3@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$4@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$4
	mov	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$4@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$5@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$5
	mov	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$5@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$6@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$6
	mov	rcx, QWORD PTR $T15[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$6@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$7@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$7
	mov	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$7@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$8@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$8
	mov	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$8@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$9@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$9
	mov	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$9@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
;	COMDAT ?update@TilePattern@@QEAAXXZ
_TEXT	SEGMENT
this$ = 16
?update@TilePattern@@QEAAXXZ PROC			; TilePattern::update, COMDAT

; 81   : 	void update() {

$LN72:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi

; 82   : 		totalHeight = 0.f;

	xor	esi, esi
	mov	r11, rcx
	mov	DWORD PTR [rcx], esi

; 83   : 		for (int i=0; i<rows.size(); i++) {

	mov	edi, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rax, QWORD PTR [rcx+40]
	sub	rax, QWORD PTR [rcx+32]
	sar	rax, 5
; File g:\dropbox\github\berconmaps\src\tile.h

; 83   : 		for (int i=0; i<rows.size(); i++) {

	test	rax, rax
	je	$LN3@update
	mov	QWORD PTR [rsp+16], rbx
	mov	edx, esi
	mov	ebx, esi
	npad	3
$LL4@update:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	r8, QWORD PTR [r11+32]
; File g:\dropbox\github\berconmaps\src\tile.h

; 65   : 		for (int i=0; i<tiles.size(); i++)

	mov	r10d, esi
	mov	DWORD PTR [rdx+r8+4], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rax, QWORD PTR [rdx+r8+16]
	sub	rax, QWORD PTR [rdx+r8+8]
	sar	rax, 2
; File g:\dropbox\github\berconmaps\src\tile.h

; 65   : 		for (int i=0; i<tiles.size(); i++)

	test	rax, rax
	je	SHORT $LN30@update

; 66   : 			totalWidth += tiles[i];

	mov	r9, QWORD PTR [rdx+r8+8]
	vxorps	xmm0, xmm0, xmm0
	npad	8
$LL31@update:
	vaddss	xmm0, xmm0, DWORD PTR [r9]
	vmovss	DWORD PTR [rdx+r8+4], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rcx, QWORD PTR [rdx+r8+16]
; File g:\dropbox\github\berconmaps\src\tile.h

; 65   : 		for (int i=0; i<tiles.size(); i++)

	lea	r9, QWORD PTR [r9+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	rcx, QWORD PTR [rdx+r8+8]
; File g:\dropbox\github\berconmaps\src\tile.h

; 65   : 		for (int i=0; i<tiles.size(); i++)

	inc	r10d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	rcx, 2
; File g:\dropbox\github\berconmaps\src\tile.h

; 65   : 		for (int i=0; i<tiles.size(); i++)

	movsxd	rax, r10d
	cmp	rax, rcx
	jb	SHORT $LL31@update
$LN30@update:

; 84   : 			rows[i].update();
; 85   : 			totalHeight += heights[i];

	mov	rax, QWORD PTR [r11+8]
	inc	edi
	add	rdx, 32					; 00000020H
	vmovss	xmm0, DWORD PTR [rbx+rax]
	vaddss	xmm1, xmm0, DWORD PTR [r11]
	vmovss	DWORD PTR [r11], xmm1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rcx, QWORD PTR [r11+40]
; File g:\dropbox\github\berconmaps\src\tile.h

; 83   : 		for (int i=0; i<rows.size(); i++) {

	add	rbx, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	rcx, QWORD PTR [r11+32]
	sar	rcx, 5
; File g:\dropbox\github\berconmaps\src\tile.h

; 83   : 		for (int i=0; i<rows.size(); i++) {

	movsxd	rax, edi
	cmp	rax, rcx
	jb	$LL4@update
	mov	rbx, QWORD PTR [rsp+16]
$LN3@update:

; 86   : 		}
; 87   : 	}

	mov	rsi, QWORD PTR [rsp+24]
	pop	rdi
	ret	0
?update@TilePattern@@QEAAXXZ ENDP			; TilePattern::update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
this$ = 96
s$ = 104
$T2 = 112
?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; TilePattern::setPattern, COMDAT

; 560  : void TilePattern::setPattern(std::wstring s) {

$LN181:
	mov	r11, rsp
	mov	QWORD PTR [r11+16], rdx
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	QWORD PTR [r11-56], -2
	mov	QWORD PTR [r11+8], rbx
	mov	QWORD PTR [r11+32], rsi
	mov	rdi, rdx
	mov	rbx, rcx

; 561  : 	parsePattern(s, this);

	lea	rax, QWORD PTR [r11-48]
	mov	QWORD PTR [r11+24], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [r11-24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	esi, esi
	mov	QWORD PTR [r11-32], rsi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR $T1[rsp], si
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
	lea	rcx, QWORD PTR [r11-48]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 561  : 	parsePattern(s, this);

	mov	rdx, rbx
	lea	rcx, QWORD PTR $T1[rsp]
	call	?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z ; parsePattern

; 562  : 	update();

	mov	rcx, rbx
	call	?update@TilePattern@@QEAAXXZ		; TilePattern::update
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	r8, QWORD PTR [rdi+24]
	cmp	r8, 8
	jb	SHORT $LN108@setPattern

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rdi
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN108@setPattern:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+16], rsi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rdi+24], 8
	jb	SHORT $LN175@setPattern
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rax], si
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN176@setPattern
$LN175@setPattern:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rdi], si
$LN176@setPattern:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 563  : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; TilePattern::setPattern
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
this$ = 96
s$ = 104
$T2 = 112
?dtor$0@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA PROC ; `TilePattern::setPattern'::`1'::dtor$0
	mov	rcx, QWORD PTR s$[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA ENDP ; `TilePattern::setPattern'::`1'::dtor$0
$T1 = 40
this$ = 96
s$ = 104
$T2 = 112
?dtor$1@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA PROC ; `TilePattern::setPattern'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA ENDP ; `TilePattern::setPattern'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
this$ = 96
s$ = 104
$T2 = 112
?dtor$0@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA PROC ; `TilePattern::setPattern'::`1'::dtor$0
	mov	rcx, QWORD PTR s$[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA ENDP ; `TilePattern::setPattern'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
this$ = 96
s$ = 104
$T2 = 112
?dtor$1@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA PROC ; `TilePattern::setPattern'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA ENDP ; `TilePattern::setPattern'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBAXPEAVTileRow@@0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBAXPEAVTileRow@@0@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Orphan_range, COMDAT

; 1794 : 		}

	ret	0
?_Orphan_range@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBAXPEAVTileRow@@0@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Xlen@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBAXXZ PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Xlen, COMDAT

; 1764 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBAXXZ ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?_Reserve@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Reserve, COMDAT

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

$LN95:
	sub	rsp, 40					; 00000028H

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	r10, QWORD PTR [rcx+16]

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	mov	r9, rcx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, r10
	sub	rax, r8
	sar	rax, 5

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	rax, rdx
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rcx, QWORD PTR [rcx]

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	r11, 576460752303423487			; 07ffffffffffffffH

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	r8, rcx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	rax, r11

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	r8, 5

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	sub	rax, r8
	cmp	rax, rdx
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Reserve:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r10, rcx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	add	rdx, r8

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	r10, 5
	xor	ecx, ecx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r10
	shr	rax, 1
	sub	r11, rax
	add	rax, r10
	cmp	r11, r10
	cmovae	rcx, rax
	cmp	rcx, rdx
	cmovae	rdx, rcx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	rcx, r9

; 1632 : 			}
; 1633 : 		}

	add	rsp, 40					; 00000028H

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z ; std::vector<TileRow,std::allocator<TileRow> >::_Reallocate
$LN2@Reserve:

; 1632 : 			}
; 1633 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN94@Reserve:
?_Reserve@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 112
this$ = 112
_Count$ = 120
$T3 = 128
_Ptr$ = 136
?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Reallocate, COMDAT

; 1601 : 		{	// move to array of exactly _Count elements

$LN138:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 72					; 00000048H
	mov	QWORD PTR $T1[rsp], -2
	mov	rsi, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z ; std::allocator<TileRow>::allocate
	mov	r14, rax
	mov	QWORD PTR _Ptr$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 810  : 	return {};

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	movzx	r8d, BYTE PTR $T3[rsp]
	mov	BYTE PTR [rsp+40], r8b
	mov	BYTE PTR [rsp+32], al
	mov	r9, rbx
	mov	r8, r14
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninitialized_move_al_unchecked1@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@00AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<TileRow * __ptr64,TileRow * __ptr64,std::allocator<TileRow> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx]
	mov	rdi, rdx
	sub	rdi, rcx

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	rcx, rcx
	je	SHORT $LN3@Reallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T2[rsp]
	mov	r8, rbx
	call	??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	rdx, QWORD PTR [rbx]
	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	sar	r8, 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@_K@Z ; std::allocator<TileRow>::deallocate
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	shl	rsi, 5
	add	rsi, r14
	mov	QWORD PTR [rbx+16], rsi

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	and	rdi, -32				; ffffffffffffffe0H
	add	rdi, r14
	mov	QWORD PTR [rbx+8], rdi

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	QWORD PTR [rbx], r14

; 1623 : 		}

	add	rsp, 72					; 00000048H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN137@Reallocate:
?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Reallocate
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 112
this$ = 112
_Count$ = 120
$T3 = 128
_Ptr$ = 136
?catch$0@?0??_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Reallocate'::`1'::catch$0

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?deallocate@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@_K@Z ; std::allocator<TileRow>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Reallocate'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 112
this$ = 112
_Count$ = 120
$T3 = 128
_Ptr$ = 136
?catch$0@?0??_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Reallocate'::`1'::catch$0

; 1606 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?deallocate@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@_K@Z ; std::allocator<TileRow>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1608 : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Reallocate@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Reallocate'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBA_NPEBVTileRow@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBA_NPEBVTileRow@@@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Inside, COMDAT

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	rdx, QWORD PTR [rcx+8]
	jae	SHORT $LN3@Inside
	cmp	QWORD PTR [rcx], rdx
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1598 : 		}

	ret	0
$LN3@Inside:

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	xor	al, al

; 1598 : 		}

	ret	0
?_Inside@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBA_NPEBVTileRow@@@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBA_K_K@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Grow_to, COMDAT

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	r9, QWORD PTR [rcx+16]

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	r8, 576460752303423487			; 07ffffffffffffffH

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r9, QWORD PTR [rcx]
	sar	r9, 5

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r9
	shr	rax, 1
	sub	r8, rax
	lea	rcx, QWORD PTR [rax+r9]
	xor	eax, eax
	cmp	r8, r9
	cmovae	rax, rcx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	rax, rdx
	cmovb	rax, rdx

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	ret	0
?_Grow_to@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEBA_K_K@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAXPEAVTileRow@@0@Z
_TEXT	SEGMENT
$T1 = 8
this$ = 8
_First$ = 16
_Last$ = 24
?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAXPEAVTileRow@@0@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Destroy, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1580 : 		{	// destroy [_First, _Last) using allocator

	mov	rax, r8
	mov	r10, rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	r8, rcx
	mov	rdx, rax
	mov	rcx, r10
	jmp	??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>
?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAXPEAVTileRow@@0@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
this$ = 64
?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ PROC ; std::vector<TileRow,std::allocator<TileRow> >::clear, COMDAT

; 1539 : 		{	// erase all

$LN35:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	r9d, BYTE PTR $T2[rsp]
	mov	r8, rcx
	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx]
	call	??$_Destroy_range1@V?$allocator@VTileRow@@@std@@PEAVTileRow@@@std@@YAXPEAVTileRow@@0AEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<TileRow>,TileRow * __ptr64>
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rbx+8], rax

; 1543 : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ ENDP ; std::vector<TileRow,std::allocator<TileRow> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
$T3 = 64
this$ = 64
$T4 = 72
$T5 = 72
_Val$ = 72
?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::push_back, COMDAT

; 1276 : 		{	// insert element at end

$LN175:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+80], rbx
	mov	rdi, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	rdx, rax
	jae	SHORT $LN2@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	rcx, rdx
	ja	SHORT $LN2@push_back

; 1277 : 		if (_Inside(_STD addressof(_Val)))
; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	sub	rdi, rcx

; 1280 : 			if (this->_Mylast() == this->_Myend())

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

	mov	edx, 1
	mov	rcx, rbx
	call	?_Reserve@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z ; std::vector<TileRow,std::allocator<TileRow> >::_Reserve
$LN4@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR $T3[rsp], rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

	and	rdi, -32				; ffffffffffffffe0H
	add	rdi, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T5[rsp], rcx
	test	rcx, rcx
	je	SHORT $LN93@push_back
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdi+4]
	mov	DWORD PTR [rcx+4], eax
	lea	rdx, QWORD PTR [rdi+8]
	add	rcx, 8
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
$LN93@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1287 : 		else

	jmp	SHORT $LN174@push_back
$LN2@push_back:

; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

	mov	edx, 1
	mov	rcx, rbx
	call	?_Reserve@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@IEAAX_K@Z ; std::vector<TileRow,std::allocator<TileRow> >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR $T2[rsp], rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T4[rsp], rcx
	test	rcx, rcx
	je	SHORT $LN157@push_back
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdi+4]
	mov	DWORD PTR [rcx+4], eax
	lea	rdx, QWORD PTR [rdi+8]
	add	rcx, 8
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
$LN157@push_back:
$LN174@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	QWORD PTR [rbx+8], 32			; 00000020H

; 1295 : 			}
; 1296 : 		}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::push_back
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
$T3 = 64
this$ = 64
$T4 = 72
$T5 = 72
_Val$ = 72
?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR $T3[rbp]
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$0
$T1 = 32
$T2 = 64
$T3 = 64
this$ = 64
$T4 = 72
$T5 = 72
_Val$ = 72
?dtor$1@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$1
	mov	rcx, QWORD PTR $T5[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$1
$T1 = 32
$T2 = 64
$T3 = 64
this$ = 64
$T4 = 72
$T5 = 72
_Val$ = 72
?dtor$2@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR $T2[rbp]
	mov	rcx, QWORD PTR $T4[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$2
$T1 = 32
$T2 = 64
$T3 = 64
this$ = 64
$T4 = 72
$T5 = 72
_Val$ = 72
?dtor$3@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$3
	mov	rcx, QWORD PTR $T4[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$3@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
$T3 = 64
this$ = 64
$T4 = 72
$T5 = 72
_Val$ = 72
?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR $T3[rbp]
	mov	rcx, QWORD PTR $T5[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
$T3 = 64
this$ = 64
$T4 = 72
$T5 = 72
_Val$ = 72
?dtor$1@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$1
	mov	rcx, QWORD PTR $T5[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
$T3 = 64
this$ = 64
$T4 = 72
$T5 = 72
_Val$ = 72
?dtor$2@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdx, QWORD PTR $T2[rbp]
	mov	rcx, QWORD PTR $T4[rbp]
	call	??3@YAXPEAX0@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
$T3 = 64
this$ = 64
$T4 = 72
$T5 = 72
_Val$ = 72
?dtor$3@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$3
	mov	rcx, QWORD PTR $T4[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$3@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAAEAVTileRow@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAAEAVTileRow@@_K@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::operator[], COMDAT

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	shl	rdx, 5
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1243 : 		}

	ret	0
??A?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAAEAVTileRow@@_K@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ PROC ; std::vector<TileRow,std::allocator<TileRow> >::max_size, COMDAT

; 1185 : 		return (this->_Getal().max_size());

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<TileRow,std::allocator<TileRow> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ PROC ; std::vector<TileRow,std::allocator<TileRow> >::size, COMDAT

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 1181 : 		}

	ret	0
?size@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<TileRow,std::allocator<TileRow> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Unused_capacity, COMDAT

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	sar	rax, 5

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ PROC ; std::vector<TileRow,std::allocator<TileRow> >::capacity, COMDAT

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 1044 : 		}

	ret	0
?capacity@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<TileRow,std::allocator<TileRow> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<TileRow> >,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_second, COMDAT

; 320  : 		return (_Myval2);

	mov	rax, rcx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<TileRow> >,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<TileRow> >,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_second, COMDAT

; 315  : 		return (_Myval2);

	mov	rax, rcx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<TileRow> >,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<TileRow> >,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_first, COMDAT

; 300  : 		return (*this);

	mov	rax, rcx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<TileRow> >,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<TileRow> >,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_first, COMDAT

; 295  : 		return (*this);

	mov	rax, rcx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<TileRow> >,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myend, COMDAT

; 668  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myend, COMDAT

; 663  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Mylast, COMDAT

; 658  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Mylast, COMDAT

; 653  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myfirst, COMDAT

; 648  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myfirst, COMDAT

; 643  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Get_data, COMDAT

; 638  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Get_data, COMDAT

; 633  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Getal, COMDAT

; 628  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Getal, COMDAT

; 623  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Orphan_all, COMDAT

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEBA_KU_Nil@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?max_size@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEBA_KU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<TileRow> >::max_size, COMDAT

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1009 : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEBA_KU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<TileRow> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
_Count$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<TileRow> >::deallocate, COMDAT

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	jmp	?deallocate@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@_K@Z ; std::allocator<TileRow>::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAXPEAVTileRow@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<TileRow> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?allocate@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<TileRow> >::allocate, COMDAT

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z ; std::allocator<TileRow>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<TileRow> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SA_KAEBV?$allocator@VTileRow@@@2@@Z
_TEXT	SEGMENT
_Al$ = 8
?max_size@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SA_KAEBV?$allocator@VTileRow@@@2@@Z PROC ; std::allocator_traits<std::allocator<TileRow> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SA_KAEBV?$allocator@VTileRow@@@2@@Z ENDP ; std::allocator_traits<std::allocator<TileRow> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@VTileRow@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$allocator@VTileRow@@@std@@QEBA_KXZ PROC	; std::allocator<TileRow>::max_size, COMDAT

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@VTileRow@@@std@@QEBA_KXZ ENDP	; std::allocator<TileRow>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z PROC ; std::allocator<TileRow>::allocate, COMDAT

; 724  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 51   : 	if (_Count == 0)

	test	rdx, rdx
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	eax, eax
$LN3@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	rdx, rax
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	rdx, 5

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	rcx, QWORD PTR [rdx+39]

; 66   : 		if (_Block_size <= _User_size)

	cmp	rcx, rdx
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	rax, rax
	jne	SHORT $LN9@allocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	mov	rcx, rdx
	call	??2@YAPEAX_K@Z				; operator new

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	rax, rax
	jne	SHORT $LN3@allocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN14@allocate:
?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z ENDP ; std::allocator<TileRow>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@_K@Z PROC ; std::allocator<TileRow>::deallocate, COMDAT

; 719  : 		{	// deallocate object at _Ptr

$LN14:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN4@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	r8, 5

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN7@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN13@deallocate:
?deallocate@?$allocator@VTileRow@@@std@@QEAAXPEAVTileRow@@_K@Z ENDP ; std::allocator<TileRow>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??_GTileRow@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_GTileRow@@QEAAPEAXI@Z PROC				; TileRow::`scalar deleting destructor', COMDAT
$LN73:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rsi
	mov	esi, edx
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rdx, QWORD PTR [rcx+8]
	test	rdx, rdx
	je	SHORT $LN10@scalar

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	r8, QWORD PTR [rcx+24]
	sub	r8, rdx
	sar	r8, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	add	rcx, 8
	call	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx+8], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+16], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+24], rax
$LN10@scalar:
	test	sil, 1
	je	SHORT $LN72@scalar
	mov	edx, 32					; 00000020H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN72@scalar:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??_GTileRow@@QEAAPEAXI@Z ENDP				; TileRow::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
?dtor$0@?0???_GTileRow@@QEAAPEAXI@Z@4HA PROC		; `TileRow::`scalar deleting destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???_GTileRow@@QEAAPEAXI@Z@4HA ENDP		; `TileRow::`scalar deleting destructor''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
?dtor$0@?0???_GTileRow@@QEAAPEAXI@Z@4HA PROC		; `TileRow::`scalar deleting destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???_GTileRow@@QEAAPEAXI@Z@4HA ENDP		; `TileRow::`scalar deleting destructor''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0TileRow@@QEAA@$$QEAV0@@Z
_TEXT	SEGMENT
$T1 = 0
this$ = 32
__that$ = 40
??0TileRow@@QEAA@$$QEAV0@@Z PROC			; TileRow::TileRow, COMDAT
$LN80:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	QWORD PTR $T1[rsp], -2
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax

; 485  : 		: _Myfirst(),

	xor	r8d, r8d
	mov	QWORD PTR [rcx+8], r8

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+16], r8

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+24], r8

; 870  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 871  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 872  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [rdx+24]
	mov	QWORD PTR [rcx+24], rax

; 873  : 
; 874  : 		_Right._Myfirst() = pointer();

	mov	QWORD PTR [rdx+8], r8

; 875  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [rdx+16], r8

; 876  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [rdx+24], r8
	mov	rax, rcx
	add	rsp, 24
	ret	0
??0TileRow@@QEAA@$$QEAV0@@Z ENDP			; TileRow::TileRow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
__that$ = 40
?dtor$0@?0???0TileRow@@QEAA@$$QEAV0@@Z@4HA PROC		; `TileRow::TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0TileRow@@QEAA@$$QEAV0@@Z@4HA ENDP		; `TileRow::TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
__that$ = 40
?dtor$0@?0???0TileRow@@QEAA@$$QEAV0@@Z@4HA PROC		; `TileRow::TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0TileRow@@QEAA@$$QEAV0@@Z@4HA ENDP		; `TileRow::TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0TileRow@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__that$ = 72
??0TileRow@@QEAA@AEBV0@@Z PROC				; TileRow::TileRow, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	add	rdx, 8
	add	rcx, 8
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0TileRow@@QEAA@AEBV0@@Z ENDP				; TileRow::TileRow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__that$ = 72
?dtor$0@?0???0TileRow@@QEAA@AEBV0@@Z@4HA PROC		; `TileRow::TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0TileRow@@QEAA@AEBV0@@Z@4HA ENDP		; `TileRow::TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__that$ = 72
?dtor$0@?0???0TileRow@@QEAA@AEBV0@@Z@4HA PROC		; `TileRow::TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0TileRow@@QEAA@AEBV0@@Z@4HA ENDP		; `TileRow::TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1TileRow@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1TileRow@@QEAA@XZ PROC				; TileRow::~TileRow, COMDAT
$LN69:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	lea	rbx, QWORD PTR [rcx+8]

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rdx, QWORD PTR [rbx]
	test	rdx, rdx
	je	SHORT $LN7@TileRow

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	sar	r8, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN7@TileRow:
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??1TileRow@@QEAA@XZ ENDP				; TileRow::~TileRow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1TileRow@@QEAA@XZ@4HA PROC			; `TileRow::~TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???1TileRow@@QEAA@XZ@4HA ENDP			; `TileRow::~TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1TileRow@@QEAA@XZ@4HA PROC			; `TileRow::~TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???1TileRow@@QEAA@XZ@4HA ENDP			; `TileRow::~TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
;	COMDAT ?update@TileRow@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?update@TileRow@@QEAAXXZ PROC				; TileRow::update, COMDAT

; 64   : 		totalWidth = 0.f;

	xor	r8d, r8d
	mov	rdx, rcx
	mov	DWORD PTR [rcx+4], r8d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	sar	rax, 2
; File g:\dropbox\github\berconmaps\src\tile.h

; 65   : 		for (int i=0; i<tiles.size(); i++)

	test	rax, rax
	je	SHORT $LN3@update
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	r9, QWORD PTR [rcx+8]
	vxorps	xmm0, xmm0, xmm0
	npad	13
$LL4@update:
; File g:\dropbox\github\berconmaps\src\tile.h

; 66   : 			totalWidth += tiles[i];

	vaddss	xmm0, xmm0, DWORD PTR [r9]
	vmovss	DWORD PTR [rdx+4], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rcx, QWORD PTR [rdx+16]
; File g:\dropbox\github\berconmaps\src\tile.h

; 65   : 		for (int i=0; i<tiles.size(); i++)

	lea	r9, QWORD PTR [r9+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	rcx, QWORD PTR [rdx+8]
; File g:\dropbox\github\berconmaps\src\tile.h

; 65   : 		for (int i=0; i<tiles.size(); i++)

	inc	r8d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	rcx, 2
; File g:\dropbox\github\berconmaps\src\tile.h

; 65   : 		for (int i=0; i<tiles.size(); i++)

	movsxd	rax, r8d
	cmp	rax, rcx
	jb	SHORT $LL4@update
$LN3@update:

; 67   : 	}

	ret	0
?update@TileRow@@QEAAXXZ ENDP				; TileRow::update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IEBAXPEAM0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IEBAXPEAM0@Z PROC ; std::vector<float,std::allocator<float> >::_Orphan_range, COMDAT

; 1794 : 		}

	ret	0
?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@IEBAXPEAM0@Z ENDP ; std::vector<float,std::allocator<float> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IEBAXXZ PROC	; std::vector<float,std::allocator<float> >::_Xlen, COMDAT

; 1764 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@IEBAXXZ ENDP	; std::vector<float,std::allocator<float> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IEAAXXZ PROC	; std::vector<float,std::allocator<float> >::_Tidy, COMDAT

; 1636 : 		{	// free all storage

$LN65:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN2@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	r8, QWORD PTR [rcx+16]
	sub	r8, rdx
	sar	r8, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	call	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 1646 : 			}
; 1647 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IEAAXXZ ENDP	; std::vector<float,std::allocator<float> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z PROC ; std::vector<float,std::allocator<float> >::_Reserve, COMDAT

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

$LN95:
	sub	rsp, 40					; 00000028H

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	r10, QWORD PTR [rcx+16]

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	mov	r9, rcx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	r8, QWORD PTR [rcx+8]
	mov	rax, r10
	sub	rax, r8
	sar	rax, 2

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	rax, rdx
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rcx, QWORD PTR [rcx]

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	r11, 4611686018427387903		; 3fffffffffffffffH

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	r8, rcx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	rax, r11

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	r8, 2

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	sub	rax, r8
	cmp	rax, rdx
	jae	SHORT $LN3@Reserve

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Reserve:

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r10, rcx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	add	rdx, r8

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	r10, 2
	xor	ecx, ecx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r10
	shr	rax, 1
	sub	r11, rax
	add	rax, r10
	cmp	r11, r10
	cmovae	rcx, rax
	cmp	rcx, rdx
	cmovae	rdx, rcx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	rcx, r9

; 1632 : 			}
; 1633 : 		}

	add	rsp, 40					; 00000028H

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Reallocate
$LN2@Reserve:

; 1632 : 			}
; 1633 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN94@Reserve:
?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z ENDP ; std::vector<float,std::allocator<float> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 80
_Count$ = 88
_Ptr$ = 96
?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z PROC ; std::vector<float,std::allocator<float> >::_Reallocate, COMDAT

; 1601 : 		{	// move to array of exactly _Count elements

$LN132:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+104], rbx
	mov	r14, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate
	mov	rsi, rax
	mov	QWORD PTR _Ptr$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);

	mov	r8, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	r8, rdx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rax
	call	QWORD PTR __imp_memmove
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rdx, QWORD PTR [rbx]
	mov	rdi, QWORD PTR [rbx+8]
	sub	rdi, rdx
	sar	rdi, 2

; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	rdx, rdx
	je	SHORT $LN3@Reallocate

; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	sar	r8, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	lea	rax, QWORD PTR [rsi+r14*4]
	mov	QWORD PTR [rbx+16], rax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	lea	rax, QWORD PTR [rsi+rdi*4]
	mov	QWORD PTR [rbx+8], rax

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	QWORD PTR [rbx], rsi

; 1623 : 		}

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN131@Reallocate:
?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z ENDP ; std::vector<float,std::allocator<float> >::_Reallocate
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 80
_Count$ = 88
_Ptr$ = 96
?catch$0@?0??_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z@4HA PROC ; `std::vector<float,std::allocator<float> >::_Reallocate'::`1'::catch$0

; 1606 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z@4HA ENDP ; `std::vector<float,std::allocator<float> >::_Reallocate'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 80
_Count$ = 88
_Ptr$ = 96
?catch$0@?0??_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z@4HA PROC ; `std::vector<float,std::allocator<float> >::_Reallocate'::`1'::catch$0

; 1606 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rbp]
	mov	rdx, QWORD PTR _Ptr$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1608 : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Reallocate@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z@4HA ENDP ; `std::vector<float,std::allocator<float> >::_Reallocate'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@MV?$allocator@M@std@@@std@@IEBA_NPEBM@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@MV?$allocator@M@std@@@std@@IEBA_NPEBM@Z PROC ; std::vector<float,std::allocator<float> >::_Inside, COMDAT

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	rdx, QWORD PTR [rcx+8]
	jae	SHORT $LN3@Inside
	cmp	QWORD PTR [rcx], rdx
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1598 : 		}

	ret	0
$LN3@Inside:

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	xor	al, al

; 1598 : 		}

	ret	0
?_Inside@?$vector@MV?$allocator@M@std@@@std@@IEBA_NPEBM@Z ENDP ; std::vector<float,std::allocator<float> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@MV?$allocator@M@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@MV?$allocator@M@std@@@std@@IEBA_K_K@Z PROC ; std::vector<float,std::allocator<float> >::_Grow_to, COMDAT

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	r9, QWORD PTR [rcx+16]

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	r8, 4611686018427387903			; 3fffffffffffffffH

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	r9, QWORD PTR [rcx]
	sar	r9, 2

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	rax, r9
	shr	rax, 1
	sub	r8, rax
	lea	rcx, QWORD PTR [rax+r9]
	xor	eax, eax
	cmp	r8, r9
	cmovae	rax, rcx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	rax, rdx
	cmovb	rax, rdx

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	ret	0
?_Grow_to@?$vector@MV?$allocator@M@std@@@std@@IEBA_K_K@Z ENDP ; std::vector<float,std::allocator<float> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IEAAXPEAM0@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IEAAXPEAM0@Z PROC ; std::vector<float,std::allocator<float> >::_Destroy, COMDAT

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	0
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IEAAXPEAM0@Z ENDP ; std::vector<float,std::allocator<float> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@MV?$allocator@M@std@@@std@@IEAA_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Capacity$ = 56
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IEAA_N_K@Z PROC ; std::vector<float,std::allocator<float> >::_Buy, COMDAT

; 1561 : 		{	// allocate array with _Capacity elements

$LN78:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1562 : 		this->_Myfirst() = pointer();

	xor	eax, eax
	mov	rdi, rdx
	mov	QWORD PTR [rcx], rax
	mov	rbx, rcx

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax

; 1565 : 
; 1566 : 		if (_Capacity == 0)

	test	rdx, rdx
	je	SHORT $LN1@Buy

; 1567 : 			return (false);
; 1568 : 		else if (max_size() < _Capacity)

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	jbe	SHORT $LN4@Buy

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN4@Buy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rbx], rax

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	lea	rax, QWORD PTR [rax+rdi*4]
	mov	QWORD PTR [rbx+16], rax

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1
$LN1@Buy:

; 1577 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN77@Buy:
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IEAA_N_K@Z ENDP ; std::vector<float,std::allocator<float> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@MV?$allocator@M@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@MV?$allocator@M@std@@@std@@QEAAXXZ PROC	; std::vector<float,std::allocator<float> >::clear, COMDAT

; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1543 : 		}

	ret	0
?clear@?$vector@MV?$allocator@M@std@@@std@@QEAAXXZ ENDP	; std::vector<float,std::allocator<float> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAXAEBM@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAXAEBM@Z PROC ; std::vector<float,std::allocator<float> >::push_back, COMDAT

; 1276 : 		{	// insert element at end

$LN167:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	rax, QWORD PTR [rcx+8]

; 1276 : 		{	// insert element at end

	mov	rdi, rdx
	mov	rbx, rcx

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	rdx, rax
	jae	SHORT $LN2@push_back
	mov	rcx, QWORD PTR [rcx]
	cmp	rcx, rdx
	ja	SHORT $LN2@push_back

; 1277 : 		if (_Inside(_STD addressof(_Val)))
; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	sub	rdi, rcx
	sar	rdi, 2

; 1280 : 			if (this->_Mylast() == this->_Myend())

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

	mov	edx, 1
	mov	rcx, rbx
	call	?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Reserve
$LN4@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR [rbx+8]
	test	rdx, rdx
	je	SHORT $LN153@push_back
	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	QWORD PTR [rbx+8], 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR [rax+rdi*4]
	mov	DWORD PTR [rdx], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1296 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@push_back:

; 1282 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),
; 1284 : 				this->_Myfirst()[_Idx]);
; 1285 : 			++this->_Mylast();
; 1286 : 			}
; 1287 : 		else
; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

	mov	edx, 1
	mov	rcx, rbx
	call	?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN153@push_back
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rcx], eax
$LN153@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	QWORD PTR [rbx+8], 4

; 1296 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAXAEBM@Z ENDP ; std::vector<float,std::allocator<float> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z PROC ; std::vector<float,std::allocator<float> >::operator[], COMDAT

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*4]

; 1243 : 		}

	ret	0
??A?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z ENDP ; std::vector<float,std::allocator<float> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ PROC ; std::vector<float,std::allocator<float> >::max_size, COMDAT

; 1185 : 		return (this->_Getal().max_size());

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ ENDP ; std::vector<float,std::allocator<float> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ PROC	; std::vector<float,std::allocator<float> >::size, COMDAT

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1181 : 		}

	ret	0
?size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ ENDP	; std::vector<float,std::allocator<float> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@MV?$allocator@M@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@MV?$allocator@M@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::end, COMDAT

; 46   : 		: _Ptr(_Parg)

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1073 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));

	mov	rax, rdx

; 1074 : 		}

	ret	0
?end@?$vector@MV?$allocator@M@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@MV?$allocator@M@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@MV?$allocator@M@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::begin, COMDAT

; 46   : 		: _Ptr(_Parg)

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1063 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));

	mov	rax, rdx

; 1064 : 		}

	ret	0
?begin@?$vector@MV?$allocator@M@std@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@M@std@@@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ PROC ; std::vector<float,std::allocator<float> >::_Unused_capacity, COMDAT

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	sar	rax, 2

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ ENDP ; std::vector<float,std::allocator<float> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ PROC ; std::vector<float,std::allocator<float> >::capacity, COMDAT

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1044 : 		}

	ret	0
?capacity@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ ENDP ; std::vector<float,std::allocator<float> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ PROC	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >, COMDAT

; 975  : 		{	// destroy the object

$LN66:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	je	SHORT $LN4@vector

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	r8, QWORD PTR [rcx+16]
	sub	r8, rdx
	sar	r8, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	call	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
	npad	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 976  : 		_Tidy();
; 977  : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ENDP	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAM@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAM@Z PROC ; std::vector<float,std::allocator<float> >::push_back, COMDAT

; 896  : 		{	// insert by moving into element at end

$LN171:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	rax, QWORD PTR [rcx+8]

; 896  : 		{	// insert by moving into element at end

	mov	rdi, rdx
	mov	rbx, rcx

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	rdx, rax
	jae	SHORT $LN2@push_back
	mov	rcx, QWORD PTR [rcx]
	cmp	rcx, rdx
	ja	SHORT $LN2@push_back

; 897  : 		if (_Inside(_STD addressof(_Val)))
; 898  : 			{	// push back an element
; 899  : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	sub	rdi, rcx
	sar	rdi, 2

; 900  : 			if (this->_Mylast() == this->_Myend())

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN4@push_back

; 901  : 				_Reserve(1);

	mov	edx, 1
	mov	rcx, rbx
	call	?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Reserve
$LN4@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR [rbx+8]
	test	rdx, rdx
	je	SHORT $LN157@push_back
	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 914  : 			++this->_Mylast();

	add	QWORD PTR [rbx+8], 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR [rax+rdi*4]
	mov	DWORD PTR [rdx], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 916  : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@push_back:

; 902  : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 903  : 			this->_Getal().construct(_Unfancy(this->_Mylast()),
; 904  : 				_STD forward<value_type>(this->_Myfirst()[_Idx]));
; 905  : 			++this->_Mylast();
; 906  : 			}
; 907  : 		else
; 908  : 			{	// push back a non-element
; 909  : 			if (this->_Mylast() == this->_Myend())

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN5@push_back

; 910  : 				_Reserve(1);

	mov	edx, 1
	mov	rcx, rbx
	call	?_Reserve@?$vector@MV?$allocator@M@std@@@std@@IEAAX_K@Z ; std::vector<float,std::allocator<float> >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN157@push_back
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rcx], eax
$LN157@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 914  : 			++this->_Mylast();

	add	QWORD PTR [rbx+8], 4

; 916  : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAM@Z ENDP ; std::vector<float,std::allocator<float> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Assign_rv@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$ = 24
?_Assign_rv@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<float,std::allocator<float> >::_Assign_rv, COMDAT

; 869  : 		this->_Swap_all((_Myt&)_Right);
; 870  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 871  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 872  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 873  : 
; 874  : 		_Right._Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rdx], rax

; 875  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [rdx+8], rax

; 876  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [rdx+16], rax

; 877  : 		}

	ret	0
?_Assign_rv@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<float,std::allocator<float> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT

; 485  : 		: _Myfirst(),

	xor	r8d, r8d
	mov	QWORD PTR [rcx], r8

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], r8

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], r8

; 870  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 871  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 872  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 842  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 843  : 		}

	mov	rax, rcx

; 874  : 		_Right._Myfirst() = pointer();

	mov	QWORD PTR [rdx], r8

; 875  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [rdx+8], r8

; 876  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [rdx+16], r8

; 842  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 843  : 		}

	ret	0
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT

; 748  : 		{	// construct by copying _Right

$LN256:
	mov	QWORD PTR [rsp+8], rcx
	push	r14
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	mov	r14, rdx
	mov	rsi, rcx

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	rbx, QWORD PTR [rdx+8]
	sub	rbx, QWORD PTR [rdx]
	sar	rbx, 2

; 1562 : 		this->_Myfirst() = pointer();

	mov	QWORD PTR [rcx], rax

; 1563 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1564 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax

; 1565 : 
; 1566 : 		if (_Capacity == 0)

	test	rbx, rbx
	je	SHORT $LN7@vector

; 1567 : 			return (false);
; 1568 : 		else if (max_size() < _Capacity)

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rbx, rax
	jbe	SHORT $LN46@vector

; 1765 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN46@vector:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	mov	rdx, rbx
	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	QWORD PTR [rsi], rax

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rsi+8], rax

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	lea	rax, QWORD PTR [rax+rbx*4]
	mov	QWORD PTR [rsi+16], rax

; 46   : 		: _Ptr(_Parg)

	mov	rdi, QWORD PTR [r14+8]
	mov	rdx, QWORD PTR [r14]

; 751  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),

	mov	rbx, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	rdi, rdx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rdi
	mov	rcx, rbx
	call	QWORD PTR __imp_memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rdi+rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 751  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),

	mov	QWORD PTR [rsi+8], rax
$LN7@vector:

; 752  : 				this->_Myfirst());
; 753  : 			_CATCH_ALL
; 754  : 			_Tidy();
; 755  : 			_RERAISE;
; 756  : 			_CATCH_END
; 757  : 		}

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
$LN255@vector:
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >'::`1'::catch$0

; 752  : 				this->_Myfirst());
; 753  : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z$0:

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rbx]
	test	rdx, rdx
	je	SHORT $LN192@catch$0

; 1575 : 			}
; 1576 : 		return (true);
; 1577 : 		}
; 1578 : 
; 1579 : 	void _Destroy(pointer _First, pointer _Last)
; 1580 : 		{	// destroy [_First, _Last) using allocator
; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}
; 1583 : 
; 1584 : 	size_type _Grow_to(size_type _Count) const
; 1585 : 		{	// grow by 50% or at least to _Count
; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)
; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}
; 1594 : 
; 1595 : 	bool _Inside(const value_type *_Ptr) const
; 1596 : 		{	// test if _Ptr points inside vector
; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);
; 1598 : 		}
; 1599 : 
; 1600 : 	void _Reallocate(size_type _Count)
; 1601 : 		{	// move to array of exactly _Count elements
; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())
; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1616 : 				this->_Myend() - this->_Myfirst());
; 1617 : 			}
; 1618 : 
; 1619 : 		this->_Orphan_all();
; 1620 : 		this->_Myend() = _Ptr + _Count;
; 1621 : 		this->_Mylast() = _Ptr + _Size;
; 1622 : 		this->_Myfirst() = _Ptr;
; 1623 : 		}
; 1624 : 
; 1625 : 	void _Reserve(size_type _Count)
; 1626 : 		{	// ensure room for _Count new elements, grow exponentially
; 1627 : 		if (_Unused_capacity() < _Count)
; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)
; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	void _Tidy()
; 1636 : 		{	// free all storage
; 1637 : 		if (this->_Myfirst() != pointer())
; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	sar	r8, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	QWORD PTR [rbx], 0

; 1575 : 			}
; 1576 : 		return (true);
; 1577 : 		}
; 1578 : 
; 1579 : 	void _Destroy(pointer _First, pointer _Last)
; 1580 : 		{	// destroy [_First, _Last) using allocator
; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}
; 1583 : 
; 1584 : 	size_type _Grow_to(size_type _Count) const
; 1585 : 		{	// grow by 50% or at least to _Count
; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)
; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}
; 1594 : 
; 1595 : 	bool _Inside(const value_type *_Ptr) const
; 1596 : 		{	// test if _Ptr points inside vector
; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);
; 1598 : 		}
; 1599 : 
; 1600 : 	void _Reallocate(size_type _Count)
; 1601 : 		{	// move to array of exactly _Count elements
; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())
; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1616 : 				this->_Myend() - this->_Myfirst());
; 1617 : 			}
; 1618 : 
; 1619 : 		this->_Orphan_all();
; 1620 : 		this->_Myend() = _Ptr + _Count;
; 1621 : 		this->_Mylast() = _Ptr + _Size;
; 1622 : 		this->_Myfirst() = _Ptr;
; 1623 : 		}
; 1624 : 
; 1625 : 	void _Reserve(size_type _Count)
; 1626 : 		{	// ensure room for _Count new elements, grow exponentially
; 1627 : 		if (_Unused_capacity() < _Count)
; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)
; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	void _Tidy()
; 1636 : 		{	// free all storage
; 1637 : 		if (this->_Myfirst() != pointer())
; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1642 : 				this->_Myend() - this->_Myfirst());
; 1643 : 			this->_Myfirst() = pointer();
; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], 0

; 1575 : 			}
; 1576 : 		return (true);
; 1577 : 		}
; 1578 : 
; 1579 : 	void _Destroy(pointer _First, pointer _Last)
; 1580 : 		{	// destroy [_First, _Last) using allocator
; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}
; 1583 : 
; 1584 : 	size_type _Grow_to(size_type _Count) const
; 1585 : 		{	// grow by 50% or at least to _Count
; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)
; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}
; 1594 : 
; 1595 : 	bool _Inside(const value_type *_Ptr) const
; 1596 : 		{	// test if _Ptr points inside vector
; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);
; 1598 : 		}
; 1599 : 
; 1600 : 	void _Reallocate(size_type _Count)
; 1601 : 		{	// move to array of exactly _Count elements
; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())
; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1616 : 				this->_Myend() - this->_Myfirst());
; 1617 : 			}
; 1618 : 
; 1619 : 		this->_Orphan_all();
; 1620 : 		this->_Myend() = _Ptr + _Count;
; 1621 : 		this->_Mylast() = _Ptr + _Size;
; 1622 : 		this->_Myfirst() = _Ptr;
; 1623 : 		}
; 1624 : 
; 1625 : 	void _Reserve(size_type _Count)
; 1626 : 		{	// ensure room for _Count new elements, grow exponentially
; 1627 : 		if (_Unused_capacity() < _Count)
; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)
; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	void _Tidy()
; 1636 : 		{	// free all storage
; 1637 : 		if (this->_Myfirst() != pointer())
; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1642 : 				this->_Myend() - this->_Myfirst());
; 1643 : 			this->_Myfirst() = pointer();
; 1644 : 			this->_Mylast() = pointer();
; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], 0
$LN192@catch$0:

; 752  : 				this->_Myfirst());
; 753  : 			_CATCH_ALL
; 754  : 			_Tidy();
; 755  : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >'::`1'::catch$0

; 753  : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z$0:

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	rbx, QWORD PTR this$[rbp]
	mov	rdx, QWORD PTR [rbx]
	test	rdx, rdx
	je	SHORT $LN192@catch$0

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	r8, QWORD PTR [rbx+16]
	sub	r8, rdx
	sar	r8, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	QWORD PTR [rbx], 0

; 1644 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], 0

; 1645 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], 0
$LN192@catch$0:

; 754  : 			_Tidy();
; 755  : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ PROC	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 708  : 		}

	mov	rax, rcx
	ret	0
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ENDP	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second, COMDAT

; 320  : 		return (_Myval2);

	mov	rax, rcx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second, COMDAT

; 315  : 		return (_Myval2);

	mov	rax, rcx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first, COMDAT

; 300  : 		return (*this);

	mov	rax, rcx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first, COMDAT

; 295  : 		return (*this);

	mov	rax, rcx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@M@std@@@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<float> >,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<float> >::_Vector_val<std::_Simple_types<float> >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 489  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<float> >::_Vector_val<std::_Simple_types<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend, COMDAT

; 668  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend, COMDAT

; 663  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast, COMDAT

; 658  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast, COMDAT

; 653  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst, COMDAT

; 648  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst, COMDAT

; 643  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data, COMDAT

; 638  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data, COMDAT

; 633  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal, COMDAT

; 628  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal, COMDAT

; 623  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@M@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAXAEAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Swap_all, COMDAT

; 618  : 		_Get_data()._Swap_all(_Right._Get_data());
; 619  : 		}

	ret	0
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Orphan_all, COMDAT

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >, COMDAT

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 521  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEBA_KU_Nil@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?max_size@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEBA_KU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<float> >::max_size, COMDAT

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 1009 : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEBA_KU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<float> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAXPEAM_K@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
_Count$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAXPEAM_K@Z PROC ; std::_Wrap_alloc<std::allocator<float> >::deallocate, COMDAT

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	jmp	?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ; std::allocator<float>::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAXPEAM_K@Z ENDP ; std::_Wrap_alloc<std::allocator<float> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAPEAM_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?allocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAPEAM_K@Z PROC ; std::_Wrap_alloc<std::allocator<float> >::allocate, COMDAT

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAAPEAM_K@Z ENDP ; std::_Wrap_alloc<std::allocator<float> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAA@$$QEAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<float> >::_Wrap_alloc<std::allocator<float> >, COMDAT

; 947  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAA@$$QEAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<float> >::_Wrap_alloc<std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAA@XZ PROC	; std::_Wrap_alloc<std::allocator<float> >::_Wrap_alloc<std::allocator<float> >, COMDAT

; 937  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEAA@XZ ENDP	; std::_Wrap_alloc<std::allocator<float> >::_Wrap_alloc<std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEBA?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
__formal$ = 24
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEBA?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<float> >::select_on_container_copy_construction, COMDAT

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	rax, rdx

; 914  : 		}

	ret	0
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@M@std@@@std@@QEBA?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<float> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@M@std@@@std@@SA?AV?$allocator@M@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@M@std@@@std@@SA?AV?$allocator@M@2@AEBV32@@Z PROC ; std::allocator_traits<std::allocator<float> >::select_on_container_copy_construction, COMDAT

; 875  : 		return (_Al);

	mov	rax, rcx

; 876  : 		}

	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@M@std@@@std@@SA?AV?$allocator@M@2@AEBV32@@Z ENDP ; std::allocator_traits<std::allocator<float> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@M@std@@@std@@SA_KAEBV?$allocator@M@2@@Z
_TEXT	SEGMENT
_Al$ = 8
?max_size@?$allocator_traits@V?$allocator@M@std@@@std@@SA_KAEBV?$allocator@M@2@@Z PROC ; std::allocator_traits<std::allocator<float> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@M@std@@@std@@SA_KAEBV?$allocator@M@2@@Z ENDP ; std::allocator_traits<std::allocator<float> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@M@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$allocator@M@std@@QEBA_KXZ PROC		; std::allocator<float>::max_size, COMDAT

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@M@std@@QEBA_KXZ ENDP		; std::allocator<float>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@M@std@@QEAAPEAM_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@M@std@@QEAAPEAM_K@Z PROC		; std::allocator<float>::allocate, COMDAT

; 724  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 51   : 	if (_Count == 0)

	test	rdx, rdx
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	eax, eax
$LN3@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	lea	rcx, QWORD PTR [rdx*4]

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	rax, QWORD PTR [rcx+39]

; 66   : 		if (_Block_size <= _User_size)

	cmp	rax, rcx
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	rax, rax
	jne	SHORT $LN9@allocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPEAX_K@Z				; operator new

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	rax, rax
	jne	SHORT $LN3@allocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN14@allocate:
?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ENDP		; std::allocator<float>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z PROC	; std::allocator<float>::deallocate, COMDAT

; 719  : 		{	// deallocate object at _Ptr

$LN14:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN4@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [r8*4]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN7@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN13@deallocate:
?deallocate@?$allocator@M@std@@QEAAXPEAM_K@Z ENDP	; std::allocator<float>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@M@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??0?$allocator@M@std@@QEAA@AEBV01@@Z PROC		; std::allocator<float>::allocator<float>, COMDAT

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@M@std@@QEAA@AEBV01@@Z ENDP		; std::allocator<float>::allocator<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@M@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@M@std@@QEAA@XZ PROC			; std::allocator<float>::allocator<float>, COMDAT

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@M@std@@QEAA@XZ ENDP			; std::allocator<float>::allocator<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
;	COMDAT ??0TileRow@@QEAA@M@Z
_TEXT	SEGMENT
$T1 = 0
this$ = 32
offset$ = 40
??0TileRow@@QEAA@M@Z PROC				; TileRow::TileRow, COMDAT

; 57   : 	TileRow(float offset) {this->offset = offset;}

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	QWORD PTR $T1[rsp], -2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx+8], rax

; 486  : 		_Mylast(),

	mov	QWORD PTR [rcx+16], rax

; 487  : 		_Myend()

	mov	QWORD PTR [rcx+24], rax
; File g:\dropbox\github\berconmaps\src\tile.h

; 57   : 	TileRow(float offset) {this->offset = offset;}

	vmovss	DWORD PTR [rcx], xmm1
	mov	rax, rcx
	add	rsp, 24
	ret	0
??0TileRow@@QEAA@M@Z ENDP				; TileRow::TileRow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
offset$ = 40
?dtor$0@?0???0TileRow@@QEAA@M@Z@4HA PROC		; `TileRow::TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0TileRow@@QEAA@M@Z@4HA ENDP		; `TileRow::TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
offset$ = 40
?dtor$0@?0???0TileRow@@QEAA@M@Z@4HA PROC		; `TileRow::TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0TileRow@@QEAA@M@Z@4HA ENDP		; `TileRow::TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor', COMDAT
$LN83:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+64], rbx
	mov	edi, edx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	r8, QWORD PTR [rcx+24]
	cmp	r8, 8
	jb	SHORT $LN9@scalar

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, QWORD PTR [rcx]
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
	npad	1
$LN9@scalar:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	ecx, ecx
	mov	QWORD PTR [rbx+16], rcx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN76@scalar
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN77@scalar
$LN76@scalar:
	mov	rax, rbx
$LN77@scalar:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rax], cx
	test	dil, 1
	je	SHORT $LN82@scalar
	mov	edx, 32					; 00000020H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN82@scalar:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran, COMDAT

; 2282 : 		{	// report an out_of_range error

$LN4:
	sub	rsp, 40					; 00000028H

; 2283 : 		_Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN3@Xran:
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAX_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset, COMDAT

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

$LN15:
	sub	rsp, 40					; 00000028H

; 2271 : 		if (this->_Mysize() < _Off)

	cmp	QWORD PTR [rcx+16], rdx
	jae	SHORT $LN2@Check_offs

; 2283 : 		_Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN2@Check_offs:

; 2272 : 			_Xran();
; 2273 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN14@Check_offs:
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAX_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen, COMDAT

; 2265 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 2266 : 		_Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Built$ = 56
_Newsize$ = 64
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT

; 2248 : 		{	// initialize buffer, deallocating any storage

$LN78:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rcx

; 2249 : 		if (!_Built)

	test	dl, dl
	je	SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

	mov	QWORD PTR [rsp+48], rsi
	mov	rsi, QWORD PTR [rcx]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

	test	r8, r8
	je	SHORT $LN42@Tidy
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	add	r8, r8
	mov	rdx, rsi
	call	memcpy
$LN42@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	mov	r8, QWORD PTR [rbx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, rsi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rcx, rbx
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
	mov	rsi, QWORD PTR [rsp+48]
$LN4@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rdi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN71@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rax+rdi*2], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2262 : 		}

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN71@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rbx+rdi*2], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2262 : 		}

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_NPEB_W@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_NPEB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	rdx, rdx
	je	SHORT $LN4@Inside

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	rax, QWORD PTR [rcx+24]
	cmp	rax, 8
	jb	SHORT $LN14@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	r8, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN15@Inside
$LN14@Inside:
	mov	r8, rcx
$LN15@Inside:

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	rdx, r8
	jb	SHORT $LN4@Inside

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	rax, 8
	jb	SHORT $LN26@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	r8, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN27@Inside
$LN26@Inside:
	mov	r8, rcx
$LN27@Inside:

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	rax, QWORD PTR [rcx+16]
	lea	rcx, QWORD PTR [r8+rax*2]
	cmp	rcx, rdx
	jbe	SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

	mov	al, 1

; 2244 : 		}

	ret	0
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

	xor	al, al

; 2244 : 		}

	ret	0
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_NPEB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_N_K_N@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Trim$ = 64
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_N_K_N@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow, COMDAT

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

$LN69:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2225 : 		if (max_size() < _Newsize)

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH
	mov	rbx, rdx
	cmp	rdx, rax
	jbe	SHORT $LN2@Grow

; 2266 : 		_Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN2@Grow:

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	QWORD PTR [rcx+24], rbx
	jae	SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	mov	r8, QWORD PTR [rcx+16]
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
	test	rbx, rbx
	setne	al

; 2235 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	test	r8b, r8b
	je	SHORT $LN5@Grow
	cmp	rbx, 8
	jae	SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

	mov	r8, QWORD PTR [rcx+16]
	mov	dl, 1
	cmp	rbx, r8
	cmovb	r8, rbx
	call	?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_N_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
	test	rbx, rbx
	setne	al

; 2235 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

	test	rbx, rbx
	jne	SHORT $LN67@Grow

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN60@Grow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN60@Grow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rcx], ax
	test	rbx, rbx
$LN67@Grow:
	setne	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2235 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN68@Grow:
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_N_K_N@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8

; 2217 : 		{	// set new length and null terminator

	mov	rax, rcx

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rdx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN9@Eos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rcx]
$LN9@Eos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [rax+rdx*2], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2220 : 		}

	ret	0
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z
_TEXT	SEGMENT
_Ptr$ = 32
$T1 = 40
this$ = 80
_Newres$ = 88
_Newsize$ = 88
_Oldlen$ = 96
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy, COMDAT

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

$LN326:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+104], rbx
	mov	rsi, r8
	mov	rbx, rcx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	rdi, rdx
	or	rdi, 7

; 2184 : 		if (max_size() < _Newres)

	mov	r9, 9223372036854775806			; 7ffffffffffffffeH
	cmp	rdi, r9
	jbe	SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	rdi, rdx

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

	jmp	SHORT $LN81@Copy
$LN2@Copy:
	mov	r8, QWORD PTR [rcx+24]
	mov	rcx, r8
	shr	rcx, 1
	mov	rax, -6148914691236517205		; aaaaaaaaaaaaaaabH
	mul	rdi
	shr	rdx, 1
	cmp	rcx, rdx
	jbe	SHORT $LN81@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

	mov	rax, r9
	sub	rax, rcx
	cmp	r8, rax

; 2189 : 			_Newres = this->_Myres()

	lea	rdi, QWORD PTR [rcx+r8]

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

	jbe	SHORT $LN81@Copy

; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	rdi, r9
$LN81@Copy:

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	rdx, QWORD PTR [rdi+1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	mov	rcx, rbx
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
	mov	r14, rax
	mov	QWORD PTR _Ptr$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
	jmp	SHORT $LN18@Copy
$LN19@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
	mov	rbx, QWORD PTR this$[rsp]
	mov	rsi, QWORD PTR _Oldlen$[rsp]
	mov	rdi, QWORD PTR _Newres$[rsp]
	mov	r14, QWORD PTR _Ptr$[rsp]
$LN18@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2207 : 		if (0 < _Oldlen)

	test	rsi, rsi
	je	SHORT $LN197@Copy

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN188@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rdx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN189@Copy
$LN188@Copy:
	mov	rdx, rbx
$LN189@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 310  : 		return (_Count == 0 ? _First1

	test	rsi, rsi
	je	SHORT $LN197@Copy
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	r8, QWORD PTR [rsi+rsi]
	mov	rcx, r14
	call	memcpy
$LN197@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	r8, QWORD PTR [rbx+24]
	cmp	r8, 8
	jb	SHORT $LN203@Copy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, QWORD PTR [rbx]
	mov	rcx, rbx
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN203@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	ecx, ecx
	mov	QWORD PTR [rbx+16], rcx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN270@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN271@Copy
$LN270@Copy:
	mov	rax, rbx
$LN271@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rax], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR [rbx], r14
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2212 : 		this->_Myres() = _Newres;

	mov	QWORD PTR [rbx+24], rdi

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rsi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN319@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rbx, r14
$LN319@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rbx+rsi*2], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2214 : 		}

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN324@Copy:
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ptr$ = 32
$T1 = 40
this$ = 80
_Newres$ = 88
_Newsize$ = 88
_Oldlen$ = 96
?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy'::`1'::catch$1

; 2197 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z$0:

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	rdx, QWORD PTR _Newsize$[rbp]
	mov	QWORD PTR _Newres$[rbp], rdx

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	inc	rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	mov	rcx, QWORD PTR this$[rbp]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
	mov	QWORD PTR _Ptr$[rbp], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

	lea	rax, $LN19@catch$1
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy'::`1'::catch$1
_Ptr$ = 32
$T1 = 40
this$ = 80
_Newres$ = 88
_Newsize$ = 88
_Oldlen$ = 96
?catch$0@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy'::`1'::catch$0

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z$1:

; 734  : 		return (_Get_data()._Myres);

	mov	rbx, QWORD PTR this$[rbp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	r8, QWORD PTR [rbx+24]
	cmp	r8, 8
	jb	SHORT $LN107@catch$0

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, QWORD PTR [rbx]
	mov	rcx, rbx
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN107@catch$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN175@catch$0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rbx, QWORD PTR [rbx]
$LN175@catch$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [rbx], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT text$x
text$x	SEGMENT
_Ptr$ = 32
$T1 = 40
this$ = 80
_Newres$ = 88
_Newsize$ = 88
_Oldlen$ = 96
?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy'::`1'::catch$1

; 2197 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z$0:

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	rdx, QWORD PTR _Newsize$[rbp]
	mov	QWORD PTR _Newres$[rbp], rdx

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	inc	rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	mov	rcx, QWORD PTR this$[rbp]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
	mov	QWORD PTR _Ptr$[rbp], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2205 : 		_CATCH_END

	lea	rax, $LN19@catch$1
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$1@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT text$x
text$x	SEGMENT
_Ptr$ = 32
$T1 = 40
this$ = 80
_Newres$ = 88
_Newsize$ = 88
_Oldlen$ = 96
?catch$0@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy'::`1'::catch$0

; 735  : 		}
; 736  : 
; 737  : 	const size_type& _Myres() const _NOEXCEPT
; 738  : 		{	// return const reference to _Myres
; 739  : 		return (_Get_data()._Myres);
; 740  : 		}
; 741  : 
; 742  : private:
; 743  : 	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
; 744  : 	};
; 745  : 
; 746  : 		// TEMPLATE CLASS basic_string
; 747  : template<class _Elem,
; 748  : 	class _Traits,
; 749  : 	class _Alloc>
; 750  : 	class basic_string
; 751  : 		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
; 752  : 	{	// null-terminated transparent array of elements
; 753  : public:
; 754  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 755  : 	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
; 756  : 	typedef _Traits traits_type;
; 757  : 	typedef _Alloc allocator_type;
; 758  : 
; 759  : 	typedef typename _Mybase::_Alty _Alty;
; 760  : 
; 761  : 	typedef typename _Mybase::value_type value_type;
; 762  : 	typedef typename _Mybase::size_type size_type;
; 763  : 	typedef typename _Mybase::difference_type difference_type;
; 764  : 	typedef typename _Mybase::pointer pointer;
; 765  : 	typedef typename _Mybase::const_pointer const_pointer;
; 766  : 	typedef typename _Mybase::reference reference;
; 767  : 	typedef typename _Mybase::const_reference const_reference;
; 768  : 
; 769  : 	typedef typename _Mybase::iterator iterator;
; 770  : 	typedef typename _Mybase::const_iterator const_iterator;
; 771  : 
; 772  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 773  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 774  : 
; 775  : 	basic_string(const _Myt& _Right)
; 776  : 
; 777  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 778  : 
; 779  : 
; 780  : 		{	// construct by copying _Right
; 781  : 		_Tidy();
; 782  : 		assign(_Right, 0, npos);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct by copying with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Right, 0, npos);
; 790  : 		}
; 791  : 
; 792  : 	basic_string() _NOEXCEPT_OP(is_nothrow_default_constructible<_Alloc>::value)
; 793  : 		: _Mybase()
; 794  : 		{	// construct empty string
; 795  : 		_Tidy();
; 796  : 		}
; 797  : 
; 798  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 799  : 		: _Mybase(_Al)
; 800  : 		{	// construct empty string with allocator
; 801  : 		_Tidy();
; 802  : 		}
; 803  : 
; 804  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 805  : 		size_type _Count = npos)
; 806  : 		: _Mybase(_Right._Getal())
; 807  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 808  : 		_Tidy();
; 809  : 		assign(_Right, _Roff, _Count);
; 810  : 		}
; 811  : 
; 812  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 813  : 		const _Alloc& _Al)
; 814  : 		: _Mybase(_Al)
; 815  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 816  : 		_Tidy();
; 817  : 		assign(_Right, _Roff, _Count);
; 818  : 		}
; 819  : 
; 820  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 823  : 		_Tidy();
; 824  : 		assign(_Ptr, _Count);
; 825  : 		}
; 826  : 
; 827  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 828  : 		: _Mybase(_Al)
; 829  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 830  : 		_Tidy();
; 831  : 		assign(_Ptr, _Count);
; 832  : 		}
; 833  : 
; 834  : 	basic_string(const _Elem *_Ptr)
; 835  : 		: _Mybase()
; 836  : 		{	// construct from [_Ptr, <null>)
; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);
; 839  : 		}
; 840  : 
; 841  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 842  : 		: _Mybase(_Al)
; 843  : 		{	// construct from [_Ptr, <null>) with allocator
; 844  : 		_Tidy();
; 845  : 		assign(_Ptr);
; 846  : 		}
; 847  : 
; 848  : 	basic_string(size_type _Count, _Elem _Ch)
; 849  : 		: _Mybase()
; 850  : 		{	// construct from _Count * _Ch
; 851  : 		_Tidy();
; 852  : 		assign(_Count, _Ch);
; 853  : 		}
; 854  : 
; 855  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 856  : 		: _Mybase(_Al)
; 857  : 		{	// construct from _Count * _Ch with allocator
; 858  : 		_Tidy();
; 859  : 		assign(_Count, _Ch);
; 860  : 		}
; 861  : 
; 862  : 	template<class _Iter,
; 863  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 864  : 			void>::type>
; 865  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 866  : 		: _Mybase(_Al)
; 867  : 		{	// construct from [_First, _Last) with optional allocator
; 868  : 		_DEBUG_RANGE(_First, _Last);
; 869  : 		_Tidy();
; 870  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>());
; 871  : 		}
; 872  : 
; 873  : 	template<class _Iter>
; 874  : 		void _Construct(_Iter _First,
; 875  : 			_Iter _Last, input_iterator_tag)
; 876  : 		{	// initialize from [_First, _Last), input iterators
; 877  : 		_TRY_BEGIN
; 878  : 		for (; _First != _Last; ++_First)
; 879  : 			append((size_type)1, (_Elem)*_First);
; 880  : 		_CATCH_ALL
; 881  : 		_Tidy(true);
; 882  : 		_RERAISE;
; 883  : 		_CATCH_END
; 884  : 		}
; 885  : 
; 886  : 	template<class _Iter>
; 887  : 		void _Construct(_Iter _First,
; 888  : 			_Iter _Last, forward_iterator_tag)
; 889  : 		{	// initialize from [_First, _Last), forward iterators
; 890  : 		size_type _Count = _STD distance(_First, _Last);
; 891  : 		reserve(_Count);
; 892  : 		_Construct(_First, _Last, input_iterator_tag());
; 893  : 		}
; 894  : 
; 895  : 	void _Construct(_Elem *_First,
; 896  : 		_Elem *_Last, random_access_iterator_tag)
; 897  : 		{	// initialize from [_First, _Last), pointers
; 898  : 		if (_First != _Last)
; 899  : 			assign(_First, _Last - _First);
; 900  : 		}
; 901  : 
; 902  : 	void _Construct(const _Elem *_First,
; 903  : 		const _Elem *_Last, random_access_iterator_tag)
; 904  : 		{	// initialize from [_First, _Last), const pointers
; 905  : 		if (_First != _Last)
; 906  : 			assign(_First, _Last - _First);
; 907  : 		}
; 908  : 
; 909  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 910  : 		: _Mybase(_STD move(_Right._Getal()))
; 911  : 		{	// construct by moving _Right
; 912  : 		_Tidy();
; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 914  : 		}
; 915  : 
; 916  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 917  : 		: _Mybase(_Al)
; 918  : 		{	// construct by moving _Right, allocator
; 919  : 		if (this->_Getal() != _Right._Getal())
; 920  : 			assign(_Right.begin(), _Right.end());
; 921  : 		else
; 922  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 923  : 		}
; 924  : 
; 925  : 	_Myt& operator=(_Myt&& _Right)
; 926  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 927  : 			|| _Alty::is_always_equal::value)
; 928  : 		{	// assign by moving _Right
; 929  : 		if (this != &_Right)
; 930  : 			{	// different, assign it
; 931  : 			_Tidy(true);
; 932  : 
; 933  : 			if (_Alty::propagate_on_container_move_assignment::value
; 934  : 				&& this->_Getal() != _Right._Getal())
; 935  : 				this->_Move_alloc(_Right._Getal());
; 936  : 
; 937  : 			if (this->_Getal() != _Right._Getal())
; 938  : 				assign(_Right.begin(), _Right.end());
; 939  : 			else
; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 941  : 			}
; 942  : 		return (*this);
; 943  : 		}
; 944  : 
; 945  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 946  : 		{	// assign by moving _Right
; 947  : 		if (this == &_Right)
; 948  : 			;
; 949  : 		else if (get_allocator() != _Right.get_allocator()
; 950  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 951  : 			*this = _Right;
; 952  : 		else
; 953  : 			{	// not same, clear this and steal from _Right
; 954  : 			_Tidy(true);
; 955  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 956  : 			}
; 957  : 		return (*this);
; 958  : 		}
; 959  : 
; 960  : 	void _Assign_rv(_Myt&& _Right)
; 961  : 		{	// assign by moving _Right
; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 964  : 				_Right._Mysize() + 1);
; 965  : 		else
; 966  : 			{	// copy pointer
; 967  : 			this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);
; 968  : 			_Right._Bx()._Ptr = pointer();
; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();
; 971  : 		this->_Myres() = _Right._Myres();
; 972  : 		_Right._Tidy();
; 973  : 		}
; 974  : 
; 975  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 976  : 		const _Alloc& _Al = allocator_type())
; 977  : 		: _Mybase(_Al)
; 978  : 		{	// construct from initializer_list
; 979  : 		_Tidy();
; 980  : 		assign(_Ilist.begin(), _Ilist.end());
; 981  : 		}
; 982  : 
; 983  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 984  : 		{	// assign initializer_list
; 985  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 986  : 		}
; 987  : 
; 988  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 989  : 		{	// append initializer_list
; 990  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 991  : 		}
; 992  : 
; 993  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// assign initializer_list
; 995  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 999  : 		{	// append initializer_list
; 1000 : 		return (append(_Ilist.begin(), _Ilist.end()));
; 1001 : 		}
; 1002 : 
; 1003 : 	iterator insert(const_iterator _Where,
; 1004 : 		_XSTD initializer_list<_Elem> _Ilist)
; 1005 : 		{	// insert initializer_list
; 1006 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1007 : 		}
; 1008 : 
; 1009 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1010 : 		_XSTD initializer_list<_Elem> _Ilist)
; 1011 : 		{	// replace with initializer_list
; 1012 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	~basic_string() _NOEXCEPT
; 1016 : 		{	// destroy the string
; 1017 : 		_Tidy(true);
; 1018 : 		}
; 1019 : 
; 1020 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1021 : 
; 1022 : 	_Myt& operator=(const _Myt& _Right)
; 1023 : 		{	// assign _Right
; 1024 : 		if (this != &_Right)
; 1025 : 			{	// different, assign it
; 1026 : 			if (this->_Getal() != _Right._Getal()
; 1027 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1028 : 				{	// change allocator before copying
; 1029 : 				_Tidy(true);
; 1030 : 				this->_Copy_alloc(_Right._Getal());
; 1031 : 				}
; 1032 : 
; 1033 : 			assign(_Right);
; 1034 : 			}
; 1035 : 		return (*this);
; 1036 : 		}
; 1037 : 
; 1038 : 	_Myt& operator=(const _Elem *_Ptr)
; 1039 : 		{	// assign [_Ptr, <null>)
; 1040 : 		return (assign(_Ptr));
; 1041 : 		}
; 1042 : 
; 1043 : 	_Myt& operator=(_Elem _Ch)
; 1044 : 		{	// assign 1 * _Ch
; 1045 : 		return (assign(1, _Ch));
; 1046 : 		}
; 1047 : 
; 1048 : 	_Myt& operator+=(const _Myt& _Right)
; 1049 : 		{	// append _Right
; 1050 : 		return (append(_Right));
; 1051 : 		}
; 1052 : 
; 1053 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1054 : 		{	// append [_Ptr, <null>)
; 1055 : 		return (append(_Ptr));
; 1056 : 		}
; 1057 : 
; 1058 : 	_Myt& operator+=(_Elem _Ch)
; 1059 : 		{	// append 1 * _Ch
; 1060 : 		return (append((size_type)1, _Ch));
; 1061 : 		}
; 1062 : 
; 1063 : 	_Myt& append(const _Myt& _Right)
; 1064 : 		{	// append _Right
; 1065 : 		return (append(_Right, 0, npos));
; 1066 : 		}
; 1067 : 
; 1068 : 	_Myt& append(const _Myt& _Right,
; 1069 : 		size_type _Roff, size_type _Count = npos)
; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1071 : 		_Right._Check_offset(_Roff);
; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)
; 1074 : 			_Xlen();	// result too long
; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;
; 1077 : 		if (0 < _Count && _Grow(_Num))
; 1078 : 			{	// make room and append new stuff
; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1080 : 				_Right._Myptr() + _Roff, _Count);
; 1081 : 			_Eos(_Num);
; 1082 : 			}
; 1083 : 		return (*this);
; 1084 : 		}
; 1085 : 
; 1086 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1087 : 		{	// append [_Ptr, _Ptr + _Count)
; 1088 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1089 : 		if (_Inside(_Ptr))
; 1090 : 			return (append(*this,
; 1091 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1092 : 		if (npos - this->_Mysize() <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		const size_type _Num = this->_Mysize() + _Count;
; 1096 : 		if (0 < _Count && _Grow(_Num))
; 1097 : 			{	// make room and append new stuff
; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	_Myt& append(const _Elem *_Ptr)
; 1105 : 		{	// append [_Ptr, <null>)
; 1106 : 		_DEBUG_POINTER(_Ptr);
; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1108 : 		}
; 1109 : 
; 1110 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1111 : 		{	// append _Count * _Ch
; 1112 : 		if (npos - this->_Mysize() <= _Count)
; 1113 : 			_Xlen();	// result too long
; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;
; 1116 : 		if (0 < _Count && _Grow(_Num))
; 1117 : 			{	// make room and append new stuff using assign
; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1119 : 			_Eos(_Num);
; 1120 : 			}
; 1121 : 		return (*this);
; 1122 : 		}
; 1123 : 
; 1124 : 	template<class _Iter>
; 1125 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1126 : 			_Myt&>::type
; 1127 : 		append(_Iter _First, _Iter _Last)
; 1128 : 		{	// append [_First, _Last), input iterators
; 1129 : 		return (replace(end(), end(), _First, _Last));
; 1130 : 		}
; 1131 : 
; 1132 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1133 : 		{	// append [_First, _Last), const pointers
; 1134 : 		return (replace(end(), end(), _First, _Last));
; 1135 : 		}
; 1136 : 
; 1137 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1138 : 		{	// append [_First, _Last), const_iterators
; 1139 : 		return (replace(end(), end(), _First, _Last));
; 1140 : 		}
; 1141 : 
; 1142 : 	_Myt& assign(const _Myt& _Right)
; 1143 : 		{	// assign _Right
; 1144 : 		return (assign(_Right, 0, npos));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Myt& _Right,
; 1148 : 		size_type _Roff, size_type _Count = npos)
; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1150 : 		_Right._Check_offset(_Roff);
; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1152 : 
; 1153 : 		if (this == &_Right)
; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring
; 1155 : 		else if (_Grow(_Count))
; 1156 : 			{	// make room and assign new stuff
; 1157 : 			_Traits::copy(this->_Myptr(),
; 1158 : 				_Right._Myptr() + _Roff, _Count);
; 1159 : 			_Eos(_Count);
; 1160 : 			}
; 1161 : 		return (*this);
; 1162 : 		}
; 1163 : 
; 1164 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))
; 1168 : 			return (assign(*this,
; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))
; 1172 : 			{	// make room and assign new stuff
; 1173 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1174 : 			_Eos(_Count);
; 1175 : 			}
; 1176 : 		return (*this);
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(const _Elem *_Ptr)
; 1180 : 		{	// assign [_Ptr, <null>)
; 1181 : 		_DEBUG_POINTER(_Ptr);
; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1183 : 		}
; 1184 : 
; 1185 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1186 : 		{	// assign _Count * _Ch
; 1187 : 		if (_Count == npos)
; 1188 : 			_Xlen();	// result too long
; 1189 : 
; 1190 : 		if (_Grow(_Count))
; 1191 : 			{	// make room and assign new stuff
; 1192 : 			_Chassign(0, _Count, _Ch);
; 1193 : 			_Eos(_Count);
; 1194 : 			}
; 1195 : 		return (*this);
; 1196 : 		}
; 1197 : 
; 1198 : 	template<class _Iter>
; 1199 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1200 : 			_Myt&>::type
; 1201 : 		assign(_Iter _First, _Iter _Last)
; 1202 : 		{	// assign [_First, _Last), input iterators
; 1203 : 		return (replace(begin(), end(), _First, _Last));
; 1204 : 		}
; 1205 : 
; 1206 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1207 : 		{	// assign [_First, _Last), const pointers
; 1208 : 		return (replace(begin(), end(), _First, _Last));
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1212 : 		{	// assign [_First, _Last), const_iterators
; 1213 : 		return (replace(begin(), end(), _First, _Last));
; 1214 : 		}
; 1215 : 
; 1216 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1217 : 		{	// insert _Right at _Off
; 1218 : 		return (insert(_Off, _Right, 0, npos));
; 1219 : 		}
; 1220 : 
; 1221 : 	_Myt& insert(size_type _Off,
; 1222 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1223 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1224 : 		_Check_offset(_Off);
; 1225 : 		_Right._Check_offset(_Roff);
; 1226 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1227 : 		if (npos - this->_Mysize() <= _Count)
; 1228 : 			_Xlen();	// result too long
; 1229 : 
; 1230 : 		const size_type _Num = this->_Mysize() + _Count;
; 1231 : 		if (0 < _Count && _Grow(_Num))
; 1232 : 			{	// make room and insert new stuff
; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1234 : 				this->_Myptr() + _Off,
; 1235 : 				this->_Mysize() - _Off);	// empty out hole
; 1236 : 			if (this == &_Right)
; 1237 : 				_Traits::move(this->_Myptr() + _Off,
; 1238 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1239 : 						_Count);	// substring
; 1240 : 			else
; 1241 : 				_Traits::copy(this->_Myptr() + _Off,
; 1242 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1243 : 			_Eos(_Num);
; 1244 : 			}
; 1245 : 		return (*this);
; 1246 : 		}
; 1247 : 
; 1248 : 	_Myt& insert(size_type _Off,
; 1249 : 		const _Elem *_Ptr, size_type _Count)
; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1251 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1252 : 		if (_Inside(_Ptr))
; 1253 : 			return (insert(_Off, *this,
; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);
; 1256 : 		if (npos - this->_Mysize() <= _Count)
; 1257 : 			_Xlen();	// result too long
; 1258 : 		const size_type _Num = this->_Mysize() + _Count;
; 1259 : 		if (0 < _Count && _Grow(_Num))
; 1260 : 			{	// make room and insert new stuff
; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1262 : 				this->_Myptr() + _Off,
; 1263 : 				this->_Mysize() - _Off);	// empty out hole
; 1264 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1265 : 			_Eos(_Num);
; 1266 : 			}
; 1267 : 		return (*this);
; 1268 : 		}
; 1269 : 
; 1270 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1271 : 		{	// insert [_Ptr, <null>) at _Off
; 1272 : 		_DEBUG_POINTER(_Ptr);
; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1274 : 		}
; 1275 : 
; 1276 : 	_Myt& insert(size_type _Off,
; 1277 : 		size_type _Count, _Elem _Ch)
; 1278 : 		{	// insert _Count * _Ch at _Off
; 1279 : 		_Check_offset(_Off);
; 1280 : 		if (npos - this->_Mysize() <= _Count)
; 1281 : 			_Xlen();	// result too long
; 1282 : 		const size_type _Num = this->_Mysize() + _Count;
; 1283 : 		if (0 < _Count && _Grow(_Num))
; 1284 : 			{	// make room and insert new stuff
; 1285 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1286 : 				this->_Myptr() + _Off,
; 1287 : 				this->_Mysize() - _Off);	// empty out hole
; 1288 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1289 : 			_Eos(_Num);
; 1290 : 			}
; 1291 : 		return (*this);
; 1292 : 		}
; 1293 : 
; 1294 : 	iterator insert(const_iterator _Where)
; 1295 : 		{	// insert <null> at _Where
; 1296 : 		return (insert(_Where, _Elem()));
; 1297 : 		}
; 1298 : 
; 1299 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1300 : 		{	// insert _Ch at _Where
; 1301 : 		size_type _Off = _Where - begin();
; 1302 : 		insert(_Off, 1, _Ch);
; 1303 : 		return (begin() + _Off);
; 1304 : 		}
; 1305 : 
; 1306 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1307 : 		{	// insert _Count * _Elem at _Where
; 1308 : 		size_type _Off = _Where - begin();
; 1309 : 		insert(_Off, _Count, _Ch);
; 1310 : 		return (begin() + _Off);
; 1311 : 		}
; 1312 : 
; 1313 : 	template<class _Iter>
; 1314 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1315 : 			iterator>::type
; 1316 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1317 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1318 : 		size_type _Off = _Where - begin();
; 1319 : 		replace(_Where, _Where, _First, _Last);
; 1320 : 		return (begin() + _Off);
; 1321 : 		}
; 1322 : 
; 1323 : 	iterator insert(const_iterator _Where,
; 1324 : 		const_pointer _First, const_pointer _Last)
; 1325 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1326 : 		size_type _Off = _Where - begin();
; 1327 : 		replace(_Where, _Where, _First, _Last);
; 1328 : 		return (begin() + _Off);
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where,
; 1332 : 		const_iterator _First, const_iterator _Last)
; 1333 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1334 : 		size_type _Off = _Where - begin();
; 1335 : 		replace(_Where, _Where, _First, _Last);
; 1336 : 		return (begin() + _Off);
; 1337 : 		}
; 1338 : 
; 1339 : 	_Myt& erase(size_type _Off = 0)
; 1340 : 		{	// erase elements [_Off, ...)
; 1341 : 		_Check_offset(_Off);
; 1342 : 		_Eos(_Off);
; 1343 : 		return (*this);
; 1344 : 		}
; 1345 : 
; 1346 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1347 : 		{	// erase elements [_Off, _Off + _Count)
; 1348 : 		_Check_offset(_Off);
; 1349 : 		if (this->_Mysize() - _Off <= _Count)
; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1351 : 		else if (0 < _Count)
; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1356 : 			_Eos(_Newsize);
; 1357 : 			}
; 1358 : 		return (*this);
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator erase(const_iterator _Where)
; 1362 : 		{	// erase element at _Where
; 1363 : 		size_type _Count = _Where - begin();
; 1364 : 		erase(_Count, 1);
; 1365 : 		return (begin() + _Count);
; 1366 : 		}
; 1367 : 
; 1368 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1369 : 		{	// erase substring [_First, _Last)
; 1370 : 		_DEBUG_RANGE(_First, _Last);
; 1371 : 		size_type _Count = _First - begin();
; 1372 : 		erase(_Count, _Last - _First);
; 1373 : 		return (begin() + _Count);
; 1374 : 		}
; 1375 : 
; 1376 : 	void clear() _NOEXCEPT
; 1377 : 		{	// erase all
; 1378 : 		_Eos(0);
; 1379 : 		}
; 1380 : 
; 1381 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1382 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1383 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1384 : 		}
; 1385 : 
; 1386 : 	_Myt& replace(size_type _Off,
; 1387 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1388 : 			size_type _Count = npos)
; 1389 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1390 : 		_Check_offset(_Off);
; 1391 : 		_Right._Check_offset(_Roff);
; 1392 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1393 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1394 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1395 : 			_Xlen();	// result too long
; 1396 : 
; 1397 : 		const size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1398 : 		const size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1399 : 		if (this->_Mysize() < _Newsize)
; 1400 : 			_Grow(_Newsize);
; 1401 : 
; 1402 : 		if (_Count == _N0)
; 1403 : 			{	// only one movement required, so _Traits::move handles any overlap
; 1404 : 			_Traits::move(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (this != &_Right)
; 1408 : 			{	// no overlap, just move down and copy in new stuff
; 1409 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1410 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1411 : 			_Traits::copy(this->_Myptr() + _Off,
; 1412 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1413 : 			}
; 1414 : 		else if (_Count < _N0)
; 1415 : 			{	// hole doesn't get larger, just copy in substring
; 1416 : 			_Traits::move(this->_Myptr() + _Off,
; 1417 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1419 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1420 : 			}
; 1421 : 		else if (_Roff <= _Off)
; 1422 : 			{	// hole gets larger, substring begins before hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1427 : 			}
; 1428 : 		else if (_Off + _N0 <= _Roff)
; 1429 : 			{	// hole gets larger, substring begins after hole
; 1430 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1431 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1432 : 			_Traits::move(this->_Myptr() + _Off,
; 1433 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1434 : 				_Count);	// fill hole
; 1435 : 			}
; 1436 : 		else
; 1437 : 			{	// hole gets larger, substring begins in hole
; 1438 : 			_Traits::move(this->_Myptr() + _Off,
; 1439 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1442 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1443 : 				this->_Myptr() + _Roff + _Count,
; 1444 : 				_Count - _N0);	// fill rest of new hole
; 1445 : 			}
; 1446 : 
; 1447 : 		_Eos(_Newsize);
; 1448 : 		return (*this);
; 1449 : 		}
; 1450 : 
; 1451 : 	_Myt& replace(size_type _Off,
; 1452 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1453 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1454 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1455 : 		if (_Inside(_Ptr))
; 1456 : 			return (replace(_Off, _N0, *this,
; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);
; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1462 : 			_Xlen();	// result too long
; 1463 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1464 : 
; 1465 : 		if (_Count < _N0)
; 1466 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1467 : 				this->_Myptr() + _Off + _N0,
; 1468 : 				_Nm);	// smaller hole, move tail up
; 1469 : 		const size_type _Num = this->_Mysize() + _Count - _N0;
; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))
; 1472 : 			{	// make room and rearrange
; 1473 : 			if (_N0 < _Count)
; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1476 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1477 : 			_Eos(_Num);
; 1478 : 			}
; 1479 : 		return (*this);
; 1480 : 		}
; 1481 : 
; 1482 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1483 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1484 : 		_DEBUG_POINTER(_Ptr);
; 1485 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1486 : 		}
; 1487 : 
; 1488 : 	_Myt& replace(size_type _Off,
; 1489 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1490 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1491 : 		_Check_offset(_Off);
; 1492 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1493 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1494 : 			_Xlen();	// result too long
; 1495 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1496 : 
; 1497 : 		if (_Count < _N0)
; 1498 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1499 : 				this->_Myptr() + _Off + _N0,
; 1500 : 				_Nm);	// smaller hole, move tail up
; 1501 : 		const size_type _Num = this->_Mysize() + _Count - _N0;
; 1502 : 		if ((0 < _Count || 0 < _N0)
; 1503 : 			&& _Grow(_Num))
; 1504 : 			{	// make room and rearrange
; 1505 : 			if (_N0 < _Count)
; 1506 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1507 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1508 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1509 : 			_Eos(_Num);
; 1510 : 			}
; 1511 : 		return (*this);
; 1512 : 		}
; 1513 : 
; 1514 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1515 : 		const _Myt& _Right)
; 1516 : 		{	// replace [_First, _Last) with _Right
; 1517 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1518 : 		}
; 1519 : 
; 1520 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1521 : 		const _Elem *_Ptr, size_type _Count)
; 1522 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1523 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1524 : 		}
; 1525 : 
; 1526 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1527 : 		const _Elem *_Ptr)
; 1528 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1529 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1530 : 		}
; 1531 : 
; 1532 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1533 : 		size_type _Count, _Elem _Ch)
; 1534 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1535 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1536 : 		}
; 1537 : 
; 1538 : 	template<class _Iter>
; 1539 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1540 : 			_Myt&>::type
; 1541 : 		replace(const_iterator _First, const_iterator _Last,
; 1542 : 			_Iter _First2, _Iter _Last2)
; 1543 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1544 : 		_Myt _Right(_First2, _Last2);
; 1545 : 		replace(_First, _Last, _Right);
; 1546 : 		return (*this);
; 1547 : 		}
; 1548 : 
; 1549 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1550 : 		const_pointer _First2, const_pointer _Last2)
; 1551 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1552 : 		if (_First2 == _Last2)
; 1553 : 			erase(_First - begin(), _Last - _First);
; 1554 : 		else
; 1555 : 			replace(_First - begin(), _Last - _First,
; 1556 : 				&*_First2, _Last2 - _First2);
; 1557 : 		return (*this);
; 1558 : 		}
; 1559 : 
; 1560 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1561 : 		pointer _First2, pointer _Last2)
; 1562 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1563 : 		if (_First2 == _Last2)
; 1564 : 			erase(_First - begin(), _Last - _First);
; 1565 : 		else
; 1566 : 			replace(_First - begin(), _Last - _First,
; 1567 : 				&*_First2, _Last2 - _First2);
; 1568 : 		return (*this);
; 1569 : 		}
; 1570 : 
; 1571 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1572 : 		const_iterator _First2, const_iterator _Last2)
; 1573 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1574 : 		if (_First2 == _Last2)
; 1575 : 			erase(_First - begin(), _Last - _First);
; 1576 : 		else
; 1577 : 			replace(_First - begin(), _Last - _First,
; 1578 : 				&*_First2, _Last2 - _First2);
; 1579 : 		return (*this);
; 1580 : 		}
; 1581 : 
; 1582 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1583 : 		iterator _First2, iterator _Last2)
; 1584 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1585 : 		if (_First2 == _Last2)
; 1586 : 			erase(_First - begin(), _Last - _First);
; 1587 : 		else
; 1588 : 			replace(_First - begin(), _Last - _First,
; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);
; 1591 : 		}
; 1592 : 
; 1593 : 	iterator begin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of mutable sequence
; 1595 : 		auto _Mydata = &this->_Get_data();
; 1596 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		auto _Mydata = &this->_Get_data();
; 1602 : 		return (const_iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));
; 1603 : 		}
; 1604 : 
; 1605 : 	iterator end() _NOEXCEPT
; 1606 : 		{	// return iterator for end of mutable sequence
; 1607 : 		auto _Mydata = &this->_Get_data();
; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));
; 1609 : 		}
; 1610 : 
; 1611 : 	const_iterator end() const _NOEXCEPT
; 1612 : 		{	// return iterator for end of nonmutable sequence
; 1613 : 		auto _Mydata = &this->_Get_data();
; 1614 : 		return (const_iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));
; 1615 : 		}
; 1616 : 
; 1617 : 	reverse_iterator rbegin() _NOEXCEPT
; 1618 : 		{	// return iterator for beginning of reversed mutable sequence
; 1619 : 		return (reverse_iterator(end()));
; 1620 : 		}
; 1621 : 
; 1622 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1623 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1624 : 		return (const_reverse_iterator(end()));
; 1625 : 		}
; 1626 : 
; 1627 : 	reverse_iterator rend() _NOEXCEPT
; 1628 : 		{	// return iterator for end of reversed mutable sequence
; 1629 : 		return (reverse_iterator(begin()));
; 1630 : 		}
; 1631 : 
; 1632 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1633 : 		{	// return iterator for end of reversed nonmutable sequence
; 1634 : 		return (const_reverse_iterator(begin()));
; 1635 : 		}
; 1636 : 
; 1637 : 	const_iterator cbegin() const _NOEXCEPT
; 1638 : 		{	// return iterator for beginning of nonmutable sequence
; 1639 : 		return (begin());
; 1640 : 		}
; 1641 : 
; 1642 : 	const_iterator cend() const _NOEXCEPT
; 1643 : 		{	// return iterator for end of nonmutable sequence
; 1644 : 		return (end());
; 1645 : 		}
; 1646 : 
; 1647 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1648 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1649 : 		return (rbegin());
; 1650 : 		}
; 1651 : 
; 1652 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1653 : 		{	// return iterator for end of reversed nonmutable sequence
; 1654 : 		return (rend());
; 1655 : 		}
; 1656 : 
; 1657 : 	void shrink_to_fit()
; 1658 : 		{	// reduce capacity
; 1659 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1660 : 			{	// worth shrinking, do it
; 1661 : 			_Myt _Tmp(*this);
; 1662 : 			swap(_Tmp);
; 1663 : 			}
; 1664 : 		}
; 1665 : 
; 1666 : 	reference at(size_type _Off)
; 1667 : 		{	// subscript mutable sequence with checking
; 1668 : 		_Check_offset_exclusive(_Off);
; 1669 : 		return (this->_Myptr()[_Off]);
; 1670 : 		}
; 1671 : 
; 1672 : 	const_reference at(size_type _Off) const
; 1673 : 		{	// subscript nonmutable sequence with checking
; 1674 : 		_Check_offset_exclusive(_Off);
; 1675 : 		return (this->_Myptr()[_Off]);
; 1676 : 		}
; 1677 : 
; 1678 : 	reference operator[](size_type _Off)
; 1679 : 		{	// subscript mutable sequence
; 1680 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1681 : 		if (this->_Mysize() < _Off)	// sic
; 1682 : 			_DEBUG_ERROR("string subscript out of range");
; 1683 : 
; 1684 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1685 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1686 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1687 : 
; 1688 : 		return (this->_Myptr()[_Off]);
; 1689 : 		}
; 1690 : 
; 1691 : 	const_reference operator[](size_type _Off) const
; 1692 : 		{	// subscript nonmutable sequence
; 1693 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1694 : 		if (this->_Mysize() < _Off)	// sic
; 1695 : 			_DEBUG_ERROR("string subscript out of range");
; 1696 : 
; 1697 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1698 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1699 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1700 : 
; 1701 : 		return (this->_Myptr()[_Off]);
; 1702 : 		}
; 1703 : 
; 1704 : 	void push_back(_Elem _Ch)
; 1705 : 		{	// insert element at end
; 1706 : 		auto& _Dx = this->_Get_data();
; 1707 : 		auto& _Sz = _Dx._Mysize;
; 1708 : 		if (_Sz == _Dx._Myres)
; 1709 : 			_Grow(_Sz + 1); // _Grow checks for overflow
; 1710 : 		auto _Ptr = _Dx._Myptr();
; 1711 : 		_Traits::assign(_Ptr[_Sz], _Ch);
; 1712 : 		++_Sz;
; 1713 : 		_Traits::assign(_Ptr[_Sz], _Elem());
; 1714 : 		}
; 1715 : 
; 1716 : 	void pop_back()
; 1717 : 		{	// erase element at end
; 1718 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1719 : 		}
; 1720 : 
; 1721 : 	reference front()
; 1722 : 		{	// return first element of mutable sequence
; 1723 : 		return (*begin());
; 1724 : 		}
; 1725 : 
; 1726 : 	const_reference front() const
; 1727 : 		{	// return first element of nonmutable sequence
; 1728 : 		return (*begin());
; 1729 : 		}
; 1730 : 
; 1731 : 	reference back()
; 1732 : 		{	// return last element of mutable sequence
; 1733 : 		return (*(end() - 1));
; 1734 : 		}
; 1735 : 
; 1736 : 	const_reference back() const
; 1737 : 		{	// return last element of nonmutable sequence
; 1738 : 		return (*(end() - 1));
; 1739 : 		}
; 1740 : 
; 1741 : 	const _Elem *c_str() const _NOEXCEPT
; 1742 : 		{	// return pointer to null-terminated nonmutable array
; 1743 : 		return (this->_Myptr());
; 1744 : 		}
; 1745 : 
; 1746 : 	const _Elem *data() const _NOEXCEPT
; 1747 : 		{	// return pointer to nonmutable array
; 1748 : 		return (this->_Myptr());
; 1749 : 		}
; 1750 : 
; 1751 : #if _HAS_CXX17
; 1752 : 	_Elem *data() _NOEXCEPT
; 1753 : 		{	// return pointer to mutable array
; 1754 : 		return (this->_Myptr());
; 1755 : 		}
; 1756 : #endif /* _HAS_CXX17 */
; 1757 : 
; 1758 : 	size_type length() const _NOEXCEPT
; 1759 : 		{	// return length of sequence
; 1760 : 		return (this->_Mysize());
; 1761 : 		}
; 1762 : 
; 1763 : 	size_type size() const _NOEXCEPT
; 1764 : 		{	// return length of sequence
; 1765 : 		return (this->_Mysize());
; 1766 : 		}
; 1767 : 
; 1768 : 	size_type max_size() const _NOEXCEPT
; 1769 : 		{	// return maximum possible length of sequence
; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1772 : 		}
; 1773 : 
; 1774 : 	void resize(size_type _Newsize)
; 1775 : 		{	// determine new length, padding with null elements as needed
; 1776 : 		resize(_Newsize, _Elem());
; 1777 : 		}
; 1778 : 
; 1779 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1780 : 		{	// determine new length, padding with _Ch elements as needed
; 1781 : 		if (_Newsize <= this->_Mysize())
; 1782 : 			_Eos(_Newsize);
; 1783 : 		else
; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1785 : 		}
; 1786 : 
; 1787 : 	size_type capacity() const _NOEXCEPT
; 1788 : 		{	// return current length of allocated storage
; 1789 : 		return (this->_Myres());
; 1790 : 		}
; 1791 : 
; 1792 : 	void reserve(size_type _Newcap = 0)
; 1793 : 		{	// determine new minimum length of allocated storage
; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))
; 1798 : 				_Eos(_Size);
; 1799 : 			}
; 1800 : 		}
; 1801 : 
; 1802 : 	bool empty() const _NOEXCEPT
; 1803 : 		{	// test if sequence is empty
; 1804 : 		return (this->_Mysize() == 0);
; 1805 : 		}
; 1806 : 
; 1807 : 	_SCL_INSECURE_DEPRECATE_FN(basic_string::copy)
; 1808 : 	size_type copy(_Elem *_Ptr,
; 1809 : 		size_type _Count, size_type _Off = 0) const
; 1810 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1811 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1812 : 		_Check_offset(_Off);
; 1813 : 		_Count = _Clamp_suffix_size(_Off, _Count);
; 1814 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1819 : 		size_type _Count, size_type _Off = 0) const
; 1820 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1821 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1822 : 		_Check_offset(_Off);
; 1823 : 		_Count = _Clamp_suffix_size(_Off, _Count);
; 1824 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1825 : 		return (_Count);
; 1826 : 		}
; 1827 : 
; 1828 : 	void _Swap_bx(_Myt& _Right)
; 1829 : 		{	// exchange _Bx() with _Right._Bx()
; 1830 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1831 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1832 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1833 : 			else
; 1834 : 				{	// swap large with small
; 1835 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1836 : 				this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 1837 : 				_Traits::copy(this->_Bx()._Buf,
; 1838 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1839 : 				this->_Getal().construct(_STD addressof(_Right._Bx()._Ptr), _Ptr);
; 1840 : 				}
; 1841 : 		else
; 1842 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1843 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1844 : 			else
; 1845 : 				{	// swap small with large
; 1846 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1847 : 				this->_Getal().destroy(_STD addressof(_Right._Bx()._Ptr));
; 1848 : 				_Traits::copy(_Right._Bx()._Buf,
; 1849 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1850 : 				this->_Getal().construct(_STD addressof(this->_Bx()._Ptr), _Ptr);
; 1851 : 				}
; 1852 : 		}
; 1853 : 
; 1854 : 	void swap(_Myt& _Right)
; 1855 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1856 : 			|| _Alty::is_always_equal::value)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this != &_Right)
; 1859 : 			{	// (maybe) swap allocators, swap control information
; 1860 : 			_Pocs(this->_Getal(), _Right._Getal());
; 1861 : 			this->_Swap_all(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1864 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1865 : 			}
; 1866 : 		}
; 1867 : 
; 1868 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1869 : 		{	// look for _Right beginning at or after _Off
; 1870 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1871 : 		}
; 1872 : 
; 1873 : 	size_type find(const _Elem *_Ptr,
; 1874 : 		size_type _Off, size_type _Count) const
; 1875 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1876 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1877 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1878 : 			return (_Off);	// null string always matches (if inside string)
; 1879 : 
; 1880 : 		size_type _Nm;
; 1881 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1882 : 			{	// room for match, look for it
; 1883 : 			const _Elem *_Uptr, *_Vptr;
; 1884 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1885 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1886 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1887 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1888 : 					return (_Uptr - this->_Myptr());	// found a match
; 1889 : 			}
; 1890 : 
; 1891 : 		return (npos);	// no match
; 1892 : 		}
; 1893 : 
; 1894 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1895 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1896 : 		_DEBUG_POINTER(_Ptr);
; 1897 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1898 : 		}
; 1899 : 
; 1900 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1901 : 		{	// look for _Ch at or after _Off
; 1902 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1903 : 		}
; 1904 : 
; 1905 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1906 : 		{	// look for _Right beginning before _Off
; 1907 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1908 : 		}
; 1909 : 
; 1910 : 	size_type rfind(const _Elem *_Ptr,
; 1911 : 		size_type _Off, size_type _Count) const
; 1912 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1913 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1914 : 		if (_Count == 0)
; 1915 : 			return (_Off < this->_Mysize() ? _Off
; 1916 : 				: this->_Mysize());	// null always matches
; 1917 : 		if (_Count <= this->_Mysize())
; 1918 : 			{	// room for match, look for it
; 1919 : 			const _Elem *_Uptr = this->_Myptr() +
; 1920 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1921 : 					: this->_Mysize() - _Count);
; 1922 : 			for (; ; --_Uptr)
; 1923 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1924 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1925 : 					return (_Uptr - this->_Myptr());	// found a match
; 1926 : 				else if (_Uptr == this->_Myptr())
; 1927 : 					break;	// at beginning, no more chance for match
; 1928 : 			}
; 1929 : 
; 1930 : 		return (npos);	// no match
; 1931 : 		}
; 1932 : 
; 1933 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1934 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1935 : 		_DEBUG_POINTER(_Ptr);
; 1936 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1937 : 		}
; 1938 : 
; 1939 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1940 : 		{	// look for _Ch before _Off
; 1941 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1942 : 		}
; 1943 : 
; 1944 : 	size_type find_first_of(const _Myt& _Right,
; 1945 : 		size_type _Off = 0) const _NOEXCEPT
; 1946 : 		{	// look for one of _Right at or after _Off
; 1947 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1948 : 		}
; 1949 : 
; 1950 : 	size_type find_first_of(const _Elem *_Ptr,
; 1951 : 		size_type _Off, size_type _Count) const
; 1952 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1953 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1954 : 		if (0 < _Count && _Off < this->_Mysize())
; 1955 : 			{	// room for match, look for it
; 1956 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1957 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1958 : 				_Uptr < _Vptr; ++_Uptr)
; 1959 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1960 : 					return (_Uptr - this->_Myptr());	// found a match
; 1961 : 			}
; 1962 : 
; 1963 : 		return (npos);	// no match
; 1964 : 		}
; 1965 : 
; 1966 : 	size_type find_first_of(const _Elem *_Ptr,
; 1967 : 		size_type _Off = 0) const
; 1968 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1969 : 		_DEBUG_POINTER(_Ptr);
; 1970 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1971 : 		}
; 1972 : 
; 1973 : 	size_type find_first_of(_Elem _Ch,
; 1974 : 		size_type _Off = 0) const
; 1975 : 		{	// look for _Ch at or after _Off
; 1976 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1977 : 		}
; 1978 : 
; 1979 : 	size_type find_last_of(const _Myt& _Right,
; 1980 : 		size_type _Off = npos) const _NOEXCEPT
; 1981 : 		{	// look for one of _Right before _Off
; 1982 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1983 : 		}
; 1984 : 
; 1985 : 	size_type find_last_of(const _Elem *_Ptr,
; 1986 : 		size_type _Off, size_type _Count) const
; 1987 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1988 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1989 : 		if (0 < _Count && 0 < this->_Mysize())
; 1990 : 			{	// worth searching, do it
; 1991 : 			const _Elem *_Uptr = this->_Myptr()
; 1992 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 1993 : 			for (; ; --_Uptr)
; 1994 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1995 : 					return (_Uptr - this->_Myptr());	// found a match
; 1996 : 				else if (_Uptr == this->_Myptr())
; 1997 : 					break;	// at beginning, no more chance for match
; 1998 : 			}
; 1999 : 
; 2000 : 		return (npos);	// no match
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_last_of(const _Elem *_Ptr,
; 2004 : 		size_type _Off = npos) const
; 2005 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2006 : 		_DEBUG_POINTER(_Ptr);
; 2007 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2008 : 		}
; 2009 : 
; 2010 : 	size_type find_last_of(_Elem _Ch,
; 2011 : 		size_type _Off = npos) const
; 2012 : 		{	// look for _Ch before _Off
; 2013 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2014 : 		}
; 2015 : 
; 2016 : 	size_type find_first_not_of(const _Myt& _Right,
; 2017 : 		size_type _Off = 0) const _NOEXCEPT
; 2018 : 		{	// look for none of _Right at or after _Off
; 2019 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2020 : 			_Right.size()));
; 2021 : 		}
; 2022 : 
; 2023 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2024 : 		size_type _Off, size_type _Count) const
; 2025 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2026 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2027 : 		if (_Off < this->_Mysize())
; 2028 : 			{	// room for match, look for it
; 2029 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2030 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2031 : 				_Uptr < _Vptr; ++_Uptr)
; 2032 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2033 : 					return (_Uptr - this->_Myptr());
; 2034 : 			}
; 2035 : 		return (npos);
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off = 0) const
; 2040 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2041 : 		_DEBUG_POINTER(_Ptr);
; 2042 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2043 : 		}
; 2044 : 
; 2045 : 	size_type find_first_not_of(_Elem _Ch,
; 2046 : 		size_type _Off = 0) const
; 2047 : 		{	// look for non _Ch at or after _Off
; 2048 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2049 : 		}
; 2050 : 
; 2051 : 	size_type find_last_not_of(const _Myt& _Right,
; 2052 : 		size_type _Off = npos) const _NOEXCEPT
; 2053 : 		{	// look for none of _Right before _Off
; 2054 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2060 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2061 : 		if (0 < this->_Mysize())
; 2062 : 			{	// worth searching, do it
; 2063 : 			const _Elem *_Uptr = this->_Myptr()
; 2064 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2065 : 			for (; ; --_Uptr)
; 2066 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2067 : 					return (_Uptr - this->_Myptr());
; 2068 : 				else if (_Uptr == this->_Myptr())
; 2069 : 					break;
; 2070 : 			}
; 2071 : 		return (npos);
; 2072 : 		}
; 2073 : 
; 2074 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2075 : 		size_type _Off = npos) const
; 2076 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2077 : 		_DEBUG_POINTER(_Ptr);
; 2078 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2079 : 		}
; 2080 : 
; 2081 : 	size_type find_last_not_of(_Elem _Ch,
; 2082 : 		size_type _Off = npos) const
; 2083 : 		{	// look for non _Ch before _Off
; 2084 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2085 : 		}
; 2086 : 
; 2087 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2088 : 		{	// return [_Off, _Off + _Count) as new string
; 2089 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2090 : 		}
; 2091 : 
; 2092 : 	static int _Traits_compare(const _Elem * const _Left, const size_type _Left_size,
; 2093 : 		const _Elem * const _Right, const size_type _Right_size)
; 2094 : 		{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;
; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);
; 2097 : 
; 2098 : 		if (_Ans != 0)
; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)
; 2102 : 			return (-1);
; 2103 : 
; 2104 : 		if (_Left_size > _Right_size)
; 2105 : 			return (1);
; 2106 : 
; 2107 : 		return (0);
; 2108 : 		}
; 2109 : 
; 2110 : 	size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const
; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off
; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;
; 2113 : 		if (_Size <= _Max_effective_size)
; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}
; 2118 : 
; 2119 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2120 : 		{	// compare [0, _Mysize()) with _Right
; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),
; 2122 : 			_Right._Myptr(), _Right._Mysize()));
; 2123 : 		}
; 2124 : 
; 2125 : 	int compare(size_type _Off,
; 2126 : 		size_type _N0, const _Myt& _Right) const
; 2127 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2128 : 		_Check_offset(_Off);
; 2129 : 		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
; 2130 : 			_Right._Myptr(), _Right._Mysize()));
; 2131 : 		}
; 2132 : 
; 2133 : 	int compare(size_type _Off,
; 2134 : 		size_type _N0, const _Myt& _Right,
; 2135 : 		size_type _Roff, size_type _Count = npos) const
; 2136 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2137 : 		_Check_offset(_Off);
; 2138 : 		_Right._Check_offset(_Roff);
; 2139 : 		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
; 2140 : 			_Right._Myptr() + _Roff, _Right._Clamp_suffix_size(_Roff, _Count)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(const _Elem *_Ptr) const
; 2144 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),
; 2147 : 			_Ptr, _Traits::length(_Ptr)));
; 2148 : 		}
; 2149 : 
; 2150 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2152 : 		_DEBUG_POINTER(_Ptr);
; 2153 : 		_Check_offset(_Off);
; 2154 : 		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
; 2155 : 			_Ptr, _Traits::length(_Ptr)));
; 2156 : 		}
; 2157 : 
; 2158 : 	int compare(size_type _Off,
; 2159 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2160 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2161 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2162 : 		_Check_offset(_Off);
; 2163 : 		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
; 2164 : 			_Ptr, _Count));
; 2165 : 		}
; 2166 : 
; 2167 : 	allocator_type get_allocator() const _NOEXCEPT
; 2168 : 		{	// return allocator object for values
; 2169 : 		allocator_type _Ret(this->_Getal());
; 2170 : 		return (_Ret);
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2189 : 			_Newres = this->_Myres()
; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z$1:

; 734  : 		return (_Get_data()._Myres);

	mov	rbx, QWORD PTR this$[rbp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	r8, QWORD PTR [rbx+24]
	cmp	r8, 8
	jb	SHORT $LN107@catch$0

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, QWORD PTR [rbx]
	mov	rcx, rbx
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN107@catch$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN175@catch$0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rbx, QWORD PTR [rbx]
$LN175@catch$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [rbx], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2203 : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::get_allocator, COMDAT

; 2169 : 		allocator_type _Ret(this->_Getal());
; 2170 : 		return (_Ret);

	mov	rax, rdx

; 2171 : 		}

	ret	0
?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_K0@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
_Size$ = 24
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_K0@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size, COMDAT

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, rdx

; 2113 : 		if (_Size <= _Max_effective_size)

	cmp	r8, rax
	cmovbe	rax, r8

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

	ret	0
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_K0@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
__$ReturnUdt$ = 72
_Off$ = 80
_Count$ = 88
?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr, COMDAT

; 2088 : 		{	// return [_Off, _Off + _Count) as new string

$LN101:
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T2[rsp], -2
	mov	rbx, rdx
	xor	eax, eax
	mov	DWORD PTR $T1[rsp], eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rdx], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 817  : 		assign(_Right, _Roff, _Count);

	mov	rdx, rcx
	mov	rcx, rbx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
	mov	DWORD PTR $T1[rsp], 1

; 2089 : 		return (_Myt(*this, _Off, _Count, get_allocator()));

	mov	rax, rbx

; 2090 : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
	int	3
?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
__$ReturnUdt$ = 72
_Off$ = 80
_Count$ = 88
?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
__$ReturnUdt$ = 72
_Off$ = 80
_Count$ = 88
?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KPEB_W_K1@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
_Off$ = 24
_Count$ = 32
?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KPEB_W_K1@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_not_of, COMDAT

; 2025 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off

$LN80:
	mov	QWORD PTR [rsp+8], rdi

; 2026 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2027 : 		if (_Off < this->_Mysize())

	mov	r10, QWORD PTR [rcx+16]
	mov	rdi, rdx
	mov	r11, rcx
	cmp	r8, r10
	jae	SHORT $LN3@find_first

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN22@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN23@find_first
$LN22@find_first:
	mov	rax, r11
$LN23@find_first:
	cmp	QWORD PTR [rcx+24], 8

; 2028 : 			{	// room for match, look for it
; 2029 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();

	lea	r10, QWORD PTR [rax+r10*2]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN40@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN41@find_first
$LN40@find_first:
	mov	rax, r11
$LN41@find_first:

; 2030 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;

	lea	rdx, QWORD PTR [rax+r8*2]

; 2031 : 				_Uptr < _Vptr; ++_Uptr)

	cmp	rdx, r10
	jae	SHORT $LN3@find_first
	npad	1
$LL4@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 326  : 		return (_Count == 0 ? (const _Elem *)0

	test	r9, r9
	je	SHORT $LN69@find_first
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 204  :             if (*_S == _C)

	movzx	r8d, WORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 326  : 		return (_Count == 0 ? (const _Elem *)0

	mov	rcx, r9
	mov	rax, rdi
	npad	1
$LL51@find_first:
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 204  :             if (*_S == _C)

	cmp	WORD PTR [rax], r8w
	je	SHORT $LN68@find_first

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rax, 2
	sub	rcx, 1
	jne	SHORT $LL51@find_first
$LN69@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [r11+24], 8
	jb	SHORT $LN62@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	r11, QWORD PTR [r11]
$LN62@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2033 : 					return (_Uptr - this->_Myptr());

	sub	rdx, r11
	sar	rdx, 1
	mov	rax, rdx

; 2034 : 			}
; 2035 : 		return (npos);
; 2036 : 		}

	mov	rdi, QWORD PTR [rsp+8]
	ret	0
$LN68@find_first:

; 2031 : 				_Uptr < _Vptr; ++_Uptr)

	add	rdx, 2
	cmp	rdx, r10
	jb	SHORT $LL4@find_first
$LN3@find_first:

; 2034 : 			}
; 2035 : 		return (npos);
; 2036 : 		}

	mov	rdi, QWORD PTR [rsp+8]
	or	rax, -1
	ret	0
?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KPEB_W_K1@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_not_of
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z
_TEXT	SEGMENT
this$ = 16
_Right$ = 24
_Off$ = 32
?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_not_of, COMDAT

; 2018 : 		{	// look for none of _Right at or after _Off

$LN102:
	sub	rsp, 8

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rdx+24], 8

; 2018 : 		{	// look for none of _Right at or after _Off

	mov	r11, rdx

; 1765 : 		return (this->_Mysize());

	mov	r9, QWORD PTR [rdx+16]

; 2018 : 		{	// look for none of _Right at or after _Off

	mov	r10, rcx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN19@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	r11, QWORD PTR [rdx]
$LN19@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2027 : 		if (_Off < this->_Mysize())

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rsp], rbx
	cmp	r8, rax
	jae	SHORT $LN25@find_first

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN45@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN45@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [r10+24], 8

; 2029 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();

	lea	rbx, QWORD PTR [rcx+rax*2]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN62@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN63@find_first
$LN62@find_first:
	mov	rax, r10
$LN63@find_first:

; 2030 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;

	lea	rdx, QWORD PTR [rax+r8*2]

; 2031 : 				_Uptr < _Vptr; ++_Uptr)

	cmp	rdx, rbx
	jae	SHORT $LN25@find_first
	npad	5
$LL26@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 326  : 		return (_Count == 0 ? (const _Elem *)0

	test	r9, r9
	je	SHORT $LN91@find_first
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 204  :             if (*_S == _C)

	movzx	r8d, WORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 326  : 		return (_Count == 0 ? (const _Elem *)0

	mov	rcx, r9
	mov	rax, r11
	npad	1
$LL73@find_first:
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 204  :             if (*_S == _C)

	cmp	WORD PTR [rax], r8w
	je	SHORT $LN90@find_first

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rax, 2
	sub	rcx, 1
	jne	SHORT $LL73@find_first
$LN91@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [r10+24], 8
	jb	SHORT $LN84@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	r10, QWORD PTR [r10]
$LN84@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2033 : 					return (_Uptr - this->_Myptr());

	sub	rdx, r10
	sar	rdx, 1

; 2019 : 		return (find_first_not_of(_Right._Myptr(), _Off,

	mov	rax, rdx
	mov	rbx, QWORD PTR [rsp]

; 2020 : 			_Right.size()));
; 2021 : 		}

	add	rsp, 8
	ret	0
$LN90@find_first:

; 2031 : 				_Uptr < _Vptr; ++_Uptr)

	add	rdx, 2
	cmp	rdx, rbx
	jb	SHORT $LL26@find_first
$LN25@find_first:

; 2019 : 		return (find_first_not_of(_Right._Myptr(), _Off,

	or	rax, -1
	mov	rbx, QWORD PTR [rsp]

; 2020 : 			_Right.size()));
; 2021 : 		}

	add	rsp, 8
	ret	0
?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_not_of
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KPEB_W_K1@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
_Off$ = 24
_Count$ = 32
?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KPEB_W_K1@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_of, COMDAT

; 1952 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off

$LN79:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	r11, r8
	mov	rsi, rdx
	mov	r10, rcx

; 1953 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1954 : 		if (0 < _Count && _Off < this->_Mysize())

	test	r9, r9
	je	SHORT $LN3@find_first
	mov	rax, QWORD PTR [rcx+16]
	cmp	r8, rax
	jae	SHORT $LN3@find_first

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN22@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	r8, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN23@find_first
$LN22@find_first:
	mov	r8, r10
$LN23@find_first:
	cmp	QWORD PTR [rcx+24], 8

; 1955 : 			{	// room for match, look for it
; 1956 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();

	lea	rbx, QWORD PTR [r8+rax*2]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN40@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN41@find_first
$LN40@find_first:
	mov	rax, r10
$LN41@find_first:

; 1957 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;

	lea	rdx, QWORD PTR [rax+r11*2]

; 1958 : 				_Uptr < _Vptr; ++_Uptr)

	cmp	rdx, rbx
	jae	SHORT $LN3@find_first
	npad	4
$LL4@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 326  : 		return (_Count == 0 ? (const _Elem *)0

	test	r9, r9
	je	SHORT $LN76@find_first
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 204  :             if (*_S == _C)

	movzx	r8d, WORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 326  : 		return (_Count == 0 ? (const _Elem *)0

	mov	rcx, r9
	mov	rax, rsi
	npad	1
$LL51@find_first:
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 204  :             if (*_S == _C)

	cmp	WORD PTR [rax], r8w
	je	SHORT $LN69@find_first

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rax, 2
	sub	rcx, 1
	jne	SHORT $LL51@find_first
$LN76@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1958 : 				_Uptr < _Vptr; ++_Uptr)

	add	rdx, 2
	cmp	rdx, rbx
	jb	SHORT $LL4@find_first
$LN3@find_first:

; 1959 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1960 : 					return (_Uptr - this->_Myptr());	// found a match
; 1961 : 			}
; 1962 : 
; 1963 : 		return (npos);	// no match

	or	rax, -1

; 1964 : 		}

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	ret	0
$LN69@find_first:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [r10+24], 8
	jb	SHORT $LN62@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	r10, QWORD PTR [r10]
$LN62@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1964 : 		}

	mov	rbx, QWORD PTR [rsp+8]
	sub	rdx, r10
	mov	rsi, QWORD PTR [rsp+16]
	sar	rdx, 1
	mov	rax, rdx
	ret	0
?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KPEB_W_K1@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_of
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z
_TEXT	SEGMENT
this$ = 16
_Right$ = 24
_Off$ = 32
?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_of, COMDAT

; 1946 : 		{	// look for one of _Right at or after _Off

$LN101:
	sub	rsp, 8

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rdx+24], 8

; 1946 : 		{	// look for one of _Right at or after _Off

	mov	r11, rdx

; 1765 : 		return (this->_Mysize());

	mov	r10, QWORD PTR [rdx+16]

; 1946 : 		{	// look for one of _Right at or after _Off

	mov	r9, rcx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN19@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	r11, QWORD PTR [rdx]
$LN19@find_first:
	mov	QWORD PTR [rsp], rbx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1954 : 		if (0 < _Count && _Off < this->_Mysize())

	test	r10, r10
	je	SHORT $LN25@find_first
	mov	rax, QWORD PTR [rcx+16]
	cmp	r8, rax
	jae	SHORT $LN25@find_first

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN45@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN45@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [r9+24], 8

; 1956 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();

	lea	rbx, QWORD PTR [rcx+rax*2]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN62@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [r9]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN63@find_first
$LN62@find_first:
	mov	rax, r9
$LN63@find_first:

; 1957 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;

	lea	rdx, QWORD PTR [rax+r8*2]

; 1958 : 				_Uptr < _Vptr; ++_Uptr)

	cmp	rdx, rbx
	jae	SHORT $LN25@find_first
$LL26@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 326  : 		return (_Count == 0 ? (const _Elem *)0

	test	r10, r10
	je	SHORT $LN98@find_first
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 204  :             if (*_S == _C)

	movzx	r8d, WORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 326  : 		return (_Count == 0 ? (const _Elem *)0

	mov	rcx, r10
	mov	rax, r11
	npad	1
$LL73@find_first:
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 204  :             if (*_S == _C)

	cmp	WORD PTR [rax], r8w
	je	SHORT $LN91@find_first

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rax, 2
	sub	rcx, 1
	jne	SHORT $LL73@find_first
$LN98@find_first:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1958 : 				_Uptr < _Vptr; ++_Uptr)

	add	rdx, 2
	cmp	rdx, rbx
	jb	SHORT $LL26@find_first
$LN25@find_first:

; 1947 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));

	or	rax, -1
	mov	rbx, QWORD PTR [rsp]

; 1948 : 		}

	add	rsp, 8
	ret	0
$LN91@find_first:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [r9+24], 8
	jb	SHORT $LN84@find_first
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	r9, QWORD PTR [r9]
$LN84@find_first:
	mov	rbx, QWORD PTR [rsp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1960 : 					return (_Uptr - this->_Myptr());	// found a match

	sub	rdx, r9
	sar	rdx, 1

; 1947 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));

	mov	rax, rdx

; 1948 : 		}

	add	rsp, 8
	ret	0
?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_of
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH

; 1772 : 		}

	ret	0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT

; 1765 : 		return (this->_Mysize());

	mov	rax, QWORD PTR [rcx+16]

; 1766 : 		}

	ret	0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN11@c_str

; 1743 : 		return (this->_Myptr());

	mov	rax, QWORD PTR [rcx]

; 1744 : 		}

	ret	0
$LN11@c_str:

; 1743 : 		return (this->_Myptr());

	mov	rax, rcx

; 1744 : 		}

	ret	0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K0@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
_Count$ = 64
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K0@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

$LN79:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2271 : 		if (this->_Mysize() < _Off)

	mov	rdi, QWORD PTR [rcx+16]

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

	mov	r9, r8
	mov	rbx, rcx

; 2271 : 		if (this->_Mysize() < _Off)

	cmp	rdi, rdx
	jae	SHORT $LN7@erase

; 2283 : 		_Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN7@erase:

; 1348 : 		_Check_offset(_Off);
; 1349 : 		if (this->_Mysize() - _Off <= _Count)

	mov	rax, rdi
	sub	rax, rdx
	cmp	rax, r9
	ja	SHORT $LN2@erase

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rdx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN34@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN34@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [rcx+rdx*2], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	rax, rbx

; 1359 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@erase:

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1351 : 		else if (0 < _Count)

	test	r9, r9
	je	SHORT $LN4@erase

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN47@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN48@erase
$LN47@erase:
	mov	rax, rbx
$LN48@erase:

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

	sub	rdi, r9
	lea	rcx, QWORD PTR [rax+rdx*2]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	r8, rdi
	sub	r8, rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 333  : 		return (_Count == 0 ? _First1

	je	SHORT $LN60@erase
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	add	r8, r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	rdx, QWORD PTR [rcx+r9*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	call	QWORD PTR __imp_memmove
$LN60@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rdi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN71@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN72@erase
$LN71@erase:
	mov	rcx, rbx
$LN72@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [rcx+rdi*2], ax
$LN4@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	rax, rbx

; 1359 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN78@erase:
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K0@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT

; 1340 : 		{	// erase elements [_Off, ...)

$LN32:
	sub	rsp, 40					; 00000028H

; 2271 : 		if (this->_Mysize() < _Off)

	cmp	QWORD PTR [rcx+16], rdx
	jae	SHORT $LN4@erase

; 2283 : 		_Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN4@erase:

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rdx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN24@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	xor	r8d, r8d
	mov	WORD PTR [rax+rdx*2], r8w
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1343 : 		return (*this);

	mov	rax, rcx

; 1344 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN24@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	xor	r8d, r8d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	rax, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rcx+rdx*2], r8w
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1344 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN31@erase:
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 303  : 		return (*_First == 0 ? 0

	cmp	WORD PTR [rdx], 0
	jne	SHORT $LN5@assign
	xor	r8d, r8d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	jmp	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN5@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 303  : 		return (*_First == 0 ? 0

	or	r8, -1
$LL7@assign:
	inc	r8
	cmp	WORD PTR [rdx+r8*2], 0
	jne	SHORT $LL7@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	jmp	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

$LN155:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	rdx, rdx
	je	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	rdx, QWORD PTR [rcx+24]
	cmp	rdx, 8
	jb	SHORT $LN18@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN19@assign
$LN18@assign:
	mov	rax, rbx
$LN19@assign:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	rsi, rax
	jb	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	rdx, 8
	jb	SHORT $LN31@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN31@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	rax, QWORD PTR [rbx+16]
	lea	rcx, QWORD PTR [rcx+rax*2]
	cmp	rcx, rsi
	jbe	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	rdx, 8
	jb	SHORT $LN48@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN49@assign
$LN48@assign:
	mov	rax, rbx
$LN49@assign:

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))
; 1168 : 			return (assign(*this,

	sub	rsi, rax
	mov	r9, rdi
	sar	rsi, 1
	mov	rdx, rbx
	mov	r8, rsi
	mov	rcx, rbx

; 1177 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1166 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1167 : 		if (_Inside(_Ptr))
; 1168 : 			return (assign(*this,

	jmp	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN2@assign:

; 2225 : 		if (max_size() < _Newsize)

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH
	cmp	rdi, rax
	jbe	SHORT $LN53@assign

; 2266 : 		_Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN53@assign:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	QWORD PTR [rbx+24], rdi
	jae	SHORT $LN54@assign

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	mov	r8, QWORD PTR [rbx+16]
	mov	rdx, rdi
	mov	rcx, rbx
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	rdi, rdi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

	je	SHORT $LN3@assign
$LN153@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN126@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN127@assign
$LN54@assign:

; 2232 : 		else if (_Newsize == 0)

	test	rdi, rdi
	jne	SHORT $LN153@assign

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN111@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rcx], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (*this);

	mov	rax, rbx

; 1177 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN111@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rbx], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	rcx, rbx

; 1176 : 		return (*this);

	mov	rax, rbx

; 1177 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN126@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	rcx, rbx
$LN127@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 310  : 		return (_Count == 0 ? _First1

	test	rdi, rdi
	je	SHORT $LN133@assign
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	r8, QWORD PTR [rdi+rdi]
	mov	rdx, rsi
	call	memcpy
$LN133@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rdi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN144@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN145@assign
$LN144@assign:
	mov	rcx, rbx
$LN145@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [rcx+rdi*2], ax
$LN3@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1177 : 		}

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN154@assign:
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
_Roff$ = 64
_Count$ = 72
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

$LN171:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 2271 : 		if (this->_Mysize() < _Off)

	mov	rax, QWORD PTR [rdx+16]

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

	mov	rdi, r9
	mov	r14, r8
	mov	rsi, rdx
	mov	rbx, rcx

; 2271 : 		if (this->_Mysize() < _Off)

	cmp	rax, r8
	jae	SHORT $LN7@assign

; 2283 : 		_Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN7@assign:

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	sub	rax, r14

; 2113 : 		if (_Size <= _Max_effective_size)

	cmp	rdi, rax
	cmova	rdi, rax

; 1150 : 		_Right._Check_offset(_Roff);
; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1152 : 
; 1153 : 		if (this == &_Right)

	cmp	rbx, rsi
	jne	SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	lea	rcx, QWORD PTR [r8+rdi]

; 2271 : 		if (this->_Mysize() < _Off)

	cmp	QWORD PTR [rbx+16], rcx
	jae	SHORT $LN32@assign

; 2283 : 		_Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN32@assign:

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rcx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN52@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rdx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN53@assign
$LN52@assign:
	mov	rdx, rbx
$LN53@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [rdx+rcx*2], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	xor	edx, edx
	mov	rcx, rbx
	call	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase

; 1155 : 		else if (_Grow(_Count))

	jmp	$LN4@assign
$LN2@assign:

; 2225 : 		if (max_size() < _Newsize)

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH
	cmp	rdi, rax
	jbe	SHORT $LN59@assign

; 2266 : 		_Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN59@assign:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	QWORD PTR [rcx+24], rdi
	jae	SHORT $LN60@assign

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	mov	r8, QWORD PTR [rcx+16]
	mov	rdx, rdi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	rdi, rdi

; 1155 : 		else if (_Grow(_Count))

	je	SHORT $LN4@assign
$LN169@assign:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rsi+24], 8
	jb	SHORT $LN131@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rsi, QWORD PTR [rsi]
$LN131@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN143@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN144@assign
$LN60@assign:

; 2232 : 		else if (_Newsize == 0)

	test	rdi, rdi
	jne	SHORT $LN169@assign

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN118@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN118@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rcx], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	jmp	SHORT $LN4@assign
$LN143@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	rcx, rbx
$LN144@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 310  : 		return (_Count == 0 ? _First1

	test	rdi, rdi
	je	SHORT $LN150@assign
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	r8, QWORD PTR [rdi+rdi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1157 : 			_Traits::copy(this->_Myptr(),

	lea	rdx, QWORD PTR [rsi+r14*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	call	memcpy
$LN150@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rdi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN161@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN162@assign
$LN161@assign:
	mov	rcx, rbx
$LN162@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [rcx+rdi*2], ax
$LN4@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1162 : 		}

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN170@assign:
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 1016 : 		{	// destroy the string

$LN79:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	r8, QWORD PTR [rcx+24]
	cmp	r8, 8
	jb	SHORT $LN6@basic_stri

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	r8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rdx, QWORD PTR [rcx]
	call	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
	npad	1
$LN6@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	ecx, ecx
	mov	QWORD PTR [rbx+16], rcx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8
	jb	SHORT $LN73@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rax], cx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN74@basic_stri
$LN73@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rbx], cx
$LN74@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1018 : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv, COMDAT

; 961  : 		{	// assign by moving _Right

$LN176:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

	xor	edi, edi
	mov	rbx, rdx
	cmp	QWORD PTR [rdx+24], 8
	mov	rsi, rcx
	jae	SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

	mov	r8, QWORD PTR [rdx+16]
	add	r8, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 333  : 		return (_Count == 0 ? _First1

	je	SHORT $LN3@Assign_rv
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	add	r8, r8
	call	QWORD PTR __imp_memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 965  : 		else

	jmp	SHORT $LN3@Assign_rv
$LN2@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	rsi, rsi
	je	SHORT $LN63@Assign_rv
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN63@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 968  : 			_Right._Bx()._Ptr = pointer();

	mov	QWORD PTR [rdx], rdi
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rsi+16], rax

; 971  : 		this->_Myres() = _Right._Myres();

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR [rsi+24], rax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rbx+24], 8

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], rdi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN169@Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rax], di
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 973  : 		}

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN169@Assign_rv:
	mov	rsi, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rbx], di
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 973  : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 911  : 		{	// construct by moving _Right

$LN97:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rcx], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
	npad	1

; 914  : 		}

	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@PEB_W@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@PEB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 836  : 		{	// construct from [_Ptr, <null>)

$LN93:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	r8d, r8d

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], r8

; 836  : 		{	// construct from [_Ptr, <null>)

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rcx], r8w

; 303  : 		return (*_First == 0 ? 0

	cmp	WORD PTR [rdx], r8w
	je	SHORT $LN90@basic_stri
	or	r8, -1
	npad	10
$LL91@basic_stri:
	inc	r8
	cmp	WORD PTR [rdx+r8*2], 0
	jne	SHORT $LL91@basic_stri
$LN90@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);
; 839  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@PEB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
_Roff$ = 64
_Count$ = 72
_Al$ = 80
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 815  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator

$LN90:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rax

; 815  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rcx], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 817  : 		assign(_Right, _Roff, _Count);

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 818  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 780  : 		{	// construct by copying _Right

$LN100:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	xor	eax, eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rax

; 781  : 		_Tidy();
; 782  : 		assign(_Right, 0, npos);

	or	r9, -1
	xor	r8d, r8d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 345  : 		_Left = _Right;

	mov	WORD PTR [rcx], ax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 780  : 		{	// construct by copying _Right

	mov	rbx, rcx

; 781  : 		_Tidy();
; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 783  : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
	ret	0
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT

; 320  : 		return (_Myval2);

	mov	rax, rcx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT

; 315  : 		return (_Myval2);

	mov	rax, rcx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 300  : 		return (*this);

	mov	rax, rcx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 295  : 		return (*this);

	mov	rax, rcx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEA_KXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres, COMDAT

; 734  : 		return (_Get_data()._Myres);

	lea	rax, QWORD PTR [rcx+24]

; 735  : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEA_KXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEB_KXZ
_TEXT	SEGMENT
this$ = 8
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEB_KXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT

; 729  : 		return (_Get_data()._Mysize);

	lea	rax, QWORD PTR [rcx+16]

; 730  : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEB_KXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEA_KXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT

; 724  : 		return (_Get_data()._Mysize);

	lea	rax, QWORD PTR [rcx+16]

; 725  : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEA_KXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx, COMDAT

; 714  : 		return (_Get_data()._Bx);

	mov	rax, rcx

; 715  : 		}

	ret	0
?_Bx@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAT_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT

; 707  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 708  : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT

; 702  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 703  : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT

; 697  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 698  : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT

; 692  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 693  : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT

; 496  : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 497  : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax

; 590  : 		}

	mov	rax, rcx
	ret	0
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAPEB_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN9@Myptr

; 583  : 		return (_Get_data()._Myptr());

	mov	rax, QWORD PTR [rcx]

; 584  : 		}

	ret	0
$LN9@Myptr:

; 583  : 		return (_Get_data()._Myptr());

	mov	rax, rcx

; 584  : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAPEB_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAPEA_WXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAPEA_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN9@Myptr

; 578  : 		return (_Get_data()._Myptr());

	mov	rax, QWORD PTR [rcx]

; 579  : 		}

	ret	0
$LN9@Myptr:

; 578  : 		return (_Get_data()._Myptr());

	mov	rax, rcx

; 579  : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAPEA_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
	ret	0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT

; 534  : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

	mov	rax, rcx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN3@Myptr
	mov	rax, QWORD PTR [rcx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

	ret	0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	mov	rax, rcx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	QWORD PTR [rcx+24], 8
	jb	SHORT $LN3@Myptr
	mov	rax, QWORD PTR [rcx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

	ret	0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	rax, rcx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT

; 496  : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 497  : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax

; 499  : 		}

	mov	rax, rcx
	ret	0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEBA_KU_Nil@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEBA_KU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size, COMDAT

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 1009 : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEBA_KU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAAXPEA_W_K@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
_Count$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAAXPEA_W_K@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate, COMDAT

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	jmp	?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ; std::allocator<wchar_t>::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAAXPEA_W_K@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAAPEA_W_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAAPEA_W_K@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate, COMDAT

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAAPEA_W_K@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAA@$$QEAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT

; 947  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAA@$$QEAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT

; 937  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEBA?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
__formal$ = 24
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEBA?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	rax, rdx

; 914  : 		}

	ret	0
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QEBA?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 875  : 		return (_Al);

	mov	rax, rcx

; 876  : 		}

	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z
_TEXT	SEGMENT
_Al$ = 8
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@_W@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$allocator@_W@std@@QEBA_KXZ PROC		; std::allocator<wchar_t>::max_size, COMDAT

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@_W@std@@QEBA_KXZ ENDP		; std::allocator<wchar_t>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z PROC	; std::allocator<wchar_t>::allocate, COMDAT

; 724  : 		{	// allocate array of _Count elements

$LN15:
	sub	rsp, 40					; 00000028H

; 51   : 	if (_Count == 0)

	test	rdx, rdx
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	eax, eax
$LN3@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdx, rax
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	lea	rcx, QWORD PTR [rdx+rdx]

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	rax, QWORD PTR [rcx+39]

; 66   : 		if (_Block_size <= _User_size)

	cmp	rax, rcx
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	rax, rax
	jne	SHORT $LN9@allocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPEAX_K@Z				; operator new

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	rax, rax
	jne	SHORT $LN3@allocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN14@allocate:
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ENDP	; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT

; 719  : 		{	// deallocate object at _Ptr

$LN14:
	sub	rsp, 40					; 00000028H

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	r8, rax
	jbe	SHORT $LN4@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	lea	rax, QWORD PTR [r8+r8]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	dl, 31
	je	SHORT $LN6@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rdx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rdx
	jb	SHORT $LN7@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rdx, rax
	cmp	rdx, 8
	jae	SHORT $LN8@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rdx, 39					; 00000027H
	jbe	SHORT $LN9@deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rdx, rax
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	rcx, rdx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	add	rsp, 40					; 00000028H

; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN13@deallocate:
?deallocate@?$allocator@_W@std@@QEAAXPEA_W_K@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??0?$allocator@_W@std@@QEAA@AEBV01@@Z PROC		; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@_W@std@@QEAA@AEBV01@@Z ENDP		; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@_W@std@@QEAA@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@_W@std@@QEAA@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ
text$di	SEGMENT
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ PROC	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId'', COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR ?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A, xmm0

; 32   : 		static AssetId kInvalidId;

	ret	0
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ENDP	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ PROC		; MaxSDK::AssetManagement::AssetId::AssetId, COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR [rcx], xmm0
	mov	rax, rcx
	ret	0
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ ENDP		; MaxSDK::AssetManagement::AssetId::AssetId
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPEAX_K1@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Count$ = 56
_Sz$ = 64
?_Deallocate@std@@YAXPEAX_K1@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

$LN11:
	sub	rsp, 40					; 00000028H
	mov	r9, rdx

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	rax, -1
	xor	edx, edx
	div	r8
	cmp	r9, rax
	jbe	SHORT $LN2@Deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2@Deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	imul	r9, r8

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	r9, 4096				; 00001000H
	jb	SHORT $LN3@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31
	je	SHORT $LN4@Deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@Deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	rax, QWORD PTR [rcx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	rax, rcx
	jb	SHORT $LN5@Deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN5@Deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	rcx, rax
	cmp	rcx, 8
	jae	SHORT $LN6@Deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN6@Deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	rcx, 39					; 00000027H
	jbe	SHORT $LN7@Deallocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, rax
$LN3@Deallocate:

; 133  : 	}

	add	rsp, 40					; 00000028H

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPEAX@Z				; operator delete
$LN10@Deallocate:
?_Deallocate@std@@YAXPEAX_K1@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPEAX_K0_N@Z
_TEXT	SEGMENT
_Count$ = 48
_Sz$ = 56
_Try_aligned_allocation$ = 64
?_Allocate@std@@YAPEAX_K0_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

$LN12:
	sub	rsp, 40					; 00000028H
	mov	r9, rdx

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

	test	rcx, rcx
	jne	SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

	xor	eax, eax
$LN8@Allocate:

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	xor	edx, edx
	or	rax, -1
	div	r9
	cmp	rax, rcx
	jae	SHORT $LN3@Allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN3@Allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	imul	rcx, r9

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	test	r8b, r8b
	je	SHORT $LN4@Allocate
	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	rax, QWORD PTR [rcx+39]

; 66   : 		if (_Block_size <= _User_size)

	cmp	rax, rcx
	ja	SHORT $LN6@Allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	int	3
$LN6@Allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	rax, rax
	jne	SHORT $LN7@Allocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@Allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPEAX_K@Z				; operator new

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	rax, rax
	jne	SHORT $LN8@Allocate
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@Allocate:
?_Allocate@std@@YAPEAX_K0_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 55   : 		}

	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Swap_all@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Swap_all@_Container_base0@std@@QEAAXAEAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT

; 48   : 		}

	ret	0
?_Swap_all@_Container_base0@std@@QEAAXAEAU12@@Z ENDP	; std::_Container_base0::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 44   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@_W@std@@SAGXZ
_TEXT	SEGMENT
?eof@?$char_traits@_W@std@@SAGXZ PROC			; std::char_traits<wchar_t>::eof, COMDAT

; 386  : 		return (WEOF);

	mov	eax, 65535				; 0000ffffH

; 387  : 		}

	ret	0
?eof@?$char_traits@_W@std@@SAGXZ ENDP			; std::char_traits<wchar_t>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@_W@std@@SAGAEBG@Z
_TEXT	SEGMENT
_Meta$ = 8
?not_eof@?$char_traits@_W@std@@SAGAEBG@Z PROC		; std::char_traits<wchar_t>::not_eof, COMDAT

; 381  : 		return (_Meta != eof() ? _Meta : !eof());

	movzx	eax, WORD PTR [rcx]
	mov	ecx, 65535				; 0000ffffH
	cmp	ax, cx
	je	SHORT $LN3@not_eof
	movzx	eax, ax

; 382  : 		}

	ret	0
$LN3@not_eof:

; 381  : 		return (_Meta != eof() ? _Meta : !eof());

	xor	eax, eax

; 382  : 		}

	ret	0
?not_eof@?$char_traits@_W@std@@SAGAEBG@Z ENDP		; std::char_traits<wchar_t>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@_W@std@@SA_NAEBG0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq_int_type@?$char_traits@_W@std@@SA_NAEBG0@Z PROC	; std::char_traits<wchar_t>::eq_int_type, COMDAT

; 374  : 		{	// test for metacharacter equality

	movzx	eax, WORD PTR [rdx]
	cmp	WORD PTR [rcx], ax
	sete	al

; 375  : 		return (_Left == _Right);
; 376  : 		}

	ret	0
?eq_int_type@?$char_traits@_W@std@@SA_NAEBG0@Z ENDP	; std::char_traits<wchar_t>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@_W@std@@SAGAEB_W@Z
_TEXT	SEGMENT
_Ch$ = 8
?to_int_type@?$char_traits@_W@std@@SAGAEB_W@Z PROC	; std::char_traits<wchar_t>::to_int_type, COMDAT

; 369  : 		return (_Ch);

	movzx	eax, WORD PTR [rcx]

; 370  : 		}

	ret	0
?to_int_type@?$char_traits@_W@std@@SAGAEB_W@Z ENDP	; std::char_traits<wchar_t>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@_W@std@@SA_WAEBG@Z
_TEXT	SEGMENT
_Meta$ = 8
?to_char_type@?$char_traits@_W@std@@SA_WAEBG@Z PROC	; std::char_traits<wchar_t>::to_char_type, COMDAT

; 363  : 		return (_Meta);

	movzx	eax, WORD PTR [rcx]

; 364  : 		}

	ret	0
?to_char_type@?$char_traits@_W@std@@SA_WAEBG@Z ENDP	; std::char_traits<wchar_t>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq@?$char_traits@_W@std@@SA_NAEB_W0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq@?$char_traits@_W@std@@SA_NAEB_W0@Z PROC		; std::char_traits<wchar_t>::eq, COMDAT

; 350  : 		{	// test for element equality

	movzx	eax, WORD PTR [rdx]
	cmp	WORD PTR [rcx], ax
	sete	al

; 351  : 		return (_Left == _Right);
; 352  : 		}

	ret	0
?eq@?$char_traits@_W@std@@SA_NAEB_W0@Z ENDP		; std::char_traits<wchar_t>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAEA_WAEB_W@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$char_traits@_W@std@@SAXAEA_WAEB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 345  : 		_Left = _Right;

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax

; 346  : 		}

	ret	0
?assign@?$char_traits@_W@std@@SAXAEA_WAEB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@_W@std@@SAPEA_WPEA_WPEB_W_K@Z
_TEXT	SEGMENT
_First1$ = 8
_First2$ = 16
_Count$ = 24
?move@?$char_traits@_W@std@@SAPEA_WPEA_WPEB_W_K@Z PROC	; std::char_traits<wchar_t>::move, COMDAT

; 333  : 		return (_Count == 0 ? _First1

	test	r8, r8
	jne	SHORT $LN3@move
	mov	rax, rcx

; 335  : 		}

	ret	0
$LN3@move:
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	add	r8, r8
	rex_jmp	QWORD PTR __imp_memmove
?move@?$char_traits@_W@std@@SAPEA_WPEA_WPEB_W_K@Z ENDP	; std::char_traits<wchar_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?find@?$char_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Ch$ = 24
?find@?$char_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z PROC	; std::char_traits<wchar_t>::find, COMDAT

; 326  : 		return (_Count == 0 ? (const _Elem *)0

	test	rdx, rdx
	je	SHORT $LN7@find
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 204  :             if (*_S == _C)

	movzx	eax, WORD PTR [r8]
	npad	7
$LL8@find:
	cmp	WORD PTR [rcx], ax
	je	SHORT $LN12@find

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rcx, 2
	sub	rdx, 1
	jne	SHORT $LL8@find
$LN7@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 326  : 		return (_Count == 0 ? (const _Elem *)0

	xor	eax, eax

; 327  : 			: (const _Elem *)_CSTD wmemchr(_First, _Ch, _Count));
; 328  : 		}

	ret	0
$LN12@find:

; 326  : 		return (_Count == 0 ? (const _Elem *)0

	mov	rax, rcx

; 327  : 			: (const _Elem *)_CSTD wmemchr(_First, _Ch, _Count));
; 328  : 		}

	ret	0
?find@?$char_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z ENDP	; std::char_traits<wchar_t>::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@_W@std@@SAPEA_WPEA_WPEB_W_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$char_traits@_W@std@@SAPEA_WPEA_WPEB_W_K@Z PROC	; std::char_traits<wchar_t>::copy, COMDAT

; 309  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 310  : 		return (_Count == 0 ? _First1

	test	r8, r8
	je	SHORT $LN7@copy
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	add	r8, r8
	call	memcpy
$LN7@copy:
	mov	rax, rbx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 312  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?copy@?$char_traits@_W@std@@SAPEA_WPEA_WPEB_W_K@Z ENDP	; std::char_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@_W@std@@SA_KPEB_W@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$char_traits@_W@std@@SA_KPEB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 303  : 		return (*_First == 0 ? 0

	cmp	WORD PTR [rcx], 0
	jne	SHORT $LN3@length
	xor	eax, eax

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

	ret	0
$LN3@length:

; 303  : 		return (*_First == 0 ? 0

	or	rax, -1
	npad	3
$LL5@length:
	inc	rax
	cmp	WORD PTR [rcx+rax*2], 0
	jne	SHORT $LL5@length

; 304  : 			: _CSTD wcslen(_First));
; 305  : 		}

	ret	0
?length@?$char_traits@_W@std@@SA_KPEB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 48
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 304  : 	{

$LN4:
	sub	rsp, 40					; 00000028H

; 305  : 	return (_CSTD sqrtf(_Xx));

	call	sqrtf

; 306  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 48
?sin@@YAMM@Z PROC					; sin, COMDAT

; 294  : 	{

$LN4:
	sub	rsp, 40					; 00000028H

; 295  : 	return (_CSTD sinf(_Xx));

	call	sinf

; 296  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?fmod@@YAMMM@Z
_TEXT	SEGMENT
_Xx$ = 48
_Yx$ = 56
?fmod@@YAMMM@Z PROC					; fmod, COMDAT

; 153  : 	{

$LN4:
	sub	rsp, 40					; 00000028H

; 154  : 	return (_CSTD fmodf(_Xx, _Yx));

	call	fmodf

; 155  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?fmod@@YAMMM@Z ENDP					; fmod
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 48
?cos@@YAMM@Z PROC					; cos, COMDAT

; 87   : 	{

$LN4:
	sub	rsp, 40					; 00000028H

; 88   : 	return (_CSTD cosf(_Xx));

	call	cosf

; 89   : 	}

	add	rsp, 40					; 00000028H
	ret	0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\maxtypes.h
;	COMDAT ??0Class_ID@@QEAA@KK@Z
_TEXT	SEGMENT
this$ = 8
aa$ = 16
bb$ = 24
??0Class_ID@@QEAA@KK@Z PROC				; Class_ID::Class_ID, COMDAT

; 160  : 	Class_ID(ulong aa, ulong bb) { a = aa; b = bb; }

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	DWORD PTR [rcx+4], r8d
	ret	0
??0Class_ID@@QEAA@KK@Z ENDP				; Class_ID::Class_ID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??3@YAXPEAX0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
??3@YAXPEAX0@Z PROC					; operator delete, COMDAT

; 94   :         return;
; 95   :     }

	ret	0
??3@YAXPEAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 88   :         (void)_Size;
; 89   :         return _Where;

	mov	rax, rdx

; 90   :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
;	COMDAT wmemmove
_TEXT	SEGMENT
_S1$ = 8
_S2$ = 16
_N$ = 24
wmemmove PROC						; COMDAT

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	add	r8, r8
	rex_jmp	QWORD PTR __imp_memmove
wmemmove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
;	COMDAT wmemcpy
_TEXT	SEGMENT
_S1$ = 48
_S2$ = 56
_N$ = 64
wmemcpy	PROC						; COMDAT

; 231  :     {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	add	r8, r8
	mov	rbx, rcx
	call	memcpy
	mov	rax, rbx

; 235  :         #pragma warning(pop)
; 236  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
wmemcpy	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
;	COMDAT wmemchr
_TEXT	SEGMENT
_S$ = 8
_C$ = 16
_N$ = 24
wmemchr	PROC						; COMDAT

; 203  :         for (; 0 < _N; ++_S, --_N)

	test	r8, r8
	je	SHORT $LN3@wmemchr
$LL4@wmemchr:

; 204  :             if (*_S == _C)

	cmp	WORD PTR [rcx], dx
	je	SHORT $LN8@wmemchr

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rcx, 2
	sub	r8, 1
	jne	SHORT $LL4@wmemchr
$LN3@wmemchr:

; 206  : 
; 207  :         return 0;

	xor	eax, eax

; 208  :     }

	ret	0
$LN8@wmemchr:

; 205  :                 return (wchar_t _CONST_RETURN*)_S;

	mov	rax, rcx

; 208  :     }

	ret	0
wmemchr	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 8
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
__t$ = 48
__s$ = 56
__n$ = 64
__f$ = 72
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN12:
	test	r8, r8
	je	SHORT $LN10@vector
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r9
	mov	rbx, r8
	mov	rbp, rdx
	mov	rdi, rcx
$LL2@vector:
	mov	rcx, rdi
	call	rsi
	add	rdi, rbp
	sub	rbx, 1
	jne	SHORT $LL2@vector
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN10@vector:
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
