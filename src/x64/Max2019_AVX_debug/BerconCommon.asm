; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27031.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	WinbaseIsolationAwarePrivateT_UnPgpgk
PUBLIC	IsolationAwarePrivateT_SqbjaYRiRY
PUBLIC	IsolationAwarePrivateT_SAbnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
EXTRN	GUID_NULL:BYTE
;	COMDAT IsolationAwarePrivateT_SqbjaYRiRY
_BSS	SEGMENT
IsolationAwarePrivateT_SqbjaYRiRY DD 01H DUP (?)
_BSS	ENDS
;	COMDAT IsolationAwarePrivateT_SAbnPgpgk
_BSS	SEGMENT
IsolationAwarePrivateT_SAbnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_UnPgpgk
_DATA	SEGMENT
WinbaseIsolationAwarePrivateT_UnPgpgk DQ ffffffffffffffffH
_DATA	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ	; Tab<VertexNormalsCallback *>::~Tab<VertexNormalsCallback *>
PUBLIC	??0VertexNormalsControl@@QEAA@XZ		; VertexNormalsControl::VertexNormalsControl
PUBLIC	?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z ; BerconXYZ::update
PUBLIC	?update@BerconXYZ@@QEAAXXZ			; BerconXYZ::update
PUBLIC	?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z ; BerconXYZ::reset
PUBLIC	?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z ; BerconXYZ::get
PUBLIC	?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z ; BerconXYZ::get
PUBLIC	?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z ; BerconXYZ::get
PUBLIC	?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z ; BerconXYZ::get
PUBLIC	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z ; BerconXYZ::get
PUBLIC	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z ; BerconXYZ::get
PUBLIC	?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z ; BerconXYZ::seedRandomGen
PUBLIC	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
PUBLIC	?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z ; BerconXYZ::EnableStuff
PUBLIC	?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z ; BerconXYZ::getBasis
PUBLIC	__real@38d1b717
PUBLIC	__real@3c8efa35
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@46fffe00
PUBLIC	__real@49742400
PUBLIC	__real@c9742400
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__imp_srand:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp_?zfree@@YAXPEAPEAX@Z:PROC
EXTRN	__imp_??0Interval@@QEAA@HH@Z:PROC
EXTRN	__imp_?GetCOREInterface@@YAPEAVInterface@@XZ:PROC
EXTRN	__imp_??0Point3@@QEAA@XZ:PROC
EXTRN	__imp_??TPoint3@@QEBA?AV0@AEBV0@@Z:PROC
EXTRN	__imp_?Normalize@@YA?AVPoint3@@AEBV1@@Z:PROC
EXTRN	__imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z:PROC
EXTRN	__imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z:PROC
EXTRN	__imp_?IdentityMatrix@Matrix3@@QEAAXXZ:PROC
EXTRN	__imp_?Translate@Matrix3@@QEAAXAEBVPoint3@@@Z:PROC
EXTRN	__imp_?RotateX@Matrix3@@QEAAXM@Z:PROC
EXTRN	__imp_?RotateY@Matrix3@@QEAAXM@Z:PROC
EXTRN	__imp_?RotateZ@Matrix3@@QEAAXM@Z:PROC
EXTRN	__imp_?Scale@Matrix3@@QEAAXAEBVPoint3@@H@Z:PROC
EXTRN	__imp_?Invert@Matrix3@@QEAAXXZ:PROC
EXTRN	__imp_?ReleaseISpinner@@YAXPEAVISpinnerControl@@@Z:PROC
EXTRN	__imp_?SetupFloatSpinner@@YAPEAVISpinnerControl@@PEAUHWND__@@HHMMMM@Z:PROC
EXTRN	__imp_?SetupUniverseSpinner@@YAPEAVISpinnerControl@@PEAUHWND__@@HHMMMM@Z:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	_fltused:DWORD
_BSS	SEGMENT
?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A DB 010H DUP (?) ; MaxSDK::AssetManagement::kInvalidId
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+25
	DD	imagerel $unwind$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0VertexNormalsControl@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+36
	DD	imagerel $unwind$??0VertexNormalsControl@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z DD imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+48
	DD	imagerel $unwind$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z DD imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+48
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+257
	DD	imagerel $chain$1$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z DD imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+257
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+309
	DD	imagerel $chain$2$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z DD imagerel $LN14
	DD	imagerel $LN14+36
	DD	imagerel $unwind$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z DD imagerel $LN14+36
	DD	imagerel $LN14+1860
	DD	imagerel $chain$3$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z DD imagerel $LN14+1860
	DD	imagerel $LN14+1984
	DD	imagerel $chain$4$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?update@BerconXYZ@@QEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+407
	DD	imagerel $unwind$?update@BerconXYZ@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z DD imagerel $LN8
	DD	imagerel $LN8+24
	DD	imagerel $unwind$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z DD imagerel $LN8+24
	DD	imagerel $LN8+943
	DD	imagerel $chain$2$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z DD imagerel $LN8+943
	DD	imagerel $LN8+944
	DD	imagerel $chain$3$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z DD imagerel $LN6
	DD	imagerel $LN6+219
	DD	imagerel $unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z DD imagerel $LN41
	DD	imagerel $LN41+907
	DD	imagerel $unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z DD imagerel $LN6
	DD	imagerel $LN6+180
	DD	imagerel $unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z DD imagerel $LN42
	DD	imagerel $LN42+871
	DD	imagerel $unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z DD imagerel $LN66
	DD	imagerel $LN66+773
	DD	imagerel $unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z DD imagerel $LN66+773
	DD	imagerel $LN66+1050
	DD	imagerel $chain$0$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z DD imagerel $LN66+1050
	DD	imagerel $LN66+1158
	DD	imagerel $chain$1$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z DD imagerel $LN44
	DD	imagerel $LN44+373
	DD	imagerel $unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z DD imagerel $LN44+373
	DD	imagerel $LN44+509
	DD	imagerel $chain$0$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z DD imagerel $LN44+509
	DD	imagerel $LN44+638
	DD	imagerel $chain$1$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD imagerel $LN12
	DD	imagerel $LN12+107
	DD	imagerel $unwind$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD imagerel $LN12+107
	DD	imagerel $LN12+150
	DD	imagerel $chain$0$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD imagerel $LN12+150
	DD	imagerel $LN12+226
	DD	imagerel $chain$1$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD imagerel $LN12+226
	DD	imagerel $LN12+231
	DD	imagerel $chain$2$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD imagerel $LN12+231
	DD	imagerel $LN12+277
	DD	imagerel $chain$3$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD imagerel $LN31
	DD	imagerel $LN31+42
	DD	imagerel $unwind$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD imagerel $LN31+42
	DD	imagerel $LN31+143
	DD	imagerel $chain$2$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD imagerel $LN31+143
	DD	imagerel $LN31+189
	DD	imagerel $chain$3$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD imagerel $LN31+189
	DD	imagerel $LN31+271
	DD	imagerel $chain$4$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD imagerel $LN31+271
	DD	imagerel $LN31+279
	DD	imagerel $chain$5$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD imagerel $LN31+279
	DD	imagerel $LN31+649
	DD	imagerel $chain$6$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD imagerel $LN31+649
	DD	imagerel $LN31+704
	DD	imagerel $chain$7$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD imagerel $LN31+704
	DD	imagerel $LN31+1054
	DD	imagerel $chain$8$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD imagerel $LN13
	DD	imagerel $LN13+29
	DD	imagerel $unwind$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD imagerel $LN13+29
	DD	imagerel $LN13+66
	DD	imagerel $chain$0$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD imagerel $LN13+66
	DD	imagerel $LN13+691
	DD	imagerel $chain$2$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD imagerel $LN13+691
	DD	imagerel $LN13+707
	DD	imagerel $chain$3$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD imagerel $LN13+707
	DD	imagerel $LN13+708
	DD	imagerel $chain$4$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z DD imagerel $LN43
	DD	imagerel $LN43+416
	DD	imagerel $unwind$?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?kInvalidId$initializer$@AssetManagement@MaxSDK@@3P6AXXZEA DQ FLAT:??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ; MaxSDK::AssetManagement::kInvalidId$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c9742400
CONST	SEGMENT
__real@c9742400 DD 0c9742400r			; -1e+06
CONST	ENDS
;	COMDAT __real@49742400
CONST	SEGMENT
__real@49742400 DD 049742400r			; 1e+06
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
_DATA	SEGMENT
?BlinnClassID@@3VClass_ID@@A DD 038H			; BlinnClassID
	DD	00H
?AnisoShaderClassID@@3VClass_ID@@A DD 02857f460H	; AnisoShaderClassID
	DD	00H
?AnisoShaderDlgClassID@@3VClass_ID@@A DD 02857f460H	; AnisoShaderDlgClassID
	DD	00H
?OrenNayarBlinnShaderClassID@@3VClass_ID@@A DD 02857f421H ; OrenNayarBlinnShaderClassID
	DD	00H
?OrenNayarShaderDlgClassID@@3VClass_ID@@A DD 02857f422H	; OrenNayarShaderDlgClassID
	DD	00H
?StraussShaderClassID@@3VClass_ID@@A DD 02857f450H	; StraussShaderClassID
	DD	00H
?kTriObjNormalXTCID@@3VClass_ID@@B DD 0730a33d7H	; kTriObjNormalXTCID
	DD	027246c55H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z DD 061201H
	DD	0117412H
	DD	0103412H
	DD	0500bd212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+29
	DD	imagerel $unwind$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD 021H
	DD	imagerel $LN13+29
	DD	imagerel $LN13+66
	DD	imagerel $chain$0$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD 040a21H
	DD	0c740aH
	DD	0a3405H
	DD	imagerel $LN13+29
	DD	imagerel $LN13+66
	DD	imagerel $chain$0$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD 020521H
	DD	0b6405H
	DD	imagerel $LN13
	DD	imagerel $LN13+29
	DD	imagerel $unwind$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD 041401H
	DD	0d5414H
	DD	0e0107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+42
	DD	imagerel $unwind$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD 020021H
	DD	016d400H
	DD	imagerel $LN31
	DD	imagerel $LN31+42
	DD	imagerel $unwind$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD 021H
	DD	imagerel $LN31+42
	DD	imagerel $LN31+143
	DD	imagerel $chain$2$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD 021H
	DD	imagerel $LN31+143
	DD	imagerel $LN31+189
	DD	imagerel $chain$3$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD 020821H
	DD	010f408H
	DD	imagerel $LN31+143
	DD	imagerel $LN31+189
	DD	imagerel $chain$3$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD 020821H
	DD	0143408H
	DD	imagerel $LN31+42
	DD	imagerel $LN31+143
	DD	imagerel $chain$2$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD 061421H
	DD	017e414H
	DD	016d40dH
	DD	0156404H
	DD	imagerel $LN31
	DD	imagerel $LN31+42
	DD	imagerel $unwind$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD 0c2a01H
	DD	04982aH
	DD	058825H
	DD	067820H
	DD	076818H
	DD	011010cH
	DD	050047005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+107
	DD	imagerel $unwind$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN12+107
	DD	imagerel $LN12+150
	DD	imagerel $chain$0$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD 020521H
	DD	07e405H
	DD	imagerel $LN12+107
	DD	imagerel $LN12+150
	DD	imagerel $chain$0$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN12
	DD	imagerel $LN12+107
	DD	imagerel $unwind$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD 060f01H
	DD	09640fH
	DD	08540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z DD 021H
	DD	imagerel $LN44
	DD	imagerel $LN44+373
	DD	imagerel $unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z DD 020621H
	DD	057806H
	DD	imagerel $LN44
	DD	imagerel $LN44+373
	DD	imagerel $unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z DD 0a2101H
	DD	066821H
	DD	0146415H
	DD	0133415H
	DD	0e00ed215H
	DD	0500b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z DD 021H
	DD	imagerel $LN66
	DD	imagerel $LN66+773
	DD	imagerel $unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z DD 020621H
	DD	057806H
	DD	imagerel $LN66
	DD	imagerel $LN66+773
	DD	imagerel $unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z DD 0c2c01H
	DD	06682cH
	DD	0166419H
	DD	0153419H
	DD	0f012d219H
	DD	0d00ee010H
	DD	0500b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z DD 0d2501H
	DD	031c425H
	DD	0307425H
	DD	02f6425H
	DD	02e3425H
	DD	02a0125H
	DD	0e017f019H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z DD 071201H
	DD	0196412H
	DD	0183412H
	DD	0160112H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z DD 0d2501H
	DD	033c425H
	DD	0327425H
	DD	0316425H
	DD	0303425H
	DD	02c0125H
	DD	0e017f019H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z DD 091701H
	DD	01c6417H
	DD	01b5417H
	DD	01a3417H
	DD	0180117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z DD 021H
	DD	imagerel $LN8
	DD	imagerel $LN8+24
	DD	imagerel $unwind$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z DD 061621H
	DD	036816H
	DD	0be40dH
	DD	0a3405H
	DD	imagerel $LN8
	DD	imagerel $LN8+24
	DD	imagerel $unwind$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z DD 061801H
	DD	0d6418H
	DD	0c5418H
	DD	070147218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?update@BerconXYZ@@QEAAXXZ DD 040a01H
	DD	010340aH
	DD	07006d20aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+36
	DD	imagerel $unwind$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z DD 081a21H
	DD	013f41aH
	DD	014d413H
	DD	015c40bH
	DD	0165404H
	DD	imagerel $LN14
	DD	imagerel $LN14+36
	DD	imagerel $unwind$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z DD 062401H
	DD	0170124H
	DD	0701be01dH
	DD	03019601aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z DD 021H
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+48
	DD	imagerel $unwind$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z DD 041021H
	DD	012c410H
	DD	0117408H
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+48
	DD	imagerel $unwind$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z DD 060c01H
	DD	0f008920cH
	DD	06004e006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0VertexNormalsControl@@QEAA@XZ DD imagerel ??0VertexNormalsControl@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0VertexNormalsControl@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0VertexNormalsControl@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0VertexNormalsControl@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0VertexNormalsControl@@QEAA@XZ
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??0VertexNormalsControl@@QEAA@XZ
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0VertexNormalsControl@@QEAA@XZ DD 011111H
	DD	02209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0VertexNormalsControl@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ DD imagerel ??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 081901H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	070153219H
xdata	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?tiling@@YAHHAEAMAEAH@Z
_TEXT	SEGMENT
type$ = 8
x$ = 16
flip$ = 24
?tiling@@YAHHAEAMAEAH@Z PROC				; tiling, COMDAT

; 249  : 	switch (type) {

	sub	ecx, 1
	je	$LN4@tiling
	sub	ecx, 1
	je	$LN8@tiling
	sub	ecx, 1
	je	SHORT $LN10@tiling
	cmp	ecx, 1
	jne	$LN7@tiling

; 257  : 			return TRUE;				
; 258  : 		}
; 259  : 		case 4: {if (x<0||x>1) return FALSE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm1
	ja	SHORT $LN16@tiling
	vcomiss	xmm1, DWORD PTR __real@3f800000
	jbe	$LN7@tiling
$LN16@tiling:
	xor	eax, eax

; 260  : 	}
; 261  : 	return TRUE;
; 262  : }

	ret	0
$LN10@tiling:

; 252  : 		case 3: {
; 253  : 			if (x<0) x = -x;

	vmovss	xmm1, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN11@tiling
	vxorps	xmm1, xmm1, DWORD PTR __xmm@80000000800000008000000080000000
$LN11@tiling:

; 254  : 			int ix = (int)x;

	vcvttss2si eax, xmm1
	vxorps	xmm2, xmm2, xmm2

; 255  : 			if (ix%2==0) x = x - ix;

	vcvtsi2ss xmm2, xmm2, eax
	test	al, 1
	jne	SHORT $LN12@tiling
	vsubss	xmm0, xmm1, xmm2
	vmovss	DWORD PTR [rdx], xmm0
	mov	eax, 1

; 260  : 	}
; 261  : 	return TRUE;
; 262  : }

	ret	0
$LN12@tiling:

; 256  : 			else { x = 1.f - x + ix; flip = 1; }

	vmovss	xmm0, DWORD PTR __real@3f800000
	vsubss	xmm1, xmm0, xmm1
	vaddss	xmm2, xmm1, xmm2
	vmovss	DWORD PTR [rdx], xmm2
	mov	DWORD PTR [r8], 1
	mov	eax, 1

; 260  : 	}
; 261  : 	return TRUE;
; 262  : }

	ret	0
$LN8@tiling:

; 251  : 		case 2: {D_LOOP(x) return TRUE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vcvttss2si eax, xmm1
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vsubss	xmm2, xmm1, xmm0
	vxorps	xmm1, xmm1, xmm1
	vcomiss	xmm1, xmm2
	vmovss	DWORD PTR [rdx], xmm2
	jbe	SHORT $LN7@tiling
	vaddss	xmm0, xmm2, DWORD PTR __real@3f800000
	vmovss	DWORD PTR [rdx], xmm0
	mov	eax, 1

; 260  : 	}
; 261  : 	return TRUE;
; 262  : }

	ret	0
$LN4@tiling:

; 250  : 		case 1: {D_STRE(x) return TRUE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN5@tiling
	mov	DWORD PTR [rdx], 0
	mov	eax, 1

; 260  : 	}
; 261  : 	return TRUE;
; 262  : }

	ret	0
$LN5@tiling:

; 250  : 		case 1: {D_STRE(x) return TRUE;}

	vcomiss	xmm1, DWORD PTR __real@3f800000
	jbe	SHORT $LN7@tiling
	mov	DWORD PTR [rdx], 1065353216		; 3f800000H
$LN7@tiling:
	mov	eax, 1

; 260  : 	}
; 261  : 	return TRUE;
; 262  : }

	ret	0
?tiling@@YAHHAEAMAEAH@Z ENDP				; tiling
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?tiling@@YAHHAEAM@Z
_TEXT	SEGMENT
type$ = 8
x$ = 16
?tiling@@YAHHAEAM@Z PROC				; tiling, COMDAT

; 239  : 	switch (type) {

	sub	ecx, 1
	je	$LN4@tiling
	sub	ecx, 1
	je	SHORT $LN8@tiling
	sub	ecx, 1
	je	SHORT $LN10@tiling
	cmp	ecx, 1
	jne	$LN7@tiling

; 243  : 		case 4: {if (x<0||x>1) return FALSE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm1
	ja	SHORT $LN16@tiling
	vcomiss	xmm1, DWORD PTR __real@3f800000
	jbe	$LN7@tiling
$LN16@tiling:
	xor	eax, eax

; 244  : 	}
; 245  : 	return TRUE;
; 246  : }

	ret	0
$LN10@tiling:

; 242  : 		case 3: {D_MIRR(x) return TRUE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN11@tiling
	vxorps	xmm1, xmm1, DWORD PTR __xmm@80000000800000008000000080000000
$LN11@tiling:
	vcvttss2si eax, xmm1
	vxorps	xmm2, xmm2, xmm2
	vcvtsi2ss xmm2, xmm2, eax
	test	al, 1
	jne	SHORT $LN12@tiling
	vsubss	xmm0, xmm1, xmm2
	vmovss	DWORD PTR [rdx], xmm0

; 244  : 	}
; 245  : 	return TRUE;
; 246  : }

	mov	eax, 1
	ret	0
$LN12@tiling:

; 242  : 		case 3: {D_MIRR(x) return TRUE;}

	vmovss	xmm0, DWORD PTR __real@3f800000
	vsubss	xmm1, xmm0, xmm1
	vaddss	xmm0, xmm1, xmm2
	vmovss	DWORD PTR [rdx], xmm0

; 244  : 	}
; 245  : 	return TRUE;
; 246  : }

	mov	eax, 1
	ret	0
$LN8@tiling:

; 241  : 		case 2: {D_LOOP(x) return TRUE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vcvttss2si eax, xmm1
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vsubss	xmm2, xmm1, xmm0
	vxorps	xmm1, xmm1, xmm1
	vcomiss	xmm1, xmm2
	vmovss	DWORD PTR [rdx], xmm2
	jbe	SHORT $LN7@tiling
	vaddss	xmm0, xmm2, DWORD PTR __real@3f800000
	vmovss	DWORD PTR [rdx], xmm0

; 244  : 	}
; 245  : 	return TRUE;
; 246  : }

	mov	eax, 1
	ret	0
$LN4@tiling:

; 240  : 		case 1: {D_STRE(x) return TRUE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN5@tiling
	mov	DWORD PTR [rdx], 0

; 244  : 	}
; 245  : 	return TRUE;
; 246  : }

	mov	eax, 1
	ret	0
$LN5@tiling:

; 240  : 		case 1: {D_STRE(x) return TRUE;}

	vcomiss	xmm1, DWORD PTR __real@3f800000
	jbe	SHORT $LN7@tiling
	mov	DWORD PTR [rdx], 1065353216		; 3f800000H
$LN7@tiling:

; 244  : 	}
; 245  : 	return TRUE;
; 246  : }

	mov	eax, 1
	ret	0
?tiling@@YAHHAEAM@Z ENDP				; tiling
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 44
$T8 = 44
$T9 = 44
$T10 = 44
$T11 = 44
temp$12 = 56
this$ = 128
transform$ = 136
b$ = 144
?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z PROC	; BerconXYZ::getBasis, COMDAT

; 146  : void BerconXYZ::getBasis(Matrix3 transform, Point3* b) {

$LN43:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi
	push	rbp
	mov	rbp, rsp
	sub	rsp, 112				; 00000070H

; 147  : 	if (mappingType==4&&mode2D) {

	cmp	DWORD PTR [rcx], 4
	mov	rdi, r8
	mov	rbx, rdx
	jne	$LN2@getBasis
	cmp	DWORD PTR [rcx+260], 0
	je	$LN2@getBasis

; 148  : 		Matrix3 temp = transform;

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	xmm1, XMMWORD PTR [rdx+32]
	mov	eax, DWORD PTR [rdx+48]

; 149  : 		temp.Invert();

	lea	rcx, QWORD PTR temp$12[rbp-112]
	vmovups	YMMWORD PTR temp$12[rbp-112], ymm0
	vmovups	XMMWORD PTR temp$12[rbp-80], xmm1
	mov	DWORD PTR temp$12[rbp-64], eax
	vzeroupper
	call	QWORD PTR __imp_?Invert@Matrix3@@QEAAXXZ
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR temp$12[rbp-112]
	vmovss	xmm1, DWORD PTR temp$12[rbp-108]
	vmovss	DWORD PTR $T6[rbp-112], xmm0
	vmovss	xmm0, DWORD PTR temp$12[rbp-104]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 150  : 		b[0] = Normalize(temp.GetRow(0));

	lea	rdx, QWORD PTR $T6[rbp-112]
	lea	rcx, QWORD PTR $T11[rbp-112]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T6[rbp-104], xmm0
	vmovss	DWORD PTR $T6[rbp-108], xmm1
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 150  : 		b[0] = Normalize(temp.GetRow(0));

	call	QWORD PTR __imp_?Normalize@@YA?AVPoint3@@AEBV1@@Z
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm1, DWORD PTR temp$12[rbp-96]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 151  : 		b[1] = Normalize(temp.GetRow(1));

	lea	rdx, QWORD PTR $T5[rbp-112]
	lea	rcx, QWORD PTR $T10[rbp-112]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR temp$12[rbp-100]
	vmovss	DWORD PTR $T5[rbp-112], xmm0
	vmovss	xmm0, DWORD PTR temp$12[rbp-92]
	vmovss	DWORD PTR $T5[rbp-104], xmm0
	vmovss	DWORD PTR $T5[rbp-108], xmm1
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 150  : 		b[0] = Normalize(temp.GetRow(0));

	mov	DWORD PTR [rdi+8], eax

; 151  : 		b[1] = Normalize(temp.GetRow(1));

	call	QWORD PTR __imp_?Normalize@@YA?AVPoint3@@AEBV1@@Z
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm1, DWORD PTR temp$12[rbp-84]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 151  : 		b[1] = Normalize(temp.GetRow(1));

	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi+12], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR temp$12[rbp-88]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 151  : 		b[1] = Normalize(temp.GetRow(1));

	mov	eax, DWORD PTR [rax+8]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T4[rbp-112], xmm0
	vmovss	xmm0, DWORD PTR temp$12[rbp-80]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 153  : 	} else {

	jmp	$LN41@getBasis
$LN2@getBasis:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR [rdx]
	vmovss	xmm1, DWORD PTR [rdx+4]
	vmovss	DWORD PTR $T3[rbp-112], xmm0
	vmovss	xmm0, DWORD PTR [rdx+8]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 154  : 		b[0] = Normalize(transform.GetRow(0));

	lea	rdx, QWORD PTR $T3[rbp-112]
	lea	rcx, QWORD PTR $T9[rbp-112]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T3[rbp-104], xmm0
	vmovss	DWORD PTR $T3[rbp-108], xmm1
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 154  : 		b[0] = Normalize(transform.GetRow(0));

	call	QWORD PTR __imp_?Normalize@@YA?AVPoint3@@AEBV1@@Z
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm1, DWORD PTR [rbx+16]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 155  : 		b[1] = Normalize(transform.GetRow(1));

	lea	rdx, QWORD PTR $T2[rbp-112]
	lea	rcx, QWORD PTR $T8[rbp-112]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR [rbx+12]
	vmovss	DWORD PTR $T2[rbp-112], xmm0
	vmovss	xmm0, DWORD PTR [rbx+20]
	vmovss	DWORD PTR $T2[rbp-104], xmm0
	vmovss	DWORD PTR $T2[rbp-108], xmm1
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 154  : 		b[0] = Normalize(transform.GetRow(0));

	mov	DWORD PTR [rdi+8], eax

; 155  : 		b[1] = Normalize(transform.GetRow(1));

	call	QWORD PTR __imp_?Normalize@@YA?AVPoint3@@AEBV1@@Z
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm1, DWORD PTR [rbx+28]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 155  : 		b[1] = Normalize(transform.GetRow(1));

	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi+12], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR [rbx+24]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 155  : 		b[1] = Normalize(transform.GetRow(1));

	mov	eax, DWORD PTR [rax+8]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T1[rbp-112], xmm0
	vmovss	xmm0, DWORD PTR [rbx+32]
$LN41@getBasis:
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 158  : }

	lea	rdx, QWORD PTR $T1[rbp-112]
	mov	DWORD PTR [rdi+20], eax
	lea	rcx, QWORD PTR $T7[rbp-112]
	vmovss	DWORD PTR $T1[rbp-108], xmm1
	vmovss	DWORD PTR $T1[rbp-104], xmm0
	call	QWORD PTR __imp_?Normalize@@YA?AVPoint3@@AEBV1@@Z
	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+16]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi+24], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+32], eax
	mov	rdi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rbp
	ret	0
?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z ENDP	; BerconXYZ::getBasis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File g:\dropbox\github\berconmaps\src\berconcommon.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File g:\dropbox\github\berconmaps\src\berconcommon.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
_TEXT	SEGMENT
this$ = 80
pblock$ = 88
t$ = 96
?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z PROC	; BerconXYZ::EnableStuff, COMDAT

; 116  : void BerconXYZ::EnableStuff(IParamBlock2* pblock, TimeValue t) {	

$LN13:

; 117  : 	if (pblock) {

	test	rdx, rdx
	je	$LN11@EnableStuf
	mov	QWORD PTR [rsp+32], rbp
	push	r14
	sub	rsp, 64					; 00000040H

; 118  : 		IParamMap2 *map = pblock->GetMap();

	mov	rax, QWORD PTR [rdx]
	mov	r9, rdx
	mov	r14, rcx
	mov	QWORD PTR [rsp+88], rsi
	xor	edx, edx
	mov	rcx, r9
	mov	ebp, r8d
	call	QWORD PTR [rax+2328]
	mov	rsi, rax

; 119  : 		if (map) {

	test	rax, rax
	je	$LN10@EnableStuf

; 120  : 			map->Enable(xyz_size_y2, !lock);			

	mov	r10, QWORD PTR [rax]
	mov	rcx, rax
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+96], rdi
	xor	edi, edi
	cmp	DWORD PTR [r14+112], edi
	mov	r8d, edi
	sete	r8b
	xor	r9d, r9d
	lea	edx, QWORD PTR [rdi+18]
	call	QWORD PTR [r10+184]

; 121  : 			map->Enable(xyz_size_z2, !lock);

	cmp	DWORD PTR [r14+112], edi
	lea	edx, QWORD PTR [rdi+19]
	mov	rax, QWORD PTR [rsi]
	mov	r8d, edi
	sete	r8b
	mov	rcx, rsi
	xor	r9d, r9d
	call	QWORD PTR [rax+184]

; 122  : 
; 123  : 			bool s = mappingType==0; // || mappingType==1;
; 124  : 			map->Enable(xyz_tile_x, s);

	mov	rax, QWORD PTR [rsi]
	lea	edx, QWORD PTR [rdi+11]
	mov	ebx, edi
	mov	rcx, rsi
	cmp	DWORD PTR [r14], ebx
	sete	bl
	xor	r9d, r9d
	mov	r8d, ebx
	call	QWORD PTR [rax+184]

; 125  : 			map->Enable(xyz_tile_y, s);

	mov	rax, QWORD PTR [rsi]
	lea	edx, QWORD PTR [rdi+12]
	xor	r9d, r9d
	mov	r8d, ebx
	mov	rcx, rsi
	call	QWORD PTR [rax+184]

; 126  : 			map->Enable(xyz_tile_z, s);

	mov	rax, QWORD PTR [rsi]
	lea	edx, QWORD PTR [rdi+13]
	xor	r9d, r9d
	mov	r8d, ebx
	mov	rcx, rsi
	call	QWORD PTR [rax+184]
; File g:\dropbox\github\berconmaps\src\berconcommon.h

; 360  : 	int isRealworld() { return mappingType == 0 || mappingType == 4 ? 0 : 1; }

	test	DWORD PTR [r14], -5			; fffffffbH
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 130  : 			setSpinnerType(map, t, xyz_offset_x, IDC_OFF_X, IDC_OFF_X_SPIN, type, true);	

	mov	r9d, 1072				; 00000430H
	mov	BYTE PTR [rsp+48], 1
	mov	r8d, 2
; File g:\dropbox\github\berconmaps\src\berconcommon.h

; 360  : 	int isRealworld() { return mappingType == 0 || mappingType == 4 ? 0 : 1; }

	setne	dil
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 130  : 			setSpinnerType(map, t, xyz_offset_x, IDC_OFF_X, IDC_OFF_X_SPIN, type, true);	

	mov	edx, ebp
	mov	DWORD PTR [rsp+40], edi
	mov	rcx, rsi
	mov	DWORD PTR [rsp+32], 1073		; 00000431H
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 131  : 			setSpinnerType(map, t, xyz_offset_y, IDC_OFF_Y, IDC_OFF_Y_SPIN, type, true);	

	mov	BYTE PTR [rsp+48], 1
	mov	r9d, 1053				; 0000041dH
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 3
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1054		; 0000041eH
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 132  : 			setSpinnerType(map, t, xyz_offset_z, IDC_OFF_Z, IDC_OFF_Z_SPIN, type, true);	

	mov	BYTE PTR [rsp+48], 1
	mov	r9d, 1063				; 00000427H
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 4
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1064		; 00000428H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 133  : 			setSpinnerType(map, t, xyz_size_x, IDC_SIZ_X, IDC_SIZ_X_SPIN, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1055				; 0000041fH
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 5
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1056		; 00000420H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 134  : 			setSpinnerType(map, t, xyz_size_y, IDC_SIZ_Y, IDC_SIZ_Y_SPIN, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1059				; 00000423H
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 6
	mov	DWORD PTR [rsp+32], 1060		; 00000424H
	mov	edx, ebp
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 135  : 			setSpinnerType(map, t, xyz_size_z, IDC_SIZ_Z, IDC_SIZ_Z_SPIN, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1067				; 0000042bH
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 7
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1068		; 0000042cH
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 136  : 			setSpinnerType(map, t, xyz_offset_x2, IDC_OFF_X2, IDC_OFF_X_SPIN2, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1094				; 00000446H
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 14
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1095		; 00000447H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 137  : 			setSpinnerType(map, t, xyz_offset_y2, IDC_OFF_Y2, IDC_OFF_Y_SPIN2, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1101				; 0000044dH
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 15
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1102		; 0000044eH
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 138  : 			setSpinnerType(map, t, xyz_offset_z2, IDC_OFF_Z2, IDC_OFF_Z_SPIN2, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1108				; 00000454H
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 16
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1109		; 00000455H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 139  : 			setSpinnerType(map, t, xyz_size_x2, IDC_SIZ_X2, IDC_SIZ_X_SPIN2, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1096				; 00000448H
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 17
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1097		; 00000449H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 140  : 			setSpinnerType(map, t, xyz_size_y2, IDC_SIZ_Y2, IDC_SIZ_Y_SPIN2, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1103				; 0000044fH
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 18
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1104		; 00000450H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 141  : 			setSpinnerType(map, t, xyz_size_z2, IDC_SIZ_Z2, IDC_SIZ_Z_SPIN2, type);

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1110				; 00000456H
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 19
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1111		; 00000457H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType
	mov	rdi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+80]
$LN10@EnableStuf:

; 142  : 		}
; 143  : 	}
; 144  : }

	mov	rsi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
$LN11@EnableStuf:
	ret	0
?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z ENDP	; BerconXYZ::EnableStuff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
_TEXT	SEGMENT
scale$ = 32
$T1 = 48
$T2 = 48
$T3 = 48
this$ = 160
__$ReturnUdt$ = 168
sc$ = 176
inv$ = 184
?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z PROC ; BerconXYZ::random, COMDAT

; 178  : Matrix3 BerconXYZ::random(ShadeContext& sc, Matrix3* inv) {

$LN31:
	mov	rax, rsp
	push	rbp
	push	rdi
	sub	rsp, 136				; 00000088H

; 212  : 	if (p_randMat) { 		

	cmp	DWORD PTR [rcx+100], 0

; 178  : Matrix3 BerconXYZ::random(ShadeContext& sc, Matrix3* inv) {

	mov	rbp, rdx
	vmovaps	XMMWORD PTR [rax-40], xmm6
	mov	rdi, rcx
	vmovaps	XMMWORD PTR [rax-56], xmm7
	vmovaps	XMMWORD PTR [rax-72], xmm8
	vmovaps	XMMWORD PTR [rax-88], xmm9
	mov	QWORD PTR [rax+16], rsi

; 210  : 	int seed = 1;

	mov	esi, 1

; 178  : Matrix3 BerconXYZ::random(ShadeContext& sc, Matrix3* inv) {

	mov	QWORD PTR [rax+24], r13
	mov	r13, r9
	mov	QWORD PTR [rax+32], r14
	mov	r14, r8

; 212  : 	if (p_randMat) { 		

	je	SHORT $LN10@random

; 213  : 		seed += sc.mtlNum;

	mov	esi, DWORD PTR [r8+28]
	inc	esi
$LN10@random:

; 214  : 	}
; 215  : 	if (p_randObj) {

	cmp	DWORD PTR [rcx+96], 0
	je	SHORT $LN12@random

; 216  : 		INode *node=sc.Node();

	mov	rax, QWORD PTR [r8]
	mov	rcx, r14
	call	QWORD PTR [rax+72]

; 217  : 		if (node) {

	test	rax, rax
	je	SHORT $LN12@random

; 218  : 			int hand = (int) node->GetHandle();

	mov	rdx, QWORD PTR [rax]
	mov	rcx, rax
	call	QWORD PTR [rdx+2600]

; 219  : 			seed += hand*(hand*hand*15731 + 789221);

	mov	ecx, eax
	imul	ecx, eax
	imul	edx, ecx, 15731				; 00003d73H
	add	edx, 789221				; 000c0ae5H
	imul	edx, eax
	add	esi, edx
$LN12@random:

; 220  : 		}
; 221  : 	}
; 222  : 	if (p_randPar) {

	cmp	DWORD PTR [rdi+104], 0
	je	$LN15@random

; 223  : 		Object *ob = sc.GetEvalObject();		

	mov	rax, QWORD PTR [r14]
	mov	rcx, r14
	mov	QWORD PTR [rsp+160], rbx
	call	QWORD PTR [rax+80]
	mov	rbx, rax

; 224  : 		if (ob && ob->IsParticleSystem()) {

	test	rax, rax
	je	SHORT $LN27@random
	mov	rdx, QWORD PTR [rax]
	mov	rcx, rax
	call	QWORD PTR [rdx+1896]
	test	eax, eax
	je	SHORT $LN27@random

; 225  : 			ParticleObject *obj = (ParticleObject*)ob;
; 226  : 			IChkMtlAPI* chkMtlAPI = static_cast<IChkMtlAPI*>(obj->GetInterface(I_NEWMTLINTERFACE));

	mov	r8, QWORD PTR [rbx]
	mov	edx, 4752				; 00001290H
	mov	rcx, rbx
	mov	QWORD PTR [rsp+128], r15
	call	QWORD PTR [r8+72]
	mov	r15, rax

; 227  : 			if ((chkMtlAPI && chkMtlAPI->SupportsParticleIDbyFace())) {

	test	rax, rax
	je	SHORT $LN28@random
	mov	rdx, QWORD PTR [rax]
	mov	rcx, rax
	call	QWORD PTR [rdx]
	test	eax, eax
	je	SHORT $LN28@random

; 228  : 				int id = chkMtlAPI->GetParticleFromFace(sc.FaceNumber());

	mov	rdx, QWORD PTR [r14]
	mov	rcx, r14
	mov	rbx, QWORD PTR [r15]
	call	QWORD PTR [rdx+96]
	mov	edx, eax
	mov	rcx, r15
	call	QWORD PTR [rbx+8]

; 229  : 				seed += id*(id*id*571 + 789221);

	mov	ecx, eax
	imul	ecx, eax
	imul	edx, ecx, 571				; 0000023bH
	add	edx, 789221				; 000c0ae5H
	imul	edx, eax
	add	esi, edx
$LN28@random:
	mov	r15, QWORD PTR [rsp+128]
$LN27@random:
	mov	rbx, QWORD PTR [rsp+160]
$LN15@random:

; 230  : 			}			
; 231  : 		}
; 232  : 	}
; 233  : 
; 234  : 	seed *= p_seed;

	imul	esi, DWORD PTR [rdi+92]

; 235  : 	srand(seed*(seed*seed*15731 + 789221));	

	mov	eax, esi
	imul	eax, esi
	imul	ecx, eax, 15731				; 00003d73H
	add	ecx, 789221				; 000c0ae5H
	imul	ecx, esi
	call	QWORD PTR __imp_srand

; 182  : 	transform.IdentityMatrix();

	mov	rcx, rbp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h

; 172  :    Matrix3(){ flags = 0; }

	mov	DWORD PTR [rbp+48], 0
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 182  : 	transform.IdentityMatrix();

	call	QWORD PTR __imp_?IdentityMatrix@Matrix3@@QEAAXXZ

; 183  : 	transform.Translate(Point3(offX+offX2*URANDF(), offY+offY2*URANDF(), offZ+offZ2*URANDF()));

	call	QWORD PTR __imp_rand
	vmovss	xmm9, DWORD PTR __real@46fffe00
	vmovss	xmm8, DWORD PTR __real@3f800000
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm0, xmm0, xmm9
	vaddss	xmm1, xmm0, xmm0
	vsubss	xmm1, xmm1, xmm8
	vmulss	xmm0, xmm1, DWORD PTR [rdi+64]
	vaddss	xmm7, xmm0, DWORD PTR [rdi+16]
	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rdi+60]
	vaddss	xmm6, xmm0, DWORD PTR [rdi+12]
	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rdi+56]
	vaddss	xmm1, xmm0, DWORD PTR [rdi+8]
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rbp
	vmovss	DWORD PTR $T3[rsp], xmm1
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T3[rsp+4], xmm6
	vmovss	DWORD PTR $T3[rsp+8], xmm7
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 183  : 	transform.Translate(Point3(offX+offX2*URANDF(), offY+offY2*URANDF(), offZ+offZ2*URANDF()));

	call	QWORD PTR __imp_?Translate@Matrix3@@QEAAXAEBVPoint3@@@Z

; 184  :  	transform.RotateX(angX+angX2*URANDF());

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rdi+80]
	vaddss	xmm1, xmm0, DWORD PTR [rdi+32]
	mov	rcx, rbp
	call	QWORD PTR __imp_?RotateX@Matrix3@@QEAAXM@Z

; 185  : 	transform.RotateY(angY+angY2*URANDF());

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rdi+84]
	vaddss	xmm1, xmm0, DWORD PTR [rdi+36]
	mov	rcx, rbp
	call	QWORD PTR __imp_?RotateY@Matrix3@@QEAAXM@Z

; 186  : 	transform.RotateZ(angZ+angZ2*URANDF());	

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rdi+88]
	vaddss	xmm1, xmm0, DWORD PTR [rdi+40]
	mov	rcx, rbp
	call	QWORD PTR __imp_?RotateZ@Matrix3@@QEAAXM@Z
	mov	r14, QWORD PTR [rsp+184]
	mov	rsi, QWORD PTR [rsp+168]

; 187  : 
; 188  : 	if (inv) {

	test	r13, r13
	je	SHORT $LN2@random

; 189  : 		*inv = transform;

	vmovups	ymm0, YMMWORD PTR [rbp]
	vmovups	YMMWORD PTR [r13], ymm0
	vmovups	xmm1, XMMWORD PTR [rbp+32]
	vmovups	XMMWORD PTR [r13+32], xmm1
	mov	eax, DWORD PTR [rbp+48]

; 190  : 		inv->Invert();

	mov	rcx, r13
	mov	DWORD PTR [r13+48], eax
	vzeroupper
	call	QWORD PTR __imp_?Invert@Matrix3@@QEAAXXZ
$LN2@random:

; 191  : 	}
; 192  : 
; 193  : 	Point3 scale;
; 194  : 	if (lock) {

	cmp	DWORD PTR [rdi+112], 0
	mov	r13, QWORD PTR [rsp+176]
	je	SHORT $LN3@random

; 195  : 		float add = sizeX2*URANDF();

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rdi+68]

; 196  : 		scale = Point3(sizeX+add, sizeY+add, sizeZ+add);	

	vaddss	xmm4, xmm0, DWORD PTR [rdi+20]
	vaddss	xmm1, xmm0, DWORD PTR [rdi+24]
	vaddss	xmm0, xmm0, DWORD PTR [rdi+28]
	vunpcklps xmm1, xmm4, xmm1
	vmovsd	QWORD PTR scale$[rsp], xmm1
	vmovss	DWORD PTR $T2[rsp+8], xmm0

; 197  : 	} else {

	jmp	$LN29@random
$LN3@random:

; 198  : 		scale = Point3(sizeX+sizeX2*URANDF(), sizeY+sizeY2*URANDF(), sizeZ+sizeZ2*URANDF());

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rdi+76]
	vaddss	xmm7, xmm0, DWORD PTR [rdi+28]
	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rdi+72]
	vaddss	xmm6, xmm0, DWORD PTR [rdi+24]
	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rdi+68]
	vaddss	xmm1, xmm0, DWORD PTR [rdi+20]
	vunpcklps xmm0, xmm1, xmm6
	vmovsd	QWORD PTR scale$[rsp], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T1[rsp+8], xmm7
$LN29@random:
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 200  : 	if (scale.x < 0.0001f) scale.x = 0.0001f;

	vmovss	xmm5, DWORD PTR __real@38d1b717
	vmovss	xmm1, DWORD PTR scale$[rsp]

; 201  : 	if (scale.y < 0.0001f) scale.y = 0.0001f;

	vmovss	xmm2, DWORD PTR scale$[rsp+4]
	mov	eax, DWORD PTR $T1[rsp+8]

; 202  : 	if (scale.z < 0.0001f) scale.z = 0.0001f;
; 203  : 	scale.x = 1.f/scale.x; scale.y = 1.f/scale.y; scale.z = 1.f/scale.z;
; 204  : 	transform.Scale(scale);

	lea	rdx, QWORD PTR scale$[rsp]
	vcmpltss xmm0, xmm1, xmm5
	vblendvps xmm4, xmm1, xmm5, xmm0
	vcmpltss xmm0, xmm2, xmm5
	vblendvps xmm3, xmm2, xmm5, xmm0
	mov	DWORD PTR scale$[rsp+8], eax
	xor	r8d, r8d
	vmovss	xmm1, DWORD PTR scale$[rsp+8]
	vcmpltss xmm0, xmm1, xmm5
	vblendvps xmm2, xmm1, xmm5, xmm0
	vdivss	xmm0, xmm8, xmm4
	vmovss	DWORD PTR scale$[rsp], xmm0
	vdivss	xmm0, xmm8, xmm2
	vdivss	xmm1, xmm8, xmm3
	mov	rcx, rbp
	vmovss	DWORD PTR scale$[rsp+8], xmm0
	vmovss	DWORD PTR scale$[rsp+4], xmm1
	call	QWORD PTR __imp_?Scale@Matrix3@@QEAAXAEBVPoint3@@H@Z

; 205  : 
; 206  : 	return transform;
; 207  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+112]
	mov	rax, rbp
	vmovaps	xmm7, XMMWORD PTR [rsp+96]
	vmovaps	xmm8, XMMWORD PTR [rsp+80]
	vmovaps	xmm9, XMMWORD PTR [rsp+64]
	add	rsp, 136				; 00000088H
	pop	rdi
	pop	rbp
	ret	0
?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ENDP ; BerconXYZ::random
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
_TEXT	SEGMENT
this$ = 48
sc$ = 56
?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z PROC ; BerconXYZ::seedRandomGen, COMDAT

; 209  : void BerconXYZ::seedRandomGen(ShadeContext& sc) {

$LN12:
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 210  : 	int seed = 1;
; 211  : 
; 212  : 	if (p_randMat) { 		

	cmp	DWORD PTR [rcx+100], 0
	mov	rsi, rdx
	mov	rbp, rcx
	mov	edi, 1
	je	SHORT $LN2@seedRandom

; 213  : 		seed += sc.mtlNum;

	mov	edi, DWORD PTR [rdx+28]
	inc	edi
$LN2@seedRandom:

; 214  : 	}
; 215  : 	if (p_randObj) {

	cmp	DWORD PTR [rcx+96], 0
	je	SHORT $LN4@seedRandom

; 216  : 		INode *node=sc.Node();

	mov	rax, QWORD PTR [rdx]
	mov	rcx, rsi
	call	QWORD PTR [rax+72]

; 217  : 		if (node) {

	test	rax, rax
	je	SHORT $LN4@seedRandom

; 218  : 			int hand = (int) node->GetHandle();

	mov	rdx, QWORD PTR [rax]
	mov	rcx, rax
	call	QWORD PTR [rdx+2600]

; 219  : 			seed += hand*(hand*hand*15731 + 789221);

	mov	ecx, eax
	imul	ecx, eax
	imul	edx, ecx, 15731				; 00003d73H
	add	edx, 789221				; 000c0ae5H
	imul	edx, eax
	add	edi, edx
$LN4@seedRandom:

; 220  : 		}
; 221  : 	}
; 222  : 	if (p_randPar) {

	cmp	DWORD PTR [rbp+104], 0
	je	$LN7@seedRandom

; 223  : 		Object *ob = sc.GetEvalObject();		

	mov	rax, QWORD PTR [rsi]
	mov	rcx, rsi
	mov	QWORD PTR [rsp+48], rbx
	call	QWORD PTR [rax+80]
	mov	rbx, rax

; 224  : 		if (ob && ob->IsParticleSystem()) {

	test	rax, rax
	je	SHORT $LN9@seedRandom
	mov	rdx, QWORD PTR [rax]
	mov	rcx, rax
	call	QWORD PTR [rdx+1896]
	test	eax, eax
	je	SHORT $LN9@seedRandom

; 225  : 			ParticleObject *obj = (ParticleObject*)ob;
; 226  : 			IChkMtlAPI* chkMtlAPI = static_cast<IChkMtlAPI*>(obj->GetInterface(I_NEWMTLINTERFACE));

	mov	r8, QWORD PTR [rbx]
	mov	edx, 4752				; 00001290H
	mov	rcx, rbx
	mov	QWORD PTR [rsp+56], r14
	call	QWORD PTR [r8+72]
	mov	r14, rax

; 227  : 			if ((chkMtlAPI && chkMtlAPI->SupportsParticleIDbyFace())) {

	test	rax, rax
	je	SHORT $LN10@seedRandom
	mov	rdx, QWORD PTR [rax]
	mov	rcx, rax
	call	QWORD PTR [rdx]
	test	eax, eax
	je	SHORT $LN10@seedRandom

; 228  : 				int id = chkMtlAPI->GetParticleFromFace(sc.FaceNumber());

	mov	rdx, QWORD PTR [rsi]
	mov	rcx, rsi
	mov	rbx, QWORD PTR [r14]
	call	QWORD PTR [rdx+96]
	mov	edx, eax
	mov	rcx, r14
	call	QWORD PTR [rbx+8]

; 229  : 				seed += id*(id*id*571 + 789221);

	mov	ecx, eax
	imul	ecx, eax
	imul	edx, ecx, 571				; 0000023bH
	add	edx, 789221				; 000c0ae5H
	imul	edx, eax
	add	edi, edx
$LN10@seedRandom:
	mov	r14, QWORD PTR [rsp+56]
$LN9@seedRandom:
	mov	rbx, QWORD PTR [rsp+48]
$LN7@seedRandom:

; 230  : 			}			
; 231  : 		}
; 232  : 	}
; 233  : 
; 234  : 	seed *= p_seed;

	imul	edi, DWORD PTR [rbp+92]

; 235  : 	srand(seed*(seed*seed*15731 + 789221));	

	mov	eax, edi
	imul	eax, edi
	imul	ecx, eax, 15731				; 00003d73H
	add	ecx, 789221				; 000c0ae5H
	imul	ecx, edi

; 236  : }

	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 235  : 	srand(seed*(seed*seed*15731 + 789221));	

	rex_jmp	QWORD PTR __imp_srand
?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z ENDP ; BerconXYZ::seedRandomGen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point2.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z
_TEXT	SEGMENT
duv$1 = 32
$T2 = 32
$T3 = 32
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 60
$T10 = 60
$T11 = 60
$T12 = 60
$T13 = 60
uv$14 = 144
this$ = 144
sc$ = 152
p$ = 160
transform$ = 168
flips$ = 176
?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z PROC ; BerconXYZ::get, COMDAT

; 312  : int BerconXYZ::get(ShadeContext& sc, Point3& p, Matrix3 transform, int* flips) {

$LN44:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rbp
	push	rdi
	push	r14
	mov	rbp, rsp
	sub	rsp, 112				; 00000070H

; 313  : 	switch (mappingType) {

	mov	r10d, DWORD PTR [rcx]
	mov	r14, r9
	vmovaps	XMMWORD PTR [rsp+96], xmm6
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx
	test	r10d, r10d
	je	$LN4@get
	sub	r10d, 1
	je	$LN17@get
	sub	r10d, 1
	je	$LN18@get
	sub	r10d, 1
	je	SHORT $LN19@get
	cmp	r10d, 1
	jne	$LN16@get

; 334  : 			sc.ScreenUV(uv, duv);

	mov	rax, QWORD PTR [rdx]
	lea	r8, QWORD PTR duv$1[rbp-112]
	vxorps	xmm6, xmm6, xmm6
	lea	rdx, QWORD PTR uv$14[rbp-112]
	mov	rcx, rsi
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point2.h

; 50   : 	Point2() : x(0.0f), y(0.0f) {}

	vmovss	DWORD PTR uv$14[rbp-112], xmm6
	vmovss	DWORD PTR uv$14[rbp-108], xmm6
	vmovss	DWORD PTR duv$1[rbp-112], xmm6
	vmovss	DWORD PTR duv$1[rbp-108], xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 334  : 			sc.ScreenUV(uv, duv);

	call	QWORD PTR [rax+272]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR uv$14[rbp-112]
	vmovss	xmm1, DWORD PTR uv$14[rbp-108]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 335  : 			p = transform * Point3(uv.x, uv.y, 0.f);

	lea	r8, QWORD PTR $T4[rbp-112]
	mov	rdx, r14
	lea	rcx, QWORD PTR $T9[rbp-112]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T4[rbp-112], xmm0
	vmovss	DWORD PTR $T4[rbp-108], xmm1
	vmovss	DWORD PTR $T4[rbp-104], xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 335  : 			p = transform * Point3(uv.x, uv.y, 0.f);

	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+8], eax

; 336  : 			break;}
; 337  : 		}
; 338  : 	return TRUE;

	mov	eax, 1
	jmp	$LN1@get
$LN19@get:

; 328  : 			break;}
; 329  : 		case 3: {
; 330  : 			p = transform * sc.PointTo(sc.P(),REF_WORLD);

	mov	rbx, QWORD PTR [rdx]
	mov	rcx, rsi
	lea	rdx, QWORD PTR $T10[rbp-112]
	call	QWORD PTR [rbx+208]
	mov	r9d, 1

; 331  : 			break;}

	jmp	SHORT $LN42@get
$LN18@get:

; 325  : 			break;
; 326  : 		case 2: {
; 327  : 			p = transform * sc.PointTo(sc.P(),REF_OBJECT);

	mov	rbx, QWORD PTR [rdx]
	mov	rcx, rsi
	lea	rdx, QWORD PTR $T11[rbp-112]
	call	QWORD PTR [rbx+208]
	mov	r9d, 2
$LN42@get:

; 336  : 			break;}
; 337  : 		}
; 338  : 	return TRUE;

	mov	r8, rax
	lea	rdx, QWORD PTR $T5[rbp-112]
	mov	rcx, rsi
	call	QWORD PTR [rbx+416]
	mov	rdx, r14
	lea	rcx, QWORD PTR $T2[rbp-112]
	mov	r8, rax
	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+8], eax
	mov	eax, 1
	jmp	$LN1@get
$LN17@get:

; 322  : 			break;
; 323  : 		case 1:			
; 324  : 			p = transform * sc.UVW(mappingChannel);			

	mov	rax, QWORD PTR [rdx]
	lea	rdx, QWORD PTR $T12[rbp-112]
	mov	r8d, DWORD PTR [rcx+4]
	mov	rcx, rsi
	call	QWORD PTR [rax+296]
	mov	rdx, r14
	lea	rcx, QWORD PTR $T6[rbp-112]
	mov	r8, rax
	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+8], eax

; 336  : 			break;}
; 337  : 		}
; 338  : 	return TRUE;

	mov	eax, 1
	jmp	$LN1@get
$LN4@get:

; 315  : 			p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;	

	mov	rax, QWORD PTR [rdx]
	lea	rdx, QWORD PTR $T13[rbp-112]
	mov	r8d, DWORD PTR [rcx+4]
	mov	rcx, rsi
	vmovaps	XMMWORD PTR [rsp+80], xmm7
	call	QWORD PTR [rax+296]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 293  :    return(Point3(x-b.x,y-b.y,z-b.z));

	vmovss	xmm6, DWORD PTR __real@3f000000
	vxorps	xmm7, xmm7, xmm7
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 315  : 			p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;	

	lea	r8, QWORD PTR $T8[rbp-112]
	mov	rdx, r14
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 293  :    return(Point3(x-b.x,y-b.y,z-b.z));

	vmovss	xmm0, DWORD PTR [rax+8]
	vsubss	xmm3, xmm0, xmm7
	vmovss	xmm0, DWORD PTR [rax+4]
	vsubss	xmm2, xmm0, xmm6
	vmovss	xmm0, DWORD PTR [rax]
	vsubss	xmm1, xmm0, xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 315  : 			p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;	

	lea	rcx, QWORD PTR $T3[rbp-112]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 293  :    return(Point3(x-b.x,y-b.y,z-b.z));

	vmovss	DWORD PTR $T8[rbp-112], xmm1

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T8[rbp-108], xmm2
	vmovss	DWORD PTR $T8[rbp-104], xmm3
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 315  : 			p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;	

	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z

; 316  : 			if (flips) { if (!tiling(tileX, p.x, flips[0])) return FALSE; }

	mov	r9, QWORD PTR flips$[rbp-112]
	mov	rdx, rdi
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vaddss	xmm3, xmm6, DWORD PTR [rax]
	vaddss	xmm2, xmm6, DWORD PTR [rax+4]
	vaddss	xmm0, xmm7, DWORD PTR [rax+8]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 316  : 			if (flips) { if (!tiling(tileX, p.x, flips[0])) return FALSE; }

	vmovaps	xmm7, XMMWORD PTR [rsp+80]
	vunpcklps xmm1, xmm3, xmm2
	vmovsd	QWORD PTR [rdi], xmm1
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vmovss	DWORD PTR $T7[rbp-104], xmm0
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 315  : 			p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;	

	mov	eax, DWORD PTR $T7[rbp-104]
	mov	DWORD PTR [rdi+8], eax
	mov	ecx, DWORD PTR [rbx+44]

; 316  : 			if (flips) { if (!tiling(tileX, p.x, flips[0])) return FALSE; }

	test	r9, r9
	je	SHORT $LN5@get
	mov	r8, r9
	call	?tiling@@YAHHAEAMAEAH@Z			; tiling
	test	eax, eax
	jne	SHORT $LN8@get
$LN40@get:

; 321  : 			else { if (!tiling(tileZ, p.z)) return FALSE; }

	xor	eax, eax
$LN1@get:

; 339  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+96]
	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
$LN5@get:

; 317  : 			else { if (!tiling(tileX, p.x)) return FALSE; }

	call	?tiling@@YAHHAEAM@Z			; tiling
	test	eax, eax
	je	SHORT $LN40@get
$LN8@get:

; 318  : 			if (flips) { if (!tiling(tileY, p.y, flips[1])) return FALSE; }

	mov	ecx, DWORD PTR [rbx+48]
	lea	rdx, QWORD PTR [rdi+4]
	test	r9, r9
	je	SHORT $LN9@get
	lea	r8, QWORD PTR [r9+4]
	call	?tiling@@YAHHAEAMAEAH@Z			; tiling
	test	eax, eax
	jne	SHORT $LN12@get
	jmp	SHORT $LN40@get
$LN9@get:

; 319  : 			else { if (!tiling(tileY, p.y)) return FALSE; }

	call	?tiling@@YAHHAEAM@Z			; tiling
	test	eax, eax
	je	SHORT $LN40@get
$LN12@get:

; 320  : 			if (flips) { if (!tiling(tileZ, p.z, flips[2])) return FALSE; }

	mov	ecx, DWORD PTR [rbx+52]
	lea	rdx, QWORD PTR [rdi+8]
	test	r9, r9
	je	SHORT $LN13@get
	lea	r8, QWORD PTR [r9+8]
	call	?tiling@@YAHHAEAMAEAH@Z			; tiling
	test	eax, eax
	jne	SHORT $LN16@get
	jmp	SHORT $LN40@get
$LN13@get:

; 321  : 			else { if (!tiling(tileZ, p.z)) return FALSE; }

	call	?tiling@@YAHHAEAM@Z			; tiling
	test	eax, eax
	je	SHORT $LN40@get
$LN16@get:

; 336  : 			break;}
; 337  : 		}
; 338  : 	return TRUE;

	mov	eax, 1
	jmp	SHORT $LN1@get
?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z ENDP ; BerconXYZ::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point2.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z
_TEXT	SEGMENT
duv$1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
duvw$17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 64
$T22 = 64
$T23 = 64
$T24 = 64
$T25 = 64
$T26 = 64
$T27 = 64
$T28 = 64
$T29 = 64
$T30 = 64
uv$31 = 160
this$ = 160
sc$ = 168
p$ = 176
dpdx$ = 184
dpdy$ = 192
transform$ = 200
flips$ = 208
?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z PROC ; BerconXYZ::get, COMDAT

; 266  : int BerconXYZ::get(ShadeContext& sc, Point3& p, Point3& dpdx, Point3& dpdy, Matrix3 transform, int* flips) {

$LN66:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rbp
	push	rdi
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 112				; 00000070H

; 267  : 	switch (mappingType) {

	mov	r13, QWORD PTR dpdy$[rbp-112]
	mov	rdi, r8
	mov	r8d, DWORD PTR [rcx]
	mov	r15, r9
	vmovaps	XMMWORD PTR [rsp+96], xmm6
	mov	r14, rdx
	mov	rsi, rcx
	test	r8d, r8d
	js	$LN18@get
	cmp	r8d, 1
	jle	$LN4@get
	cmp	r8d, 2
	je	$LN19@get
	cmp	r8d, 3
	je	$LN20@get
	cmp	r8d, 4
	jne	$LN18@get

; 300  : 			sc.ScreenUV(uv, duv);

	mov	rax, QWORD PTR [rdx]
	lea	r8, QWORD PTR duv$1[rbp-112]
	vxorps	xmm6, xmm6, xmm6
	lea	rdx, QWORD PTR uv$31[rbp-112]
	mov	rcx, r14
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point2.h

; 50   : 	Point2() : x(0.0f), y(0.0f) {}

	vmovss	DWORD PTR uv$31[rbp-112], xmm6
	vmovss	DWORD PTR uv$31[rbp-108], xmm6
	vmovss	DWORD PTR duv$1[rbp-112], xmm6
	vmovss	DWORD PTR duv$1[rbp-108], xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 300  : 			sc.ScreenUV(uv, duv);

	call	QWORD PTR [rax+272]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR uv$31[rbp-112]
	vmovss	xmm1, DWORD PTR uv$31[rbp-108]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 301  : 			p = transform * Point3(uv.x, uv.y, 0.f);

	mov	rbx, QWORD PTR transform$[rbp-112]
	lea	r8, QWORD PTR $T10[rbp-112]
	mov	rdx, rbx
	lea	rcx, QWORD PTR $T23[rbp-112]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T10[rbp-112], xmm0
	vmovss	DWORD PTR $T10[rbp-108], xmm1
	vmovss	DWORD PTR $T10[rbp-104], xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 301  : 			p = transform * Point3(uv.x, uv.y, 0.f);

	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z

; 302  : 			dpdx = VectorTransform(transform, Point3(duv.x, 0.f, 0.f));

	lea	r8, QWORD PTR $T9[rbp-112]
	mov	rdx, rbx
	lea	rcx, QWORD PTR $T22[rbp-112]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR duv$1[rbp-112]
	vmovss	DWORD PTR $T9[rbp-112], xmm0
	vmovss	DWORD PTR $T9[rbp-108], xmm6
	vmovss	DWORD PTR $T9[rbp-104], xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 301  : 			p = transform * Point3(uv.x, uv.y, 0.f);

	mov	DWORD PTR [rdi+8], eax

; 302  : 			dpdx = VectorTransform(transform, Point3(duv.x, 0.f, 0.f));

	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 303  : 			dpdy = VectorTransform(transform, Point3(0.f, duv.y, 0.f));

	lea	r8, QWORD PTR $T8[rbp-112]
	lea	rcx, QWORD PTR $T21[rbp-112]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r15], xmm0
	mov	eax, DWORD PTR [rax+8]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR duv$1[rbp-108]
	vmovss	DWORD PTR $T8[rbp-108], xmm0
	vmovss	DWORD PTR $T8[rbp-112], xmm6
	vmovss	DWORD PTR $T8[rbp-104], xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 302  : 			dpdx = VectorTransform(transform, Point3(duv.x, 0.f, 0.f));

	mov	DWORD PTR [r15+8], eax
$LN64@get:

; 307  : 	dpdx = dpdx * filtering; dpdy = dpdy * filtering;

	mov	rdx, rbx
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r13], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r13+8], eax
$LN18@get:
	vmovss	xmm0, DWORD PTR [rsi+108]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm2, xmm0, DWORD PTR [r15]
	vmulss	xmm1, xmm0, DWORD PTR [r15+4]
	vmulss	xmm0, xmm0, DWORD PTR [r15+8]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 307  : 	dpdx = dpdx * filtering; dpdy = dpdy * filtering;

	vunpcklps xmm1, xmm2, xmm1
	vmovsd	QWORD PTR [r15], xmm1
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmovss	DWORD PTR $T7[rbp-104], xmm0
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 307  : 	dpdx = dpdx * filtering; dpdy = dpdy * filtering;

	mov	eax, DWORD PTR $T7[rbp-104]
	mov	DWORD PTR [r15+8], eax

; 308  : 	
; 309  : 	return TRUE;

	mov	eax, 1
	vmovss	xmm0, DWORD PTR [rsi+108]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm2, xmm0, DWORD PTR [r13]
	vmulss	xmm1, xmm0, DWORD PTR [r13+4]
	vmulss	xmm0, xmm0, DWORD PTR [r13+8]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 307  : 	dpdx = dpdx * filtering; dpdy = dpdy * filtering;

	vunpcklps xmm1, xmm2, xmm1
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmovss	DWORD PTR $T6[rbp-104], xmm0
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 307  : 	dpdx = dpdx * filtering; dpdy = dpdy * filtering;

	mov	ecx, DWORD PTR $T6[rbp-104]
	vmovsd	QWORD PTR [r13], xmm1
	mov	DWORD PTR [r13+8], ecx
$LN1@get:

; 310  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+96]
	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rbp
	ret	0
$LN20@get:

; 291  : 			break;}
; 292  : 		case 3: {
; 293  : 			p = transform * sc.PointTo(sc.P(),REF_WORLD);

	mov	rbx, QWORD PTR [rdx]
	mov	rcx, r14
	lea	rdx, QWORD PTR $T25[rbp-112]
	call	QWORD PTR [rbx+208]
	mov	r9d, 1
	lea	rdx, QWORD PTR $T12[rbp-112]
	mov	r8, rax
	mov	rcx, r14
	call	QWORD PTR [rbx+416]
	mov	rbx, QWORD PTR transform$[rbp-112]
	lea	rcx, QWORD PTR $T2[rbp-112]
	mov	r8, rax
	mov	rdx, rbx
	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z

; 294  : 			sc.DP(dpdx, dpdy);	

	mov	r8, r13
	mov	rdx, r15
	mov	rcx, r14
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+8], eax
	mov	rax, QWORD PTR [r14]
	call	QWORD PTR [rax+216]

; 295  : 			dpdx = VectorTransform(transform, sc.VectorTo(dpdx, REF_WORLD));

	mov	rax, QWORD PTR [r14]
	lea	rdx, QWORD PTR $T24[rbp-112]
	mov	r9d, 1
	mov	r8, r15
	mov	rcx, r14
	call	QWORD PTR [rax+432]
	mov	rdx, rbx
	lea	rcx, QWORD PTR $T11[rbp-112]
	mov	r8, rax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 296  : 			dpdy = VectorTransform(transform, sc.VectorTo(dpdy, REF_WORLD));

	mov	r9d, 1

; 297  : 			break;}

	jmp	$LN63@get
$LN19@get:

; 285  : 			break;
; 286  : 		case 2: {
; 287  : 			p = transform * sc.PointTo(sc.P(),REF_OBJECT);

	mov	rbx, QWORD PTR [rdx]
	mov	rcx, r14
	lea	rdx, QWORD PTR $T28[rbp-112]
	call	QWORD PTR [rbx+208]
	mov	r9d, 2
	lea	rdx, QWORD PTR $T15[rbp-112]
	mov	r8, rax
	mov	rcx, r14
	call	QWORD PTR [rbx+416]
	mov	rbx, QWORD PTR transform$[rbp-112]
	lea	rcx, QWORD PTR $T3[rbp-112]
	mov	r8, rax
	mov	rdx, rbx
	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z

; 288  : 			sc.DP(dpdx, dpdy);	

	mov	r8, r13
	mov	rdx, r15
	mov	rcx, r14
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+8], eax
	mov	rax, QWORD PTR [r14]
	call	QWORD PTR [rax+216]

; 289  : 			dpdx = VectorTransform(transform, sc.VectorTo(dpdx, REF_OBJECT));

	mov	rax, QWORD PTR [r14]
	lea	rdx, QWORD PTR $T27[rbp-112]
	mov	r9d, 2
	mov	r8, r15
	mov	rcx, r14
	call	QWORD PTR [rax+432]
	mov	rdx, rbx
	lea	rcx, QWORD PTR $T14[rbp-112]
	mov	r8, rax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 290  : 			dpdy = VectorTransform(transform, sc.VectorTo(dpdy, REF_OBJECT));

	mov	r9d, 2
$LN63@get:

; 307  : 	dpdx = dpdx * filtering; dpdy = dpdy * filtering;

	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r15], xmm0
	mov	eax, DWORD PTR [rax+8]
	lea	rdx, QWORD PTR $T26[rbp-112]
	mov	DWORD PTR [r15+8], eax
	mov	r8, r13
	mov	rax, QWORD PTR [r14]
	mov	rcx, r14
	call	QWORD PTR [rax+432]
	mov	r8, rax
	lea	rcx, QWORD PTR $T13[rbp-112]
	jmp	$LN64@get
$LN4@get:

; 268  : 		case 0:
; 269  : 		case 1:
; 270  : 			if (mappingType)

	mov	rax, QWORD PTR [rdx]
	test	r8d, r8d
	mov	ecx, DWORD PTR [rcx+4]
	lea	rdx, QWORD PTR $T30[rbp-112]
	vmovaps	XMMWORD PTR [rsp+80], xmm7
	mov	r8d, ecx
	vxorps	xmm7, xmm7, xmm7
	mov	r9, QWORD PTR [rax+296]
	mov	rcx, r14
	je	SHORT $LN5@get

; 271  : 				p = transform * sc.UVW(mappingChannel);			

	call	r9
	mov	rbx, QWORD PTR transform$[rbp-112]
	lea	rcx, QWORD PTR $T20[rbp-112]
	mov	rdx, rbx
	mov	r8, rax
	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]

; 272  : 			else

	jmp	SHORT $LN58@get
$LN5@get:

; 273  : 				p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;

	call	r9
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 293  :    return(Point3(x-b.x,y-b.y,z-b.z));

	vmovss	xmm6, DWORD PTR __real@3f000000
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 273  : 				p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;

	mov	rbx, QWORD PTR transform$[rbp-112]
	lea	r8, QWORD PTR $T19[rbp-112]
	mov	rdx, rbx
	lea	rcx, QWORD PTR $T5[rbp-112]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 293  :    return(Point3(x-b.x,y-b.y,z-b.z));

	vmovss	xmm0, DWORD PTR [rax+8]
	vmovss	xmm1, DWORD PTR [rax+4]
	vsubss	xmm3, xmm0, xmm7
	vmovss	xmm0, DWORD PTR [rax]
	vsubss	xmm2, xmm1, xmm6
	vsubss	xmm1, xmm0, xmm6
	vmovss	DWORD PTR $T19[rbp-112], xmm1

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T19[rbp-108], xmm2
	vmovss	DWORD PTR $T19[rbp-104], xmm3
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 273  : 				p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;

	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vaddss	xmm3, xmm6, DWORD PTR [rax]
	vaddss	xmm2, xmm6, DWORD PTR [rax+4]
	vaddss	xmm0, xmm7, DWORD PTR [rax+8]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 273  : 				p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;

	vunpcklps xmm1, xmm3, xmm2
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vmovss	DWORD PTR $T18[rbp-104], xmm0
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 273  : 				p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;

	mov	eax, DWORD PTR $T18[rbp-104]
	vmovsd	QWORD PTR [rdi], xmm1
$LN58@get:

; 274  : 			{
; 275  : 			Point3 duvw = VectorTransform(transform, sc.DUVW(mappingChannel));

	mov	DWORD PTR [rdi+8], eax
	lea	rdx, QWORD PTR $T29[rbp-112]
	mov	rax, QWORD PTR [r14]
	mov	rcx, r14
	mov	r8d, DWORD PTR [rsi+4]
	call	QWORD PTR [rax+304]
	mov	rdx, rbx
	lea	rcx, QWORD PTR duvw$17[rbp-112]
	mov	r8, rax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR duvw$17[rbp-112]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 279  : 			if (flips) { if (!tiling(tileX, p.x, flips[0])) return FALSE; }

	mov	r9, QWORD PTR flips$[rbp-112]
	mov	rdx, rdi
	vunpcklps xmm0, xmm0, xmm7
	vmovsd	QWORD PTR [r15], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR duvw$17[rbp-108]
	vmovss	DWORD PTR $T4[rbp-104], xmm7
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 276  : 			dpdx = Point3(duvw.x, 0.f, 0.f);

	mov	eax, DWORD PTR $T4[rbp-104]
	mov	DWORD PTR [r15+8], eax

; 277  : 			dpdy = Point3(0.f, duvw.y, 0.f);

	vunpcklps xmm0, xmm7, xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T16[rbp-104], xmm7
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 277  : 			dpdy = Point3(0.f, duvw.y, 0.f);

	mov	eax, DWORD PTR $T16[rbp-104]

; 279  : 			if (flips) { if (!tiling(tileX, p.x, flips[0])) return FALSE; }

	vmovaps	xmm7, XMMWORD PTR [rsp+80]
	vmovsd	QWORD PTR [r13], xmm0
	mov	DWORD PTR [r13+8], eax
	mov	ecx, DWORD PTR [rsi+44]
	test	r9, r9
	je	SHORT $LN7@get
	mov	r8, r9
	call	?tiling@@YAHHAEAMAEAH@Z			; tiling
	test	eax, eax
	jne	SHORT $LN10@get

; 284  : 			else { if (!tiling(tileZ, p.z)) return FALSE; }

	jmp	$LN1@get
$LN7@get:

; 280  : 			else { if (!tiling(tileX, p.x)) return FALSE; }

	call	?tiling@@YAHHAEAM@Z			; tiling
	test	eax, eax
	je	SHORT $LN57@get
$LN10@get:

; 281  : 			if (flips) { if (!tiling(tileY, p.y, flips[1])) return FALSE; }

	mov	ecx, DWORD PTR [rsi+48]
	lea	rdx, QWORD PTR [rdi+4]
	test	r9, r9
	je	SHORT $LN11@get
	lea	r8, QWORD PTR [r9+4]
	call	?tiling@@YAHHAEAMAEAH@Z			; tiling
	test	eax, eax
	jne	SHORT $LN14@get

; 284  : 			else { if (!tiling(tileZ, p.z)) return FALSE; }

	jmp	$LN1@get
$LN11@get:

; 282  : 			else { if (!tiling(tileY, p.y)) return FALSE; }

	call	?tiling@@YAHHAEAM@Z			; tiling
	test	eax, eax
	je	SHORT $LN57@get
$LN14@get:

; 283  : 			if (flips) { if (!tiling(tileZ, p.z, flips[2])) return FALSE; }

	mov	ecx, DWORD PTR [rsi+52]
	lea	rdx, QWORD PTR [rdi+8]
	test	r9, r9
	je	SHORT $LN15@get
	lea	r8, QWORD PTR [r9+8]
	call	?tiling@@YAHHAEAMAEAH@Z			; tiling
	jmp	SHORT $LN60@get
$LN15@get:

; 284  : 			else { if (!tiling(tileZ, p.z)) return FALSE; }

	call	?tiling@@YAHHAEAM@Z			; tiling
$LN60@get:
	test	eax, eax
	jne	$LN18@get
$LN57@get:
	xor	eax, eax
	jmp	$LN1@get
?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z ENDP ; BerconXYZ::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z
_TEXT	SEGMENT
transform$2$ = 48
$T1 = 48
$T2 = 48
$T3 = 48
transform$1$ = 64
dp$4 = 64
$T5 = 64
$T6 = 120
$T7 = 120
$T8 = 120
$T9 = 144
$T10 = 144
$T11 = 144
transform$12 = 144
inv$13 = 208
$T14 = 272
$T15 = 272
$T16 = 272
this$ = 368
sc$ = 376
p$ = 384
basis$ = 392
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z PROC ; BerconXYZ::get, COMDAT

; 395  : int BerconXYZ::get(ShadeContext& sc, Point3& p, Point3* basis) {	

$LN42:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r12
	push	rbp
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-80]
	sub	rsp, 336				; 00000150H

; 396  : 	/*int* flips = NULL;
; 397  : 	if (mappingType == 0) {
; 398  : 		flips = new int[3];
; 399  : 		flips[0]=0;flips[1]=0;flips[2]=0;
; 400  : 	}*/
; 401  : 
; 402  : 	if ((mappingType == 0 || mappingType == 1) && mode2D) {

	cmp	DWORD PTR [rcx], 1
	mov	r14, r9
	mov	rsi, r8
	mov	r15, rdx
	mov	rbx, rcx
	ja	$LN5@get
	cmp	DWORD PTR [rcx+260], 0
	je	$LN5@get
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h

; 172  :    Matrix3(){ flags = 0; }

	xor	edi, edi
	mov	DWORD PTR inv$13[rbp-208], edi
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 404  : 		Matrix3 transform = variance?random(sc, &inv):tm;

	cmp	BYTE PTR [rcx+116], dil
	je	SHORT $LN16@get
	mov	r8, rdx
	lea	r9, QWORD PTR inv$13[rbp-256]
	lea	rdx, QWORD PTR $T16[rbp-256]
	call	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
	movzx	ecx, BYTE PTR [rbx+116]
	jmp	SHORT $LN17@get
$LN16@get:
	mov	eax, DWORD PTR [rcx+204]
	vmovups	ymm0, YMMWORD PTR [rcx+156]
	vmovups	xmm1, XMMWORD PTR [rcx+188]
	mov	DWORD PTR $T5[rsp+48], eax
	xor	cl, cl
	vmovups	YMMWORD PTR $T5[rsp], ymm0
	vmovups	XMMWORD PTR $T5[rsp+32], xmm1
	lea	rax, QWORD PTR $T5[rsp]
$LN17@get:
	vmovups	ymm2, YMMWORD PTR [rax]
	vmovups	YMMWORD PTR transform$12[rbp-256], ymm2
	vmovups	xmm3, XMMWORD PTR [rax+32]
	vmovups	XMMWORD PTR transform$12[rbp-224], xmm3
	mov	edx, DWORD PTR [rax+48]
	mov	DWORD PTR transform$12[rbp-208], edx

; 405  : 		if (!variance) inv = invNoScaleTm;

	test	cl, cl
	jne	SHORT $LN8@get
	vmovups	ymm0, YMMWORD PTR [rbx+208]
	vmovups	xmm1, XMMWORD PTR [rbx+240]
	mov	eax, DWORD PTR [rbx+256]
	vmovups	YMMWORD PTR inv$13[rbp-256], ymm0
	vmovups	XMMWORD PTR inv$13[rbp-224], xmm1
	mov	DWORD PTR inv$13[rbp-208], eax
$LN8@get:

; 406  : 		
; 407  : 		if (!get(sc, p, transform)) {return FALSE;}

	mov	DWORD PTR $T15[rbp-208], edx
	lea	r9, QWORD PTR $T15[rbp-256]
	mov	rdx, r15
	mov	QWORD PTR [rsp+32], rdi
	vmovups	YMMWORD PTR $T15[rbp-256], ymm2
	vmovups	XMMWORD PTR $T15[rbp-224], xmm3
	mov	r8, rsi
	mov	rcx, rbx
	vzeroupper
	call	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z ; BerconXYZ::get
	test	eax, eax
	je	$LN37@get

; 408  : 		Point3 dp[3];				

	lea	rdi, QWORD PTR dp$4[rsp]
	mov	esi, 3
	npad	2
$LL23@get:
	mov	rcx, rdi
	call	QWORD PTR __imp_??0Point3@@QEAA@XZ
	add	rdi, 12
	sub	rsi, 1
	jne	SHORT $LL23@get

; 409  : 				 
; 410  : 		if (sc.BumpBasisVectors(dp, AXIS_UV, mappingChannel)) {

	mov	rax, QWORD PTR [r15]
	lea	rdx, QWORD PTR dp$4[rsp]
	mov	r9d, DWORD PTR [rbx+4]
	xor	r8d, r8d
	mov	rcx, r15
	call	QWORD PTR [rax+320]
	test	eax, eax
	je	$LN10@get

; 411  : 			basis[0] = VectorTransform(inv, dp[0]);

	lea	r8, QWORD PTR dp$4[rsp]
	lea	rdx, QWORD PTR inv$13[rbp-256]
	lea	rcx, QWORD PTR $T8[rsp]
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 412  : 			basis[1] = VectorTransform(inv, dp[1]);

	lea	r8, QWORD PTR dp$4[rsp+12]
	lea	rdx, QWORD PTR inv$13[rbp-256]
	lea	rcx, QWORD PTR $T7[rsp]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r14+8], eax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 413  : 			basis[2] = VectorTransform(inv, dp[0]^dp[1]);

	lea	r8, QWORD PTR dp$4[rsp+12]
	lea	rdx, QWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR dp$4[rsp]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14+12], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r14+20], eax
	call	QWORD PTR __imp_??TPoint3@@QEBA?AV0@AEBV0@@Z
	mov	r8, rax
$LN40@get:

; 430  : 	}
; 431  : 
; 432  : 	/*if (flips) {
; 433  : 		if (flips[0]) basis[0] *= -1;
; 434  : 		if (flips[1]) basis[1] *= -1;
; 435  : 		if (flips[2]) basis[2] *= -1;
; 436  : 	}
; 437  : 	delete[] flips;*/
; 438  : 
; 439  : 	return TRUE;

	lea	rdx, QWORD PTR inv$13[rbp-256]
	lea	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14+24], xmm0
	mov	eax, DWORD PTR [rax+8]
	jmp	$LN39@get
$LN10@get:

; 414  : 		} else {
; 415  : 			sc.DPdUVW(dp, mappingChannel);

	mov	rax, QWORD PTR [r15]
	lea	rdx, QWORD PTR dp$4[rsp]
	mov	r8d, DWORD PTR [rbx+4]
	mov	rcx, r15
	call	QWORD PTR [rax+312]

; 416  : 			transform.Invert();

	lea	rcx, QWORD PTR transform$12[rbp-256]
	call	QWORD PTR __imp_?Invert@Matrix3@@QEAAXXZ

; 417  : 			basis[0] = VectorTransform(inv, dp[0]);

	lea	r8, QWORD PTR dp$4[rsp]
	lea	rdx, QWORD PTR inv$13[rbp-256]
	lea	rcx, QWORD PTR $T2[rsp]
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 418  : 			basis[1] = VectorTransform(inv, dp[1]);

	lea	r8, QWORD PTR dp$4[rsp+12]
	lea	rdx, QWORD PTR inv$13[rbp-256]
	lea	rcx, QWORD PTR $T1[rsp]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r14+8], eax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 419  : 			basis[2] = VectorTransform(inv, dp[2]);			

	lea	r8, QWORD PTR dp$4[rsp+24]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14+12], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r14+20], eax

; 420  : 		 }
; 421  : 
; 422  : 	} else {

	jmp	$LN40@get
$LN5@get:

; 423  : 		Matrix3 transform = variance?random(sc):tm;

	cmp	BYTE PTR [rcx+116], 0
	je	SHORT $LN18@get
	xor	r9d, r9d
	lea	rdx, QWORD PTR $T11[rbp-256]
	mov	r8, r15
	call	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
	jmp	SHORT $LN19@get
$LN18@get:
	mov	eax, DWORD PTR [rcx+204]
	vmovups	ymm0, YMMWORD PTR [rcx+156]
	vmovups	xmm1, XMMWORD PTR [rcx+188]
	mov	DWORD PTR $T10[rbp-208], eax
	lea	rax, QWORD PTR $T10[rbp-256]
	vmovups	YMMWORD PTR $T10[rbp-256], ymm0
	vmovups	XMMWORD PTR $T10[rbp-224], xmm1
$LN19@get:
	vmovups	ymm0, YMMWORD PTR [rax]

; 424  : 		if (!get(sc, p, transform)) {return FALSE;}

	vmovups	xmm1, XMMWORD PTR [rax+32]
	mov	r12d, DWORD PTR [rax+48]
	lea	r9, QWORD PTR $T14[rbp-256]
	vmovups	YMMWORD PTR transform$1$[rsp], ymm0
	vmovups	xmm0, XMMWORD PTR [rax+32]
	vmovups	XMMWORD PTR transform$2$[rsp], xmm0
	vmovups	ymm0, YMMWORD PTR [rax]
	xor	edi, edi
	mov	DWORD PTR $T14[rbp-208], r12d
	vmovups	YMMWORD PTR $T14[rbp-256], ymm0
	vmovups	XMMWORD PTR $T14[rbp-224], xmm1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rsi
	mov	rdx, r15
	mov	rcx, rbx
	vzeroupper
	call	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z ; BerconXYZ::get
	test	eax, eax
	jne	SHORT $LN12@get
$LN37@get:
	xor	eax, eax
	jmp	SHORT $LN1@get
$LN12@get:

; 425  : 		if (variance)

	cmp	BYTE PTR [rbx+116], dil
	je	SHORT $LN13@get

; 426  : 			getBasis(transform, basis);

	vmovups	ymm0, YMMWORD PTR transform$1$[rsp]
	vmovups	xmm1, XMMWORD PTR transform$2$[rsp]
	vmovups	YMMWORD PTR $T9[rbp-256], ymm0
	vmovups	XMMWORD PTR $T9[rbp-224], xmm1
	mov	DWORD PTR $T9[rbp-208], r12d
	lea	rdx, QWORD PTR $T9[rbp-256]
	mov	r8, r14
	mov	rcx, rbx
	vzeroupper
	call	?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z ; BerconXYZ::getBasis

; 427  : 		else

	jmp	SHORT $LN3@get
$LN13@get:

; 428  : 			for (int i=0; i<3; i++)
; 429  : 				basis[i] = b[i];

	vmovsd	xmm0, QWORD PTR [rbx+120]
	vmovsd	QWORD PTR [r14], xmm0
	mov	eax, DWORD PTR [rbx+128]
	mov	DWORD PTR [r14+8], eax
	vmovsd	xmm0, QWORD PTR [rbx+132]
	vmovsd	QWORD PTR [r14+12], xmm0
	mov	eax, DWORD PTR [rbx+140]
	mov	DWORD PTR [r14+20], eax
	vmovsd	xmm0, QWORD PTR [rbx+144]
	vmovsd	QWORD PTR [r14+24], xmm0
	mov	eax, DWORD PTR [rbx+152]
$LN39@get:

; 430  : 	}
; 431  : 
; 432  : 	/*if (flips) {
; 433  : 		if (flips[0]) basis[0] *= -1;
; 434  : 		if (flips[1]) basis[1] *= -1;
; 435  : 		if (flips[2]) basis[2] *= -1;
; 436  : 	}
; 437  : 	delete[] flips;*/
; 438  : 
; 439  : 	return TRUE;

	mov	DWORD PTR [r14+32], eax
$LN3@get:
	mov	eax, 1
$LN1@get:

; 440  : }

	lea	r11, QWORD PTR [rsp+336]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rdi, QWORD PTR [r11+48]
	mov	r12, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rbp
	ret	0
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z ENDP ; BerconXYZ::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 112
this$ = 192
sc$ = 200
p$ = 208
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z PROC ; BerconXYZ::get, COMDAT

; 345  : int BerconXYZ::get(ShadeContext& sc, Point3& p) {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H

; 346  : 	return get(sc, p, variance?random(sc):tm);

	cmp	BYTE PTR [rcx+116], 0
	mov	rsi, r8
	mov	rdi, rdx
	mov	rbx, rcx
	je	SHORT $LN3@get
	mov	r8, rdx
	xor	r9d, r9d
	lea	rdx, QWORD PTR $T2[rsp]
	call	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
	jmp	SHORT $LN4@get
$LN3@get:
	mov	eax, DWORD PTR [rcx+204]
	vmovups	ymm0, YMMWORD PTR [rcx+156]
	vmovups	xmm1, XMMWORD PTR [rcx+188]
	mov	DWORD PTR $T1[rsp+48], eax
	lea	rax, QWORD PTR $T1[rsp]
	vmovups	YMMWORD PTR $T1[rsp], ymm0
	vmovups	XMMWORD PTR $T1[rsp+32], xmm1
$LN4@get:
	vmovups	ymm0, YMMWORD PTR [rax]
	vmovups	xmm1, XMMWORD PTR [rax+32]
	mov	eax, DWORD PTR [rax+48]
	lea	r9, QWORD PTR $T3[rsp]
	vmovups	YMMWORD PTR $T3[rsp], ymm0
	vmovups	XMMWORD PTR $T3[rsp+32], xmm1
	mov	DWORD PTR $T3[rsp+48], eax
	mov	r8, rsi
	mov	QWORD PTR [rsp+32], 0
	mov	rdx, rdi
	mov	rcx, rbx
	vzeroupper
	call	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z ; BerconXYZ::get

; 347  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z ENDP ; BerconXYZ::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z
_TEXT	SEGMENT
transform$2$ = 64
$T1 = 64
$T2 = 64
$T3 = 64
transform$1$ = 80
dp$4 = 80
$T5 = 80
$T6 = 136
$T7 = 136
$T8 = 136
$T9 = 160
$T10 = 160
$T11 = 160
transform$12 = 160
inv$13 = 224
$T14 = 288
$T15 = 288
$T16 = 288
this$ = 384
sc$ = 392
p$ = 400
dpdx$ = 408
dpdy$ = 416
basis$ = 424
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z PROC ; BerconXYZ::get, COMDAT

; 349  : int BerconXYZ::get(ShadeContext& sc, Point3& p, Point3& dpdx, Point3& dpdy, Point3* basis) {

$LN41:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r12
	push	rbp
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-96]
	sub	rsp, 352				; 00000160H

; 350  : 	/*int* flips = NULL;
; 351  : 	if (mappingType == 0) {
; 352  : 		flips = new int[3];
; 353  : 		flips[0]=0;flips[1]=0;flips[2]=0;
; 354  : 	}*/
; 355  : 
; 356  : 	if ((mappingType == 0 || mappingType == 1) && mode2D) {

	cmp	DWORD PTR [rcx], 1
	mov	rsi, r9
	mov	r15, r8
	mov	r14, rdx
	mov	rbx, rcx
	ja	$LN5@get
	cmp	DWORD PTR [rcx+260], 0
	je	$LN5@get
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h

; 172  :    Matrix3(){ flags = 0; }

	xor	edi, edi
	mov	DWORD PTR inv$13[rbp-208], edi
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 358  : 		Matrix3 transform = variance?random(sc, &inv):tm;

	cmp	BYTE PTR [rcx+116], dil
	je	SHORT $LN16@get
	mov	r8, rdx
	lea	r9, QWORD PTR inv$13[rbp-256]
	lea	rdx, QWORD PTR $T16[rbp-256]
	call	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
	movzx	ecx, BYTE PTR [rbx+116]
	jmp	SHORT $LN17@get
$LN16@get:
	mov	eax, DWORD PTR [rcx+204]
	vmovups	ymm0, YMMWORD PTR [rcx+156]
	vmovups	xmm1, XMMWORD PTR [rcx+188]
	mov	DWORD PTR $T5[rbp-208], eax
	xor	cl, cl
	vmovups	YMMWORD PTR $T5[rsp], ymm0
	vmovups	XMMWORD PTR $T5[rsp+32], xmm1
	lea	rax, QWORD PTR $T5[rsp]
$LN17@get:
	vmovups	ymm2, YMMWORD PTR [rax]
	vmovups	YMMWORD PTR transform$12[rbp-256], ymm2
	vmovups	xmm3, XMMWORD PTR [rax+32]
	vmovups	XMMWORD PTR transform$12[rbp-224], xmm3
	mov	edx, DWORD PTR [rax+48]
	mov	DWORD PTR transform$12[rbp-208], edx

; 359  : 		if (!variance) inv = invNoScaleTm;

	test	cl, cl
	jne	SHORT $LN8@get
	vmovups	ymm0, YMMWORD PTR [rbx+208]
	vmovups	xmm1, XMMWORD PTR [rbx+240]
	mov	eax, DWORD PTR [rbx+256]
	vmovups	YMMWORD PTR inv$13[rbp-256], ymm0
	vmovups	XMMWORD PTR inv$13[rbp-224], xmm1
	mov	DWORD PTR inv$13[rbp-208], eax
$LN8@get:

; 360  : 		
; 361  : 		if (!get(sc, p, dpdx, dpdy, transform)) {return FALSE;}

	lea	rax, QWORD PTR $T15[rbp-256]
	mov	QWORD PTR [rsp+48], rdi
	mov	QWORD PTR [rsp+40], rax
	mov	r9, rsi
	mov	rax, QWORD PTR dpdy$[rbp-256]
	mov	r8, r15
	mov	DWORD PTR $T15[rbp-208], edx
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	mov	rdx, r14
	vmovups	YMMWORD PTR $T15[rbp-256], ymm2
	vmovups	XMMWORD PTR $T15[rbp-224], xmm3
	vzeroupper
	call	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z ; BerconXYZ::get
	test	eax, eax
	je	$LN37@get

; 362  : 		Point3 dp[3];				

	lea	rdi, QWORD PTR dp$4[rsp]
	mov	esi, 3
$LL23@get:
	mov	rcx, rdi
	call	QWORD PTR __imp_??0Point3@@QEAA@XZ
	add	rdi, 12
	sub	rsi, 1
	jne	SHORT $LL23@get

; 363  : 				 
; 364  : 		if (sc.BumpBasisVectors(dp, AXIS_UV, mappingChannel)) {

	mov	rax, QWORD PTR [r14]
	lea	rdx, QWORD PTR dp$4[rsp]
	mov	r9d, DWORD PTR [rbx+4]
	xor	r8d, r8d
	mov	rdi, QWORD PTR basis$[rbp-256]
	mov	rcx, r14
	call	QWORD PTR [rax+320]
	test	eax, eax
	je	SHORT $LN10@get

; 365  : 			basis[0] = VectorTransform(inv, dp[0]);

	lea	r8, QWORD PTR dp$4[rsp]
	lea	rdx, QWORD PTR inv$13[rbp-256]
	lea	rcx, QWORD PTR $T8[rbp-256]
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 366  : 			basis[1] = VectorTransform(inv, dp[1]);

	lea	r8, QWORD PTR dp$4[rsp+12]
	lea	rdx, QWORD PTR inv$13[rbp-256]
	lea	rcx, QWORD PTR $T7[rbp-256]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+8], eax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 367  : 			basis[2] = VectorTransform(inv, dp[0]^dp[1]);

	lea	r8, QWORD PTR dp$4[rsp+12]
	lea	rdx, QWORD PTR $T6[rbp-256]
	lea	rcx, QWORD PTR dp$4[rsp]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi+12], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+20], eax
	call	QWORD PTR __imp_??TPoint3@@QEBA?AV0@AEBV0@@Z
	mov	r8, rax

; 368  : 		} else {

	jmp	SHORT $LN39@get
$LN10@get:

; 369  : 			sc.DPdUVW(dp, mappingChannel);

	mov	rax, QWORD PTR [r14]
	lea	rdx, QWORD PTR dp$4[rsp]
	mov	r8d, DWORD PTR [rbx+4]
	mov	rcx, r14
	call	QWORD PTR [rax+312]

; 370  : 			transform.Invert();

	lea	rcx, QWORD PTR transform$12[rbp-256]
	call	QWORD PTR __imp_?Invert@Matrix3@@QEAAXXZ

; 371  : 			basis[0] = VectorTransform(inv, dp[0]);

	lea	r8, QWORD PTR dp$4[rsp]
	lea	rdx, QWORD PTR inv$13[rbp-256]
	lea	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 372  : 			basis[1] = VectorTransform(inv, dp[1]);

	lea	r8, QWORD PTR dp$4[rsp+12]
	lea	rdx, QWORD PTR inv$13[rbp-256]
	lea	rcx, QWORD PTR $T2[rsp]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+8], eax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 373  : 			basis[2] = VectorTransform(inv, dp[2]);			

	lea	r8, QWORD PTR dp$4[rsp+24]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi+12], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+20], eax
$LN39@get:

; 383  : 	}
; 384  : 
; 385  : 	/*if (flips) {
; 386  : 		if (flips[0]) basis[0] *= -1;
; 387  : 		if (flips[1]) basis[1] *= -1;
; 388  : 		if (flips[2]) basis[2] *= -1;
; 389  : 	}
; 390  : 	delete[] flips;*/
; 391  : 
; 392  : 	return TRUE;

	lea	rdx, QWORD PTR inv$13[rbp-256]
	lea	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi+24], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+32], eax
	jmp	$LN3@get
$LN5@get:

; 374  : 		 }		
; 375  : 	} else {	
; 376  : 		Matrix3 transform = variance?random(sc):tm;

	cmp	BYTE PTR [rcx+116], 0
	je	SHORT $LN18@get
	xor	r9d, r9d
	lea	rdx, QWORD PTR $T11[rbp-256]
	mov	r8, r14
	call	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
	jmp	SHORT $LN19@get
$LN18@get:
	mov	eax, DWORD PTR [rcx+204]
	vmovups	ymm0, YMMWORD PTR [rcx+156]
	vmovups	xmm1, XMMWORD PTR [rcx+188]
	mov	DWORD PTR $T10[rbp-208], eax
	lea	rax, QWORD PTR $T10[rbp-256]
	vmovups	YMMWORD PTR $T10[rbp-256], ymm0
	vmovups	XMMWORD PTR $T10[rbp-224], xmm1
$LN19@get:
	vmovups	ymm0, YMMWORD PTR [rax]

; 377  : 		if (!get(sc, p, dpdx, dpdy, transform)) {return FALSE;}

	vmovups	xmm1, XMMWORD PTR [rax+32]
	mov	r12d, DWORD PTR [rax+48]
	xor	edi, edi
	vmovups	YMMWORD PTR transform$1$[rsp], ymm0
	vmovups	xmm0, XMMWORD PTR [rax+32]
	mov	QWORD PTR [rsp+48], rdi
	mov	r9, rsi
	vmovups	XMMWORD PTR transform$2$[rsp], xmm0
	vmovups	ymm0, YMMWORD PTR [rax]
	lea	rax, QWORD PTR $T14[rbp-256]
	mov	DWORD PTR $T14[rbp-208], r12d
	mov	QWORD PTR [rsp+40], rax
	mov	r8, r15
	mov	rax, QWORD PTR dpdy$[rbp-256]
	mov	rdx, r14
	mov	QWORD PTR [rsp+32], rax
	mov	rcx, rbx
	vmovups	YMMWORD PTR $T14[rbp-256], ymm0
	vmovups	XMMWORD PTR $T14[rbp-224], xmm1
	vzeroupper
	call	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z ; BerconXYZ::get
	test	eax, eax
	jne	SHORT $LN12@get
$LN37@get:
	xor	eax, eax
	jmp	$LN1@get
$LN12@get:

; 378  : 		if (variance)

	cmp	BYTE PTR [rbx+116], dil
	je	SHORT $LN13@get

; 379  : 			getBasis(transform, basis);

	vmovups	ymm0, YMMWORD PTR transform$1$[rsp]
	vmovups	xmm1, XMMWORD PTR transform$2$[rsp]
	mov	r8, QWORD PTR basis$[rbp-256]
	lea	rdx, QWORD PTR $T9[rbp-256]
	vmovups	YMMWORD PTR $T9[rbp-256], ymm0
	vmovups	XMMWORD PTR $T9[rbp-224], xmm1
	mov	DWORD PTR $T9[rbp-208], r12d
	mov	rcx, rbx
	vzeroupper
	call	?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z ; BerconXYZ::getBasis

; 380  : 		else

	jmp	SHORT $LN3@get
$LN13@get:

; 381  : 			for (int i=0; i<3; i++)
; 382  : 				basis[i] = b[i];

	vmovsd	xmm0, QWORD PTR [rbx+120]
	mov	rcx, QWORD PTR basis$[rbp-256]
	vmovsd	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rbx+128]
	mov	DWORD PTR [rcx+8], eax
	vmovsd	xmm0, QWORD PTR [rbx+132]
	vmovsd	QWORD PTR [rcx+12], xmm0
	mov	eax, DWORD PTR [rbx+140]
	mov	DWORD PTR [rcx+20], eax
	vmovsd	xmm0, QWORD PTR [rbx+144]
	vmovsd	QWORD PTR [rcx+24], xmm0
	mov	eax, DWORD PTR [rbx+152]
	mov	DWORD PTR [rcx+32], eax
$LN3@get:

; 383  : 	}
; 384  : 
; 385  : 	/*if (flips) {
; 386  : 		if (flips[0]) basis[0] *= -1;
; 387  : 		if (flips[1]) basis[1] *= -1;
; 388  : 		if (flips[2]) basis[2] *= -1;
; 389  : 	}
; 390  : 	delete[] flips;*/
; 391  : 
; 392  : 	return TRUE;

	mov	eax, 1
$LN1@get:

; 393  : }

	lea	r11, QWORD PTR [rsp+352]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	mov	rdi, QWORD PTR [r11+48]
	mov	r12, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rbp
	ret	0
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z ENDP ; BerconXYZ::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 128
this$ = 208
sc$ = 216
p$ = 224
dpdx$ = 232
dpdy$ = 240
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z PROC ; BerconXYZ::get, COMDAT

; 341  : int BerconXYZ::get(ShadeContext& sc, Point3& p, Point3& dpdx, Point3& dpdy) {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 342  : 	return get(sc, p, dpdx, dpdy, variance?random(sc):tm);

	cmp	BYTE PTR [rcx+116], 0
	mov	rsi, r9
	mov	rbp, r8
	mov	rdi, rdx
	mov	rbx, rcx
	je	SHORT $LN3@get
	mov	r8, rdx
	xor	r9d, r9d
	lea	rdx, QWORD PTR $T2[rsp]
	call	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
	jmp	SHORT $LN4@get
$LN3@get:
	mov	eax, DWORD PTR [rcx+204]
	vmovups	ymm0, YMMWORD PTR [rcx+156]
	vmovups	xmm1, XMMWORD PTR [rcx+188]
	mov	DWORD PTR $T1[rsp+48], eax
	lea	rax, QWORD PTR $T1[rsp]
	vmovups	YMMWORD PTR $T1[rsp], ymm0
	vmovups	XMMWORD PTR $T1[rsp+32], xmm1
$LN4@get:
	vmovups	ymm0, YMMWORD PTR [rax]
	vmovups	xmm1, XMMWORD PTR [rax+32]
	mov	eax, DWORD PTR [rax+48]
	mov	r9, rsi
	mov	DWORD PTR $T3[rsp+48], eax
	mov	r8, rbp
	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rsp+48], 0
	mov	QWORD PTR [rsp+40], rax
	mov	rdx, rdi
	mov	rax, QWORD PTR dpdy$[rsp]
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	vmovups	YMMWORD PTR $T3[rsp], ymm0
	vmovups	XMMWORD PTR $T3[rsp+32], xmm1
	vzeroupper
	call	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z ; BerconXYZ::get

; 343  : }

	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z ENDP ; BerconXYZ::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.h
;	COMDAT ?isRealworld@BerconXYZ@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?isRealworld@BerconXYZ@@QEAAHXZ PROC			; BerconXYZ::isRealworld, COMDAT

; 360  : 	int isRealworld() { return mappingType == 0 || mappingType == 4 ? 0 : 1; }

	test	DWORD PTR [rcx], -5			; fffffffbH
	mov	eax, 0
	setne	al
	ret	0
?isRealworld@BerconXYZ@@QEAAHXZ ENDP			; BerconXYZ::isRealworld
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\interval.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\interval.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z
_TEXT	SEGMENT
this$ = 80
pblock$ = 88
ivalid$ = 96
type$ = 104
x$ = 112
y$ = 120
z$ = 128
?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z PROC ; BerconXYZ::reset, COMDAT

; 23   : void BerconXYZ::reset(IParamBlock2* pblock, Interval& ivalid, int type, int x, int y, int z) {

$LN8:

; 24   : 	if (!pblock) return;

	test	rdx, rdx
	je	$LN6@reset
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 25   : 	//if (!pblock->GetMap()) return;
; 26   : 
; 27   : 	TimeValue t = GetCOREInterface()->GetTime();

	mov	QWORD PTR [rsp+80], rbx
	mov	ebp, r9d
	mov	QWORD PTR [rsp+88], r14
	mov	rsi, r8
	vmovaps	XMMWORD PTR [rsp+48], xmm6
	mov	rdi, rdx
	call	QWORD PTR __imp_?GetCOREInterface@@YAPEAVInterface@@XZ
	mov	rcx, rax
	mov	r10, QWORD PTR [rax]
	call	QWORD PTR [r10+1448]

; 28   : 
; 29   : 	pblockSetValue(xyz_offset_x, 0.f);	

	mov	r10, QWORD PTR [rdi]
	xor	r14d, r14d
	mov	edx, 2
	mov	DWORD PTR [rsp+32], r14d
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, eax
	mov	rcx, rdi
	mov	ebx, eax
	call	QWORD PTR [r10+1584]

; 30   : 	pblockSetValue(xyz_offset_y, 0.f);	

	mov	r9, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+3]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [r9+1584]

; 31   : 	pblockSetValue(xyz_offset_z, 0.f);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+4]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 32   : 	pblockSetValue(xyz_size_x, 1.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+5]
	vmovss	xmm6, DWORD PTR __real@3f800000
	vmovaps	xmm3, xmm6
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 33   : 	pblockSetValue(xyz_size_y, 1.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+6]
	vmovaps	xmm3, xmm6
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 34   : 	pblockSetValue(xyz_size_z, 1.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+7]
	vmovaps	xmm3, xmm6
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 35   : 	pblockSetValue(xyz_angle_x, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+8]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 36   : 	pblockSetValue(xyz_angle_y, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+9]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 37   : 	pblockSetValue(xyz_angle_z, 0.f);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+10]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 38   : 
; 39   : 	pblockSetValue(xyz_offset_x2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+14]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 40   : 	pblockSetValue(xyz_offset_y2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+15]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 41   : 	pblockSetValue(xyz_offset_z2, 0.f);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+16]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 42   : 	pblockSetValue(xyz_size_x2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+17]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 43   : 	pblockSetValue(xyz_size_y2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+18]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 44   : 	pblockSetValue(xyz_size_z2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+19]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 45   : 	pblockSetValue(xyz_angle_x2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+20]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 46   : 	pblockSetValue(xyz_angle_y2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+21]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 47   : 	pblockSetValue(xyz_angle_z2, 0.f);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+22]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 48   : 
; 49   : 	pblockSetValue(xyz_tile_x, x);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+11]
	mov	r9d, DWORD PTR x$[rsp]
	mov	r8d, ebx
	mov	rcx, rdi
	mov	DWORD PTR [rsp+32], r14d
	call	QWORD PTR [rax+1576]

; 50   : 	pblockSetValue(xyz_tile_y, y);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+12]
	mov	r9d, DWORD PTR y$[rsp]
	mov	r8d, ebx
	mov	rcx, rdi
	mov	DWORD PTR [rsp+32], r14d
	call	QWORD PTR [rax+1576]

; 51   : 	pblockSetValue(xyz_tile_z, z);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+13]
	mov	r9d, DWORD PTR z$[rsp]
	mov	r8d, ebx
	mov	rcx, rdi
	mov	DWORD PTR [rsp+32], r14d
	call	QWORD PTR [rax+1576]

; 52   : 
; 53   : 	pblockSetValue(xyz_seed, 12345);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+23]
	mov	r9d, 12345				; 00003039H
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 54   : 	pblockSetValue(xyz_rand_obj, TRUE);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+25]
	lea	r9d, QWORD PTR [r14+1]
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 55   : 	pblockSetValue(xyz_rand_mat, FALSE);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+24]
	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 56   : 	pblockSetValue(xyz_rand_par, FALSE);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+26]
	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 57   : 
; 58   : 	pblockSetValue(xyz_map, type);

	mov	rax, QWORD PTR [rdi]
	xor	edx, edx
	mov	r9d, ebp
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 59   : 	pblockSetValue(xyz_chan, 1);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 1
	mov	r9d, edx
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 60   : 
; 61   : 	pblockSetValue(xyz_lock, TRUE);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+27]
	lea	r9d, QWORD PTR [r14+1]
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 62   : 
; 63   : 	pblockSetValue(xyz_filtering, 1.f);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+28]
	vmovaps	xmm3, xmm6
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\interval.h

; 118  : 		void SetEmpty() { start = TIME_NegInfinity; end = TIME_NegInfinity; }

	vmovaps	xmm6, XMMWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 66   : }

	mov	rbp, QWORD PTR [rsp+96]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\interval.h

; 118  : 		void SetEmpty() { start = TIME_NegInfinity; end = TIME_NegInfinity; }

	mov	DWORD PTR [rsi], -2147483648		; ffffffff80000000H
	mov	DWORD PTR [rsi+4], -2147483648		; ffffffff80000000H
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 66   : }

	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
$LN6@reset:
	ret	0
?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z ENDP ; BerconXYZ::reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?update@BerconXYZ@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$ = 128
?update@BerconXYZ@@QEAAXXZ PROC				; BerconXYZ::update, COMDAT

; 161  : void BerconXYZ::update() {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 112				; 00000070H

; 162  : 	tm.IdentityMatrix();

	lea	rbx, QWORD PTR [rcx+156]
	mov	rdi, rcx
	mov	rcx, rbx
	call	QWORD PTR __imp_?IdentityMatrix@Matrix3@@QEAAXXZ
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR [rdi+8]
	vmovss	xmm1, DWORD PTR [rdi+12]
	vmovss	DWORD PTR $T2[rsp], xmm0
	vmovss	xmm0, DWORD PTR [rdi+16]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 163  : 	tm.Translate(Point3(offX, offY, offZ));

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rbx
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T2[rsp+8], xmm0
	vmovss	DWORD PTR $T2[rsp+4], xmm1
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 163  : 	tm.Translate(Point3(offX, offY, offZ));

	call	QWORD PTR __imp_?Translate@Matrix3@@QEAAXAEBVPoint3@@@Z

; 164  :  	tm.RotateX(angX);

	vmovss	xmm1, DWORD PTR [rdi+32]
	mov	rcx, rbx
	call	QWORD PTR __imp_?RotateX@Matrix3@@QEAAXM@Z

; 165  : 	tm.RotateY(angY);

	vmovss	xmm1, DWORD PTR [rdi+36]
	mov	rcx, rbx
	call	QWORD PTR __imp_?RotateY@Matrix3@@QEAAXM@Z

; 166  : 	tm.RotateZ(angZ);

	vmovss	xmm1, DWORD PTR [rdi+40]
	mov	rcx, rbx
	call	QWORD PTR __imp_?RotateZ@Matrix3@@QEAAXM@Z

; 167  : 
; 168  : 	invNoScaleTm = tm;

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	xmm1, XMMWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rbx+48]
	lea	rcx, QWORD PTR [rdi+208]
	vmovups	YMMWORD PTR [rcx], ymm0
	vmovups	XMMWORD PTR [rcx+32], xmm1
	mov	DWORD PTR [rcx+48], eax

; 169  : 	invNoScaleTm.Invert();

	vzeroupper
	call	QWORD PTR __imp_?Invert@Matrix3@@QEAAXXZ

; 170  : 
; 171  : 	tm.Scale(Point3(1.f/sizeX, 1.f/sizeY, 1.f/sizeZ));

	vmovss	xmm2, DWORD PTR __real@3f800000
	vdivss	xmm0, xmm2, DWORD PTR [rdi+20]
	vdivss	xmm1, xmm2, DWORD PTR [rdi+24]
	vmovss	DWORD PTR $T1[rsp], xmm0
	vdivss	xmm0, xmm2, DWORD PTR [rdi+28]
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	vmovss	DWORD PTR $T1[rsp+8], xmm0
	vmovss	DWORD PTR $T1[rsp+4], xmm1
	call	QWORD PTR __imp_?Scale@Matrix3@@QEAAXAEBVPoint3@@H@Z

; 172  : 
; 173  : 	getBasis(tm, b);

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	xmm1, XMMWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rbx+48]
	lea	r8, QWORD PTR [rdi+120]
	vmovups	YMMWORD PTR $T3[rsp], ymm0
	vmovups	XMMWORD PTR $T3[rsp+32], xmm1
	mov	DWORD PTR $T3[rsp+48], eax
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rdi
	vzeroupper
	call	?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z ; BerconXYZ::getBasis

; 174  : 	
; 175  : 	variance = NZERO(offX2) || NZERO(offY2) || NZERO(offZ2) || NZERO(sizeX2) || NZERO(sizeY2) || NZERO(sizeZ2) || NZERO(angX2) || NZERO(angY2) || NZERO(angZ2);

	vmovss	xmm0, DWORD PTR [rdi+56]
	vmovss	xmm1, DWORD PTR __real@38d1b717
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+60]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+64]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+68]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+72]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+76]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+80]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+84]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+88]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	mov	BYTE PTR [rdi+116], 0

; 176  : }

	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
$LN3@update:
	mov	rbx, QWORD PTR [rsp+128]
	mov	BYTE PTR [rdi+116], 1
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
?update@BerconXYZ@@QEAAXXZ ENDP				; BerconXYZ::update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z
_TEXT	SEGMENT
tv310 = 48
tv461 = 56
$T1 = 56
$T2 = 56
$T3 = 80
this$ = 224
tv305 = 232
pblock$ = 232
t$ = 240
ivalid$ = 248
?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z PROC ; BerconXYZ::update, COMDAT

; 68   : void BerconXYZ::update(IParamBlock2* pblock, TimeValue t, Interval& ivalid) {

$LN14:

; 69   : 	if (!pblock) return;

	test	rdx, rdx
	je	$LN12@update

; 68   : void BerconXYZ::update(IParamBlock2* pblock, TimeValue t, Interval& ivalid) {

	mov	rax, rsp
	mov	QWORD PTR [rax+32], r9
	mov	DWORD PTR [rax+24], r8d
	mov	QWORD PTR [rax+8], rcx
	push	rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 184				; 000000b8H

; 70   : 	//if (!pblock->GetMap()) return;
; 71   : 
; 72   : 	pblockGetValue(xyz_offset_x, offX);	

	mov	QWORD PTR [rax-40], rbp
	mov	rsi, r9
	mov	QWORD PTR [rax-48], r12
	lea	r9, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax-56], r13
	mov	rbx, rdx
	mov	QWORD PTR [rax-64], r15
	mov	r14, rcx
	mov	rax, QWORD PTR [rdx]
	xor	ebp, ebp
	mov	edx, 2
	mov	DWORD PTR [rsp+40], ebp
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], rsi
	mov	edi, r8d
	call	QWORD PTR [rax+1712]

; 73   : 	pblockGetValue(xyz_offset_y, offY);	

	mov	rax, QWORD PTR [rbx]
	lea	edx, QWORD PTR [rbp+3]
	mov	DWORD PTR [rsp+40], ebp
	lea	r9, QWORD PTR [r14+12]
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 74   : 	pblockGetValue(xyz_offset_z, offZ);

	mov	rax, QWORD PTR [rbx]
	lea	edx, QWORD PTR [rbp+4]
	mov	DWORD PTR [rsp+40], ebp
	lea	r9, QWORD PTR [r14+16]
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 75   : 	pblockGetValue(xyz_size_x, sizeX);	

	mov	rax, QWORD PTR [rbx]
	lea	r9, QWORD PTR [r14+20]
	lea	edx, QWORD PTR [rbp+5]
	mov	DWORD PTR [rsp+40], ebp
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 76   : 	pblockGetValue(xyz_size_y, sizeY);	

	mov	rax, QWORD PTR [rbx]
	lea	r9, QWORD PTR [r14+24]
	lea	edx, QWORD PTR [rbp+6]
	mov	DWORD PTR [rsp+40], ebp
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 77   : 	pblockGetValue(xyz_size_z, sizeZ);	

	mov	rax, QWORD PTR [rbx]
	lea	edx, QWORD PTR [rbp+7]
	mov	DWORD PTR [rsp+40], ebp
	lea	r9, QWORD PTR [r14+28]
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 78   : 	pblockGetValue(xyz_angle_x, angX);	

	mov	rax, QWORD PTR [rbx]
	lea	edx, QWORD PTR [rbp+8]
	mov	DWORD PTR [rsp+40], ebp
	lea	r9, QWORD PTR [r14+32]
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 79   : 	pblockGetValue(xyz_angle_y, angY);	

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+9]
	mov	rax, QWORD PTR [rbx]
	lea	r9, QWORD PTR [r14+36]
	mov	DWORD PTR [rsp+40], ebp
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 80   : 	pblockGetValue(xyz_angle_z, angZ);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+10]
	mov	rax, QWORD PTR [rbx]
	lea	r9, QWORD PTR [r14+40]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 81   : 
; 82   : 	pblockGetValue(xyz_offset_x2, offX2);	

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+14]
	mov	rax, QWORD PTR [rbx]
	lea	r9, QWORD PTR [r14+56]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 83   : 	pblockGetValue(xyz_offset_y2, offY2);	

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+15]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 60					; 0000003cH
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 84   : 	pblockGetValue(xyz_offset_z2, offZ2);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+16]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 64					; 00000040H
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 85   : 	pblockGetValue(xyz_size_x2, sizeX2);	

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+17]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 68					; 00000044H
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 86   : 	pblockGetValue(xyz_size_y2, sizeY2);	

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+18]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 72					; 00000048H
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 87   : 	pblockGetValue(xyz_size_z2, sizeZ2);	

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+19]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 76					; 0000004cH
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 88   : 	pblockGetValue(xyz_angle_x2, angX2);	

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+20]
	mov	r8, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rbx]
	add	r8, 80					; 00000050H
	mov	QWORD PTR tv305[rsp], r8
	mov	r9, r8
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 89   : 	pblockGetValue(xyz_angle_y2, angY2);	

	mov	r8, QWORD PTR this$[rsp]
	lea	edx, QWORD PTR [rbp+21]
	mov	rcx, QWORD PTR ivalid$[rsp]
	add	r8, 84					; 00000054H
	mov	rax, QWORD PTR [rbx]
	mov	r9, r8
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR tv310[rsp], r8
	mov	QWORD PTR [rsp+32], rcx
	mov	r8d, DWORD PTR t$[rsp]
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 90   : 	pblockGetValue(xyz_angle_z2, angZ2);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+22]
	mov	r8, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rbx]
	add	r8, 88					; 00000058H
	mov	QWORD PTR tv461[rsp], r8
	mov	r9, r8
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 91   : 
; 92   : 	pblockGetValue(xyz_tile_x, tileX);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+11]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 44					; 0000002cH
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1704]

; 93   : 	pblockGetValue(xyz_tile_y, tileY);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+12]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 48					; 00000030H
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1704]

; 94   : 	pblockGetValue(xyz_tile_z, tileZ);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+13]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 52					; 00000034H
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1704]

; 95   : 
; 96   : 	pblockGetValue(xyz_seed, p_seed);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+23]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 92					; 0000005cH
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1704]

; 97   : 	pblockGetValue(xyz_rand_obj, p_randObj);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+25]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 96					; 00000060H
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1704]

; 98   : 	pblockGetValue(xyz_rand_mat, p_randMat);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+24]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 100					; 00000064H
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1704]

; 99   : 	pblockGetValue(xyz_rand_par, p_randPar);

	mov	r9, QWORD PTR this$[rsp]
	lea	edx, QWORD PTR [rbp+26]
	mov	rax, QWORD PTR [rbx]
	add	r9, 104					; 00000068H
	mov	rcx, QWORD PTR ivalid$[rsp]
	mov	DWORD PTR [rsp+40], ebp
	mov	r8d, DWORD PTR t$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1704]

; 100  : 
; 101  : 	pblockGetValue(xyz_map, mappingType);

	mov	rcx, QWORD PTR ivalid$[rsp]
	xor	edx, edx
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], edx
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1704]

; 102  : 	pblockGetValue(xyz_chan, mappingChannel);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+1]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 4
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1704]

; 103  : 
; 104  : 	pblockGetValue(xyz_lock, lock);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+27]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 112					; 00000070H
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1704]

; 105  : 
; 106  : 	pblockGetValue(xyz_filtering, filtering);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rbp+28]
	mov	rax, QWORD PTR [rbx]
	mov	r9, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	add	r9, 108					; 0000006cH
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbx
	call	QWORD PTR [rax+1712]

; 107  : 	
; 108  : 
; 109  : 	angX *= DEG_TO_RAD; angY *= DEG_TO_RAD; angZ *= DEG_TO_RAD;

	vmovss	xmm3, DWORD PTR __real@3c8efa35

; 110  : 	angX2 *= DEG_TO_RAD; angY2 *= DEG_TO_RAD; angZ2 *= DEG_TO_RAD;

	mov	rax, QWORD PTR tv305[rsp]

; 111  : 
; 112  : 	EnableStuff(pblock, t);

	mov	rdx, rbx
	vmulss	xmm0, xmm3, DWORD PTR [r14+32]
	vmulss	xmm2, xmm3, DWORD PTR [r14+36]
	vmulss	xmm1, xmm3, DWORD PTR [r14+40]
	mov	rbx, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR t$[rsp]
	mov	rcx, rbx
	vmovss	DWORD PTR [r14+32], xmm0
	vmulss	xmm0, xmm3, DWORD PTR [rax]
	vmovss	DWORD PTR [rax], xmm0
	mov	rax, QWORD PTR tv310[rsp]
	vmovss	DWORD PTR [r14+36], xmm2
	vmovss	DWORD PTR [r14+40], xmm1
	vmulss	xmm2, xmm3, DWORD PTR [rax]
	vmovss	DWORD PTR [rax], xmm2
	mov	rax, QWORD PTR tv461[rsp]
	vmulss	xmm1, xmm3, DWORD PTR [rax]
	vmovss	DWORD PTR [rax], xmm1
	call	?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z ; BerconXYZ::EnableStuff

; 162  : 	tm.IdentityMatrix();

	add	rbx, 156				; 0000009cH
	mov	rcx, rbx
	call	QWORD PTR __imp_?IdentityMatrix@Matrix3@@QEAAXXZ
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	mov	rax, QWORD PTR this$[rsp]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 163  : 	tm.Translate(Point3(offX, offY, offZ));

	lea	rdx, QWORD PTR $T2[rsp]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm2, DWORD PTR [r14+12]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 163  : 	tm.Translate(Point3(offX, offY, offZ));

	mov	rcx, rbx
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T2[rsp+4], xmm2
	vmovss	xmm0, DWORD PTR [rax+8]
	vmovss	DWORD PTR $T2[rsp], xmm0
	vmovss	xmm0, DWORD PTR [r14+16]
	vmovss	DWORD PTR $T2[rsp+8], xmm0
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 163  : 	tm.Translate(Point3(offX, offY, offZ));

	call	QWORD PTR __imp_?Translate@Matrix3@@QEAAXAEBVPoint3@@@Z

; 164  :  	tm.RotateX(angX);

	vmovss	xmm1, DWORD PTR [r14+32]
	mov	rcx, rbx
	call	QWORD PTR __imp_?RotateX@Matrix3@@QEAAXM@Z

; 165  : 	tm.RotateY(angY);

	vmovss	xmm1, DWORD PTR [r14+36]
	mov	rcx, rbx
	call	QWORD PTR __imp_?RotateY@Matrix3@@QEAAXM@Z

; 166  : 	tm.RotateZ(angZ);

	vmovss	xmm1, DWORD PTR [r14+40]
	mov	rcx, rbx
	call	QWORD PTR __imp_?RotateZ@Matrix3@@QEAAXM@Z

; 167  : 
; 168  : 	invNoScaleTm = tm;

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	xmm1, XMMWORD PTR [rbx+32]
	mov	rdi, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rbx+48]
	lea	rcx, QWORD PTR [rdi+208]
	vmovups	YMMWORD PTR [rcx], ymm0
	vmovups	XMMWORD PTR [rcx+32], xmm1
	mov	DWORD PTR [rcx+48], eax

; 169  : 	invNoScaleTm.Invert();

	vzeroupper
	call	QWORD PTR __imp_?Invert@Matrix3@@QEAAXXZ

; 170  : 
; 171  : 	tm.Scale(Point3(1.f/sizeX, 1.f/sizeY, 1.f/sizeZ));

	vmovss	xmm2, DWORD PTR __real@3f800000
	vdivss	xmm0, xmm2, DWORD PTR [rdi+20]
	vdivss	xmm1, xmm2, DWORD PTR [rdi+24]
	vmovss	DWORD PTR $T1[rsp], xmm0
	vdivss	xmm0, xmm2, DWORD PTR [r14+28]
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	vmovss	DWORD PTR $T1[rsp+8], xmm0
	vmovss	DWORD PTR $T1[rsp+4], xmm1
	call	QWORD PTR __imp_?Scale@Matrix3@@QEAAXAEBVPoint3@@H@Z

; 172  : 
; 173  : 	getBasis(tm, b);

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	xmm1, XMMWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rbx+48]
	lea	r8, QWORD PTR [rdi+120]
	vmovups	YMMWORD PTR $T3[rsp], ymm0
	vmovups	XMMWORD PTR $T3[rsp+32], xmm1
	mov	DWORD PTR $T3[rsp+48], eax
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rdi
	vzeroupper
	call	?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z ; BerconXYZ::getBasis

; 174  : 	
; 175  : 	variance = NZERO(offX2) || NZERO(offY2) || NZERO(offZ2) || NZERO(sizeX2) || NZERO(sizeY2) || NZERO(sizeZ2) || NZERO(angX2) || NZERO(angY2) || NZERO(angZ2);

	vmovss	xmm0, DWORD PTR [r14+56]
	vmovss	xmm1, DWORD PTR __real@38d1b717
	vcomiss	xmm0, xmm1
	mov	r15, QWORD PTR [rsp+152]
	mov	r13, QWORD PTR [rsp+160]
	mov	r12, QWORD PTR [rsp+168]
	mov	rbp, QWORD PTR [rsp+176]
	ja	SHORT $LN6@update
	vmovss	xmm0, DWORD PTR [rdi+60]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN6@update
	vmovss	xmm0, DWORD PTR [rdi+64]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN6@update
	vmovss	xmm0, DWORD PTR [rdi+68]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN6@update
	vmovss	xmm0, DWORD PTR [rdi+72]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN6@update
	vmovss	xmm0, DWORD PTR [rdi+76]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN6@update
	vmovss	xmm0, DWORD PTR [rdi+80]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN6@update
	vmovss	xmm0, DWORD PTR [rdi+84]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN6@update
	vmovss	xmm0, DWORD PTR [rdi+88]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN6@update
	xor	al, al
	mov	BYTE PTR [rdi+116], al

; 113  : 	update();
; 114  : }

	add	rsp, 184				; 000000b8H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN6@update:

; 175  : 	variance = NZERO(offX2) || NZERO(offY2) || NZERO(offZ2) || NZERO(sizeX2) || NZERO(sizeY2) || NZERO(sizeZ2) || NZERO(angX2) || NZERO(angY2) || NZERO(angZ2);

	mov	al, 1
	mov	BYTE PTR [rdi+116], al

; 113  : 	update();
; 114  : }

	add	rsp, 184				; 000000b8H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
$LN12@update:
	ret	0
?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z ENDP ; BerconXYZ::update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.h
;	COMDAT ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
_TEXT	SEGMENT
$T1 = 64
val$ = 128
map$ = 128
t$ = 136
pb_id$ = 144
edit_id$ = 152
spin_id$ = 160
spinnerTypeWorld$ = 168
allowNegative$ = 176
?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z PROC	; setSpinnerType, COMDAT

; 89   :  static void setSpinnerType(IParamMap2 *map, TimeValue t, int pb_id, int edit_id, int spin_id, int spinnerTypeWorld = 1, bool allowNegative = false) {

	push	rbx
	push	rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 90   : 	HWND hWnd = map->GetHWnd();

	mov	rax, QWORD PTR [rcx]
	mov	ebp, r9d
	mov	r14d, r8d
	mov	r15d, edx
	mov	rbx, rcx
	call	QWORD PTR [rax+112]
	mov	rsi, rax

; 91   : 	if (!hWnd) return;

	test	rax, rax
	je	$LN1@setSpinner

; 92   : 
; 93   : 	float val;
; 94   : 	map->GetParamBlock()->GetValue(pb_id, t, val, FOREVER);

	mov	r10, QWORD PTR [rbx]
	mov	rcx, rbx
	mov	QWORD PTR [rsp+136], rdi
	mov	QWORD PTR [rsp+144], r12
	call	QWORD PTR [r10+136]
	mov	edx, -2147483648			; ffffffff80000000H
	lea	rcx, QWORD PTR $T1[rsp]
	mov	r8d, 2147483647				; 7fffffffH
	mov	rbx, rax
	mov	rdi, QWORD PTR [rax]
	call	QWORD PTR __imp_??0Interval@@QEAA@HH@Z
	xor	r12d, r12d
	lea	r9, QWORD PTR val$[rsp]
	mov	DWORD PTR [rsp+40], r12d
	mov	r8d, r15d
	movzx	edx, r14w
	mov	QWORD PTR [rsp+32], rax
	mov	rcx, rbx
	call	QWORD PTR [rdi+1712]

; 95   : 
; 96   : 	float minVal = allowNegative ? -1000000.f : 0.f;
; 97   : 
; 98   : 	ISpinnerControl* spin;
; 99   : 	if (spinnerTypeWorld)

	cmp	DWORD PTR spinnerTypeWorld$[rsp], 0
	mov	r8d, ebp
	movzx	eax, BYTE PTR allowNegative$[rsp]
	mov	rcx, rsi
	mov	rdi, QWORD PTR [rsp+136]
	mov	edx, DWORD PTR spin_id$[rsp]
	vmovd	xmm1, r12d
	mov	r12, QWORD PTR [rsp+144]
	vmovd	xmm0, eax
	vpcmpeqd xmm3, xmm0, xmm1
	vmovss	xmm1, DWORD PTR __real@c9742400
	vmovss	xmm0, DWORD PTR __real@3dcccccd
	vmovss	DWORD PTR [rsp+48], xmm0
	vmovss	xmm0, DWORD PTR __real@49742400
	vxorps	xmm2, xmm2, xmm2
	vblendvps xmm3, xmm1, xmm2, xmm3
	vmovss	xmm1, DWORD PTR val$[rsp]
	vmovss	DWORD PTR [rsp+40], xmm1
	vmovss	DWORD PTR [rsp+32], xmm0
	je	SHORT $LN3@setSpinner

; 100  : 		spin = SetupUniverseSpinner(hWnd, spin_id, edit_id, minVal, 1000000.f, val);

	call	QWORD PTR __imp_?SetupUniverseSpinner@@YAPEAVISpinnerControl@@PEAUHWND__@@HHMMMM@Z

; 101  : 	else

	jmp	SHORT $LN6@setSpinner
$LN3@setSpinner:

; 102  : 		spin = SetupFloatSpinner(hWnd, spin_id, edit_id, minVal, 1000000.f, val);

	call	QWORD PTR __imp_?SetupFloatSpinner@@YAPEAVISpinnerControl@@PEAUHWND__@@HHMMMM@Z
$LN6@setSpinner:

; 103  : 	spin->SetAutoScale(TRUE);

	mov	rbx, rax
	mov	edx, 1
	mov	rax, QWORD PTR [rax]
	mov	rcx, rbx
	call	QWORD PTR [rax+88]

; 104  : 	ReleaseISpinner(spin);

	mov	rcx, rbx
	call	QWORD PTR __imp_?ReleaseISpinner@@YAXPEAVISpinnerControl@@@Z
$LN1@setSpinner:

; 105  : }

	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ENDP	; setSpinnerType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\mesh.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\tab.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\mesh.h
;	COMDAT ??0VertexNormalsControl@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 0
this$ = 32
??0VertexNormalsControl@@QEAA@XZ PROC			; VertexNormalsControl::VertexNormalsControl, COMDAT

; 2949 : 	DllExport VertexNormalsControl () : mUseFaceAngles(true) { }

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	QWORD PTR $T1[rsp], -2
	mov	BYTE PTR [rcx], 1
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\tab.h

; 186  : 		Tab() : th(NULL)

	mov	QWORD PTR [rcx+8], 0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\mesh.h

; 2949 : 	DllExport VertexNormalsControl () : mUseFaceAngles(true) { }

	mov	rax, rcx
	add	rsp, 24
	ret	0
??0VertexNormalsControl@@QEAA@XZ ENDP			; VertexNormalsControl::VertexNormalsControl
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
?dtor$0@?0???0VertexNormalsControl@@QEAA@XZ@4HA PROC	; `VertexNormalsControl::VertexNormalsControl'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ ; Tab<VertexNormalsCallback *>::~Tab<VertexNormalsCallback *>
?dtor$0@?0???0VertexNormalsControl@@QEAA@XZ@4HA ENDP	; `VertexNormalsControl::VertexNormalsControl'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
?dtor$0@?0???0VertexNormalsControl@@QEAA@XZ@4HA PROC	; `VertexNormalsControl::VertexNormalsControl'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ ; Tab<VertexNormalsCallback *>::~Tab<VertexNormalsCallback *>
?dtor$0@?0???0VertexNormalsControl@@QEAA@XZ@4HA ENDP	; `VertexNormalsControl::VertexNormalsControl'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\tab.h
;	COMDAT ??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ PROC	; Tab<VertexNormalsCallback *>::~Tab<VertexNormalsCallback *>, COMDAT

; 204  : 		~Tab() {

$LN5:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2

; 205  : 			zfree((void**)&th); 

	call	QWORD PTR __imp_?zfree@@YAXPEAPEAX@Z
	npad	1

; 206  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ ENDP	; Tab<VertexNormalsCallback *>::~Tab<VertexNormalsCallback *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\tab.h
;	COMDAT ??0?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ PROC	; Tab<VertexNormalsCallback *>::Tab<VertexNormalsCallback *>, COMDAT

; 186  : 		Tab() : th(NULL)

	mov	QWORD PTR [rcx], 0

; 188  : 			ADSK_MAXSDK_IS_PLAIN_OLD_DATA_TYPE(T);
; 189  : 		}

	mov	rax, rcx
	ret	0
??0?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ ENDP	; Tab<VertexNormalsCallback *>::Tab<VertexNormalsCallback *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
;	COMDAT ?GetRow@Matrix3@@QEBA?AVPoint3@@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
i$ = 24
?GetRow@Matrix3@@QEBA?AVPoint3@@H@Z PROC		; Matrix3::GetRow, COMDAT

; 118  :    const Point3& operator[](int i) const { return((Point3&)(*m[i])); }

	movsxd	rax, r8d
	lea	r8, QWORD PTR [rax+rax*2]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	mov	eax, DWORD PTR [rcx+r8*4]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [rcx+r8*4+4]
	mov	DWORD PTR [rdx+4], eax
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rdx+8], eax
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h

; 260  :    Point3 GetRow(int i) const { return (*this)[i]; }

	mov	rax, rdx
	ret	0
?GetRow@Matrix3@@QEBA?AVPoint3@@H@Z ENDP		; Matrix3::GetRow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
;	COMDAT ??0Matrix3@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Matrix3@@QEAA@XZ PROC				; Matrix3::Matrix3, COMDAT

; 172  :    Matrix3(){ flags = 0; }

	mov	DWORD PTR [rcx+48], 0
	mov	rax, rcx
	ret	0
??0Matrix3@@QEAA@XZ ENDP				; Matrix3::Matrix3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
;	COMDAT ??AMatrix3@@QEBAAEBVPoint3@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??AMatrix3@@QEBAAEBVPoint3@@H@Z PROC			; Matrix3::operator[], COMDAT

; 118  :    const Point3& operator[](int i) const { return((Point3&)(*m[i])); }

	movsxd	rax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	lea	rax, QWORD PTR [rcx+rdx*4]
	ret	0
??AMatrix3@@QEBAAEBVPoint3@@H@Z ENDP			; Matrix3::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
;	COMDAT ??D@YA?AVPoint3@@AEBV0@M@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
a$ = 16
f$ = 24
??D@YA?AVPoint3@@AEBV0@M@Z PROC				; operator*, COMDAT

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm0, xmm2, DWORD PTR [rdx]
	vmulss	xmm1, xmm2, DWORD PTR [rdx+4]

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR [rcx], xmm0

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm0, xmm2, DWORD PTR [rdx+8]

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR [rcx+8], xmm0
	vmovss	DWORD PTR [rcx+4], xmm1

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	mov	rax, rcx

; 328  :    }

	ret	0
??D@YA?AVPoint3@@AEBV0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\interval.h
;	COMDAT ?SetEmpty@Interval@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?SetEmpty@Interval@@QEAAXXZ PROC			; Interval::SetEmpty, COMDAT

; 118  : 		void SetEmpty() { start = TIME_NegInfinity; end = TIME_NegInfinity; }

	mov	DWORD PTR [rcx], -2147483648		; ffffffff80000000H
	mov	DWORD PTR [rcx+4], -2147483648		; ffffffff80000000H
	ret	0
?SetEmpty@Interval@@QEAAXXZ ENDP			; Interval::SetEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ
text$di	SEGMENT
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ PROC	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId'', COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR ?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A, xmm0

; 32   : 		static AssetId kInvalidId;

	ret	0
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ENDP	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ PROC		; MaxSDK::AssetManagement::AssetId::AssetId, COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR [rcx], xmm0
	mov	rax, rcx
	ret	0
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ ENDP		; MaxSDK::AssetManagement::AssetId::AssetId
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\maxtypes.h
;	COMDAT ??0Class_ID@@QEAA@KK@Z
_TEXT	SEGMENT
this$ = 8
aa$ = 16
bb$ = 24
??0Class_ID@@QEAA@KK@Z PROC				; Class_ID::Class_ID, COMDAT

; 160  : 	Class_ID(ulong aa, ulong bb) { a = aa; b = bb; }

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	DWORD PTR [rcx+4], r8d
	ret	0
??0Class_ID@@QEAA@KK@Z ENDP				; Class_ID::Class_ID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 8
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
__t$ = 48
__s$ = 56
__n$ = 64
__f$ = 72
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN12:
	test	r8, r8
	je	SHORT $LN10@vector
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r9
	mov	rbx, r8
	mov	rbp, rdx
	mov	rdi, rcx
$LL2@vector:
	mov	rcx, rdi
	call	rsi
	add	rdi, rbp
	sub	rbx, 1
	jne	SHORT $LL2@vector
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN10@vector:
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
