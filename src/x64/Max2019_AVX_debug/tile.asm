; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27031.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	WinbaseIsolationAwarePrivateT_UnPgpgk
PUBLIC	IsolationAwarePrivateT_SqbjaYRiRY
PUBLIC	IsolationAwarePrivateT_SAbnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
EXTRN	GUID_NULL:BYTE
;	COMDAT IsolationAwarePrivateT_SqbjaYRiRY
_BSS	SEGMENT
IsolationAwarePrivateT_SqbjaYRiRY DD 01H DUP (?)
_BSS	ENDS
;	COMDAT IsolationAwarePrivateT_SAbnPgpgk
_BSS	SEGMENT
IsolationAwarePrivateT_SAbnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_UnPgpgk
_DATA	SEGMENT
WinbaseIsolationAwarePrivateT_UnPgpgk DQ ffffffffffffffffH
_DATA	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_of
PUBLIC	?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_not_of
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
PUBLIC	?deallocate@?$allocator@M@std@@QEAAXQEAM_K@Z	; std::allocator<float>::deallocate
PUBLIC	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z	; std::allocator<float>::allocate
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
PUBLIC	?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z ; std::vector<float,std::allocator<float> >::_Change_array
PUBLIC	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@AEAAXXZ ; std::vector<float,std::allocator<float> >::_Tidy
PUBLIC	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
PUBLIC	??1TileRow@@QEAA@XZ				; TileRow::~TileRow
PUBLIC	?deallocate@?$allocator@VTileRow@@@std@@QEAAXQEAVTileRow@@_K@Z ; std::allocator<TileRow>::deallocate
PUBLIC	?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z ; std::vector<TileRow,std::allocator<TileRow> >::_Destroy
PUBLIC	?_Xlength@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@CAXXZ ; std::vector<TileRow,std::allocator<TileRow> >::_Xlength
PUBLIC	?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; TilePattern::setPattern
PUBLIC	?setPreset@TilePattern@@QEAAXH@Z		; TilePattern::setPreset
PUBLIC	?edgeBlur@Tile@@CAMMMH@Z			; Tile::edgeBlur
PUBLIC	?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z ; Tile::corner
PUBLIC	?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z		; Tile::rotatePoint2
PUBLIC	?rotateUV@Tile@@CAXHMAEAVPoint3@@@Z		; Tile::rotateUV
PUBLIC	?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z ; Tile::uvMapping
PUBLIC	?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z ; Tile::drawTile
PUBLIC	?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ; Tile::pat_xBond
PUBLIC	?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ; Tile::pat_herring
PUBLIC	?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ; Tile::draw
PUBLIC	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
PUBLIC	??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Destroy
PUBLIC	?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlength
PUBLIC	??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGXZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos
PUBLIC	??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor'
PUBLIC	??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z ; std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>
PUBLIC	??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float>
PUBLIC	??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float const &>
PUBLIC	??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z ; std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >
PUBLIC	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::~_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >
PUBLIC	??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
PUBLIC	??_C@_1BA@HLCPMHKJ@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1@ ; `string'
PUBLIC	??_C@_1CI@MGOLCOH@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA0?$AA?4?$AA5?$AA?0?$AA?5@ ; `string'
PUBLIC	??_C@_1HM@KFKBNDNL@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1@ ; `string'
PUBLIC	??_C@_1HG@LGFFBGEF@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4@ ; `string'
PUBLIC	??_C@_1DI@OGPGLDJP@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?4@ ; `string'
PUBLIC	??_C@_1EG@NKHPAEJM@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5@ ; `string'
PUBLIC	??_C@_1FC@MFPKJHBG@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5@ ; `string'
PUBLIC	??_C@_1CK@FBIPLABB@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA0?$AA?0@ ; `string'
PUBLIC	??_C@_1FC@LEIJMHNO@?$AA0?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0@ ; `string'
PUBLIC	??_C@_1FC@DKDGEDND@?$AA0?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1@ ; `string'
PUBLIC	??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
PUBLIC	??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
PUBLIC	??_C@_13CGOKJPIL@?$AA?1@			; `string'
PUBLIC	??_C@_13DEFPDAGF@?$AA?0@			; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@38d1b717
PUBLIC	__real@3dfcb924
PUBLIC	__real@3f000000
PUBLIC	__real@3f490fdb
PUBLIC	__real@3f800000
PUBLIC	__real@3f9d70a4
PUBLIC	__real@3fa9999a
PUBLIC	__real@3fb504f3
PUBLIC	__real@3fc90fdb
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@403f666666666666
PUBLIC	__real@4048f5c3
PUBLIC	__real@40490fdb
PUBLIC	__real@4096cbe4
PUBLIC	__real@40dfffc000000000
PUBLIC	__real@41fb4c0b
PUBLIC	__real@5f800000
PUBLIC	__xmm@00000000000000070000000000000000
PUBLIC	__xmm@7fffffff7fffffff7fffffff7fffffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp_srand:PROC
EXTRN	__imp_rand:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPEBD@Z:PROC		; std::_Xout_of_range
EXTRN	__imp_??1ios_base@std@@UEAA@XZ:PROC
EXTRN	__imp_?_Ios_base_dtor@ios_base@std@@CAXPEAV12@@Z:PROC
EXTRN	__imp_??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ:PROC
EXTRN	__imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_??5?$basic_istream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV01@AEAN@Z:PROC
EXTRN	__imp_??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QEAA@PEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z:PROC
EXTRN	__imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_??0Point3@@QEAA@AEBV0@@Z:PROC
EXTRN	?smooth@@YAMMMM@Z:PROC				; smooth
EXTRN	?snoise@Perlin@@SAMM@Z:PROC			; Perlin::snoise
EXTRN	??_E?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
EXTRN	?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAAXXZ:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock
EXTRN	?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAAXXZ:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
EXTRN	?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAXAEBVlocale@2@@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue
EXTRN	?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAPEAV12@PEA_W_J@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf
EXTRN	?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAA_JXZ:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc
EXTRN	?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAHXZ:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync
EXTRN	?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAGXZ:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow
EXTRN	?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAA_JPEA_W_J@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn
EXTRN	?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAA_JPEB_W_J@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	cosf:PROC
EXTRN	fmodf:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	sinf:PROC
EXTRN	sqrtf:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp_??_7ios_base@std@@6B@:BYTE
EXTRN	__imp_??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	_fltused:DWORD
_BSS	SEGMENT
?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A DB 010H DUP (?) ; MaxSDK::AssetManagement::kInvalidId
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wmemcpy DD imagerel $LN4
	DD	imagerel $LN4+26
	DD	imagerel $unwind$wmemcpy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z DD imagerel $LN6
	DD	imagerel $LN6+26
	DD	imagerel $unwind$?copy@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN13
	DD	imagerel $LN13+43
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD imagerel $LN20
	DD	imagerel $LN20+63
	DD	imagerel $unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD imagerel $LN30
	DD	imagerel $LN30+113
	DD	imagerel $unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z DD imagerel $LN7
	DD	imagerel $LN7+21
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN77
	DD	imagerel $LN77+158
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z DD imagerel $LN47
	DD	imagerel $LN47+82
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD imagerel $LN28
	DD	imagerel $LN28+57
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEBV12@@Z DD imagerel $LN58
	DD	imagerel $LN58+166
	DD	imagerel $unwind$?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+24
	DD	imagerel $unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD imagerel $LN25
	DD	imagerel $LN25+55
	DD	imagerel $unwind$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD imagerel $LN115
	DD	imagerel $LN115+292
	DD	imagerel $unwind$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN87
	DD	imagerel $LN87+315
	DD	imagerel $unwind$?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN86
	DD	imagerel $LN86+302
	DD	imagerel $unwind$?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN58
	DD	imagerel $LN58+111
	DD	imagerel $unwind$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA DD imagerel ?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA
	DD	imagerel ?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ DD imagerel $LN48
	DD	imagerel $LN48+98
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z DD imagerel $LN17
	DD	imagerel $LN17+64
	DD	imagerel $unwind$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0TileRow@@QEAA@M@Z DD imagerel $LN16
	DD	imagerel $LN16+43
	DD	imagerel $unwind$??0TileRow@@QEAA@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@M@std@@QEAAXQEAM_K@Z DD imagerel $LN20
	DD	imagerel $LN20+67
	DD	imagerel $unwind$?deallocate@?$allocator@M@std@@QEAAXQEAM_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@M@std@@QEAAPEAM_K@Z DD imagerel $LN30
	DD	imagerel $LN30+117
	DD	imagerel $unwind$?allocate@?$allocator@M@std@@QEAAPEAM_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN162
	DD	imagerel $LN162+171
	DD	imagerel $unwind$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA+32
	DD	imagerel $unwind$?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ DD imagerel $LN106
	DD	imagerel $LN106+102
	DD	imagerel $unwind$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM00@Z DD imagerel $LN28
	DD	imagerel $LN28+45
	DD	imagerel $unwind$?_Umove@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@MV?$allocator@M@std@@@std@@AEAA_N_K@Z DD imagerel $LN72
	DD	imagerel $LN72+88
	DD	imagerel $unwind$?_Buy@?$vector@MV?$allocator@M@std@@@std@@AEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z DD imagerel $LN102
	DD	imagerel $LN102+136
	DD	imagerel $unwind$?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@MV?$allocator@M@std@@@std@@AEAAXXZ DD imagerel $LN102
	DD	imagerel $LN102+92
	DD	imagerel $unwind$?_Tidy@?$vector@MV?$allocator@M@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1TileRow@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+31
	DD	imagerel $unwind$??1TileRow@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0TileRow@@QEAA@AEBV0@@Z DD imagerel $LN6
	DD	imagerel $LN6+55
	DD	imagerel $unwind$??0TileRow@@QEAA@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0TileRow@@QEAA@$$QEAV0@@Z DD imagerel $LN94
	DD	imagerel $LN94+86
	DD	imagerel $unwind$??0TileRow@@QEAA@$$QEAV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GTileRow@@QEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+72
	DD	imagerel $unwind$??_GTileRow@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@VTileRow@@@std@@QEAAXQEAVTileRow@@_K@Z DD imagerel $LN20
	DD	imagerel $LN20+66
	DD	imagerel $unwind$?deallocate@?$allocator@VTileRow@@@std@@QEAAXQEAVTileRow@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+116
	DD	imagerel $unwind$?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD imagerel $LN83
	DD	imagerel $LN83+86
	DD	imagerel $unwind$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ DD imagerel $LN65
	DD	imagerel $LN65+115
	DD	imagerel $unwind$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z DD imagerel $LN31
	DD	imagerel $LN31+69
	DD	imagerel $unwind$?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z DD imagerel $LN120
	DD	imagerel $LN120+203
	DD	imagerel $unwind$?_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlength@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD imagerel $LN164
	DD	imagerel $LN164+393
	DD	imagerel $unwind$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?update@TilePattern@@QEAAXXZ DD imagerel $LN74
	DD	imagerel $LN74+39
	DD	imagerel $unwind$?update@TilePattern@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?update@TilePattern@@QEAAXXZ DD imagerel $LN74+39
	DD	imagerel $LN74+218
	DD	imagerel $chain$1$?update@TilePattern@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?update@TilePattern@@QEAAXXZ DD imagerel $LN74+218
	DD	imagerel $LN74+225
	DD	imagerel $chain$2$?update@TilePattern@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setPreset@TilePattern@@QEAAXH@Z DD imagerel $LN270
	DD	imagerel $LN270+628
	DD	imagerel $unwind$?setPreset@TilePattern@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z DD imagerel $LN90
	DD	imagerel $LN90+748
	DD	imagerel $unwind$?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z DD imagerel $LN12
	DD	imagerel $LN12+116
	DD	imagerel $unwind$?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD imagerel $LN67
	DD	imagerel $LN67+55
	DD	imagerel $unwind$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD imagerel $LN67+55
	DD	imagerel $LN67+62
	DD	imagerel $chain$0$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD imagerel $LN67+62
	DD	imagerel $LN67+703
	DD	imagerel $chain$8$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD imagerel $LN67+703
	DD	imagerel $LN67+753
	DD	imagerel $chain$9$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD imagerel $LN67+753
	DD	imagerel $LN67+998
	DD	imagerel $chain$10$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD imagerel $LN67+998
	DD	imagerel $LN67+1128
	DD	imagerel $chain$11$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD imagerel $LN67+1128
	DD	imagerel $LN67+1225
	DD	imagerel $chain$12$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD imagerel $LN67+1225
	DD	imagerel $LN67+1296
	DD	imagerel $chain$13$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z DD imagerel $LN130
	DD	imagerel $LN130+140
	DD	imagerel $unwind$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z DD imagerel $LN130+140
	DD	imagerel $LN130+720
	DD	imagerel $chain$0$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z DD imagerel $LN130+720
	DD	imagerel $LN130+1621
	DD	imagerel $chain$1$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD imagerel $LN57
	DD	imagerel $LN57+237
	DD	imagerel $unwind$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD imagerel $LN57+237
	DD	imagerel $LN57+492
	DD	imagerel $chain$0$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD imagerel $LN57+492
	DD	imagerel $LN57+519
	DD	imagerel $chain$1$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD imagerel $LN21
	DD	imagerel $LN21+515
	DD	imagerel $unwind$?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD imagerel $LN82
	DD	imagerel $LN82+101
	DD	imagerel $unwind$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD imagerel $LN82+101
	DD	imagerel $LN82+480
	DD	imagerel $chain$0$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD imagerel $LN82+480
	DD	imagerel $LN82+877
	DD	imagerel $chain$2$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD imagerel $LN82+877
	DD	imagerel $LN82+923
	DD	imagerel $chain$1$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getAngle@@YAMHM@Z DD imagerel ?getAngle@@YAMHM@Z
	DD	imagerel ?getAngle@@YAMHM@Z+232
	DD	imagerel $unwind$?getAngle@@YAMHM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z DD imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+245
	DD	imagerel $unwind$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z DD imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+245
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+813
	DD	imagerel $chain$8$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z DD imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+813
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+869
	DD	imagerel $chain$9$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z DD imagerel ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
	DD	imagerel ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z+902
	DD	imagerel $unwind$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA DD imagerel ?dtor$1@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA
	DD	imagerel ?dtor$1@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z DD imagerel $LN20
	DD	imagerel $LN20+66
	DD	imagerel $unwind$?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+116
	DD	imagerel $unwind$?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ DD imagerel $LN130
	DD	imagerel $LN130+158
	DD	imagerel $unwind$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z DD imagerel $LN124
	DD	imagerel $LN124+78
	DD	imagerel $unwind$?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z DD imagerel $LN127
	DD	imagerel $LN127+100
	DD	imagerel $unwind$?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z DD imagerel $LN128
	DD	imagerel $LN128+97
	DD	imagerel $unwind$?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z DD imagerel $LN130
	DD	imagerel $LN130+97
	DD	imagerel $unwind$?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z DD imagerel $LN38
	DD	imagerel $LN38+49
	DD	imagerel $unwind$?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z DD imagerel $LN127
	DD	imagerel $LN127+39
	DD	imagerel $unwind$?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z DD imagerel $LN127+39
	DD	imagerel $LN127+98
	DD	imagerel $chain$0$?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z DD imagerel $LN127+98
	DD	imagerel $LN127+182
	DD	imagerel $chain$1$?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ DD imagerel $LN127
	DD	imagerel $LN127+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ DD imagerel $LN127+21
	DD	imagerel $LN127+80
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ DD imagerel $LN127+80
	DD	imagerel $LN127+143
	DD	imagerel $chain$1$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z DD imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2345
	DD	imagerel $unwind$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD imagerel ?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	imagerel ?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA+49
	DD	imagerel $unwind$?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD imagerel ?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	imagerel ?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA+49
	DD	imagerel $unwind$?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD imagerel ?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	imagerel ?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA+49
	DD	imagerel $unwind$?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD imagerel $LN15
	DD	imagerel $LN15+208
	DD	imagerel $unwind$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD imagerel $LN15
	DD	imagerel $LN15+100
	DD	imagerel $unwind$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD imagerel $LN62
	DD	imagerel $LN62+365
	DD	imagerel $unwind$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD imagerel $LN49
	DD	imagerel $LN49+208
	DD	imagerel $unwind$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD imagerel $LN66
	DD	imagerel $LN66+204
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD imagerel $LN66+204
	DD	imagerel $LN66+375
	DD	imagerel $chain$0$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD imagerel $LN66+375
	DD	imagerel $LN66+419
	DD	imagerel $chain$1$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN45
	DD	imagerel $LN45+344
	DD	imagerel $unwind$?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN32
	DD	imagerel $LN32+115
	DD	imagerel $unwind$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN32+115
	DD	imagerel $LN32+214
	DD	imagerel $chain$0$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN32+214
	DD	imagerel $LN32+244
	DD	imagerel $chain$1$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD imagerel $LN26
	DD	imagerel $LN26+62
	DD	imagerel $unwind$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD imagerel $LN26+62
	DD	imagerel $LN26+127
	DD	imagerel $chain$1$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD imagerel $LN26+127
	DD	imagerel $LN26+253
	DD	imagerel $chain$2$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD imagerel $LN26+253
	DD	imagerel $LN26+285
	DD	imagerel $chain$3$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ DD imagerel $LN45
	DD	imagerel $LN45+171
	DD	imagerel $unwind$?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+52
	DD	imagerel $unwind$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+59
	DD	imagerel $unwind$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ DD imagerel $LN22
	DD	imagerel $LN22+139
	DD	imagerel $unwind$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z DD imagerel $LN120
	DD	imagerel $LN120+78
	DD	imagerel $unwind$??$emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN690
	DD	imagerel $LN690+935
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$3@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA DD imagerel ?catch$3@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA
	DD	imagerel ?catch$3@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA+66
	DD	imagerel $unwind$?catch$3@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD imagerel $LN81
	DD	imagerel $LN81+86
	DD	imagerel $unwind$??$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z DD imagerel $LN54
	DD	imagerel $LN54+62
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z DD imagerel $LN12
	DD	imagerel $LN12+52
	DD	imagerel $unwind$??$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z DD imagerel $LN296
	DD	imagerel $LN296+537
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$2@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA DD imagerel ?catch$2@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA
	DD	imagerel ?catch$2@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA+70
	DD	imagerel $unwind$?catch$2@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z DD imagerel $LN208
	DD	imagerel $LN208+262
	DD	imagerel $unwind$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z@4HA+43
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z DD imagerel $LN208
	DD	imagerel $LN208+262
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z@4HA+43
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find_first_not_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$00@0@@Z DD imagerel $LN62
	DD	imagerel $LN62+283
	DD	imagerel $unwind$??$_Traits_find_first_not_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$00@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find_first_not_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$0A@@0@@Z DD imagerel $LN29
	DD	imagerel $LN29+100
	DD	imagerel $unwind$??$_Traits_find_first_not_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$0A@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find_first_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$00@0@@Z DD imagerel $LN63
	DD	imagerel $LN63+284
	DD	imagerel $unwind$??$_Traits_find_first_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$00@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find_first_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$0A@@0@@Z DD imagerel $LN29
	DD	imagerel $LN29+104
	DD	imagerel $unwind$??$_Traits_find_first_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$0A@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z DD imagerel $LN25
	DD	imagerel $LN25+69
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@QEBAXQEA_W_KQEB_W@Z DD imagerel $LN10
	DD	imagerel $LN10+48
	DD	imagerel $unwind$??R<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@QEBAXQEA_W_KQEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z DD imagerel $LN95
	DD	imagerel $LN95+42
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z DD imagerel $LN95+42
	DD	imagerel $LN95+232
	DD	imagerel $chain$1$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z DD imagerel $LN95+232
	DD	imagerel $LN95+239
	DD	imagerel $chain$3$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z DD imagerel $LN95+239
	DD	imagerel $LN95+245
	DD	imagerel $chain$4$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN23
	DD	imagerel $LN23+90
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+53
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z DD imagerel $LN32
	DD	imagerel $LN32+49
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_bitmap@_W$0A@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$??0?$_String_bitmap@_W$0A@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z DD imagerel $LN23
	DD	imagerel $LN23+69
	DD	imagerel $unwind$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN16
	DD	imagerel $LN16+62
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD imagerel $LN30
	DD	imagerel $LN30+49
	DD	imagerel $unwind$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z DD imagerel $LN121
	DD	imagerel $LN121+100
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z DD imagerel $LN163
	DD	imagerel $LN163+149
	DD	imagerel $unwind$??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z DD imagerel $LN22
	DD	imagerel $LN22+48
	DD	imagerel $unwind$??$_Uninitialized_move@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ucopy@PEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM00@Z DD imagerel $LN28
	DD	imagerel $LN28+45
	DD	imagerel $unwind$??$_Ucopy@PEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z DD imagerel $LN11
	DD	imagerel $LN11+31
	DD	imagerel $unwind$??$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD imagerel $LN103
	DD	imagerel $LN103+100
	DD	imagerel $unwind$??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD imagerel $LN145
	DD	imagerel $LN145+149
	DD	imagerel $unwind$??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move_al_unchecked@MMV?$allocator@M@std@@@std@@YAPEAMQEAM00AEAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+48
	DD	imagerel $unwind$??$_Uninitialized_move_al_unchecked@MMV?$allocator@M@std@@@std@@YAPEAMQEAM00AEAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z DD imagerel $LN22
	DD	imagerel $LN22+48
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+61
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ DD imagerel $LN26
	DD	imagerel $LN26+72
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z DD imagerel $LN106
	DD	imagerel $LN106+94
	DD	imagerel $unwind$??$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAMPEAM@std@@YAPEAMPEAM00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAMPEAM@std@@YAPEAMPEAM00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_al_unchecked@MMV?$allocator@M@std@@@std@@YAPEAMQEAM00AEAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+48
	DD	imagerel $unwind$??$_Uninitialized_copy_al_unchecked@MMV?$allocator@M@std@@@std@@YAPEAMQEAM00AEAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z DD imagerel $LN100
	DD	imagerel $LN100+84
	DD	imagerel $unwind$??$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?kInvalidId$initializer$@AssetManagement@MaxSDK@@3P6AXXZEA DQ FLAT:??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ; MaxSDK::AssetManagement::kInvalidId$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffff7fffffff7fffffff7fffffff
CONST	SEGMENT
__xmm@7fffffff7fffffff7fffffff7fffffff DB 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@00000000000000070000000000000000
CONST	SEGMENT
__xmm@00000000000000070000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 07H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@5f800000
CONST	SEGMENT
__real@5f800000 DD 05f800000r			; 1.84467e+19
CONST	ENDS
;	COMDAT __real@41fb4c0b
CONST	SEGMENT
__real@41fb4c0b DD 041fb4c0br			; 31.4121
CONST	ENDS
;	COMDAT __real@40dfffc000000000
CONST	SEGMENT
__real@40dfffc000000000 DQ 040dfffc000000000r	; 32767
CONST	ENDS
;	COMDAT __real@4096cbe4
CONST	SEGMENT
__real@4096cbe4 DD 04096cbe4r			; 4.71239
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@4048f5c3
CONST	SEGMENT
__real@4048f5c3 DD 04048f5c3r			; 3.14
CONST	ENDS
;	COMDAT __real@403f666666666666
CONST	SEGMENT
__real@403f666666666666 DQ 0403f666666666666r	; 31.4
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc90fdb
CONST	SEGMENT
__real@3fc90fdb DD 03fc90fdbr			; 1.5708
CONST	ENDS
;	COMDAT __real@3fb504f3
CONST	SEGMENT
__real@3fb504f3 DD 03fb504f3r			; 1.41421
CONST	ENDS
;	COMDAT __real@3fa9999a
CONST	SEGMENT
__real@3fa9999a DD 03fa9999ar			; 1.325
CONST	ENDS
;	COMDAT __real@3f9d70a4
CONST	SEGMENT
__real@3f9d70a4 DD 03f9d70a4r			; 1.23
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f490fdb
CONST	SEGMENT
__real@3f490fdb DD 03f490fdbr			; 0.785398
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dfcb924
CONST	SEGMENT
__real@3dfcb924 DD 03dfcb924r			; 0.1234
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ios_base@std@@8
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	imagerel ??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	imagerel ??_R2?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_iostream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_iostream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD imagerel ??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_iostream@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	imagerel ??_R2?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$all'
	DB	'ocator@_W@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD 01H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
	DD	098H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
	DD	imagerel ??_R3?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
	DD	imagerel ??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD imagerel ??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD imagerel ??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8 DD 00H ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$alloca'
	DB	'tor@_W@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DD 01H ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@8
	DD	imagerel ??_R3?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@8
	DD	imagerel ??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@ DB 'vector<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_13DEFPDAGF@?$AA?0@
CONST	SEGMENT
??_C@_13DEFPDAGF@?$AA?0@ DB ',', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13CGOKJPIL@?$AA?1@
CONST	SEGMENT
??_C@_13CGOKJPIL@?$AA?1@ DB '/', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
	DD	088H
CONST	ENDS
;	COMDAT ??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@ DD 00H ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbtable'
	DD	098H
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DQ FLAT:??_R4?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
	DQ	FLAT:??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ DQ FLAT:??_R4?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vftable'
	DQ	FLAT:??_E?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
	DQ	FLAT:?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGXZ
	DQ	FLAT:?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAGXZ
	DQ	FLAT:?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAA_JPEA_W_J@Z
	DQ	FLAT:?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAA_JPEB_W_J@Z
	DQ	FLAT:?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAPEAV12@PEA_W_J@Z
	DQ	FLAT:?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_C@_1FC@DKDGEDND@?$AA0?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1@
CONST	SEGMENT
??_C@_1FC@DKDGEDND@?$AA0?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1@ DB '0'
	DB	00H, ',', 00H, '1', 00H, ',', 00H, '.', 00H, '5', 00H, ' ', 00H
	DB	'/', 00H, ' ', 00H, '-', 00H, '.', 00H, '2', 00H, '5', 00H, ','
	DB	00H, '1', 00H, ',', 00H, '.', 00H, '5', 00H, ' ', 00H, '/', 00H
	DB	' ', 00H, '-', 00H, '.', 00H, '2', 00H, '5', 00H, ',', 00H, '1'
	DB	00H, ',', 00H, '1', 00H, ' ', 00H, '/', 00H, ' ', 00H, '-', 00H
	DB	'.', 00H, '2', 00H, '5', 00H, ',', 00H, '1', 00H, ',', 00H, '1'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@LEIJMHNO@?$AA0?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0@
CONST	SEGMENT
??_C@_1FC@LEIJMHNO@?$AA0?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0@ DB '0'
	DB	00H, ',', 00H, '1', 00H, ',', 00H, '1', 00H, ' ', 00H, '/', 00H
	DB	' ', 00H, '-', 00H, '.', 00H, '2', 00H, '5', 00H, ',', 00H, '1'
	DB	00H, ',', 00H, '.', 00H, '5', 00H, ' ', 00H, '/', 00H, ' ', 00H
	DB	'-', 00H, '.', 00H, '2', 00H, '5', 00H, ',', 00H, '1', 00H, ','
	DB	00H, '1', 00H, ' ', 00H, '/', 00H, ' ', 00H, '-', 00H, '.', 00H
	DB	'2', 00H, '5', 00H, ',', 00H, '1', 00H, ',', 00H, '.', 00H, '5'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@FBIPLABB@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA0?$AA?0@
CONST	SEGMENT
??_C@_1CK@FBIPLABB@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA0?$AA?0@ DB '.'
	DB	00H, '2', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H
	DB	' ', 00H, '.', 00H, '5', 00H, ' ', 00H, '/', 00H, ' ', 00H, '0'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@MFPKJHBG@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5@
CONST	SEGMENT
??_C@_1FC@MFPKJHBG@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5@ DB '0'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H, ','
	DB	00H, ' ', 00H, '.', 00H, '5', 00H, ' ', 00H, '/', 00H, ' ', 00H
	DB	'1', 00H, '.', 00H, '7', 00H, '5', 00H, ',', 00H, ' ', 00H, '1'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '.', 00H, '5'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@NKHPAEJM@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5@
CONST	SEGMENT
??_C@_1EG@NKHPAEJM@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5@ DB '0'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '.', 00H, '5'
	DB	00H, ' ', 00H, '/', 00H, ' ', 00H, '1', 00H, '.', 00H, '2', 00H
	DB	'5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '.', 00H
	DB	'5', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@OGPGLDJP@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?4@
CONST	SEGMENT
??_C@_1DI@OGPGLDJP@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?4@ DB '0'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	',', 00H, ' ', 00H, '.', 00H, '5', 00H, ' ', 00H, '/', 00H, ' '
	DB	00H, '.', 00H, '7', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '.', 00H, '5'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1HG@LGFFBGEF@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4@
CONST	SEGMENT
??_C@_1HG@LGFFBGEF@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4@ DB '.'
	DB	00H, '2', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H
	DB	' ', 00H, '.', 00H, '5', 00H, ' ', 00H, '/', 00H, ' ', 00H, '-'
	DB	00H, '.', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H
	DB	' ', 00H, '1', 00H, ' ', 00H, '/', 00H, ' ', 00H, '-', 00H, '.'
	DB	00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H
	DB	'1', 00H, ' ', 00H, '/', 00H, ' ', 00H, '-', 00H, '.', 00H, '5'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	' ', 00H, '/', 00H, ' ', 00H, '-', 00H, '.', 00H, '5', 00H, ','
	DB	00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HM@KFKBNDNL@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1@
CONST	SEGMENT
??_C@_1HM@KFKBNDNL@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1@ DB '.'
	DB	00H, '2', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H
	DB	' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '.', 00H, '5', 00H, ' '
	DB	00H, '/', 00H, ' ', 00H, '-', 00H, '.', 00H, '5', 00H, ',', 00H
	DB	' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H, ' ', 00H, '/'
	DB	00H, ' ', 00H, '-', 00H, '.', 00H, '5', 00H, ',', 00H, ' ', 00H
	DB	'1', 00H, ',', 00H, ' ', 00H, '1', 00H, ' ', 00H, '/', 00H, ' '
	DB	00H, '-', 00H, '.', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	',', 00H, ' ', 00H, '1', 00H, ' ', 00H, '/', 00H, ' ', 00H, '-'
	DB	00H, '.', 00H, '5', 00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H
	DB	' ', 00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@MGOLCOH@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA0?$AA?4?$AA5?$AA?0?$AA?5@
CONST	SEGMENT
??_C@_1CI@MGOLCOH@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA0?$AA?4?$AA5?$AA?0?$AA?5@ DB '0'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H
	DB	' ', 00H, '/', 00H, ' ', 00H, '0', 00H, '.', 00H, '5', 00H, ','
	DB	00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@HLCPMHKJ@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1@
CONST	SEGMENT
??_C@_1BA@HLCPMHKJ@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1@ DB '0', 00H, ','
	DB	00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?kTriObjNormalXTCID@@3VClass_ID@@B DD 0730a33d7H	; kTriObjNormalXTCID
	DD	027246c55H
?pat_herring_dir@@3PAEA DB 00H				; pat_herring_dir
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	ORG $+8
?pat_herring_x@@3PAMA DD 03f800000r		; 1	; pat_herring_x
	DD	03f800000r			; 1
	DD	040200000r			; 2.5
	DD	040600000r			; 3.5
	DD	000000000r			; 0
	DD	03fc00000r			; 1.5
	DD	040200000r			; 2.5
	DD	040800000r			; 4
	DD	03f000000r			; 0.5
	DD	03fc00000r			; 1.5
	DD	040400000r			; 3
	DD	040400000r			; 3
	DD	03f000000r			; 0.5
	DD	040000000r			; 2
	DD	040000000r			; 2
	DD	040600000r			; 3.5
?pat_herring_y@@3PAMA DD 03f000000r		; 0.5	; pat_herring_y
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	03fc00000r			; 1.5
	DD	040000000r			; 2
	DD	03f800000r			; 1
	DD	03fc00000r			; 1.5
	DD	040400000r			; 3
	DD	040000000r			; 2
	DD	040200000r			; 2.5
	DD	040200000r			; 2.5
	DD	040400000r			; 3
	DD	040600000r			; 3.5
	DD	040600000r			; 3.5
	DD	040800000r			; 4
?pat_herring_id@@3PAEA DB 01H				; pat_herring_id
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	02H
	DB	01H
	DB	04H
	DB	03H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	04H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z DD imagerel ??$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z DD 010c11H
	DD	02204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_al_unchecked@MMV?$allocator@M@std@@@std@@YAPEAMQEAM00AEAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAMPEAM@std@@YAPEAMPEAM00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z DD imagerel ??$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z DD 010c11H
	DD	02204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ DD imagerel ??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ DD 041411H
	DD	093414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ DD imagerel ??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move_al_unchecked@MMV?$allocator@M@std@@@std@@YAPEAMQEAM00AEAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD imagerel ??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z+27
	DD	00H
	DD	imagerel ??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z+141
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD 010c11H
	DD	04204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD imagerel ??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z+27
	DD	00H
	DD	imagerel ??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z+89
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD 010c11H
	DD	04204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z DD imagerel ??$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z DD 011211H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ucopy@PEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z DD imagerel ??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z+27
	DD	00H
	DD	imagerel ??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z+141
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z@4HA
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z DD 010c11H
	DD	04204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z DD imagerel ??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z+27
	DD	00H
	DD	imagerel ??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z+89
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z DD 010c11H
	DD	04204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U?$integral_constant@_N$0A@@0@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z DD imagerel ??$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z DD 041d11H
	DD	09341dH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_bitmap@_W$0A@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z DD 021H
	DD	imagerel $LN95
	DD	imagerel $LN95+42
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z DD 040021H
	DD	096400H
	DD	085400H
	DD	imagerel $LN95
	DD	imagerel $LN95+42
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z DD 040a21H
	DD	09640aH
	DD	085405H
	DD	imagerel $LN95
	DD	imagerel $LN95+42
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z DD 060e01H
	DD	0a340eH
	DD	0f00a320eH
	DD	07006e008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@QEBAXQEA_W_KQEB_W@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z DD imagerel ??$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find_first_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$0A@@0@@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find_first_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$00@0@@Z DD 0b1b01H
	DD	02a641bH
	DD	029541bH
	DD	028341bH
	DD	024011bH
	DD	0e012f014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find_first_not_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$0A@@0@@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find_first_not_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$00@0@@Z DD 0b1d01H
	DD	029741dH
	DD	028641dH
	DD	027541dH
	DD	026341dH
	DD	024011dH
	DD	0e016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z DD imagerel ??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z
	DD	0ffffffffH
	DD	imagerel ??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z+153
	DD	00H
	DD	imagerel ??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z+216
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z
	DD	01H
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z
	DD	05H
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z DD 081d19H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	030066007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z DD imagerel ??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z
	DD	0ffffffffH
	DD	imagerel ??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z+153
	DD	00H
	DD	imagerel ??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z+216
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z
	DD	01H
	DD	imagerel $tryMap$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z
	DD	05H
	DD	imagerel $ip2state$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z DD 081d19H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	030066007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$2@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z DD imagerel ??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z+286
	DD	00H
	DD	imagerel ??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z+377
	DD	0ffffffffH
	DD	imagerel ?catch$2@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA
	DD	00H
	DD	imagerel ?catch$2@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA+14
	DD	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$2@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z DD 082219H
	DD	0f0157219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0300b600cH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z DD imagerel ??$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z DD 010d11H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z DD imagerel ??$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z DD 020f11H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD imagerel ??$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD 020f11H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$3@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z DD imagerel ??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z+292
	DD	00H
	DD	imagerel ??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z+375
	DD	01H
	DD	imagerel ??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z+439
	DD	00H
	DD	imagerel ??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z+512
	DD	02H
	DD	imagerel ??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z+579
	DD	00H
	DD	imagerel ??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z+672
	DD	03H
	DD	imagerel ??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z+739
	DD	00H
	DD	imagerel ??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z+769
	DD	0ffffffffH
	DD	imagerel ?catch$3@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA
	DD	00H
	DD	imagerel ?catch$3@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA+13
	DD	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$3@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z DD 00H
	DD	03H
	DD	04H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	imagerel ?dtor$0@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z
	DD	0bH
	DD	imagerel $ip2state$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z
	DD	0c0H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z DD 092319H
	DD	01a0117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	03006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ DD imagerel ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
	DD	0ffffffffH
	DD	imagerel ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ+77
	DD	00H
	DD	imagerel ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ+87
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$4@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+62
	DD	imagerel $unwind$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD 020021H
	DD	095400H
	DD	imagerel $LN26
	DD	imagerel $LN26+62
	DD	imagerel $unwind$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD 041121H
	DD	095411H
	DD	083405H
	DD	imagerel $LN26
	DD	imagerel $LN26+62
	DD	imagerel $unwind$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z DD 060e01H
	DD	0a640eH
	DD	0f00a320eH
	DD	07006e008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+115
	DD	imagerel $unwind$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 020521H
	DD	027405H
	DD	imagerel $LN32
	DD	imagerel $LN32+115
	DD	imagerel $unwind$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 050c01H
	DD	04640cH
	DD	03340cH
	DD	0e00cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 0a1801H
	DD	067418H
	DD	056418H
	DD	045418H
	DD	033418H
	DD	0e016f018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD 021H
	DD	imagerel $LN66
	DD	imagerel $LN66+204
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD 020521H
	DD	0ae405H
	DD	imagerel $LN66
	DD	imagerel $LN66+204
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z DD 0a1601H
	DD	0c5416H
	DD	0b3416H
	DD	0f0123216H
	DD	0c00ed010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD imagerel ??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ+32
	DD	00H
	DD	imagerel ??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ+186
	DD	0ffffffffH
	DD	imagerel ??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ+201
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
	DD	00H
	DD	00H
	DD	04H
	DD	imagerel $ip2state$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD 021319H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD imagerel ??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z+54
	DD	00H
	DD	imagerel ??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z+331
	DD	0ffffffffH
	DD	imagerel ??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z+359
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
	DD	00H
	DD	00H
	DD	04H
	DD	imagerel $ip2state$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD 0a2611H
	DD	0d6426H
	DD	0c5421H
	DD	0b341cH
	DD	0f00a520eH
	DD	07006e008H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD imagerel ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ+74
	DD	00H
	DD	imagerel ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ+84
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD imagerel ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z+99
	DD	00H
	DD	imagerel ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z+109
	DD	01H
	DD	imagerel ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z+131
	DD	02H
	DD	imagerel ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z+184
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD 0ffffffffH
	DD	imagerel ?dtor$3@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
	DD	01H
	DD	imagerel ?dtor$1@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
	DD	02H
	DD	imagerel ?dtor$2@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
	DD	028H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z DD 082211H
	DD	0d6422H
	DD	0c541dH
	DD	0b3418H
	DD	07006720aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z DD imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
	DD	0ffffffffH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+57
	DD	00H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+151
	DD	02H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+201
	DD	03H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+220
	DD	02H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+367
	DD	04H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+421
	DD	05H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+449
	DD	04H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+604
	DD	06H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+637
	DD	07H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+704
	DD	09H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+771
	DD	0aH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+804
	DD	0bH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+872
	DD	0dH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+914
	DD	0eH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+920
	DD	0fH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1009
	DD	010H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1036
	DD	011H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1088
	DD	013H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1165
	DD	0fH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1207
	DD	014H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1217
	DD	0fH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1444
	DD	0dH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1454
	DD	09H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1518
	DD	019H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1531
	DD	09H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1600
	DD	04H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1657
	DD	01cH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1670
	DD	04H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1739
	DD	02H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+1909
	DD	00H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2018
	DD	04H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2025
	DD	02H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2149
	DD	00H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2273
	DD	0ffffffffH
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2289
	DD	00H
	DD	imagerel ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z+2312
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$2@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	04H
	DD	imagerel ?dtor$4@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	04H
	DD	imagerel ?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	06H
	DD	imagerel ?dtor$11@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	07H
	DD	imagerel ?dtor$12@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	04H
	DD	imagerel ?dtor$5@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	09H
	DD	imagerel ?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0aH
	DD	imagerel ?dtor$14@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0bH
	DD	imagerel ?dtor$15@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	09H
	DD	imagerel ?dtor$6@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0dH
	DD	imagerel ?dtor$16@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0dH
	DD	imagerel ?dtor$7@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0fH
	DD	imagerel ?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	010H
	DD	imagerel ?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	011H
	DD	imagerel ?dtor$19@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0fH
	DD	imagerel ?dtor$8@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0fH
	DD	imagerel ?dtor$20@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	014H
	DD	imagerel ?dtor$21@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0fH
	DD	imagerel ?dtor$22@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0fH
	DD	imagerel ?dtor$23@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	0dH
	DD	imagerel ?dtor$24@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	09H
	DD	imagerel ?dtor$25@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	019H
	DD	imagerel ?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	09H
	DD	imagerel ?dtor$27@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	04H
	DD	imagerel ?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	01cH
	DD	imagerel ?dtor$29@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
	DD	04H
	DD	imagerel ?dtor$30@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z DD 019930522H
	DD	01fH
	DD	imagerel $stateUnwindMap$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
	DD	00H
	DD	00H
	DD	025H
	DD	imagerel $ip2state$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
	DD	0b8H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z DD 0a2811H
	DD	0790120H
	DD	0e00ff011H
	DD	0c00bd00dH
	DD	060087009H
	DD	050063007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ DD 021H
	DD	imagerel $LN127
	DD	imagerel $LN127+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ DD 020521H
	DD	066405H
	DD	imagerel $LN127
	DD	imagerel $LN127+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z DD 021H
	DD	imagerel $LN127
	DD	imagerel $LN127+39
	DD	imagerel $unwind$?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z DD 020521H
	DD	087405H
	DD	imagerel $LN127
	DD	imagerel $LN127+39
	DD	imagerel $unwind$?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z DD 081301H
	DD	0a5413H
	DD	093413H
	DD	0f00f3213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z DD imagerel ?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z
	DD	0ffffffffH
	DD	imagerel ?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z+27
	DD	00H
	DD	imagerel ?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z+89
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z DD 010c11H
	DD	04204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z DD imagerel ?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z
	DD	0ffffffffH
	DD	imagerel ?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z+27
	DD	00H
	DD	imagerel ?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z+89
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z DD 010c11H
	DD	04204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z DD imagerel ?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z
	DD	0ffffffffH
	DD	imagerel ?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z+27
	DD	00H
	DD	imagerel ?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z+89
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z DD 010c11H
	DD	04204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ DD imagerel ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ DD 061919H
	DD	096419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z DD imagerel ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
	DD	0ffffffffH
	DD	imagerel ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z+119
	DD	00H
	DD	imagerel ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z+293
	DD	0ffffffffH
	DD	imagerel ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z+893
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
	DD	00H
	DD	00H
	DD	04H
	DD	imagerel $ip2state$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
	DD	048H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z DD 0b3511H
	DD	0553435H
	DD	04a0128H
	DD	0e018f01aH
	DD	0c014d016H
	DD	060117012H
	DD	05010H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z DD 021H
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+245
	DD	imagerel $unwind$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z DD 0105821H
	DD	02f858H
	DD	03e852H
	DD	04d83cH
	DD	05c836H
	DD	07a81fH
	DD	089819H
	DD	020d410H
	DD	01e5408H
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
	DD	imagerel ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z+245
	DD	imagerel $unwind$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z DD 0119101H
	DD	01fc491H
	DD	06b841H
	DD	098831H
	DD	0a7829H
	DD	0b6821H
	DD	0180111H
	DD	0e008f00aH
	DD	060057006H
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getAngle@@YAMHM@Z DD 030a01H
	DD	02680aH
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD 021H
	DD	imagerel $LN82
	DD	imagerel $LN82+101
	DD	imagerel $unwind$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD 020821H
	DD	01ce408H
	DD	imagerel $LN82+877
	DD	imagerel $LN82+923
	DD	imagerel $chain$1$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD 020521H
	DD	07b805H
	DD	imagerel $LN82
	DD	imagerel $LN82+101
	DD	imagerel $unwind$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD 0f3c01H
	DD	08983cH
	DD	098832H
	DD	0a7829H
	DD	0b6821H
	DD	01d3415H
	DD	0180115H
	DD	06009700aH
	DD	05008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD 0f5201H
	DD	05a852H
	DD	06983eH
	DD	077824H
	DD	086818H
	DD	0156413H
	DD	0143413H
	DD	0120113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD 021H
	DD	imagerel $LN57
	DD	imagerel $LN57+237
	DD	imagerel $unwind$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD 020621H
	DD	076806H
	DD	imagerel $LN57
	DD	imagerel $LN57+237
	DD	imagerel $unwind$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z DD 081501H
	DD	0155415H
	DD	0143415H
	DD	0e00ef215H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z DD 021H
	DD	imagerel $LN130
	DD	imagerel $LN130+140
	DD	imagerel $unwind$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z DD 020521H
	DD	07a805H
	DD	imagerel $LN130
	DD	imagerel $LN130+140
	DD	imagerel $unwind$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z DD 0175b01H
	DD	06b85bH
	DD	08984dH
	DD	098845H
	DD	0a783dH
	DD	0b6835H
	DD	0207423H
	DD	01f6423H
	DD	01e3423H
	DD	0180123H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD 021H
	DD	imagerel $LN67
	DD	imagerel $LN67+55
	DD	imagerel $unwind$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD 040021H
	DD	07a800H
	DD	0b6800H
	DD	imagerel $LN67+55
	DD	imagerel $LN67+62
	DD	imagerel $chain$0$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD 060021H
	DD	03f800H
	DD	07a800H
	DD	0b6800H
	DD	imagerel $LN67+55
	DD	imagerel $LN67+62
	DD	imagerel $chain$0$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD 0a0021H
	DD	03f800H
	DD	05c800H
	DD	07a800H
	DD	0a7800H
	DD	0b6800H
	DD	imagerel $LN67+55
	DD	imagerel $LN67+62
	DD	imagerel $chain$0$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD 0c0021H
	DD	03f800H
	DD	05c800H
	DD	06b800H
	DD	07a800H
	DD	0a7800H
	DD	0b6800H
	DD	imagerel $LN67+55
	DD	imagerel $LN67+62
	DD	imagerel $chain$0$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD 0107221H
	DD	03f872H
	DD	04e823H
	DD	05c81dH
	DD	06b818H
	DD	07a813H
	DD	0a780eH
	DD	0b6809H
	DD	01b7404H
	DD	imagerel $LN67+55
	DD	imagerel $LN67+62
	DD	imagerel $chain$0$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD 020421H
	DD	01a3404H
	DD	imagerel $LN67
	DD	imagerel $LN67+55
	DD	imagerel $unwind$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z DD 072401H
	DD	089824H
	DD	09881cH
	DD	018010bH
	DD	06004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z DD 081f01H
	DD	02881fH
	DD	037815H
	DD	04680cH
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z DD 0134501H
	DD	05b845H
	DD	06a840H
	DD	079836H
	DD	08882dH
	DD	097828H
	DD	0a6823H
	DD	0197417H
	DD	0183417H
	DD	0160117H
	DD	0500cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setPreset@TilePattern@@QEAAXH@Z DD imagerel ?setPreset@TilePattern@@QEAAXH@Z
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+53
	DD	00H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+55
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+102
	DD	00H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+107
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+154
	DD	01H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+159
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+206
	DD	02H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+211
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+258
	DD	03H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+263
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+310
	DD	04H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+315
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+362
	DD	05H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+367
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+414
	DD	06H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+419
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+466
	DD	07H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+468
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+515
	DD	08H
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+517
	DD	0ffffffffH
	DD	imagerel ?setPreset@TilePattern@@QEAAXH@Z+588
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setPreset@TilePattern@@QEAAXH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$3@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$4@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$5@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$6@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$7@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$8@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$9@?0??setPreset@TilePattern@@QEAAXH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?setPreset@TilePattern@@QEAAXH@Z DD 019930522H
	DD	0aH
	DD	imagerel $stateUnwindMap$?setPreset@TilePattern@@QEAAXH@Z
	DD	00H
	DD	00H
	DD	016H
	DD	imagerel $ip2state$?setPreset@TilePattern@@QEAAXH@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setPreset@TilePattern@@QEAAXH@Z DD 041e11H
	DD	0c341eH
	DD	0500a9211H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?setPreset@TilePattern@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?update@TilePattern@@QEAAXXZ DD 021H
	DD	imagerel $LN74
	DD	imagerel $LN74+39
	DD	imagerel $unwind$?update@TilePattern@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?update@TilePattern@@QEAAXXZ DD 040d21H
	DD	03640dH
	DD	023405H
	DD	imagerel $LN74
	DD	imagerel $LN74+39
	DD	imagerel $unwind$?update@TilePattern@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?update@TilePattern@@QEAAXXZ DD 030601H
	DD	045406H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD imagerel ?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z+36
	DD	00H
	DD	imagerel ?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z+366
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 081e11H
	DD	012341eH
	DD	0f00e9212H
	DD	0700ae00cH
	DD	050086009H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z DD imagerel ?_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z DD 0a2211H
	DD	0d6422H
	DD	0c541dH
	DD	0b3418H
	DD	0f006520aH
	DD	07002e004H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z DD imagerel ?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z DD 041811H
	DD	083418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ DD imagerel ?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ DD 061911H
	DD	0a6419H
	DD	093414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD imagerel ?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z DD 020f11H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@VTileRow@@@std@@QEAAXQEAVTileRow@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GTileRow@@QEAAPEAXI@Z DD imagerel ??_GTileRow@@QEAAPEAXI@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GTileRow@@QEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???_GTileRow@@QEAAPEAXI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_GTileRow@@QEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_GTileRow@@QEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_GTileRow@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GTileRow@@QEAAPEAXI@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_GTileRow@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0TileRow@@QEAA@$$QEAV0@@Z DD imagerel ??0TileRow@@QEAA@$$QEAV0@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0TileRow@@QEAA@$$QEAV0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0TileRow@@QEAA@$$QEAV0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0TileRow@@QEAA@$$QEAV0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0TileRow@@QEAA@$$QEAV0@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??0TileRow@@QEAA@$$QEAV0@@Z
	DD	00H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0TileRow@@QEAA@$$QEAV0@@Z DD 011111H
	DD	02209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0TileRow@@QEAA@$$QEAV0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0TileRow@@QEAA@AEBV0@@Z DD imagerel ??0TileRow@@QEAA@AEBV0@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0TileRow@@QEAA@AEBV0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0TileRow@@QEAA@AEBV0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0TileRow@@QEAA@AEBV0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0TileRow@@QEAA@AEBV0@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??0TileRow@@QEAA@AEBV0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0TileRow@@QEAA@AEBV0@@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0TileRow@@QEAA@AEBV0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1TileRow@@QEAA@XZ DD imagerel ??1TileRow@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1TileRow@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???1TileRow@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1TileRow@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1TileRow@@QEAA@XZ
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1TileRow@@QEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1TileRow@@QEAA@XZ DD 011211H
	DD	06209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1TileRow@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@MV?$allocator@M@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@MV?$allocator@M@std@@@std@@AEAA_N_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ DD imagerel ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD imagerel ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
	DD	0ffffffffH
	DD	imagerel ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z+108
	DD	00H
	DD	imagerel ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z+140
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
	DD	01H
	DD	imagerel $tryMap$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
	DD	05H
	DD	imagerel $ip2state$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z DD 082319H
	DD	0b7423H
	DD	0a641eH
	DD	093419H
	DD	0e007520bH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@M@std@@QEAAPEAM_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@M@std@@QEAAXQEAM_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0TileRow@@QEAA@M@Z DD imagerel ??0TileRow@@QEAA@M@Z
	DD	0ffffffffH
	DD	imagerel ??0TileRow@@QEAA@M@Z+31
	DD	00H
	DD	imagerel ??0TileRow@@QEAA@M@Z+35
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0TileRow@@QEAA@M@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0TileRow@@QEAA@M@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0TileRow@@QEAA@M@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0TileRow@@QEAA@M@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0TileRow@@QEAA@M@Z
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0TileRow@@QEAA@M@Z DD 011111H
	DD	02209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0TileRow@@QEAA@M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z DD imagerel ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DD imagerel ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
	DD	0ffffffffH
	DD	imagerel ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z+88
	DD	00H
	DD	imagerel ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z+105
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
	DD	028H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z DD 0b4301H
	DD	0285443H
	DD	02a6416H
	DD	0293416H
	DD	0240116H
	DD	0e00df00fH
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z DD 0b4301H
	DD	0285443H
	DD	02a6416H
	DD	0293416H
	DD	0240116H
	DD	0e00df00fH
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD imagerel ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEBV12@@Z DD 085201H
	DD	063452H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wmemcpy DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 081901H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	070153219H
xdata	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor', COMDAT
	movsxd	rax, DWORD PTR [rcx-4]
	sub	rcx, rax
	jmp	??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
??_E?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z PROC ; std::move<std::vector<float,std::allocator<float> > &>, COMDAT

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

	mov	rax, rcx

; 1590 : 	}

	ret	0
??$move@AEAV?$vector@MV?$allocator@M@std@@@std@@@std@@YA$$QEAV?$vector@MV?$allocator@M@std@@@0@AEAV10@@Z ENDP ; std::move<std::vector<float,std::allocator<float> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z PROC ; std::move<std::allocator<float> &>, COMDAT

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

	mov	rax, rcx

; 1590 : 	}

	ret	0
??$move@AEAV?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z ENDP ; std::move<std::allocator<float> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z
_TEXT	SEGMENT
$T1 = 0
__formal$ = 32
$T2 = 40
_Ptr$ = 40
<_Args_0>$ = 48
??$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

$LN100:
	sub	rsp, 24
	mov	QWORD PTR $T1[rsp], -2

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	QWORD PTR $T2[rsp], rdx
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rdx+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

	xor	ecx, ecx
	mov	QWORD PTR [rdx+8], rcx

; 390  : 		_Mylast(),

	mov	QWORD PTR [rdx+16], rcx

; 391  : 		_Myend()

	mov	QWORD PTR [rdx+24], rcx

; 765  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [r8+8]
	mov	QWORD PTR [rdx+8], rax

; 766  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [r8+16]
	mov	QWORD PTR [rdx+16], rax

; 767  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [r8+24]
	mov	QWORD PTR [rdx+24], rax

; 768  : 
; 769  : 		_Right._Myfirst() = pointer();

	mov	QWORD PTR [r8+8], rcx

; 770  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [r8+16], rcx

; 771  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [r8+24], rcx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 882  : 		}

	add	rsp, 24
	ret	0
??$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
__formal$ = 32
$T2 = 40
_Ptr$ = 40
<_Args_0>$ = 48
?dtor$0@?0???$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
__formal$ = 32
$T2 = 40
_Ptr$ = 40
<_Args_0>$ = 48
?dtor$0@?0???$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct@VTileRow@@V1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@$$QEAV3@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@VTileRow@@@std@@YA$$QEAVTileRow@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@VTileRow@@@std@@YA$$QEAVTileRow@@AEAV1@@Z PROC ; std::forward<TileRow>, COMDAT

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1575 : 	}

	ret	0
??$forward@VTileRow@@@std@@YA$$QEAVTileRow@@AEAV1@@Z ENDP ; std::forward<TileRow>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@MMV?$allocator@M@std@@@std@@YAPEAMQEAM00AEAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$ = 72
__formal$ = 80
__formal$ = 88
??$_Uninitialized_copy_al_unchecked@MMV?$allocator@M@std@@@std@@YAPEAMQEAM00AEAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<float,float,std::allocator<float> >, COMDAT

; 201  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 203  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy_al_unchecked@MMV?$allocator@M@std@@@std@@YAPEAMQEAM00AEAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<float,float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_copy_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@AEBQEAM0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
__formal$ = 16
__formal$ = 24
??$_Ptr_copy_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@AEBQEAM0@Z PROC ; std::_Ptr_copy_cat<float,float>, COMDAT

; 1070 : 	return {};

	mov	rax, rcx

; 1071 : 	}

	ret	0
??$_Ptr_copy_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@AEBQEAM0@Z ENDP ; std::_Ptr_copy_cat<float,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_memmove@PEAMPEAM@std@@YAPEAMPEAM00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAMPEAM@std@@YAPEAMPEAM00@Z PROC	; std::_Copy_memmove<float *,float *>, COMDAT

; 2398 : 	{	// implement copy-like function as memmove

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 2399 : 	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));
; 2400 : 	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));
; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]

; 2405 : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAMPEAM@std@@YAPEAMPEAM00@Z ENDP	; std::_Copy_memmove<float *,float *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z
_TEXT	SEGMENT
$T1 = 0
$T2 = 32
this$ = 32
<_Vals_0>$ = 40
??$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z PROC ; std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::_Emplace_back<TileRow>, COMDAT

; 163  : 		{	// construct a new element at *_Last and increment

$LN106:
	sub	rsp, 24
	mov	QWORD PTR $T1[rsp], -2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	r8, QWORD PTR [rcx+8]
	mov	QWORD PTR $T2[rsp], r8
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [r8+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

	xor	r9d, r9d
	mov	QWORD PTR [r8+8], r9

; 390  : 		_Mylast(),

	mov	QWORD PTR [r8+16], r9

; 391  : 		_Myend()

	mov	QWORD PTR [r8+24], r9

; 765  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rax

; 766  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [r8+16], rax

; 767  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [rdx+24]
	mov	QWORD PTR [r8+24], rax

; 768  : 
; 769  : 		_Right._Myfirst() = pointer();

	mov	QWORD PTR [rdx+8], r9

; 770  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [rdx+16], r9

; 771  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [rdx+24], r9
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

	add	QWORD PTR [rcx+8], 32			; 00000020H

; 166  : 		}

	add	rsp, 24
	ret	0
??$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z ENDP ; std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::_Emplace_back<TileRow>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
$T2 = 32
this$ = 32
<_Vals_0>$ = 40
?dtor$0@?0???$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z@4HA PROC ; `std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::_Emplace_back<TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z@4HA ENDP ; `std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::_Emplace_back<TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
$T2 = 32
this$ = 32
<_Vals_0>$ = 40
?dtor$0@?0???$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z@4HA PROC ; `std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::_Emplace_back<TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Emplace_back@VTileRow@@@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAX$$QEAVTileRow@@@Z@4HA ENDP ; `std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::_Emplace_back<TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@XZ PROC ; std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::_Release, COMDAT

; 170  : 		_First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 171  : 		return (_Last);
; 172  : 		}

	ret	0
?_Release@?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@XZ ENDP ; std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
this$ = 64
??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::~_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >, COMDAT

; 157  : 		{	// destroy all elements guarded by this instance

$LN26:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx

; 158  : 		_Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	mov	rbx, QWORD PTR [rcx]
	mov	QWORD PTR _First$[rsp], rbx

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rbx, rdi
	je	SHORT $LN7@Uninitiali
$LL8@Uninitiali:
	lea	rcx, QWORD PTR [rbx+8]
	call	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
	npad	1
	add	rbx, 32					; 00000020H
	mov	QWORD PTR _First$[rsp], rbx
	cmp	rbx, rdi
	jne	SHORT $LL8@Uninitiali
$LN7@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 159  : 		}

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::~_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
this$ = 64
?dtor$0@?0???1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::~_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::~_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
this$ = 64
?dtor$0@?0???1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::~_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::~_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@PEAVTileRow@@AEAV?$allocator@VTileRow@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@PEAVTileRow@@AEAV?$allocator@VTileRow@@@1@@Z PROC ; std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >, COMDAT

; 147  : 		: _First(_Dest),

	mov	QWORD PTR [rcx], rdx

; 151  : 		}

	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@PEAVTileRow@@AEAV?$allocator@VTileRow@@@1@@Z ENDP ; std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z PROC ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_back<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	xor	r8d, r8d
	mov	QWORD PTR [rax+16], r8

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rax+24], r8

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [rax], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], r8

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rdx], r8w
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

	add	QWORD PTR [rcx+8], 32			; 00000020H
	vzeroupper

; 166  : 		}

	ret	0
??$_Emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_back<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Release, COMDAT

; 170  : 		_First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 171  : 		return (_Last);
; 172  : 		}

	ret	0
?_Release@?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 157  : 		{	// destroy all elements guarded by this instance

$LN33:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+64], rbx

; 158  : 		_Destroy_range(_First, _Last, _Al);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rbx, rdi
	je	SHORT $LN7@Uninitiali
$LL8@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
	npad	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL8@Uninitiali
$LN7@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 159  : 		}

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 147  : 		: _First(_Dest),

	mov	QWORD PTR [rcx], rdx

; 151  : 		}

	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
??$_Uninitialized_copy@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z PROC ; std::_Uninitialized_copy<float *,float *,std::allocator<float> >, COMDAT

; 209  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 220  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z ENDP ; std::_Uninitialized_copy<float *,float *,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0V?$allocator@M@std@@$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@M@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
_Val1$ = 24
??$?0V?$allocator@M@std@@$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@M@1@@Z PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float> >, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@M@std@@$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@M@1@@Z ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@V?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z PROC ; std::forward<std::allocator<float> >, COMDAT

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1575 : 	}

	ret	0
??$forward@V?$allocator@M@std@@@std@@YA$$QEAV?$allocator@M@0@AEAV10@@Z ENDP ; std::forward<std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@M@std@@YAXAEAPEAMQEAM@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@M@std@@YAXAEAPEAMQEAM@Z PROC		; std::_Seek_wrapped<float>, COMDAT

; 872  : 	_It = _UIt;

	mov	QWORD PTR [rcx], rdx

; 873  : 	}

	ret	0
??$_Seek_wrapped@M@std@@YAXAEAPEAMQEAM@Z ENDP		; std::_Seek_wrapped<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@MMV?$allocator@M@std@@@std@@YAPEAMQEAM00AEAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$ = 72
__formal$ = 80
__formal$ = 88
??$_Uninitialized_move_al_unchecked@MMV?$allocator@M@std@@@std@@YAPEAMQEAM00AEAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<float,float,std::allocator<float> >, COMDAT

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 245  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move_al_unchecked@MMV?$allocator@M@std@@@std@@YAPEAMQEAM00AEAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<float,float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@AEBQEAM0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
__formal$ = 16
__formal$ = 24
??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@AEBQEAM0@Z PROC ; std::_Ptr_move_cat<float,float>, COMDAT

; 1087 : 	return {};

	mov	rax, rcx

; 1088 : 	}

	ret	0
??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@AEBQEAM0@Z ENDP ; std::_Ptr_move_cat<float,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@M_J$0A@@std@@YAPEAMQEAM_J@Z
_TEXT	SEGMENT
_Src$ = 8
__formal$ = 16
??$_Get_unwrapped_n@M_J$0A@@std@@YAPEAMQEAM_J@Z PROC	; std::_Get_unwrapped_n<float,__int64,0>, COMDAT

; 809  : 	return (_Src);

	mov	rax, rcx

; 810  : 	}

	ret	0
??$_Get_unwrapped_n@M_J$0A@@std@@YAPEAMQEAM_J@Z ENDP	; std::_Get_unwrapped_n<float,__int64,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance1@PEAMPEAM@std@@YA_JAEBQEAM0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
__formal$ = 24
??$_Idl_distance1@PEAMPEAM@std@@YA_JAEBQEAM0Urandom_access_iterator_tag@0@@Z PROC ; std::_Idl_distance1<float *,float *>, COMDAT

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 969  : 	}

	ret	0
??$_Idl_distance1@PEAMPEAM@std@@YA_JAEBQEAM0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Idl_distance1<float *,float *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PEAMPEAM@std@@YA_JAEBQEAM0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@PEAMPEAM@std@@YA_JAEBQEAM0@Z PROC	; std::_Idl_distance<float *,float *>, COMDAT

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 975  : 	return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));
; 976  : 	}

	ret	0
??$_Idl_distance@PEAMPEAM@std@@YA_JAEBQEAM0@Z ENDP	; std::_Idl_distance<float *,float *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@M@std@@YAPEAMQEAM@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Get_unwrapped@M@std@@YAPEAMQEAM@Z PROC		; std::_Get_unwrapped<float>, COMDAT

; 663  : 	return (_Ptr);

	mov	rax, rcx

; 664  : 	}

	ret	0
??$_Get_unwrapped@M@std@@YAPEAMQEAM@Z ENDP		; std::_Get_unwrapped<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@VTileRow@@@std@@YAXAEAPEAVTileRow@@QEAV1@@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@VTileRow@@@std@@YAXAEAPEAVTileRow@@QEAV1@@Z PROC ; std::_Seek_wrapped<TileRow>, COMDAT

; 872  : 	_It = _UIt;

	mov	QWORD PTR [rcx], rdx

; 873  : 	}

	ret	0
??$_Seek_wrapped@VTileRow@@@std@@YAXAEAPEAVTileRow@@QEAV1@@Z ENDP ; std::_Seek_wrapped<TileRow>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
_TEXT	SEGMENT
$T1 = 0
_Backout$ = 8
$T2 = 48
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
__formal$ = 80
__formal$ = 88
??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<TileRow *,TileRow *,std::allocator<TileRow> >, COMDAT

; 228  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

$LN145:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR $T1[rsp], -2

; 147  : 		: _First(_Dest),

	mov	QWORD PTR _Backout$[rsp], r8

; 148  : 		_Last(_Dest),

	mov	QWORD PTR _Backout$[rsp+8], r8

; 149  : 		_Al(_Al_)

	mov	QWORD PTR _Backout$[rsp+16], r9

; 229  : 	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};
; 230  : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN3@Uninitiali

; 148  : 		_Last(_Dest),

	lea	r9, QWORD PTR [rcx+24]
	xor	r10d, r10d
	npad	9
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	QWORD PTR $T2[rsp], r8
	mov	eax, DWORD PTR [r9-24]
	mov	DWORD PTR [r8], eax
	mov	eax, DWORD PTR [r9-20]
	mov	DWORD PTR [r8+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

	mov	QWORD PTR [r8+8], r10

; 390  : 		_Mylast(),

	mov	QWORD PTR [r8+16], r10

; 391  : 		_Myend()

	mov	QWORD PTR [r8+24], r10

; 765  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [r9-16]
	mov	QWORD PTR [r8+8], rax

; 766  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [r9-8]
	mov	QWORD PTR [r8+16], rax

; 767  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r8+24], rax

; 768  : 
; 769  : 		_Right._Myfirst() = pointer();

	mov	QWORD PTR [r9-16], r10

; 770  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [r9-8], r10

; 771  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [r9], r10
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

	add	r8, 32					; 00000020H
	mov	QWORD PTR _Backout$[rsp+8], r8

; 229  : 	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};
; 230  : 	for (; _First != _Last; ++_First)

	lea	r9, QWORD PTR [r9+32]
	lea	rcx, QWORD PTR [r9-24]
	cmp	rcx, rdx
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 170  : 		_First = _Last;

	mov	QWORD PTR _Backout$[rsp], r8

; 231  : 		{
; 232  : 		_Backout._Emplace_back(_STD move(*_First));
; 233  : 		}
; 234  : 
; 235  : 	return (_Backout._Release());

	mov	rax, r8

; 236  : 	}

	add	rsp, 40					; 00000028H
	ret	0
??$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<TileRow *,TileRow *,std::allocator<TileRow> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$ = 8
$T2 = 48
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
__formal$ = 80
__formal$ = 88
?dtor$0@?0???$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA PROC ; `std::_Uninitialized_move_al_unchecked<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::~_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >
?dtor$0@?0???$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA ENDP ; `std::_Uninitialized_move_al_unchecked<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$ = 8
$T2 = 48
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
__formal$ = 80
__formal$ = 88
?dtor$1@?0???$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA PROC ; `std::_Uninitialized_move_al_unchecked<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA ENDP ; `std::_Uninitialized_move_al_unchecked<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$ = 8
$T2 = 48
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
__formal$ = 80
__formal$ = 88
?dtor$0@?0???$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA PROC ; `std::_Uninitialized_move_al_unchecked<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::~_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >
?dtor$0@?0???$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA ENDP ; `std::_Uninitialized_move_al_unchecked<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$ = 8
$T2 = 48
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
__formal$ = 80
__formal$ = 88
?dtor$1@?0???$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA PROC ; `std::_Uninitialized_move_al_unchecked<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$_Uninitialized_move_al_unchecked@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@PEAV1@QEAV1@1AEAV?$allocator@VTileRow@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA ENDP ; `std::_Uninitialized_move_al_unchecked<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AEAVTileRow@@@std@@YA$$QEAVTileRow@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAVTileRow@@@std@@YA$$QEAVTileRow@@AEAV1@@Z PROC ; std::move<TileRow &>, COMDAT

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

	mov	rax, rcx

; 1590 : 	}

	ret	0
??$move@AEAVTileRow@@@std@@YA$$QEAVTileRow@@AEAV1@@Z ENDP ; std::move<TileRow &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_move_cat@VTileRow@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@AEBQEAVTileRow@@0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
??$_Ptr_move_cat@VTileRow@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@AEBQEAVTileRow@@0@Z PROC ; std::_Ptr_move_cat<TileRow,TileRow>, COMDAT

; 1087 : 	return {};

	xor	al, al

; 1088 : 	}

	ret	0
??$_Ptr_move_cat@VTileRow@@V1@@std@@YA?AU_General_ptr_iterator_tag@0@AEBQEAVTileRow@@0@Z ENDP ; std::_Ptr_move_cat<TileRow,TileRow>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@VTileRow@@_J$0A@@std@@YAPEAVTileRow@@QEAV1@_J@Z
_TEXT	SEGMENT
_Src$ = 8
__formal$ = 16
??$_Get_unwrapped_n@VTileRow@@_J$0A@@std@@YAPEAVTileRow@@QEAV1@_J@Z PROC ; std::_Get_unwrapped_n<TileRow,__int64,0>, COMDAT

; 809  : 	return (_Src);

	mov	rax, rcx

; 810  : 	}

	ret	0
??$_Get_unwrapped_n@VTileRow@@_J$0A@@std@@YAPEAVTileRow@@QEAV1@_J@Z ENDP ; std::_Get_unwrapped_n<TileRow,__int64,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance1@PEAVTileRow@@PEAV1@@std@@YA_JAEBQEAVTileRow@@0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
__formal$ = 24
??$_Idl_distance1@PEAVTileRow@@PEAV1@@std@@YA_JAEBQEAVTileRow@@0Urandom_access_iterator_tag@0@@Z PROC ; std::_Idl_distance1<TileRow *,TileRow *>, COMDAT

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 969  : 	}

	ret	0
??$_Idl_distance1@PEAVTileRow@@PEAV1@@std@@YA_JAEBQEAVTileRow@@0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Idl_distance1<TileRow *,TileRow *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PEAVTileRow@@PEAV1@@std@@YA_JAEBQEAVTileRow@@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@PEAVTileRow@@PEAV1@@std@@YA_JAEBQEAVTileRow@@0@Z PROC ; std::_Idl_distance<TileRow *,TileRow *>, COMDAT

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 975  : 	return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));
; 976  : 	}

	ret	0
??$_Idl_distance@PEAVTileRow@@PEAV1@@std@@YA_JAEBQEAVTileRow@@0@Z ENDP ; std::_Idl_distance<TileRow *,TileRow *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@VTileRow@@@std@@YAPEAVTileRow@@QEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Get_unwrapped@VTileRow@@@std@@YAPEAVTileRow@@QEAV1@@Z PROC ; std::_Get_unwrapped<TileRow>, COMDAT

; 663  : 	return (_Ptr);

	mov	rax, rcx

; 664  : 	}

	ret	0
??$_Get_unwrapped@VTileRow@@@std@@YAPEAVTileRow@@QEAV1@@Z ENDP ; std::_Get_unwrapped<TileRow>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@@Z PROC ; std::_Seek_wrapped<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 872  : 	_It = _UIt;

	mov	QWORD PTR [rcx], rdx

; 873  : 	}

	ret	0
??$_Seek_wrapped@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@@Z ENDP ; std::_Seek_wrapped<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$00@std@@@_Unused_parameter@std@@QEAA@$$QEAU?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0U?$integral_constant@_N$00@std@@@_Unused_parameter@std@@QEAA@$$QEAU?$integral_constant@_N$00@1@@Z PROC ; std::_Unused_parameter::_Unused_parameter<std::integral_constant<bool,1> >, COMDAT

; 436  : 		constexpr _Unused_parameter(_Ty&&) noexcept {}

	mov	rax, rcx
	ret	0
??$?0U?$integral_constant@_N$00@std@@@_Unused_parameter@std@@QEAA@$$QEAU?$integral_constant@_N$00@1@@Z ENDP ; std::_Unused_parameter::_Unused_parameter<std::integral_constant<bool,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
_TEXT	SEGMENT
$T1 = 0
_Backout$ = 8
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
__formal$ = 80
__formal$ = 88
??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 228  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

$LN103:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR $T1[rsp], -2

; 147  : 		: _First(_Dest),

	mov	QWORD PTR _Backout$[rsp], r8

; 148  : 		_Last(_Dest),

	mov	QWORD PTR _Backout$[rsp+8], r8

; 149  : 		_Al(_Al_)

	mov	QWORD PTR _Backout$[rsp+16], r9

; 229  : 	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};
; 230  : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN3@Uninitiali
	xor	eax, eax
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	mov	QWORD PTR [r8+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [r8+24], rax

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rcx]
	vmovups	YMMWORD PTR [r8], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rcx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

	add	r8, 32					; 00000020H
	mov	QWORD PTR _Backout$[rsp+8], r8

; 229  : 	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};
; 230  : 	for (; _First != _Last; ++_First)

	add	rcx, 32					; 00000020H
	cmp	rcx, rdx
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 170  : 		_First = _Last;

	mov	QWORD PTR _Backout$[rsp], r8

; 231  : 		{
; 232  : 		_Backout._Emplace_back(_STD move(*_First));
; 233  : 		}
; 234  : 
; 235  : 	return (_Backout._Release());

	mov	rax, r8
	vzeroupper

; 236  : 	}

	add	rsp, 40					; 00000028H
	ret	0
??$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$ = 8
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
__formal$ = 80
__formal$ = 88
?dtor$0@?0???$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA PROC ; `std::_Uninitialized_move_al_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$0@?0???$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA ENDP ; `std::_Uninitialized_move_al_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$ = 8
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
__formal$ = 80
__formal$ = 88
?dtor$0@?0???$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA PROC ; `std::_Uninitialized_move_al_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$0@?0???$_Uninitialized_move_al_unchecked@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@QEAV10@1AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z@4HA ENDP ; `std::_Uninitialized_move_al_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_move_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@AEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
??$_Ptr_move_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@AEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z PROC ; std::_Ptr_move_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 1087 : 	return {};

	xor	al, al

; 1088 : 	}

	ret	0
??$_Ptr_move_cat@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@AEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ENDP ; std::_Ptr_move_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J$0A@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@_J@Z
_TEXT	SEGMENT
_Src$ = 8
__formal$ = 16
??$_Get_unwrapped_n@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J$0A@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@_J@Z PROC ; std::_Get_unwrapped_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,__int64,0>, COMDAT

; 809  : 	return (_Src);

	mov	rax, rcx

; 810  : 	}

	ret	0
??$_Get_unwrapped_n@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_J$0A@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@_J@Z ENDP ; std::_Get_unwrapped_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,__int64,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@@std@@YA_JAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
__formal$ = 24
??$_Idl_distance1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@@std@@YA_JAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0Urandom_access_iterator_tag@0@@Z PROC ; std::_Idl_distance1<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>, COMDAT

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 969  : 	}

	ret	0
??$_Idl_distance1@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@@std@@YA_JAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Idl_distance1<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@@std@@YA_JAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@@std@@YA_JAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z PROC ; std::_Idl_distance<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>, COMDAT

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 975  : 	return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));
; 976  : 	}

	ret	0
??$_Idl_distance@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@@std@@YA_JAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ENDP ; std::_Idl_distance<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Get_unwrapped@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@@Z PROC ; std::_Get_unwrapped<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 663  : 	return (_Ptr);

	mov	rax, rcx

; 664  : 	}

	ret	0
??$_Get_unwrapped@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@@Z ENDP ; std::_Get_unwrapped<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
_TEXT	SEGMENT
__formal$ = 8
_Ptr$ = 16
??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rdx
	jmp	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
??$destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
??$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z PROC ; std::_Default_allocator_traits<std::allocator<TileRow> >::destroy<TileRow>, COMDAT

; 886  : 		{	// destroy object at _Ptr

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	lea	rcx, QWORD PTR [rdx+8]

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

	add	rsp, 56					; 00000038H
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
??$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<TileRow> >::destroy<TileRow>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
?dtor$0@?0???$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<TileRow> >::destroy<TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR _Ptr$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<TileRow> >::destroy<TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
?dtor$0@?0???$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<TileRow> >::destroy<TileRow>'::`1'::dtor$0
	mov	rcx, QWORD PTR _Ptr$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$destroy@VTileRow@@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<TileRow> >::destroy<TileRow>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z PROC ; std::move<std::allocator<wchar_t> &>, COMDAT

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

	mov	rax, rcx

; 1590 : 	}

	ret	0
??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ENDP ; std::move<std::allocator<wchar_t> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$03@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 8
??$_Get_size_of_n@$03@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<4>, COMDAT

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   : 	size_t _Result = _Count * _Ty_size;
; 26   : 	if (_Max_possible < _Count)

	mov	rdx, 4611686018427387903		; 3fffffffffffffffH
	lea	rax, QWORD PTR [rcx*4]
	cmp	rcx, rdx
	mov	r8, -1
	cmova	rax, r8

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);
; 30   : 		}
; 31   : 
; 32   : 	return (_Result);
; 33   : 	}

	ret	0
??$_Get_size_of_n@$03@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Ucopy@PEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM00@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
??$_Ucopy@PEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM00@Z PROC ; std::vector<float,std::allocator<float> >::_Ucopy<float *>, COMDAT

; 1822 : 		{	// copy [_First, _Last) to raw _Dest, using allocator

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	sub	rbx, rdx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1822 : 		{	// copy [_First, _Last) to raw _Dest, using allocator

	mov	rdi, r9
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1824 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Ucopy@PEAM@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM00@Z ENDP ; std::vector<float,std::allocator<float> >::_Ucopy<float *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$?0V?$allocator@M@std@@X@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAA@$$QEAV?$allocator@M@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$ = 16
??$?0V?$allocator@M@std@@X@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAA@$$QEAV?$allocator@M@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > ><std::allocator<float>,void>, COMDAT

; 389  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 431  : 		}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@M@std@@X@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAA@$$QEAV?$allocator@M@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > ><std::allocator<float>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
??$_Uninitialized_move@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z PROC ; std::_Uninitialized_move<float *,float *,std::allocator<float> >, COMDAT

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 261  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAMPEAMV?$allocator@M@std@@@std@@YAPEAMQEAM0PEAMAEAV?$allocator@M@0@@Z ENDP ; std::_Uninitialized_move<float *,float *,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z
_TEXT	SEGMENT
$T1 = 0
_Backout$2 = 8
$T3 = 48
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z PROC ; std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >, COMDAT

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN163:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR $T1[rsp], -2

; 147  : 		: _First(_Dest),

	mov	QWORD PTR _Backout$2[rsp], r8

; 148  : 		_Last(_Dest),

	mov	QWORD PTR _Backout$2[rsp+8], r8

; 149  : 		_Al(_Al_)

	mov	QWORD PTR _Backout$2[rsp+16], r9

; 230  : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN19@Uninitiali

; 147  : 		: _First(_Dest),

	lea	r9, QWORD PTR [rcx+24]
	xor	r10d, r10d
	npad	9
$LL20@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	QWORD PTR $T3[rsp], r8
	mov	eax, DWORD PTR [r9-24]
	mov	DWORD PTR [r8], eax
	mov	eax, DWORD PTR [r9-20]
	mov	DWORD PTR [r8+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

	mov	QWORD PTR [r8+8], r10

; 390  : 		_Mylast(),

	mov	QWORD PTR [r8+16], r10

; 391  : 		_Myend()

	mov	QWORD PTR [r8+24], r10

; 765  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [r9-16]
	mov	QWORD PTR [r8+8], rax

; 766  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [r9-8]
	mov	QWORD PTR [r8+16], rax

; 767  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r8+24], rax

; 768  : 
; 769  : 		_Right._Myfirst() = pointer();

	mov	QWORD PTR [r9-16], r10

; 770  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [r9-8], r10

; 771  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [r9], r10
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

	add	r8, 32					; 00000020H
	mov	QWORD PTR _Backout$2[rsp+8], r8

; 230  : 	for (; _First != _Last; ++_First)

	lea	r9, QWORD PTR [r9+32]
	lea	rcx, QWORD PTR [r9-24]
	cmp	rcx, rdx
	jne	SHORT $LL20@Uninitiali
$LN19@Uninitiali:

; 170  : 		_First = _Last;

	mov	QWORD PTR _Backout$2[rsp], r8

; 252  : 		// note: only called internally from elsewhere in the STL
; 253  : 	const auto _UFirst = _Get_unwrapped(_First);
; 254  : 	const auto _ULast = _Get_unwrapped(_Last);
; 255  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 256  : 	_Seek_wrapped(_Dest,
; 257  : 		_Uninitialized_move_al_unchecked(_UFirst, _ULast, _UDest, _Al,
; 258  : 			_Ptr_move_cat(_UFirst, _UDest),
; 259  : 			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(_STD move(*_UFirst))>()));
; 260  : 	return (_Dest);

	mov	rax, r8

; 261  : 	}

	add	rsp, 40					; 00000028H
	ret	0
??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z ENDP ; std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$2 = 8
$T3 = 48
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
?dtor$0@?0???$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::~_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >
?dtor$0@?0???$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$2 = 8
$T3 = 48
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
?dtor$1@?0???$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$1
	mov	rcx, QWORD PTR $T3[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$2 = 8
$T3 = 48
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
?dtor$0@?0???$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAVTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >::~_Uninitialized_backout_al<TileRow *,std::allocator<TileRow> >
?dtor$0@?0???$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$2 = 8
$T3 = 48
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
?dtor$1@?0???$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$1
	mov	rcx, QWORD PTR $T3[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 8
??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<32>, COMDAT

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   : 	size_t _Result = _Count * _Ty_size;

	mov	rax, rcx

; 26   : 	if (_Max_possible < _Count)

	mov	rdx, 576460752303423487			; 07ffffffffffffffH
	shl	rax, 5
	mov	r8, -1
	cmp	rcx, rdx
	cmova	rax, r8

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);
; 30   : 		}
; 31   : 
; 32   : 	return (_Result);
; 33   : 	}

	ret	0
??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<32>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = 0
_Backout$2 = 8
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN121:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR $T1[rsp], -2

; 147  : 		: _First(_Dest),

	mov	QWORD PTR _Backout$2[rsp], r8

; 148  : 		_Last(_Dest),

	mov	QWORD PTR _Backout$2[rsp+8], r8

; 149  : 		_Al(_Al_)

	mov	QWORD PTR _Backout$2[rsp+16], r9

; 230  : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN19@Uninitiali
	xor	eax, eax
$LL20@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	mov	QWORD PTR [r8+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [r8+24], rax

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rcx]
	vmovups	YMMWORD PTR [r8], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rcx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

	add	r8, 32					; 00000020H
	mov	QWORD PTR _Backout$2[rsp+8], r8

; 230  : 	for (; _First != _Last; ++_First)

	add	rcx, 32					; 00000020H
	cmp	rcx, rdx
	jne	SHORT $LL20@Uninitiali
$LN19@Uninitiali:

; 170  : 		_First = _Last;

	mov	QWORD PTR _Backout$2[rsp], r8

; 252  : 		// note: only called internally from elsewhere in the STL
; 253  : 	const auto _UFirst = _Get_unwrapped(_First);
; 254  : 	const auto _ULast = _Get_unwrapped(_Last);
; 255  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 256  : 	_Seek_wrapped(_Dest,
; 257  : 		_Uninitialized_move_al_unchecked(_UFirst, _ULast, _UDest, _Al,
; 258  : 			_Ptr_move_cat(_UFirst, _UDest),
; 259  : 			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(_STD move(*_UFirst))>()));
; 260  : 	return (_Dest);

	mov	rax, r8
	vzeroupper

; 261  : 	}

	add	rsp, 40					; 00000028H
	ret	0
??$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$2 = 8
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$2 = 8
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$ = 72
?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$0@?0???$_Uninitialized_move@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAV12@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$ = 64
__formal$ = 72
??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 1133 : 	{	// destroy [_First, _Last), no special optimization

$LN30:

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN27@Destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1133 : 	{	// destroy [_First, _Last), no special optimization

	mov	rdi, rdx
	mov	rbx, rcx
$LL4@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL4@Destroy_ra

; 1135 : 		{
; 1136 : 		allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1137 : 		}
; 1138 : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN27@Destroy_ra:
	ret	0
??$_Destroy_range1@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 92   : 	{	// allocate _Bytes manually aligned to at least _Big_allocation_alignment

$LN16:
	sub	rsp, 40					; 00000028H

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 94   : 	if (_Block_size <= _Bytes)

	mov	rdx, -1
	cmp	rax, rcx
	cmovbe	rax, rdx

; 52   : 		return (::operator new(_Bytes));

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 95   : 		{	// add overflow, try allocating all of memory and assume the
; 96   : 			// allocation function will throw bad_alloc
; 97   : 		_Block_size = static_cast<size_t>(-1);
; 98   : 		}
; 99   : 
; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN7@Allocate_m

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 105  : 
; 106  :   #ifdef _DEBUG
; 107  : 	static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 108  :   #endif /* _DEBUG */
; 109  : 	return (_Ptr);
; 110  : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN7@Allocate_m:

; 95   : 		{	// add overflow, try allocating all of memory and assume the
; 96   : 			// allocation function will throw bad_alloc
; 97   : 		_Block_size = static_cast<size_t>(-1);
; 98   : 		}
; 99   : 
; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN14@Allocate_m:
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
_Val1$ = 24
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z PROC ; std::forward<std::allocator<wchar_t> const &>, COMDAT

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1575 : 	}

	ret	0
??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z ENDP ; std::forward<std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z PROC	; std::forward<wchar_t * const &>, COMDAT

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1575 : 	}

	ret	0
??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z ENDP	; std::forward<wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@M@std@@@std@@YAXPEAM0AEAV?$allocator@M@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
__formal$ = 24
__formal$ = 32
??$_Destroy_range1@V?$allocator@M@std@@@std@@YAXPEAM0AEAV?$allocator@M@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<float> >, COMDAT

; 1146 : 		// nothing to do
; 1147 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@M@std@@@std@@YAXPEAM0AEAV?$allocator@M@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Al$ = 80
__formal$ = 88
??$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::allocator<TileRow> >, COMDAT

; 1133 : 	{	// destroy [_First, _Last), no special optimization

$LN23:

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN20@Destroy_ra

; 1133 : 	{	// destroy [_First, _Last), no special optimization

	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	rbx, rdx
	mov	rdi, rcx
$LL4@Destroy_ra:
	lea	rcx, QWORD PTR [rdi+8]
	call	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >

; 1134 : 	for (; _First != _Last; ++_First)

	add	rdi, 32					; 00000020H
	mov	QWORD PTR _First$[rsp], rdi
	cmp	rdi, rbx
	jne	SHORT $LL4@Destroy_ra

; 1135 : 		{
; 1136 : 		allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1137 : 		}
; 1138 : 	}

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
$LN20@Destroy_ra:
	ret	0
??$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::allocator<TileRow> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Al$ = 80
__formal$ = 88
?dtor$0@?0???$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z@4HA PROC ; `std::_Destroy_range1<std::allocator<TileRow> >'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z@4HA ENDP ; `std::_Destroy_range1<std::allocator<TileRow> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Al$ = 80
__formal$ = 88
?dtor$0@?0???$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z@4HA PROC ; `std::_Destroy_range1<std::allocator<TileRow> >'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Destroy_range1@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@U?$integral_constant@_N$0A@@0@@Z@4HA ENDP ; `std::_Destroy_range1<std::allocator<TileRow> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
_Val1$ = 24
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1575 : 	}

	ret	0
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0?$_String_bitmap@_W$0A@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_bitmap@_W$0A@@std@@QEAA@XZ PROC		; std::_String_bitmap<wchar_t,0>::_String_bitmap<wchar_t,0>, COMDAT
$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	xor	edx, edx
	mov	r8d, 256				; 00000100H
	mov	rbx, rcx
	call	memset
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$_String_bitmap@_W$0A@@std@@QEAA@XZ ENDP		; std::_String_bitmap<wchar_t,0>::_String_bitmap<wchar_t,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Match@?$_String_bitmap@_W$0A@@std@@QEBA_N_W@Z
_TEXT	SEGMENT
this$ = 8
_Ch$ = 16
?_Match@?$_String_bitmap@_W$0A@@std@@QEBA_N_W@Z PROC	; std::_String_bitmap<wchar_t,0>::_Match, COMDAT

; 214  : 		return (_Ch < 256U && _Matches[_Ch]);

	mov	eax, 256				; 00000100H
	cmp	dx, ax
	jae	SHORT $LN3@Match
	movzx	eax, dx
	cmp	BYTE PTR [rax+rcx], 0
	je	SHORT $LN3@Match
	mov	al, 1

; 215  : 		}

	ret	0
$LN3@Match:

; 214  : 		return (_Ch < 256U && _Matches[_Ch]);

	xor	al, al

; 215  : 		}

	ret	0
?_Match@?$_String_bitmap@_W$0A@@std@@QEBA_N_W@Z ENDP	; std::_String_bitmap<wchar_t,0>::_Match
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Mark@?$_String_bitmap@_W$0A@@std@@QEAA_NPEB_WQEB_W@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
?_Mark@?$_String_bitmap@_W$0A@@std@@QEAA_NPEB_WQEB_W@Z PROC ; std::_String_bitmap<wchar_t,0>::_Mark, COMDAT

; 197  : 			// returns whether all inputs can be placed in the bitmap
; 198  : 		for (; _First != _Last; ++_First)

	cmp	rdx, r8
	je	SHORT $LN3@Mark
	mov	r9d, 256				; 00000100H
	npad	5
$LL4@Mark:

; 199  : 			{
; 200  : 			const auto _Ch = *_First;

	movzx	eax, WORD PTR [rdx]

; 201  : 			if (_Ch >= 256U)

	cmp	ax, r9w
	jae	SHORT $LN8@Mark

; 204  : 				}
; 205  : 
; 206  : 			_Matches[static_cast<unsigned char>(_Ch)] = true;

	movzx	eax, al
	add	rdx, 2
	mov	BYTE PTR [rax+rcx], 1
	cmp	rdx, r8
	jne	SHORT $LL4@Mark
$LN3@Mark:

; 207  : 			}
; 208  : 
; 209  : 		return (true);

	mov	al, 1

; 210  : 		}

	ret	0
$LN8@Mark:

; 202  : 				{
; 203  : 				return (false);

	xor	al, al

; 210  : 		}

	ret	0
?_Mark@?$_String_bitmap@_W$0A@@std@@QEAA_NPEB_WQEB_W@Z ENDP ; std::_String_bitmap<wchar_t,0>::_Mark
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 330  : 	return (__builtin_addressof(_Val));

	mov	rax, rcx

; 331  : 	}

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$ = 64
??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 1154 : 	{	// destroy [_First, _Last), choose optimization

$LN32:

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN29@Destroy_ra
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1154 : 	{	// destroy [_First, _Last), choose optimization

	mov	rdi, rdx
	mov	rbx, rcx
$LL6@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL6@Destroy_ra

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<
; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN29@Destroy_ra:
	ret	0
??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 199  : 	{	// deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

$LN17:
	sub	rsp, 40					; 00000028H

; 200  :  #if defined(_M_IX86) || defined(_M_X64)
; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN13@Deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN10@Deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, r8
$LN13@Deallocate:

; 208  : 	}

	add	rsp, 40					; 00000028H

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN10@Deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN15@Deallocate:
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits,0>, COMDAT

; 180  : 	{	// allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

$LN23:
	sub	rsp, 40					; 00000028H
	mov	rax, rcx

; 181  :  #if defined(_M_IX86) || defined(_M_X64)
; 182  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN2@Allocate

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

	add	rcx, 39					; 00000027H

; 94   : 	if (_Block_size <= _Bytes)

	mov	rdx, -1
	cmp	rcx, rax
	cmovbe	rcx, rdx

; 52   : 		return (::operator new(_Bytes));

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN11@Allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 189  : 		{
; 190  : 		return (_Traits::_Allocate(_Bytes));
; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);
; 194  : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN11@Allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2@Allocate:

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));
; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

	test	rax, rax
	je	SHORT $LN3@Allocate

; 189  : 		{
; 190  : 		return (_Traits::_Allocate(_Bytes));
; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);
; 194  : 	}

	add	rsp, 40					; 00000028H

; 52   : 		return (::operator new(_Bytes));

	jmp	??2@YAPEAX_K@Z				; operator new
$LN3@Allocate:

; 189  : 		{
; 190  : 		return (_Traits::_Allocate(_Bytes));
; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);
; 194  : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN21@Allocate:
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$01@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 8
??$_Get_size_of_n@$01@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<2>, COMDAT

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   : 	size_t _Result = _Count * _Ty_size;
; 26   : 	if (_Max_possible < _Count)

	mov	rdx, 9223372036854775807		; 7fffffffffffffffH
	lea	rax, QWORD PTR [rcx+rcx]
	cmp	rcx, rdx
	mov	r8, -1
	cmova	rax, r8

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);
; 30   : 		}
; 31   : 
; 32   : 	return (_Result);
; 33   : 	}

	ret	0
??$_Get_size_of_n@$01@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z PROC		; std::_Max_value<unsigned __int64>, COMDAT

; 33   : 	return (_Left < _Right ? _Right : _Left);

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 34   : 	}

	ret	0
??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z ENDP		; std::_Max_value<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$?0AEBV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$ = 16
??$?0AEBV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t> const &,void>, COMDAT

; 1784 : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax

; 1919 : 		}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@AEBV?$allocator@_W@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@PEA_WAEBQEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_WAEBQEA_W@Z
_TEXT	SEGMENT
__formal$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEA_WAEBQEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_WAEBQEA_W@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * const &>, COMDAT

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

	ret	0
??$construct@PEA_WAEBQEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_WAEBQEA_W@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z
_TEXT	SEGMENT
this$ = 64
_New_size$ = 72
_Fn$ = 80
<_Args_0>$ = 88
??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>,wchar_t const *>, COMDAT

; 3887 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

$LN95:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 3888 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3889 : 		if (_New_size > max_size())

	mov	rbx, 9223372036854775806		; 7ffffffffffffffeH
	mov	r15, r9
	mov	r14, rdx
	mov	rdi, rcx
	cmp	rdx, rbx
	ja	$LN94@Reallocate

; 3892 : 			}
; 3893 : 
; 3894 : 		auto& _My_data = this->_Get_data();
; 3895 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	QWORD PTR [rsp+64], rbp
	mov	QWORD PTR [rsp+72], rsi
	mov	rsi, QWORD PTR [rcx+24]

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	rcx, rdx
	or	rcx, 7
	cmp	rcx, rbx

; 3870 : 		if (_Masked > _Max)

	ja	SHORT $LN24@Reallocate

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);
; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;
; 3876 : 		if (_Old > _Max - _Old / 2)

	mov	rdx, rsi
	mov	rax, rbx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rsi, rax
	ja	SHORT $LN24@Reallocate

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);
; 3879 : 			}
; 3880 : 
; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	lea	rax, QWORD PTR [rdx+rsi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	mov	rbx, rcx
	cmp	rcx, rax
	cmovb	rbx, rax
$LN24@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3898 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbx+1]
	mov	rcx, rdi
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 3901 : 		_My_data._Myres = _New_capacity;

	mov	QWORD PTR [rdi+24], rbx
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	rdx, r15
	lea	rbx, QWORD PTR [r14+r14]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3900 : 		_My_data._Mysize = _New_size;

	mov	QWORD PTR [rdi+16], r14
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	r8, rbx
	mov	rcx, rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3898 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	mov	rbp, rax
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	call	memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [rbx+rbp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3903 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	rsi, 8
	jb	SHORT $LN3@Reallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR [rsi*2+2]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN78@Reallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN75@Reallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, r8
$LN78@Reallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3913 : 		return (*this);

	mov	QWORD PTR [rdi], rbp
	mov	rax, rdi
	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]

; 3914 : 		}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN75@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN94@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3891 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
	int	3
$LN92@Reallocate:
??$_Reallocate_for@V<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@_KV<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@PEB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??R<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@QEBAXQEA_W_KQEB_W@Z
_TEXT	SEGMENT
this$ = 48
_New_ptr$ = 56
_Count$ = 64
_Ptr$ = 72
??R<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@QEBAXQEA_W_KQEB_W@Z PROC ; <lambda_3fa8b2c8193a0f3144fc4b1b8f243931>::operator(), COMDAT

; 2668 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	rbx, QWORD PTR [r8+r8]
	mov	r8, rbx
	mov	rcx, rdi
	mov	rdx, r9
	call	memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [rbx+rdi], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2671 : 			}, _Ptr));

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_3fa8b2c8193a0f3144fc4b1b8f243931>@@QEBAXQEA_W_KQEB_W@Z ENDP ; <lambda_3fa8b2c8193a0f3144fc4b1b8f243931>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@PEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_W@Z
_TEXT	SEGMENT
__formal$ = 8
_Ptr$ = 16
??$destroy@PEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_W@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

	ret	0
??$destroy@PEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_W@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z PROC	; std::addressof<wchar_t *>, COMDAT

; 330  : 	return (__builtin_addressof(_Val));

	mov	rax, rcx

; 331  : 	}

	ret	0
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z ENDP	; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPEAM0AEAV?$allocator@M@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPEAM0AEAV?$allocator@M@0@@Z PROC ; std::_Destroy_range<std::allocator<float> >, COMDAT

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<
; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

	ret	0
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPEAM0AEAV?$allocator@M@0@@Z ENDP ; std::_Destroy_range<std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><>, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_First$ = 64
_Last$ = 72
_Al$ = 80
??$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z PROC ; std::_Destroy_range<std::allocator<TileRow> >, COMDAT

; 1154 : 	{	// destroy [_First, _Last), choose optimization

$LN25:

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN22@Destroy_ra
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx

; 1154 : 	{	// destroy [_First, _Last), choose optimization

	mov	rbx, rdx
	mov	rdi, rcx

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	mov	QWORD PTR _First$[rsp], rcx
$LL6@Destroy_ra:
	lea	rcx, QWORD PTR [rdi+8]
	call	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >

; 1134 : 	for (; _First != _Last; ++_First)

	add	rdi, 32					; 00000020H
	mov	QWORD PTR _First$[rsp], rdi
	cmp	rdi, rbx
	jne	SHORT $LL6@Destroy_ra

; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
$LN22@Destroy_ra:
	ret	0
??$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<TileRow> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_First$ = 64
_Last$ = 72
_Al$ = 80
?dtor$0@?0???$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z@4HA PROC ; `std::_Destroy_range<std::allocator<TileRow> >'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z@4HA ENDP ; `std::_Destroy_range<std::allocator<TileRow> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_First$ = 64
_Last$ = 72
_Al$ = 80
?dtor$0@?0???$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z@4HA PROC ; `std::_Destroy_range<std::allocator<TileRow> >'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Destroy_range@V?$allocator@VTileRow@@@std@@@std@@YAXPEAVTileRow@@0AEAV?$allocator@VTileRow@@@0@@Z@4HA ENDP ; `std::_Destroy_range<std::allocator<TileRow> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1><>, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@_W@std@@YAPEA_WAEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@_W@std@@YAPEA_WAEA_W@Z PROC		; std::addressof<wchar_t>, COMDAT

; 330  : 	return (__builtin_addressof(_Val));

	mov	rax, rcx

; 331  : 	}

	ret	0
??$addressof@_W@std@@YAPEA_WAEA_W@Z ENDP		; std::addressof<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PEA_W@std@@SAPEA_WAEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
?pointer_to@?$pointer_traits@PEA_W@std@@SAPEA_WAEA_W@Z PROC ; std::pointer_traits<wchar_t *>::pointer_to, COMDAT

; 342  : 		return (_STD addressof(_Val));

	mov	rax, rcx

; 343  : 		}

	ret	0
?pointer_to@?$pointer_traits@PEA_W@std@@SAPEA_WAEA_W@Z ENDP ; std::pointer_traits<wchar_t *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 346  : 	return (_Ptr);

	mov	rax, rcx

; 347  : 	}

	ret	0
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$_Max_value@PEA_W@std@@YAAEBQEA_WAEBQEA_W0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Max_value@PEA_W@std@@YAAEBQEA_WAEBQEA_W0@Z PROC	; std::_Max_value<wchar_t *>, COMDAT

; 33   : 	return (_Left < _Right ? _Right : _Left);

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 34   : 	}

	ret	0
??$_Max_value@PEA_W@std@@YAAEBQEA_WAEBQEA_W0@Z ENDP	; std::_Max_value<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT

; 53   : 			// TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old basic_filebuf
; 54   : 			// would set _Fpos.
; 55   : 		return (_Myoff + _Fpos);

	mov	rax, QWORD PTR [rcx+8]
	add	rax, QWORD PTR [rcx]

; 56   : 		}

	ret	0
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 32   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

	xor	eax, eax
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], 0
	mov	QWORD PTR [rcx+16], rax

; 34   : 		}

	mov	rax, rcx
	ret	0
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$?0V?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@$$QEAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$ = 16
??$?0V?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@$$QEAV?$allocator@_W@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t>,void>, COMDAT

; 1784 : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax

; 1919 : 		}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@_W@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@$$QEAV?$allocator@_W@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::allocator<wchar_t>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Traits_find_first_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_Haystack$ = 8
_Hay_size$ = 16
_Start_at$ = 24
_Needle$ = 32
_Needle_size$ = 40
__formal$ = 48
??$_Traits_find_first_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Traits_find_first_of<std::char_traits<wchar_t> >, COMDAT

; 225  : 	{	// in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at

$LN29:
	mov	QWORD PTR [rsp+8], rbx

; 226  : 		// general algorithm
; 227  : 	if (_Needle_size != 0 && _Start_at < _Hay_size)

	mov	r10, QWORD PTR _Needle_size$[rsp]
	mov	rbx, rcx
	test	r10, r10
	je	SHORT $LN3@Traits_fin
	cmp	r8, rdx
	jae	SHORT $LN3@Traits_fin

; 228  : 		{	// room for match, look for it
; 229  : 		const auto _End = _Haystack + _Hay_size;

	lea	r11, QWORD PTR [rcx+rdx*2]

; 230  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	rdx, QWORD PTR [rcx+r8*2]
	cmp	rdx, r11
	jae	SHORT $LN3@Traits_fin
$LL4@Traits_fin:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 339  : 		return (reinterpret_cast<const _Elem *>(_CSTD wmemchr(

	mov	rcx, r10
	mov	rax, r9
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 203  :         for (; 0 < _N; ++_S, --_N)

	test	r10, r10
	je	SHORT $LN12@Traits_fin

; 204  :             if (*_S == _C)

	movzx	r8d, WORD PTR [rdx]
$LL13@Traits_fin:
	cmp	WORD PTR [rax], r8w
	je	SHORT $LN19@Traits_fin

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rax, 2
	sub	rcx, 1
	jne	SHORT $LL13@Traits_fin
$LN12@Traits_fin:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 230  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	rdx, 2
	cmp	rdx, r11
	jb	SHORT $LL4@Traits_fin
$LN3@Traits_fin:

; 235  : 				}
; 236  : 			}
; 237  : 		}
; 238  : 
; 239  : 	return (static_cast<size_t>(-1));	// no match

	mov	rax, -1

; 240  : 	}

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN19@Traits_fin:

; 231  : 			{
; 232  : 			if (_Traits::find(_Needle, _Needle_size, *_Match_try))
; 233  : 				{
; 234  : 				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match

	sub	rdx, rbx

; 240  : 	}

	mov	rbx, QWORD PTR [rsp+8]
	sar	rdx, 1
	mov	rax, rdx
	ret	0
??$_Traits_find_first_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Traits_find_first_of<std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Traits_find_first_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
_Matches$1 = 32
_Haystack$ = 320
_Hay_size$ = 328
_Start_at$ = 336
_Needle$ = 344
_Needle_size$ = 352
__formal$ = 360
??$_Traits_find_first_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$00@0@@Z PROC ; std::_Traits_find_first_of<std::char_traits<wchar_t> >, COMDAT

; 246  : 	{	// in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at

$LN63:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 288				; 00000120H

; 247  : 		// special case for std::char_traits
; 248  : 	if (_Needle_size != 0 && _Start_at < _Hay_size)

	mov	rbx, QWORD PTR _Needle_size$[rsp]
	mov	r14, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	r15, rcx
	test	rbx, rbx
	je	SHORT $LN3@Traits_fin
	cmp	r8, rdx
	jae	SHORT $LN3@Traits_fin

; 249  : 		{	// room for match, look for it
; 250  : 		_String_bitmap<typename _Traits::char_type> _Matches;
; 251  : 		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))

	mov	ebp, 256				; 00000100H
	lea	rcx, QWORD PTR _Matches$1[rsp]
	mov	r8d, ebp
	xor	edx, edx
	call	memset
	lea	rcx, QWORD PTR [r14+rbx*2]
	mov	rdx, r14

; 198  : 		for (; _First != _Last; ++_First)

	cmp	r14, rcx
	je	SHORT $LN6@Traits_fin
	npad	7
$LL14@Traits_fin:

; 199  : 			{
; 200  : 			const auto _Ch = *_First;

	movzx	eax, WORD PTR [rdx]

; 201  : 			if (_Ch >= 256U)

	cmp	ax, bp
	jae	SHORT $LN56@Traits_fin

; 202  : 				{
; 203  : 				return (false);
; 204  : 				}
; 205  : 
; 206  : 			_Matches[static_cast<unsigned char>(_Ch)] = true;

	movzx	eax, al
	add	rdx, 2
	mov	BYTE PTR _Matches$1[rsp+rax], 1
	cmp	rdx, rcx
	jne	SHORT $LL14@Traits_fin
$LN6@Traits_fin:

; 254  : 				false_type{}));
; 255  : 			}
; 256  : 
; 257  : 		const auto _End = _Haystack + _Hay_size;

	lea	rdx, QWORD PTR [r15+rsi*2]

; 258  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	rcx, QWORD PTR [r15+rdi*2]
	cmp	rcx, rdx
	jae	SHORT $LN3@Traits_fin
$LL4@Traits_fin:

; 259  : 			{
; 260  : 			if (_Matches._Match(*_Match_try))

	movzx	eax, WORD PTR [rcx]

; 214  : 		return (_Ch < 256U && _Matches[_Ch]);

	cmp	ax, bp
	jae	SHORT $LN34@Traits_fin
	movzx	eax, ax
	cmp	BYTE PTR _Matches$1[rsp+rax], 0
	jne	SHORT $LN43@Traits_fin
$LN34@Traits_fin:

; 258  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	rcx, 2
	cmp	rcx, rdx
	jb	SHORT $LL4@Traits_fin
$LN3@Traits_fin:

; 263  : 				}
; 264  : 			}
; 265  : 		}
; 266  : 
; 267  : 	return (static_cast<size_t>(-1));	// no match

	mov	rax, -1
$LN1@Traits_fin:

; 268  : 	}

	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN56@Traits_fin:

; 229  : 		const auto _End = _Haystack + _Hay_size;

	lea	r9, QWORD PTR [r15+rsi*2]

; 230  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	rdx, QWORD PTR [r15+rdi*2]
	cmp	rdx, r9
	jae	SHORT $LN19@Traits_fin
$LL20@Traits_fin:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 339  : 		return (reinterpret_cast<const _Elem *>(_CSTD wmemchr(

	mov	rcx, rbx
	mov	rax, r14
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 203  :         for (; 0 < _N; ++_S, --_N)

	test	rbx, rbx
	je	SHORT $LN28@Traits_fin

; 204  :             if (*_S == _C)

	movzx	r8d, WORD PTR [rdx]
$LL29@Traits_fin:
	cmp	WORD PTR [rax], r8w
	je	SHORT $LN42@Traits_fin

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rax, 2
	sub	rcx, 1
	jne	SHORT $LL29@Traits_fin
$LN28@Traits_fin:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 230  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	rdx, 2
	cmp	rdx, r9
	jb	SHORT $LL20@Traits_fin
$LN19@Traits_fin:

; 235  : 				}
; 236  : 			}
; 237  : 		}
; 238  : 
; 239  : 	return (static_cast<size_t>(-1));	// no match

	mov	rdx, -1

; 252  : 			{	// couldn't put one of the characters into the bitmap, fall back to the serial algorithm
; 253  : 			return (_Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,

	mov	rax, rdx
	jmp	SHORT $LN1@Traits_fin
$LN42@Traits_fin:

; 234  : 				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match

	sub	rdx, r15
	sar	rdx, 1

; 252  : 			{	// couldn't put one of the characters into the bitmap, fall back to the serial algorithm
; 253  : 			return (_Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,

	mov	rax, rdx
	jmp	SHORT $LN1@Traits_fin
$LN43@Traits_fin:

; 261  : 				{
; 262  : 				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match

	sub	rcx, r15
	sar	rcx, 1
	mov	rax, rcx
	jmp	SHORT $LN1@Traits_fin
??$_Traits_find_first_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$00@0@@Z ENDP ; std::_Traits_find_first_of<std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Traits_find_first_not_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_Haystack$ = 8
_Hay_size$ = 16
_Start_at$ = 24
_Needle$ = 32
_Needle_size$ = 40
__formal$ = 48
??$_Traits_find_first_not_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Traits_find_first_not_of<std::char_traits<wchar_t> >, COMDAT

; 331  : 	{	// in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	mov	rbx, rcx

; 332  : 		// general algorithm
; 333  : 	if (_Start_at < _Hay_size)

	cmp	r8, rdx
	jae	SHORT $LN3@Traits_fin

; 334  : 		{	// room for match, look for it
; 335  : 		const auto _End = _Haystack + _Hay_size;

	lea	r11, QWORD PTR [rcx+rdx*2]

; 336  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	r8, QWORD PTR [rcx+r8*2]
	cmp	r8, r11
	jae	SHORT $LN3@Traits_fin
	mov	r10, QWORD PTR _Needle_size$[rsp]
	npad	1
$LL4@Traits_fin:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 339  : 		return (reinterpret_cast<const _Elem *>(_CSTD wmemchr(

	mov	rdx, r10
	mov	rax, r9
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 203  :         for (; 0 < _N; ++_S, --_N)

	test	r10, r10
	je	SHORT $LN19@Traits_fin

; 204  :             if (*_S == _C)

	movzx	ecx, WORD PTR [r8]
	npad	1
$LL13@Traits_fin:
	cmp	WORD PTR [rax], cx
	je	SHORT $LN18@Traits_fin

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rax, 2
	sub	rdx, 1
	jne	SHORT $LL13@Traits_fin
$LN19@Traits_fin:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 340  : 				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match

	sub	r8, rbx
	sar	r8, 1
	mov	rax, r8

; 341  : 				}
; 342  : 			}
; 343  : 		}
; 344  : 
; 345  : 	return (static_cast<size_t>(-1));	// no match
; 346  : 	}

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN18@Traits_fin:

; 336  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	r8, 2
	cmp	r8, r11
	jb	SHORT $LL4@Traits_fin
$LN3@Traits_fin:

; 341  : 				}
; 342  : 			}
; 343  : 		}
; 344  : 
; 345  : 	return (static_cast<size_t>(-1));	// no match
; 346  : 	}

	mov	rbx, QWORD PTR [rsp+8]
	mov	rax, -1
	ret	0
??$_Traits_find_first_not_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Traits_find_first_not_of<std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Traits_find_first_not_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
_Matches$1 = 32
_Haystack$ = 304
_Hay_size$ = 312
_Start_at$ = 320
_Needle$ = 328
_Needle_size$ = 336
__formal$ = 344
??$_Traits_find_first_not_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$00@0@@Z PROC ; std::_Traits_find_first_not_of<std::char_traits<wchar_t> >, COMDAT

; 352  : 	{	// in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at

$LN62:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 288				; 00000120H
	mov	rsi, r9
	mov	rbx, r8
	mov	rdi, rdx
	mov	r14, rcx

; 353  : 		// special case for std::char_traits
; 354  : 	if (_Start_at < _Hay_size)

	cmp	r8, rdx
	jae	SHORT $LN3@Traits_fin

; 355  : 		{	// room for match, look for it
; 356  : 		_String_bitmap<typename _Traits::char_type> _Matches;
; 357  : 		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))

	mov	ebp, 256				; 00000100H
	lea	rcx, QWORD PTR _Matches$1[rsp]
	mov	r8d, ebp
	xor	edx, edx
	call	memset
	mov	r11, QWORD PTR _Needle_size$[rsp]
	mov	r10, rsi
	lea	r9, QWORD PTR [rsi+r11*2]

; 198  : 		for (; _First != _Last; ++_First)

	cmp	rsi, r9
	je	SHORT $LN6@Traits_fin
$LL14@Traits_fin:

; 199  : 			{
; 200  : 			const auto _Ch = *_First;

	movzx	eax, WORD PTR [r10]

; 201  : 			if (_Ch >= 256U)

	cmp	ax, bp
	jae	SHORT $LN56@Traits_fin

; 202  : 				{
; 203  : 				return (false);
; 204  : 				}
; 205  : 
; 206  : 			_Matches[static_cast<unsigned char>(_Ch)] = true;

	movzx	eax, al
	add	r10, 2
	mov	BYTE PTR _Matches$1[rsp+rax], 1
	cmp	r10, r9
	jne	SHORT $LL14@Traits_fin
$LN6@Traits_fin:

; 360  : 				false_type{}));
; 361  : 			}
; 362  : 
; 363  : 		const auto _End = _Haystack + _Hay_size;

	lea	rdx, QWORD PTR [r14+rdi*2]

; 364  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	rcx, QWORD PTR [r14+rbx*2]
	cmp	rcx, rdx
	jae	SHORT $LN3@Traits_fin
	npad	3
$LL4@Traits_fin:

; 365  : 			{
; 366  : 			if (!_Matches._Match(*_Match_try))

	movzx	eax, WORD PTR [rcx]

; 214  : 		return (_Ch < 256U && _Matches[_Ch]);

	cmp	ax, bp
	jae	$LN43@Traits_fin
	movzx	eax, ax
	cmp	BYTE PTR _Matches$1[rsp+rax], 0
	je	SHORT $LN43@Traits_fin

; 364  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	rcx, 2
	cmp	rcx, rdx
	jb	SHORT $LL4@Traits_fin
$LN3@Traits_fin:

; 369  : 				}
; 370  : 			}
; 371  : 		}
; 372  : 
; 373  : 	return (static_cast<size_t>(-1));	// no match

	mov	rax, -1
$LN1@Traits_fin:

; 374  : 	}

	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	ret	0
$LN56@Traits_fin:

; 335  : 		const auto _End = _Haystack + _Hay_size;

	lea	r9, QWORD PTR [r14+rdi*2]

; 336  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	rdx, QWORD PTR [r14+rbx*2]
	cmp	rdx, r9
	jae	SHORT $LN19@Traits_fin
$LL20@Traits_fin:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 339  : 		return (reinterpret_cast<const _Elem *>(_CSTD wmemchr(

	mov	rcx, r11
	mov	rax, rsi
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 203  :         for (; 0 < _N; ++_S, --_N)

	test	r11, r11
	je	SHORT $LN42@Traits_fin

; 204  :             if (*_S == _C)

	movzx	r8d, WORD PTR [rdx]
$LL29@Traits_fin:
	cmp	WORD PTR [rax], r8w
	je	SHORT $LN41@Traits_fin

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rax, 2
	sub	rcx, 1
	jne	SHORT $LL29@Traits_fin
$LN42@Traits_fin:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 340  : 				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match

	sub	rdx, r14
	sar	rdx, 1

; 358  : 			{	// couldn't put one of the characters into the bitmap, fall back to the serial algorithm
; 359  : 			return (_Traits_find_first_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,

	mov	rax, rdx
	jmp	SHORT $LN1@Traits_fin
$LN41@Traits_fin:

; 336  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	rdx, 2
	cmp	rdx, r9
	jb	SHORT $LL20@Traits_fin
$LN19@Traits_fin:

; 341  : 				}
; 342  : 			}
; 343  : 		}
; 344  : 
; 345  : 	return (static_cast<size_t>(-1));	// no match

	mov	rdx, -1

; 358  : 			{	// couldn't put one of the characters into the bitmap, fall back to the serial algorithm
; 359  : 			return (_Traits_find_first_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,

	mov	rax, rdx
	jmp	SHORT $LN1@Traits_fin
$LN43@Traits_fin:

; 367  : 				{
; 368  : 				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match

	sub	rcx, r14
	sar	rcx, 1
	mov	rax, rcx
	jmp	SHORT $LN1@Traits_fin
??$_Traits_find_first_not_of@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101U?$integral_constant@_N$00@0@@Z ENDP ; std::_Traits_find_first_not_of<std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Newvec$ = 136
??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z PROC ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float const &>, COMDAT

; 942  : 		{	// reallocate and insert by perfectly forwarding _Val at _Whereptr

$LN208:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	r13, r8
	mov	r12, rdx
	mov	rdi, rcx

; 943  : 			// pre: !_Has_unused_capacity()
; 944  : 		const size_type _Whereoff = static_cast<size_type>(_Whereptr - this->_Myfirst());

	mov	rcx, QWORD PTR [rcx]
	mov	r14, rdx
	sub	r14, rcx
	sar	r14, 2

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rax, QWORD PTR [rdi+8]
	sub	rax, rcx
	sar	rax, 2

; 945  : 		_Alty& _Al = this->_Getal();
; 946  : 		const size_type _Oldsize = size();
; 947  : 
; 948  : 		if (_Oldsize == max_size())

	mov	rdx, 4611686018427387903		; 3fffffffffffffffH
	cmp	rax, rdx
	je	$LN207@Emplace_re

; 951  : 			}
; 952  : 
; 953  : 		const size_type _Newsize = _Oldsize + 1;

	lea	r15, QWORD PTR [rax+1]

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rcx
	sar	rax, 2

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	rcx, rax
	shr	rcx, 1
	sub	rdx, rcx
	cmp	rax, rdx
	jbe	SHORT $LN48@Emplace_re

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

	mov	rbx, r15
	jmp	SHORT $LN204@Emplace_re
$LN48@Emplace_re:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rcx+rax]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

	cmp	rbx, r15
	cmovb	rbx, r15
$LN204@Emplace_re:

; 954  : 		const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 955  : 
; 956  : 		const pointer _Newvec = _Al.allocate(_Newcapacity);

	mov	QWORD PTR _Newcapacity$[rsp], rbx
	mov	rdx, rbx
	mov	rcx, rdi
	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate
	mov	rsi, rax
	mov	QWORD PTR _Newvec$[rsp], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	ecx, DWORD PTR [r13]
	mov	DWORD PTR [rax+r14*4], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 964  : 		if (_Whereptr == this->_Mylast())

	mov	r8, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rax
	cmp	r12, r8
	jne	SHORT $LN4@Emplace_re
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 968  : 		else

	jmp	SHORT $LN205@Emplace_re
$LN4@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r12
	sub	r8, rdx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 972  : 			_Umove(_Whereptr, this->_Mylast(), _Newvec + _Whereoff + 1);

	mov	r8, QWORD PTR [rdi+8]
	lea	rcx, QWORD PTR [r14+1]
	lea	rcx, QWORD PTR [rsi+rcx*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r12

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r12
$LN205@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 974  : 		_CATCH_ALL

	call	memmove
	npad	1

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);
; 977  : 		_RERAISE;
; 978  : 		_CATCH_END
; 979  : 
; 980  : 		_Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, r15
	mov	rdx, rsi
	mov	rcx, rdi
	call	?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z ; std::vector<float,std::allocator<float> >::_Change_array

; 981  : 		return (this->_Myfirst() + _Whereoff);

	mov	rax, QWORD PTR [rdi]
	lea	rax, QWORD PTR [rax+r14*4]

; 982  : 		}

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN207@Emplace_re:

; 949  : 			{
; 950  : 			_Xlength();

	call	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
	int	3
$LN203@Emplace_re:
??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z ENDP ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float const &>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Newvec$ = 136
?catch$0@?0???$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z@4HA PROC ; `std::vector<float,std::allocator<float> >::_Emplace_reallocate<float const &>'::`1'::catch$0

; 974  : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z$0:

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?deallocate@?$allocator@M@std@@QEAAXQEAM_K@Z ; std::allocator<float>::deallocate

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);
; 977  : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z@4HA ENDP ; `std::vector<float,std::allocator<float> >::_Emplace_reallocate<float const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Newvec$ = 136
?catch$0@?0???$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z@4HA PROC ; `std::vector<float,std::allocator<float> >::_Emplace_reallocate<float const &>'::`1'::catch$0

; 974  : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z$0:

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?deallocate@?$allocator@M@std@@QEAAXQEAM_K@Z ; std::allocator<float>::deallocate

; 977  : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z@4HA ENDP ; `std::vector<float,std::allocator<float> >::_Emplace_reallocate<float const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@MAEBM@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAMAEBM@Z
_TEXT	SEGMENT
__formal$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@MAEBM@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAMAEBM@Z PROC ; std::_Default_allocator_traits<std::allocator<float> >::construct<float,float const &>, COMDAT

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

	ret	0
??$construct@MAEBM@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAMAEBM@Z ENDP ; std::_Default_allocator_traits<std::allocator<float> >::construct<float,float const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBM@?$vector@MV?$allocator@M@std@@@std@@AEAAXAEBM@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@AEBM@?$vector@MV?$allocator@M@std@@@std@@AEAAXAEBM@Z PROC ; std::vector<float,std::allocator<float> >::_Emplace_back_with_unused_capacity<float const &>, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	r8, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	lea	rax, QWORD PTR [r8+4]
	mov	QWORD PTR [rcx+8], rax

; 906  : #if _HAS_CXX17
; 907  : 		return (_Result);
; 908  : #else /* ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv */
; 909  : 		(void)_Result;
; 910  : #endif /* _HAS_CXX17 */
; 911  : 		}

	ret	0
??$_Emplace_back_with_unused_capacity@AEBM@?$vector@MV?$allocator@M@std@@@std@@AEAAXAEBM@Z ENDP ; std::vector<float,std::allocator<float> >::_Emplace_back_with_unused_capacity<float const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@AEBM@std@@YAAEBMAEBM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBM@std@@YAAEBMAEBM@Z PROC			; std::forward<float const &>, COMDAT

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1575 : 	}

	ret	0
??$forward@AEBM@std@@YAAEBMAEBM@Z ENDP			; std::forward<float const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$emplace_back@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAXAEBM@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$emplace_back@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAXAEBM@Z PROC ; std::vector<float,std::allocator<float> >::emplace_back<float const &>, COMDAT

; 916  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

	mov	r8, rdx

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	rdx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], rdx

; 917  : 		if (_Has_unused_capacity())

	je	SHORT $LN2@emplace_ba
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	QWORD PTR [rcx+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	DWORD PTR [rdx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 928  : 		}

	ret	0
$LN2@emplace_ba:

; 918  : 			{
; 919  : 			return (_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...));
; 920  : 			}
; 921  : 
; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float const &>
??$emplace_back@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAXAEBM@Z ENDP ; std::vector<float,std::allocator<float> >::emplace_back<float const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Newvec$ = 136
??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z PROC ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float>, COMDAT

; 942  : 		{	// reallocate and insert by perfectly forwarding _Val at _Whereptr

$LN208:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	r13, r8
	mov	r12, rdx
	mov	rdi, rcx

; 943  : 			// pre: !_Has_unused_capacity()
; 944  : 		const size_type _Whereoff = static_cast<size_type>(_Whereptr - this->_Myfirst());

	mov	rcx, QWORD PTR [rcx]
	mov	r14, rdx
	sub	r14, rcx
	sar	r14, 2

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rax, QWORD PTR [rdi+8]
	sub	rax, rcx
	sar	rax, 2

; 945  : 		_Alty& _Al = this->_Getal();
; 946  : 		const size_type _Oldsize = size();
; 947  : 
; 948  : 		if (_Oldsize == max_size())

	mov	rdx, 4611686018427387903		; 3fffffffffffffffH
	cmp	rax, rdx
	je	$LN207@Emplace_re

; 951  : 			}
; 952  : 
; 953  : 		const size_type _Newsize = _Oldsize + 1;

	lea	r15, QWORD PTR [rax+1]

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rcx
	sar	rax, 2

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	rcx, rax
	shr	rcx, 1
	sub	rdx, rcx
	cmp	rax, rdx
	jbe	SHORT $LN48@Emplace_re

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

	mov	rbx, r15
	jmp	SHORT $LN204@Emplace_re
$LN48@Emplace_re:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [rcx+rax]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

	cmp	rbx, r15
	cmovb	rbx, r15
$LN204@Emplace_re:

; 954  : 		const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 955  : 
; 956  : 		const pointer _Newvec = _Al.allocate(_Newcapacity);

	mov	QWORD PTR _Newcapacity$[rsp], rbx
	mov	rdx, rbx
	mov	rcx, rdi
	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate
	mov	rsi, rax
	mov	QWORD PTR _Newvec$[rsp], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	ecx, DWORD PTR [r13]
	mov	DWORD PTR [rax+r14*4], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 964  : 		if (_Whereptr == this->_Mylast())

	mov	r8, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rax
	cmp	r12, r8
	jne	SHORT $LN4@Emplace_re
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 968  : 		else

	jmp	SHORT $LN205@Emplace_re
$LN4@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r12
	sub	r8, rdx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 972  : 			_Umove(_Whereptr, this->_Mylast(), _Newvec + _Whereoff + 1);

	mov	r8, QWORD PTR [rdi+8]
	lea	rcx, QWORD PTR [r14+1]
	lea	rcx, QWORD PTR [rsi+rcx*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r12

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r12
$LN205@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 974  : 		_CATCH_ALL

	call	memmove
	npad	1

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);
; 977  : 		_RERAISE;
; 978  : 		_CATCH_END
; 979  : 
; 980  : 		_Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, rbx
	mov	r8, r15
	mov	rdx, rsi
	mov	rcx, rdi
	call	?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z ; std::vector<float,std::allocator<float> >::_Change_array

; 981  : 		return (this->_Myfirst() + _Whereoff);

	mov	rax, QWORD PTR [rdi]
	lea	rax, QWORD PTR [rax+r14*4]

; 982  : 		}

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN207@Emplace_re:

; 949  : 			{
; 950  : 			_Xlength();

	call	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
	int	3
$LN203@Emplace_re:
??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z ENDP ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Newvec$ = 136
?catch$0@?0???$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z@4HA PROC ; `std::vector<float,std::allocator<float> >::_Emplace_reallocate<float>'::`1'::catch$0

; 974  : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z$0:

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?deallocate@?$allocator@M@std@@QEAAXQEAM_K@Z ; std::allocator<float>::deallocate

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);
; 977  : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z@4HA ENDP ; `std::vector<float,std::allocator<float> >::_Emplace_reallocate<float>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Newvec$ = 136
?catch$0@?0???$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z@4HA PROC ; `std::vector<float,std::allocator<float> >::_Emplace_reallocate<float>'::`1'::catch$0

; 974  : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z$0:

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?deallocate@?$allocator@M@std@@QEAAXQEAM_K@Z ; std::allocator<float>::deallocate

; 977  : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z@4HA ENDP ; `std::vector<float,std::allocator<float> >::_Emplace_reallocate<float>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@MM@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM$$QEAM@Z
_TEXT	SEGMENT
__formal$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@MM@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM$$QEAM@Z PROC ; std::_Default_allocator_traits<std::allocator<float> >::construct<float,float>, COMDAT

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

	ret	0
??$construct@MM@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAXAEAV?$allocator@M@1@QEAM$$QEAM@Z ENDP ; std::_Default_allocator_traits<std::allocator<float> >::construct<float,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@M@std@@YAPEAMPEAM@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@M@std@@YAPEAMPEAM@Z PROC			; std::_Unfancy<float>, COMDAT

; 346  : 	return (_Ptr);

	mov	rax, rcx

; 347  : 	}

	ret	0
??$_Unfancy@M@std@@YAPEAMPEAM@Z ENDP			; std::_Unfancy<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@M@?$vector@MV?$allocator@M@std@@@std@@AEAAX$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@M@?$vector@MV?$allocator@M@std@@@std@@AEAAX$$QEAM@Z PROC ; std::vector<float,std::allocator<float> >::_Emplace_back_with_unused_capacity<float>, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	r8, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	lea	rax, QWORD PTR [r8+4]
	mov	QWORD PTR [rcx+8], rax

; 906  : #if _HAS_CXX17
; 907  : 		return (_Result);
; 908  : #else /* ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv */
; 909  : 		(void)_Result;
; 910  : #endif /* _HAS_CXX17 */
; 911  : 		}

	ret	0
??$_Emplace_back_with_unused_capacity@M@?$vector@MV?$allocator@M@std@@@std@@AEAAX$$QEAM@Z ENDP ; std::vector<float,std::allocator<float> >::_Emplace_back_with_unused_capacity<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QEAMAEAM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@M@std@@YA$$QEAMAEAM@Z PROC			; std::forward<float>, COMDAT

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1575 : 	}

	ret	0
??$forward@M@std@@YA$$QEAMAEAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$emplace_back@M@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$emplace_back@M@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAM@Z PROC ; std::vector<float,std::allocator<float> >::emplace_back<float>, COMDAT

; 916  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

	mov	r8, rdx

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	rdx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], rdx

; 917  : 		if (_Has_unused_capacity())

	je	SHORT $LN2@emplace_ba
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	QWORD PTR [rcx+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	DWORD PTR [rdx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 928  : 		}

	ret	0
$LN2@emplace_ba:

; 918  : 			{
; 919  : 			return (_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...));
; 920  : 			}
; 921  : 
; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float>
??$emplace_back@M@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAM@Z ENDP ; std::vector<float,std::allocator<float> >::emplace_back<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AEAM@std@@YA$$QEAMAEAM@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAM@std@@YA$$QEAMAEAM@Z PROC			; std::move<float &>, COMDAT

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

	mov	rax, rcx

; 1590 : 	}

	ret	0
??$move@AEAM@std@@YA$$QEAMAEAM@Z ENDP			; std::move<float &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z
_TEXT	SEGMENT
_Constructed_first$ = 32
_Constructed_last$ = 40
$T1 = 48
$T2 = 56
_First$3 = 128
this$ = 128
$T4 = 136
_Whereptr$ = 136
<_Val_0>$ = 144
_Newcapacity$ = 152
??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>, COMDAT

; 942  : 		{	// reallocate and insert by perfectly forwarding _Val at _Whereptr

$LN296:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	r14, rdx
	mov	rsi, rcx

; 943  : 			// pre: !_Has_unused_capacity()
; 944  : 		const size_type _Whereoff = static_cast<size_type>(_Whereptr - this->_Myfirst());

	mov	rax, QWORD PTR [rcx]
	mov	rbx, rdx
	sub	rbx, rax

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	r15, QWORD PTR [rcx+8]
	sub	r15, rax
	sar	r15, 5

; 945  : 		_Alty& _Al = this->_Getal();
; 946  : 		const size_type _Oldsize = size();
; 947  : 
; 948  : 		if (_Oldsize == max_size())

	mov	r9, 576460752303423487			; 07ffffffffffffffH
	cmp	r15, r9
	je	$LN295@Emplace_re

; 951  : 			}
; 952  : 
; 953  : 		const size_type _Newsize = _Oldsize + 1;

	inc	r15

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rax
	sar	rcx, 5

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, r9
	sub	rax, rdx
	cmp	rcx, rax
	jbe	SHORT $LN48@Emplace_re

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

	mov	rax, r15
	jmp	SHORT $LN291@Emplace_re
$LN48@Emplace_re:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

	cmp	rax, r15
	cmovb	rax, r15
$LN291@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 25   : 	size_t _Result = _Count * _Ty_size;

	mov	QWORD PTR _Newcapacity$[rsp], rax
	mov	r13, rax
	shl	r13, 5
	mov	rdx, r13

; 26   : 	if (_Max_possible < _Count)

	cmp	rax, r9
	jbe	SHORT $LN80@Emplace_re

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

	mov	rax, -1
	mov	rdx, rax

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

	jmp	SHORT $LN289@Emplace_re
$LN80@Emplace_re:
	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN83@Emplace_re
	mov	rax, -1
$LN289@Emplace_re:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 94   : 	if (_Block_size <= _Bytes)

	cmp	rcx, rdx
	cmovbe	rcx, rax

; 52   : 		return (::operator new(_Bytes));

	call	??2@YAPEAX_K@Z				; operator new

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN92@Emplace_re

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	mov	r8, QWORD PTR <_Val_0>$[rsp]
	jmp	SHORT $LN292@Emplace_re
$LN92@Emplace_re:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN83@Emplace_re:

; 188  : 	if (_Bytes != 0)

	test	rdx, rdx
	je	SHORT $LN84@Emplace_re

; 52   : 		return (::operator new(_Bytes));

	mov	rcx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 190  : 		return (_Traits::_Allocate(_Bytes));

	mov	r8, QWORD PTR <_Val_0>$[rsp]
	jmp	SHORT $LN292@Emplace_re
$LN84@Emplace_re:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

	xor	edi, edi
$LN292@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 957  : 		const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	mov	QWORD PTR $T4[rsp], rdi
	and	rbx, -32				; ffffffffffffffe0H
	lea	r12, QWORD PTR [rbx+rdi]
	lea	rbx, QWORD PTR [r12+32]
	mov	QWORD PTR _Constructed_last$[rsp], rbx

; 958  : 		pointer _Constructed_first = _Constructed_last;

	mov	QWORD PTR _Constructed_first$[rsp], rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	QWORD PTR $T2[rsp], r12
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [r12], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [r12+4], eax
	lea	rdx, QWORD PTR [r8+8]
	lea	rcx, QWORD PTR [r12+8]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 962  : 		_Constructed_first = _Newvec + _Whereoff;

	mov	QWORD PTR _Constructed_first$[rsp], r12

; 963  : 
; 964  : 		if (_Whereptr == this->_Mylast())

	mov	rdx, QWORD PTR [rsi+8]
	mov	r9, rsi
	mov	r8, rdi
	mov	rcx, QWORD PTR [rsi]
	cmp	r14, rdx
	je	SHORT $LN293@Emplace_re

; 1828 : 		return (_Uninitialized_move(_First, _Last, _Dest, this->_Getal()));

	mov	rdx, r14
	call	??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z ; std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >

; 965  : 			{	// at back, provide strong guarantee
; 966  : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
; 967  : 			}
; 968  : 		else
; 969  : 			{	// provide basic guarantee
; 970  : 			_Umove(this->_Myfirst(), _Whereptr, _Newvec);
; 971  : 			_Constructed_first = _Newvec;

	mov	QWORD PTR _Constructed_first$[rsp], rdi

; 1828 : 		return (_Uninitialized_move(_First, _Last, _Dest, this->_Getal()));

	mov	r9, rsi
	mov	r8, rbx
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, r14
$LN293@Emplace_re:

; 972  : 			_Umove(_Whereptr, this->_Mylast(), _Newvec + _Whereoff + 1);
; 973  : 			}
; 974  : 		_CATCH_ALL

	call	??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z ; std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >
	npad	1

; 1898 : 		if (this->_Myfirst() != pointer())

	mov	rbx, QWORD PTR [rsi]
	test	rbx, rbx
	je	SHORT $LN258@Emplace_re

; 1899 : 			{	// destroy and deallocate old array
; 1900 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	r14, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	mov	QWORD PTR _First$3[rsp], rbx

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rbx, r14
	je	SHORT $LN206@Emplace_re
$LL207@Emplace_re:
	lea	rcx, QWORD PTR [rbx+8]
	call	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
	add	rbx, 32					; 00000020H
	mov	QWORD PTR _First$3[rsp], rbx
	cmp	rbx, r14
	jne	SHORT $LL207@Emplace_re
	mov	rbx, QWORD PTR [rsi]
$LN206@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN257@Emplace_re

; 115  : 	_Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rbx-8]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rcx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, 31
	ja	SHORT $LN254@Emplace_re

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rbx, rcx
$LN257@Emplace_re:

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN258@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

	mov	QWORD PTR [rsi], rdi

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

	shl	r15, 5
	add	r15, rdi
	mov	QWORD PTR [rsi+8], r15

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rdi+r13]
	mov	QWORD PTR [rsi+16], rcx

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);
; 977  : 		_RERAISE;
; 978  : 		_CATCH_END
; 979  : 
; 980  : 		_Change_array(_Newvec, _Newsize, _Newcapacity);
; 981  : 		return (this->_Myfirst() + _Whereoff);

	mov	rax, r12

; 982  : 		}

	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN254@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN295@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 950  : 			_Xlength();

	call	?_Xlength@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@CAXXZ ; std::vector<TileRow,std::allocator<TileRow> >::_Xlength
	int	3
$LN290@Emplace_re:
??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_Constructed_last$ = 40
$T1 = 48
$T2 = 56
_First$3 = 128
this$ = 128
$T4 = 136
_Whereptr$ = 136
<_Val_0>$ = 144
_Newcapacity$ = 152
?dtor$0@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_Constructed_last$ = 40
$T1 = 48
$T2 = 56
_First$3 = 128
this$ = 128
$T4 = 136
_Whereptr$ = 136
<_Val_0>$ = 144
_Newcapacity$ = 152
?catch$2@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>'::`1'::catch$2

; 972  : 			_Umove(_Whereptr, this->_Mylast(), _Newvec + _Whereoff + 1);
; 973  : 			}
; 974  : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z$0:

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);

	mov	r8, QWORD PTR _Constructed_last$[rbp]
	mov	rdx, QWORD PTR _Constructed_first$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z ; std::vector<TileRow,std::allocator<TileRow> >::_Destroy

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR $T4[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?deallocate@?$allocator@VTileRow@@@std@@QEAAXQEAVTileRow@@_K@Z ; std::allocator<TileRow>::deallocate

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);
; 977  : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$2@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>'::`1'::catch$2
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_Constructed_last$ = 40
$T1 = 48
$T2 = 56
_First$3 = 128
this$ = 128
$T4 = 136
_Whereptr$ = 136
<_Val_0>$ = 144
_Newcapacity$ = 152
?dtor$1@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>'::`1'::dtor$1
	mov	rcx, QWORD PTR _First$3[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_Constructed_last$ = 40
$T1 = 48
$T2 = 56
_First$3 = 128
this$ = 128
$T4 = 136
_Whereptr$ = 136
<_Val_0>$ = 144
_Newcapacity$ = 152
?dtor$0@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_Constructed_last$ = 40
$T1 = 48
$T2 = 56
_First$3 = 128
this$ = 128
$T4 = 136
_Whereptr$ = 136
<_Val_0>$ = 144
_Newcapacity$ = 152
?catch$2@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>'::`1'::catch$2

; 974  : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z$0:

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);

	mov	r8, QWORD PTR _Constructed_last$[rbp]
	mov	rdx, QWORD PTR _Constructed_first$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z ; std::vector<TileRow,std::allocator<TileRow> >::_Destroy

; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR $T4[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	call	?deallocate@?$allocator@VTileRow@@@std@@QEAAXQEAVTileRow@@_K@Z ; std::allocator<TileRow>::deallocate

; 977  : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$2@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>'::`1'::catch$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_Constructed_last$ = 40
$T1 = 48
$T2 = 56
_First$3 = 128
this$ = 128
$T4 = 136
_Whereptr$ = 136
<_Val_0>$ = 144
_Newcapacity$ = 152
?dtor$1@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>'::`1'::dtor$1
	mov	rcx, QWORD PTR _First$3[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$1@?0???$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 64
$T2 = 72
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const &>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

$LN12:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	mov	r9, rdx

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	QWORD PTR $T2[rsp], rdx
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [rdx+4], eax
	lea	rdx, QWORD PTR [r8+8]
	lea	rcx, QWORD PTR [r9+8]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const &>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__formal$ = 64
$T2 = 72
_Ptr$ = 72
<_Args_0>$ = 80
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__formal$ = 64
$T2 = 72
_Ptr$ = 72
<_Args_0>$ = 80
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$construct@VTileRow@@AEBV1@@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SAXAEAV?$allocator@VTileRow@@@1@QEAVTileRow@@AEBV3@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<TileRow> >::construct<TileRow,TileRow const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@VTileRow@@@std@@YAPEAVTileRow@@PEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@VTileRow@@@std@@YAPEAVTileRow@@PEAV1@@Z PROC ; std::_Unfancy<TileRow>, COMDAT

; 346  : 	return (_Ptr);

	mov	rax, rcx

; 347  : 	}

	ret	0
??$_Unfancy@VTileRow@@@std@@YAPEAVTileRow@@PEAV1@@Z ENDP ; std::_Unfancy<TileRow>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
this$ = 64
<_Val_0>$ = 72
??$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Emplace_back_with_unused_capacity<TileRow const &>, COMDAT

; 900  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

$LN54:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR $T2[rsp], rcx
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	add	rdx, 8
	add	rcx, 8
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	QWORD PTR [rbx+8], 32			; 00000020H

; 906  : #if _HAS_CXX17
; 907  : 		return (_Result);
; 908  : #else /* ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv */
; 909  : 		(void)_Result;
; 910  : #endif /* _HAS_CXX17 */
; 911  : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Emplace_back_with_unused_capacity<TileRow const &>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
this$ = 64
<_Val_0>$ = 72
?dtor$0@?0???$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_back_with_unused_capacity<TileRow const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_back_with_unused_capacity<TileRow const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
this$ = 64
<_Val_0>$ = 72
?dtor$0@?0???$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_back_with_unused_capacity<TileRow const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$_Emplace_back_with_unused_capacity@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Emplace_back_with_unused_capacity<TileRow const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@AEBVTileRow@@@std@@YAAEBVTileRow@@AEBV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBVTileRow@@@std@@YAAEBVTileRow@@AEBV1@@Z PROC ; std::forward<TileRow const &>, COMDAT

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1575 : 	}

	ret	0
??$forward@AEBVTileRow@@@std@@YAAEBVTileRow@@AEBV1@@Z ENDP ; std::forward<TileRow const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
this$ = 64
<_Val_0>$ = 72
??$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::emplace_back<TileRow const &>, COMDAT

; 916  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

$LN81:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	r9, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], r9

; 917  : 		if (_Has_unused_capacity())

	je	SHORT $LN2@emplace_ba
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	QWORD PTR $T2[rsp], r9
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r9], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [r9+4], eax
	add	rdx, 8
	lea	rcx, QWORD PTR [r9+8]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	QWORD PTR [rbx+8], 32			; 00000020H

; 923  : #if _HAS_CXX17
; 924  : 		return (_Result);
; 925  : #else /* ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv */
; 926  : 		(void)_Result;
; 927  : #endif /* _HAS_CXX17 */
; 928  : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN2@emplace_ba:

; 918  : 			{
; 919  : 			return (_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...));
; 920  : 			}
; 921  : 
; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, r9

; 923  : #if _HAS_CXX17
; 924  : 		return (_Result);
; 925  : #else /* ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv */
; 926  : 		(void)_Result;
; 927  : #endif /* _HAS_CXX17 */
; 928  : 		}

	add	rsp, 48					; 00000030H
	pop	rbx

; 918  : 			{
; 919  : 			return (_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...));
; 920  : 			}
; 921  : 
; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z ; std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>
??$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::emplace_back<TileRow const &>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
this$ = 64
<_Val_0>$ = 72
?dtor$0@?0???$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::emplace_back<TileRow const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::emplace_back<TileRow const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
this$ = 64
<_Val_0>$ = 72
?dtor$0@?0???$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::emplace_back<TileRow const &>'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???$emplace_back@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::emplace_back<TileRow const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z
_TEXT	SEGMENT
_Constructed_first$ = 32
_First$1 = 40
_First$2 = 48
_First$3 = 56
_First$4 = 64
_First$5 = 72
_First$6 = 80
_Newsize$1$ = 88
_Constructed_last$ = 96
_Newvec$ = 104
_Al$ = 112
_Backout$7 = 120
_Backout$8 = 144
_Backout$9 = 168
$T10 = 192
this$ = 272
_My_data_mem$1$ = 280
_Whereptr$ = 280
<_Val_0>$ = 288
_Newcapacity$ = 296
??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 942  : 		{	// reallocate and insert by perfectly forwarding _Val at _Whereptr

$LN690:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 208				; 000000d0H
	mov	QWORD PTR $T10[rsp], -2
	mov	r14, r8
	mov	rsi, rdx
	mov	r15, rcx

; 943  : 			// pre: !_Has_unused_capacity()
; 944  : 		const size_type _Whereoff = static_cast<size_type>(_Whereptr - this->_Myfirst());

	mov	rdx, QWORD PTR [rcx]
	mov	rdi, rsi
	sub	rdi, rdx

; 945  : 		_Alty& _Al = this->_Getal();

	mov	QWORD PTR _Al$[rsp], rcx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, rdx
	sar	rax, 5

; 946  : 		const size_type _Oldsize = size();
; 947  : 
; 948  : 		if (_Oldsize == max_size())

	mov	r9, 576460752303423487			; 07ffffffffffffffH
	cmp	rax, r9
	je	$LN689@Emplace_re

; 951  : 			}
; 952  : 
; 953  : 		const size_type _Newsize = _Oldsize + 1;

	lea	r8, QWORD PTR [rax+1]
	mov	QWORD PTR _Newsize$1$[rsp], r8

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	sar	rcx, 5

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	rdx, rcx
	shr	rdx, 1
	mov	rax, r9
	sub	rax, rdx
	cmp	rcx, rax
	jbe	SHORT $LN48@Emplace_re

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

	mov	r12, r8
	jmp	SHORT $LN685@Emplace_re
$LN48@Emplace_re:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	r12, QWORD PTR [rdx+rcx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

	cmp	r12, r8
	cmovb	r12, r8
$LN685@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 25   : 	size_t _Result = _Count * _Ty_size;

	mov	QWORD PTR _Newcapacity$[rsp], r12
	mov	rax, r12
	shl	rax, 5

; 26   : 	if (_Max_possible < _Count)

	cmp	r12, r9
	jbe	SHORT $LN80@Emplace_re

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

	mov	rdx, -1
	mov	rax, rdx

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

	jmp	SHORT $LN683@Emplace_re
$LN80@Emplace_re:
	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN83@Emplace_re
	mov	rdx, -1
$LN683@Emplace_re:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 94   : 	if (_Block_size <= _Bytes)

	cmp	rcx, rax
	cmovbe	rcx, rdx

; 52   : 		return (::operator new(_Bytes));

	call	??2@YAPEAX_K@Z				; operator new

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN92@Emplace_re

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

	lea	r13, QWORD PTR [rax+39]
	and	r13, -32				; ffffffffffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [r13-8], rax

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	xor	ebx, ebx
	jmp	SHORT $LN82@Emplace_re
$LN92@Emplace_re:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN83@Emplace_re:

; 188  : 	if (_Bytes != 0)

	test	rax, rax
	je	SHORT $LN84@Emplace_re

; 52   : 		return (::operator new(_Bytes));

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	r13, rax

; 190  : 		return (_Traits::_Allocate(_Bytes));

	xor	ebx, ebx
	jmp	SHORT $LN82@Emplace_re
$LN84@Emplace_re:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

	xor	ebx, ebx
	mov	r13d, ebx
$LN82@Emplace_re:

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

	mov	QWORD PTR _Newvec$[rsp], r13
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 957  : 		const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	and	rdi, -32				; ffffffffffffffe0H
	lea	rdx, QWORD PTR [rdi+r13]
	mov	QWORD PTR _My_data_mem$1$[rsp], rdx
	lea	rax, QWORD PTR [rdx+32]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 958  : 		pointer _Constructed_first = _Constructed_last;

	mov	QWORD PTR _Constructed_first$[rsp], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	mov	QWORD PTR [rdx+16], rbx

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rdx+24], rbx

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [r14]
	vmovups	YMMWORD PTR [rdx], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [r14+16], rbx

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [r14+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [r14], bx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 962  : 		_Constructed_first = _Newvec + _Whereoff;

	mov	QWORD PTR _Constructed_first$[rsp], rdx

; 963  : 
; 964  : 		if (_Whereptr == this->_Mylast())

	mov	rcx, QWORD PTR [r15+8]
	mov	rax, QWORD PTR [r15]
	mov	rdi, r13
	cmp	rsi, rcx
	jne	$LN4@Emplace_re
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

	mov	QWORD PTR _First$1[rsp], rax

; 147  : 		: _First(_Dest),

	mov	QWORD PTR _Backout$7[rsp], r13

; 148  : 		_Last(_Dest),

	mov	QWORD PTR _Backout$7[rsp+8], r13

; 149  : 		_Al(_Al_)

	mov	QWORD PTR _Backout$7[rsp+16], r15
$LL201@Emplace_re:

; 230  : 	for (; _First != _Last; ++_First)

	cmp	rax, rcx
	je	SHORT $LN200@Emplace_re
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	mov	QWORD PTR [rdi+16], rbx

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rdi+24], rbx

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rax]
	vmovups	YMMWORD PTR [rdi], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rbx

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rax], bx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

	add	rdi, 32					; 00000020H
	mov	QWORD PTR _Backout$7[rsp+8], rdi

; 230  : 	for (; _First != _Last; ++_First)

	add	rax, 32					; 00000020H
	mov	QWORD PTR _First$1[rsp], rax
	jmp	SHORT $LL201@Emplace_re
$LN200@Emplace_re:

; 170  : 		_First = _Last;

	mov	QWORD PTR _Backout$7[rsp], rdi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	mov	rbx, rdi
$LN686@Emplace_re:

; 1134 : 	for (; _First != _Last; ++_First)

	mov	QWORD PTR _First$2[rsp], rbx
	cmp	rbx, rdi
	je	SHORT $LN270@Emplace_re
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	vzeroupper
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	jmp	SHORT $LN686@Emplace_re
$LN270@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 968  : 		else

	mov	r14, QWORD PTR _My_data_mem$1$[rsp]
	jmp	$LN5@Emplace_re
$LN4@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

	mov	QWORD PTR _First$3[rsp], rax

; 147  : 		: _First(_Dest),

	mov	QWORD PTR _Backout$8[rsp], r13

; 148  : 		_Last(_Dest),

	mov	QWORD PTR _Backout$8[rsp+8], r13

; 149  : 		_Al(_Al_)

	mov	QWORD PTR _Backout$8[rsp+16], r15
	npad	1
$LL323@Emplace_re:

; 230  : 	for (; _First != _Last; ++_First)

	cmp	rax, rsi
	je	SHORT $LN322@Emplace_re
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	mov	QWORD PTR [rdi+16], rbx

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rdi+24], rbx

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rax]
	vmovups	YMMWORD PTR [rdi], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [rax+16], rbx

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rax], bx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

	add	rdi, 32					; 00000020H
	mov	QWORD PTR _Backout$8[rsp+8], rdi

; 230  : 	for (; _First != _Last; ++_First)

	add	rax, 32					; 00000020H
	mov	QWORD PTR _First$3[rsp], rax
	jmp	SHORT $LL323@Emplace_re
$LN322@Emplace_re:

; 170  : 		_First = _Last;

	mov	QWORD PTR _Backout$8[rsp], rdi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	mov	r14, rdi
	mov	QWORD PTR _First$4[rsp], rdi
	npad	5
$LL393@Emplace_re:

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	r14, rdi
	je	SHORT $LN392@Emplace_re
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, r14
	vzeroupper
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	r14, 32					; 00000020H
	mov	QWORD PTR _First$4[rsp], r14
	jmp	SHORT $LL393@Emplace_re
$LN392@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 971  : 			_Constructed_first = _Newvec;

	mov	QWORD PTR _Constructed_first$[rsp], r13

; 972  : 			_Umove(_Whereptr, this->_Mylast(), _Newvec + _Whereoff + 1);

	mov	rax, QWORD PTR [r15+8]
	mov	r14, QWORD PTR _My_data_mem$1$[rsp]
	lea	rdi, QWORD PTR [r14+32]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

	mov	QWORD PTR _First$5[rsp], rsi

; 147  : 		: _First(_Dest),

	mov	QWORD PTR _Backout$9[rsp], rdi

; 148  : 		_Last(_Dest),

	mov	QWORD PTR _Backout$9[rsp+8], rdi

; 149  : 		_Al(_Al_)

	mov	QWORD PTR _Backout$9[rsp+16], r15
	npad	3
$LL445@Emplace_re:

; 230  : 	for (; _First != _Last; ++_First)

	cmp	rsi, rax
	je	SHORT $LN444@Emplace_re
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	mov	QWORD PTR [rdi+16], rbx

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rdi+24], rbx

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rsi]
	vmovups	YMMWORD PTR [rdi], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [rsi+16], rbx

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rsi+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rsi], bx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

	add	rdi, 32					; 00000020H
	mov	QWORD PTR _Backout$9[rsp+8], rdi

; 230  : 	for (; _First != _Last; ++_First)

	add	rsi, 32					; 00000020H
	mov	QWORD PTR _First$5[rsp], rsi
	jmp	SHORT $LL445@Emplace_re
$LN444@Emplace_re:

; 170  : 		_First = _Last;

	mov	QWORD PTR _Backout$9[rsp], rdi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	mov	rbx, rdi
$LN687@Emplace_re:

; 1134 : 	for (; _First != _Last; ++_First)

	mov	QWORD PTR _First$6[rsp], rbx
	cmp	rbx, rdi
	je	SHORT $LN514@Emplace_re
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	vzeroupper
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	jmp	SHORT $LN687@Emplace_re
$LN514@Emplace_re:
$LN5@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1898 : 		if (this->_Myfirst() != pointer())

	mov	rbx, QWORD PTR [r15]
	test	rbx, rbx
	je	SHORT $LN634@Emplace_re

; 1899 : 			{	// destroy and deallocate old array
; 1900 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	rdi, QWORD PTR [r15+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rbx, rdi
	je	SHORT $LN575@Emplace_re
$LL576@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	vzeroupper
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL576@Emplace_re
	mov	rbx, QWORD PTR [r15]
$LN575@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rdx, QWORD PTR [r15+16]
	sub	rdx, rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN633@Emplace_re

; 115  : 	_Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rbx-8]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rcx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, 31
	ja	SHORT $LN630@Emplace_re

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rbx, rcx
$LN633@Emplace_re:

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	vzeroupper
	call	??3@YAXPEAX_K@Z				; operator delete
$LN634@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

	mov	QWORD PTR [r15], r13

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

	mov	rax, QWORD PTR _Newsize$1$[rsp]
	shl	rax, 5
	add	rax, r13
	mov	QWORD PTR [r15+8], rax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

	shl	r12, 5
	add	r12, r13
	mov	QWORD PTR [r15+16], r12

; 973  : 			}
; 974  : 		_CATCH_ALL
; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);
; 977  : 		_RERAISE;
; 978  : 		_CATCH_END
; 979  : 
; 980  : 		_Change_array(_Newvec, _Newsize, _Newcapacity);
; 981  : 		return (this->_Myfirst() + _Whereoff);

	mov	rax, r14
	vzeroupper

; 982  : 		}

	add	rsp, 208				; 000000d0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN630@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	vzeroupper
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN689@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 950  : 			_Xlength();

	call	?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlength
	int	3
$LN684@Emplace_re:
??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_First$1 = 40
_First$2 = 48
_First$3 = 56
_First$4 = 64
_First$5 = 72
_First$6 = 80
_Newsize$1$ = 88
_Constructed_last$ = 96
_Newvec$ = 104
_Al$ = 112
_Backout$7 = 120
_Backout$8 = 144
_Backout$9 = 168
$T10 = 192
this$ = 272
_My_data_mem$1$ = 280
_Whereptr$ = 280
<_Val_0>$ = 288
_Newcapacity$ = 296
?dtor$0@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$7[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$0@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_First$1 = 40
_First$2 = 48
_First$3 = 56
_First$4 = 64
_First$5 = 72
_First$6 = 80
_Newsize$1$ = 88
_Constructed_last$ = 96
_Newvec$ = 104
_Al$ = 112
_Backout$7 = 120
_Backout$8 = 144
_Backout$9 = 168
$T10 = 192
this$ = 272
_My_data_mem$1$ = 280
_Whereptr$ = 280
<_Val_0>$ = 288
_Newcapacity$ = 296
?dtor$1@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$8[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$1@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_First$1 = 40
_First$2 = 48
_First$3 = 56
_First$4 = 64
_First$5 = 72
_First$6 = 80
_Newsize$1$ = 88
_Constructed_last$ = 96
_Newvec$ = 104
_Al$ = 112
_Backout$7 = 120
_Backout$8 = 144
_Backout$9 = 168
$T10 = 192
this$ = 272
_My_data_mem$1$ = 280
_Whereptr$ = 280
<_Val_0>$ = 288
_Newcapacity$ = 296
?dtor$2@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::dtor$2
	lea	rcx, QWORD PTR _Backout$9[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$2@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::dtor$2
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_First$1 = 40
_First$2 = 48
_First$3 = 56
_First$4 = 64
_First$5 = 72
_First$6 = 80
_Newsize$1$ = 88
_Constructed_last$ = 96
_Newvec$ = 104
_Al$ = 112
_Backout$7 = 120
_Backout$8 = 144
_Backout$9 = 168
$T10 = 192
this$ = 272
_My_data_mem$1$ = 280
_Whereptr$ = 280
<_Val_0>$ = 288
_Newcapacity$ = 296
?catch$3@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::catch$3

; 973  : 			}
; 974  : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z$0:

; 973  : 			}
; 974  : 		_CATCH_ALL
; 975  : 		_Destroy(_Constructed_first, _Constructed_last);

	mov	r8, QWORD PTR _Constructed_last$[rbp]
	mov	rdx, QWORD PTR _Constructed_first$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	vzeroupper
	call	?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Destroy

; 973  : 			}
; 974  : 		_CATCH_ALL
; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate

; 973  : 			}
; 974  : 		_CATCH_ALL
; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);
; 977  : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$3@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::catch$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_First$1 = 40
_First$2 = 48
_First$3 = 56
_First$4 = 64
_First$5 = 72
_First$6 = 80
_Newsize$1$ = 88
_Constructed_last$ = 96
_Newvec$ = 104
_Al$ = 112
_Backout$7 = 120
_Backout$8 = 144
_Backout$9 = 168
$T10 = 192
this$ = 272
_My_data_mem$1$ = 280
_Whereptr$ = 280
<_Val_0>$ = 288
_Newcapacity$ = 296
?dtor$0@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$7[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$0@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_First$1 = 40
_First$2 = 48
_First$3 = 56
_First$4 = 64
_First$5 = 72
_First$6 = 80
_Newsize$1$ = 88
_Constructed_last$ = 96
_Newvec$ = 104
_Al$ = 112
_Backout$7 = 120
_Backout$8 = 144
_Backout$9 = 168
$T10 = 192
this$ = 272
_My_data_mem$1$ = 280
_Whereptr$ = 280
<_Val_0>$ = 288
_Newcapacity$ = 296
?dtor$1@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Backout$8[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$1@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_First$1 = 40
_First$2 = 48
_First$3 = 56
_First$4 = 64
_First$5 = 72
_First$6 = 80
_Newsize$1$ = 88
_Constructed_last$ = 96
_Newvec$ = 104
_Al$ = 112
_Backout$7 = 120
_Backout$8 = 144
_Backout$9 = 168
$T10 = 192
this$ = 272
_My_data_mem$1$ = 280
_Whereptr$ = 280
<_Val_0>$ = 288
_Newcapacity$ = 296
?dtor$2@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::dtor$2
	lea	rcx, QWORD PTR _Backout$9[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$2@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
_Constructed_first$ = 32
_First$1 = 40
_First$2 = 48
_First$3 = 56
_First$4 = 64
_First$5 = 72
_First$6 = 80
_Newsize$1$ = 88
_Constructed_last$ = 96
_Newvec$ = 104
_Al$ = 112
_Backout$7 = 120
_Backout$8 = 144
_Backout$9 = 168
$T10 = 192
this$ = 272
_My_data_mem$1$ = 280
_Whereptr$ = 280
<_Val_0>$ = 288
_Newcapacity$ = 296
?catch$3@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::catch$3

; 974  : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z$0:

; 975  : 		_Destroy(_Constructed_first, _Constructed_last);

	mov	r8, QWORD PTR _Constructed_last$[rbp]
	mov	rdx, QWORD PTR _Constructed_first$[rbp]
	mov	rcx, QWORD PTR this$[rbp]
	vzeroupper
	call	?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Destroy

; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate

; 977  : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$3@?0???$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >'::`1'::catch$3
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QEAV31@@Z
_TEXT	SEGMENT
__formal$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rdx+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rdx+24], rax

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [r8]
	vmovups	YMMWORD PTR [rdx], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [r8+16], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [r8+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [r8], ax
	vzeroupper
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 882  : 		}

	ret	0
??$construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SAXAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@$$QEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@@Z PROC ; std::_Unfancy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 346  : 	return (_Ptr);

	mov	rax, rcx

; 347  : 	}

	ret	0
??$_Unfancy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PEAV10@@Z ENDP ; std::_Unfancy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_back_with_unused_capacity<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	xor	r8d, r8d
	mov	QWORD PTR [rax+16], r8

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rax+24], r8

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [rax], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], r8

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rdx], r8w
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	QWORD PTR [rcx+8], 32			; 00000020H
	vzeroupper

; 906  : #if _HAS_CXX17
; 907  : 		return (_Result);
; 908  : #else /* ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv */
; 909  : 		(void)_Result;
; 910  : #endif /* _HAS_CXX17 */
; 911  : 		}

	ret	0
??$_Emplace_back_with_unused_capacity@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_back_with_unused_capacity<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z PROC ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1575 : 	}

	ret	0
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ENDP ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::emplace_back<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 916  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

$LN120:
	sub	rsp, 40					; 00000028H
	mov	r8, rdx

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	rdx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], rdx

; 917  : 		if (_Has_unused_capacity())

	je	SHORT $LN2@emplace_ba
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rdx+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rdx+24], rax

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [r8]
	vmovups	YMMWORD PTR [rdx], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [r8+16], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [r8+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [r8], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	QWORD PTR [rcx+8], 32			; 00000020H
	vzeroupper

; 923  : #if _HAS_CXX17
; 924  : 		return (_Result);
; 925  : #else /* ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv */
; 926  : 		(void)_Result;
; 927  : #endif /* _HAS_CXX17 */
; 928  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN2@emplace_ba:

; 918  : 			{
; 919  : 			return (_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...));
; 920  : 			}
; 921  : 
; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	call	??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
	vzeroupper

; 923  : #if _HAS_CXX17
; 924  : 		return (_Result);
; 925  : #else /* ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv */
; 926  : 		(void)_Result;
; 927  : #endif /* _HAS_CXX17 */
; 928  : 		}

	add	rsp, 40					; 00000028H
	ret	0
??$emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::emplace_back<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z PROC ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>, COMDAT

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

	mov	rax, rcx

; 1590 : 	}

	ret	0
??$move@AEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
;	COMDAT ??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
this$ = 64
this$ = 64
??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor', COMDAT
$LN22:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	lea	rbx, QWORD PTR [rcx+152]
	mov	QWORD PTR this$[rsp], rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 711  : 		{	// destroy the object

	mov	rax, QWORD PTR [rbx-152]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR [rcx+rbx-152], rax
	mov	rax, QWORD PTR [rbx-152]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-152]
	mov	DWORD PTR [rcx+rbx-156], edx

; 712  : 		}

	lea	rcx, QWORD PTR [rbx-128]
	call	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR [rbx-120]
	call	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
	npad	1
	mov	QWORD PTR this$[rsp], rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios

; 38   : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
	mov	QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase

; 533  : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7ios_base@std@@6B@
	mov	QWORD PTR [rbx], rax

; 534  : 		_Ios_base_dtor(this);

	mov	rcx, rbx
	call	QWORD PTR __imp_?_Ios_base_dtor@ios_base@std@@CAXPEAV12@@Z
	npad	1
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor'
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 64
this$ = 64
?dtor$0@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 64
this$ = 64
?dtor$1@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 64
this$ = 64
?dtor$4@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$4
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$4@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 64
this$ = 64
?dtor$0@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 64
this$ = 64
?dtor$1@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
this$ = 64
this$ = 64
?dtor$4@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$4
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$4@?0???_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`vbase destructor''::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor', COMDAT
$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	lea	rdi, QWORD PTR [rcx-152]
	mov	ebx, edx
	mov	rcx, rdi
	call	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
	test	bl, 1
	je	SHORT $LN4@scalar
	mov	edx, 248				; 000000f8H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_G?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor', COMDAT
$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	rdi, rcx
	call	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	test	bl, 1
	je	SHORT $LN4@scalar
	mov	edx, 120				; 00000078H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_G?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAHH@Z
_TEXT	SEGMENT
_Mode$ = 8
?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAHH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getstate, COMDAT

; 425  : 		int _State = 0;
; 426  : 		if (!(_Mode & ios_base::in))
; 427  : 			{
; 428  : 			_State |= _Noread;
; 429  : 			}
; 430  : 
; 431  : 		if (!(_Mode & ios_base::out))

	mov	eax, ecx
	mov	edx, ecx
	mov	r9d, ecx
	not	edx
	and	edx, 1
	shl	edx, 2

; 432  : 			{
; 433  : 			_State |= _Constant;
; 434  : 			}
; 435  : 
; 436  : 		if (_Mode & ios_base::app)

	mov	r8d, edx
	or	r8d, 2
	and	al, 2
	mov	eax, ecx
	cmovne	r8d, edx

; 437  : 			{
; 438  : 			_State |= _Append;
; 439  : 			}
; 440  : 
; 441  : 		if (_Mode & ios_base::ate)

	mov	ecx, r8d
	or	ecx, 8
	and	al, 8
	cmove	ecx, r8d

; 442  : 			{
; 443  : 			_State |= _Atend;
; 444  : 			}
; 445  : 
; 446  : 		return (_State);

	mov	eax, ecx
	or	eax, 16
	and	r9b, 4
	cmove	eax, ecx

; 447  : 		}

	ret	0
?_Getstate@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAHH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy, COMDAT

; 401  : 		{	// discard any allocated buffer and clear pointers

$LN45:
	push	rbx
	sub	rsp, 32					; 00000020H

; 402  : 		if (_Mystate & _Allocated)

	test	BYTE PTR [rcx+112], 1
	mov	rbx, rcx
	je	SHORT $LN35@Tidy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 235  : 		return (*_IPnext);

	mov	rax, QWORD PTR [rcx+64]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 404  : 			_Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN4@Tidy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 258  : 		return (*_IPnext + *_IPcount);

	mov	rax, QWORD PTR [rbx+88]
	movsxd	rdx, DWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 404  : 			_Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

	jmp	SHORT $LN43@Tidy
$LN4@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 240  : 		return (*_IGnext + *_IGcount);

	mov	rax, QWORD PTR [rbx+80]
	movsxd	rdx, DWORD PTR [rax]
	mov	rax, QWORD PTR [rbx+56]
	mov	rcx, QWORD PTR [rax]
$LN43@Tidy:

; 220  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [rbx+24]
	lea	rdx, QWORD PTR [rcx+rdx*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 404  : 			_Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

	mov	rcx, QWORD PTR [rax]
	sub	rdx, rcx
	sar	rdx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	add	rdx, rdx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN34@Tidy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN31@Tidy

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, r8
$LN34@Tidy:

; 207  : 	::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN35@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 251  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR [rbx+24]
	xor	ecx, ecx
	mov	QWORD PTR [rax], rcx

; 252  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], rcx

; 253  : 		*_IGcount = (int)(_Last - _Next);

	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], ecx

; 292  : 		*_IPfirst = _First;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rax], rcx

; 293  : 		*_IPnext = _First;

	mov	rax, QWORD PTR [rbx+64]
	mov	QWORD PTR [rax], rcx

; 294  : 		*_IPcount = (int)(_Last - _First);

	mov	rax, QWORD PTR [rbx+88]
	mov	DWORD PTR [rax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 412  : 		_Mystate &= ~_Allocated;

	and	DWORD PTR [rbx+112], -2
	mov	QWORD PTR [rbx+104], rcx

; 413  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN31@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN42@Tidy:
?_Tidy@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXXZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
_Count$ = 80
_State$ = 88
?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init, COMDAT

; 361  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state

$LN26:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	esi, r9d
	mov	r14, r8
	mov	r15, rdx
	mov	rdi, rcx

; 362  : 		if (_Count > INT_MAX)

	cmp	r8, 2147483647				; 7fffffffH
	ja	$LN25@Init

; 365  : 			}
; 366  : 
; 367  : 		if (_Count != 0 && (_State & (_Noread | _Constant)) != (_Noread | _Constant))

	test	r8, r8
	je	$LN3@Init
	mov	eax, r9d
	and	eax, 6
	cmp	al, 6
	je	$LN3@Init

; 369  : 			const auto _Pnew = _Unfancy(_Al.allocate(_Count));

	mov	QWORD PTR [rsp+64], rbx
	add	rcx, 116				; 00000074H
	mov	rdx, r8
	mov	QWORD PTR [rsp+72], rbp
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	rbx, QWORD PTR [r14+r14]
	mov	rdx, r15
	mov	r8, rbx
	mov	rcx, rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 369  : 			const auto _Pnew = _Unfancy(_Al.allocate(_Count));

	mov	rbp, rax
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	call	memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 371  : 			_Seekhigh = _Pnew + _Count;

	lea	rcx, QWORD PTR [rbx+rbp]

; 372  : 
; 373  : 			if (!(_State & _Noread))

	mov	r8d, esi
	mov	rbx, QWORD PTR [rsp+64]
	mov	QWORD PTR [rdi+104], rcx
	and	r8d, 4
	jne	SHORT $LN5@Init
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 251  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR [rdi+24]
	mov	QWORD PTR [rax], rbp

; 252  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rdi+56]
	mov	QWORD PTR [rax], rbp

; 253  : 		*_IGcount = (int)(_Last - _Next);

	mov	rax, QWORD PTR [rdi+80]
	mov	DWORD PTR [rax], r14d
$LN5@Init:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 378  : 			if (!(_State & _Constant))

	test	sil, 2
	jne	SHORT $LN7@Init

; 380  : 				_Mysb::setp(_Pnew,

	mov	rdx, QWORD PTR [rdi+104]
	test	sil, 24
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 299  : 		*_IPfirst = _First;

	mov	rax, QWORD PTR [rdi+32]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 380  : 				_Mysb::setp(_Pnew,

	mov	rcx, rbp
	cmovne	rcx, rdx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 301  : 		*_IPcount = (int)(_Last - _Next);

	sub	rdx, rcx
	sar	rdx, 1
	mov	QWORD PTR [rax], rbp
	mov	rax, QWORD PTR [rdi+64]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR [rdi+88]
	mov	DWORD PTR [rax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 384  : 				if (_State & _Noread)

	test	r8d, r8d
	je	SHORT $LN7@Init
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 251  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR [rdi+24]
	mov	QWORD PTR [rax], rbp

; 252  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rdi+56]

; 253  : 		*_IGcount = (int)(_Last - _Next);

	sar	rbp, 1
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR [rdi+80]
	mov	DWORD PTR [rax], ebp
$LN7@Init:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 390  : 			_State |= _Allocated;

	mov	rbp, QWORD PTR [rsp+72]
	or	esi, 1

; 391  : 			}
; 392  : 		else
; 393  : 			{
; 394  : 			_Seekhigh = nullptr;
; 395  : 			}
; 396  : 
; 397  : 		_Mystate = _State;

	mov	DWORD PTR [rdi+112], esi

; 398  : 		}

	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN3@Init:

; 391  : 			}
; 392  : 		else
; 393  : 			{
; 394  : 			_Seekhigh = nullptr;
; 395  : 			}
; 396  : 
; 397  : 		_Mystate = _State;

	mov	DWORD PTR [rdi+112], esi

; 398  : 		}

	mov	rsi, QWORD PTR [rsp+80]
	mov	QWORD PTR [rcx+104], 0
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN25@Init:

; 363  : 			{	// TRANSITION, VSO#485517
; 364  : 			_Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
	int	3
$LN23@Init:
?_Init@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAXPEB_W_KH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
this$ = 16
__$ReturnUdt$ = 24
_Pos$ = 32
_Mode$ = 40
?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos, COMDAT

; 323  : 		{	// change position to _Pos, according to _Mode

$LN32:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	r14
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 55   : 		return (_Myoff + _Fpos);

	mov	rbx, QWORD PTR [r8+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 323  : 		{	// change position to _Pos, according to _Mode

	mov	r11, rcx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 225  : 		return (*_IGnext);

	mov	r14, QWORD PTR [rcx+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 323  : 		{	// change position to _Pos, according to _Mode

	mov	r10, rdx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 55   : 		return (_Myoff + _Fpos);

	add	rbx, QWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 235  : 		return (*_IPnext);

	mov	rax, QWORD PTR [rcx+64]

; 225  : 		return (*_IGnext);

	mov	r8, QWORD PTR [r14]

; 235  : 		return (*_IPnext);

	mov	rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 327  : 		if (_Pptr_old != nullptr && _Seekhigh < _Pptr_old)

	test	rcx, rcx
	je	SHORT $LN2@seekpos
	cmp	QWORD PTR [r11+104], rcx
	jae	SHORT $LN2@seekpos

; 328  : 			{	// update high-water pointer
; 329  : 			_Seekhigh = _Pptr_old;

	mov	QWORD PTR [r11+104], rcx
$LN2@seekpos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [r11+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 333  : 		const auto _Seekdist = _Seekhigh - _Seeklow;

	mov	rdx, QWORD PTR [r11+104]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	rsi, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 333  : 		const auto _Seekdist = _Seekhigh - _Seeklow;

	mov	rax, rdx
	sub	rax, rsi
	sar	rax, 1

; 334  : 		if (static_cast<unsigned long long>(_Off) > static_cast<unsigned long long>(_Seekdist))

	cmp	rbx, rax
	jbe	SHORT $LN3@seekpos
$LN5@seekpos:

; 358  : 		}

	mov	QWORD PTR [r10], -1
	jmp	SHORT $LN30@seekpos
$LN3@seekpos:

; 335  : 			{
; 336  : 			return (pos_type(off_type(-1)));
; 337  : 			}
; 338  : 
; 339  : 		if (_Off != 0
; 340  : 			&& (((_Mode & ios_base::in) && _Gptr_old == nullptr)

	test	rbx, rbx
	je	SHORT $LN4@seekpos
	test	r9b, 1
	je	SHORT $LN6@seekpos
	test	r8, r8
	je	SHORT $LN5@seekpos
$LN6@seekpos:
	test	r9b, 2
	je	SHORT $LN4@seekpos
	test	rcx, rcx
	je	SHORT $LN5@seekpos
$LN4@seekpos:
	mov	QWORD PTR [rsp+16], rdi

; 341  : 				|| ((_Mode & ios_base::out) && _Pptr_old == nullptr)))
; 342  : 			{
; 343  : 			return (pos_type(off_type(-1)));
; 344  : 			}
; 345  : 
; 346  : 		const auto _Newptr = _Seeklow + _Off;	// may perform nullptr + 0

	lea	rdi, QWORD PTR [rsi+rbx*2]

; 347  : 		if ((_Mode & ios_base::in) && _Gptr_old != nullptr)

	test	r9b, 1
	je	SHORT $LN7@seekpos
	test	r8, r8
	je	SHORT $LN7@seekpos
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 252  : 		*_IGnext = _Next;

	mov	QWORD PTR [r14], rdi

; 253  : 		*_IGcount = (int)(_Last - _Next);

	sub	rdx, rdi
	mov	rax, QWORD PTR [r11+80]
	sar	rdx, 1
	mov	DWORD PTR [rax], edx
$LN7@seekpos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 352  : 		if ((_Mode & ios_base::out) && _Pptr_old != nullptr)

	test	r9b, 2
	je	SHORT $LN8@seekpos
	test	rcx, rcx
	je	SHORT $LN8@seekpos
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 258  : 		return (*_IPnext + *_IPcount);

	mov	rax, QWORD PTR [r11+88]
	movsxd	rdx, DWORD PTR [rax]
	mov	rax, QWORD PTR [r11+64]
	mov	rcx, QWORD PTR [rax]

; 299  : 		*_IPfirst = _First;

	mov	rax, QWORD PTR [r11+32]

; 258  : 		return (*_IPnext + *_IPcount);

	lea	r8, QWORD PTR [rcx+rdx*2]

; 299  : 		*_IPfirst = _First;

	mov	QWORD PTR [rax], rsi

; 300  : 		*_IPnext = _Next;
; 301  : 		*_IPcount = (int)(_Last - _Next);

	sub	r8, rdi
	mov	rax, QWORD PTR [r11+64]
	sar	r8, 1
	mov	QWORD PTR [rax], rdi
	mov	rax, QWORD PTR [r11+88]
	mov	DWORD PTR [rax], r8d
$LN8@seekpos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 357  : 		return (pos_type(_Off));

	mov	rdi, QWORD PTR [rsp+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 32   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

	mov	QWORD PTR [r10], rbx
$LN30@seekpos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 358  : 		}

	mov	rbx, QWORD PTR [rsp+24]
	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+32]
	mov	QWORD PTR [r10+8], 0
	mov	QWORD PTR [r10+16], rax
	mov	rax, r10
	pop	r14
	ret	0
?seekpos@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
this$ = 24
__$ReturnUdt$ = 32
_Off$ = 40
_Way$ = 48
_Mode$ = 56
?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff, COMDAT

; 249  : 		{	// change position by _Off, according to _Way, _Mode

$LN45:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	push	r15
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 225  : 		return (*_IGnext);

	mov	r15, QWORD PTR [rcx+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 249  : 		{	// change position by _Off, according to _Way, _Mode

	mov	r11, rcx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 235  : 		return (*_IPnext);

	mov	rax, QWORD PTR [rcx+64]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 249  : 		{	// change position by _Off, according to _Way, _Mode

	mov	ebx, r9d
	mov	rdi, r8
	mov	r10, rdx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 225  : 		return (*_IGnext);

	mov	rbp, QWORD PTR [r15]

; 235  : 		return (*_IPnext);

	mov	rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 252  : 		if (_Pptr_old != nullptr && _Seekhigh < _Pptr_old)

	test	rcx, rcx
	je	SHORT $LN4@seekoff
	cmp	QWORD PTR [r11+104], rcx
	jae	SHORT $LN4@seekoff

; 253  : 			{	// update high-water pointer
; 254  : 			_Seekhigh = _Pptr_old;

	mov	QWORD PTR [r11+104], rcx
$LN4@seekoff:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [r11+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 260  : 		switch (_Way)

	xor	r9d, r9d
	mov	r14, QWORD PTR [r11+104]
	mov	edx, DWORD PTR _Mode$[rsp]
	mov	r8, r14
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	rsi, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 258  : 		const auto _Seekdist = _Seekhigh - _Seeklow;

	sub	r8, rsi
	sar	r8, 1

; 260  : 		switch (_Way)

	test	ebx, ebx
	je	SHORT $LN5@seekoff
	sub	ebx, 1
	je	SHORT $LN7@seekoff
	cmp	ebx, 1
	jne	SHORT $LN13@seekoff

; 264  : 				break;
; 265  : 			case ios_base::end:
; 266  : 				_Newoff = _Seekdist;

	mov	rax, r8

; 267  : 				break;

	jmp	SHORT $LN2@seekoff
$LN7@seekoff:

; 268  : 			case ios_base::cur:
; 269  : 				{
; 270  : 				constexpr auto _Both = ios_base::in | ios_base::out;
; 271  : 				if ((_Mode & _Both) != _Both)

	mov	eax, edx
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN13@seekoff

; 272  : 					{	// prohibited by N4727 [stringbuf.virtuals] Table 107 "seekoff positioning"
; 273  : 					if (_Mode & ios_base::in)

	test	dl, 1
	je	SHORT $LN9@seekoff

; 274  : 						{
; 275  : 						if (_Gptr_old != nullptr || _Seeklow == nullptr)

	test	rbp, rbp
	jne	SHORT $LN12@seekoff
	test	rsi, rsi
	jne	SHORT $LN13@seekoff
$LN12@seekoff:

; 276  : 							{
; 277  : 							_Newoff = _Gptr_old - _Seeklow;

	mov	rax, rbp
	sub	rax, rsi
	sar	rax, 1

; 278  : 							break;

	jmp	SHORT $LN2@seekoff
$LN9@seekoff:

; 279  : 							}
; 280  : 						}
; 281  : 					else if ((_Mode & ios_base::out) && (_Pptr_old != nullptr || _Seeklow == nullptr))

	test	dl, 2
	je	SHORT $LN13@seekoff
	test	rcx, rcx
	jne	SHORT $LN14@seekoff
	test	rsi, rsi
	jne	SHORT $LN13@seekoff
$LN14@seekoff:

; 282  : 						{
; 283  : 						_Newoff = _Pptr_old - _Seeklow;

	mov	rax, rcx
	sub	rax, rsi
	sar	rax, 1

; 284  : 						break;

	jmp	SHORT $LN2@seekoff
$LN13@seekoff:

; 319  : 		}

	mov	QWORD PTR [r10], -1
	jmp	SHORT $LN43@seekoff
$LN5@seekoff:

; 261  : 			{
; 262  : 			case ios_base::beg:
; 263  : 				_Newoff = 0;

	mov	rax, r9
$LN2@seekoff:

; 285  : 						}
; 286  : 					}
; 287  : 				}
; 288  : 
; 289  : 				// fallthrough
; 290  : 			default:
; 291  : 				return (pos_type(off_type(-1)));
; 292  : 			}
; 293  : 
; 294  : 		if (static_cast<unsigned long long>(_Off) + _Newoff > static_cast<unsigned long long>(_Seekdist))

	lea	rbx, QWORD PTR [rax+rdi]
	cmp	rbx, r8
	ja	SHORT $LN13@seekoff

; 295  : 			{
; 296  : 			return (pos_type(off_type(-1)));
; 297  : 			}
; 298  : 
; 299  : 		_Off += _Newoff;
; 300  : 		if (_Off != 0
; 301  : 			&& (((_Mode & ios_base::in) && _Gptr_old == nullptr)

	test	rbx, rbx
	je	SHORT $LN17@seekoff
	test	dl, 1
	je	SHORT $LN19@seekoff
	test	rbp, rbp
	je	SHORT $LN13@seekoff
$LN19@seekoff:
	test	dl, 2
	je	SHORT $LN17@seekoff
	test	rcx, rcx
	je	SHORT $LN13@seekoff
$LN17@seekoff:

; 302  : 				|| ((_Mode & ios_base::out) && _Pptr_old == nullptr)))
; 303  : 			{
; 304  : 			return (pos_type(off_type(-1)));
; 305  : 			}
; 306  : 
; 307  : 		const auto _Newptr = _Seeklow + _Off;	// may perform nullptr + 0

	lea	rdi, QWORD PTR [rsi+rbx*2]

; 308  : 		if ((_Mode & ios_base::in) && _Gptr_old != nullptr)

	test	dl, 1
	je	SHORT $LN20@seekoff
	test	rbp, rbp
	je	SHORT $LN20@seekoff
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 252  : 		*_IGnext = _Next;

	mov	QWORD PTR [r15], rdi

; 253  : 		*_IGcount = (int)(_Last - _Next);

	sub	r14, rdi
	mov	rax, QWORD PTR [r11+80]
	sar	r14, 1
	mov	DWORD PTR [rax], r14d
$LN20@seekoff:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 313  : 		if ((_Mode & ios_base::out) && _Pptr_old != nullptr)

	test	dl, 2
	je	SHORT $LN21@seekoff
	test	rcx, rcx
	je	SHORT $LN21@seekoff
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 258  : 		return (*_IPnext + *_IPcount);

	mov	rax, QWORD PTR [r11+88]
	movsxd	rdx, DWORD PTR [rax]
	mov	rax, QWORD PTR [r11+64]
	mov	rcx, QWORD PTR [rax]

; 299  : 		*_IPfirst = _First;

	mov	rax, QWORD PTR [r11+32]

; 258  : 		return (*_IPnext + *_IPcount);

	lea	r8, QWORD PTR [rcx+rdx*2]

; 299  : 		*_IPfirst = _First;

	mov	QWORD PTR [rax], rsi

; 300  : 		*_IPnext = _Next;
; 301  : 		*_IPcount = (int)(_Last - _Next);

	sub	r8, rdi
	mov	rax, QWORD PTR [r11+64]
	sar	r8, 1
	mov	QWORD PTR [rax], rdi
	mov	rax, QWORD PTR [r11+88]
	mov	DWORD PTR [rax], r8d
$LN21@seekoff:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 32   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

	mov	QWORD PTR [r10], rbx
$LN43@seekoff:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 319  : 		}

	mov	rbx, QWORD PTR [rsp+24]
	xor	eax, eax
	mov	rbp, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+48]
	mov	QWORD PTR [r10+8], r9
	mov	QWORD PTR [r10+16], rax
	mov	rax, r10
	pop	r15
	pop	r14
	ret	0
?seekoff@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGXZ
_TEXT	SEGMENT
this$ = 8
?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGXZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 225  : 		return (*_IGnext);

	mov	r10, QWORD PTR [rcx+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 216  : 		{	// get an element from stream, but don't point past it

	mov	r9, rcx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 225  : 		return (*_IGnext);

	mov	rcx, QWORD PTR [r10]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 218  : 		if (_Gptr == nullptr)

	test	rcx, rcx
	je	SHORT $LN5@underflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 240  : 		return (*_IGnext + *_IGcount);

	mov	rdx, QWORD PTR [r9+80]
	movsxd	r8, DWORD PTR [rdx]
	lea	rdx, QWORD PTR [rcx+r8*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 223  : 		if (_Gptr < _Mysb::egptr())

	cmp	rcx, rdx
	jb	SHORT $LN34@underflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 235  : 		return (*_IPnext);

	mov	rax, QWORD PTR [r9+64]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 229  : 		const auto _Pptr = _Mysb::pptr();

	mov	r8, QWORD PTR [rax]
	test	r8, r8

; 230  : 		if (!_Pptr || (_Mystate & _Noread))

	je	SHORT $LN5@underflow
	test	BYTE PTR [r9+112], 4
	jne	SHORT $LN5@underflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	mov	rdx, QWORD PTR [r9+104]
	cmp	rdx, r8
	cmovb	rdx, r8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 236  : 		if (_Local_highwater <= _Gptr)

	cmp	rdx, rcx
	jbe	SHORT $LN5@underflow

; 237  : 			{	// nothing in the put area to take
; 238  : 			return (_Traits::eof());
; 239  : 			}
; 240  : 
; 241  : 		_Seekhigh = _Local_highwater;

	mov	QWORD PTR [r9+104], rdx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 225  : 		return (*_IGnext);

	mov	rcx, QWORD PTR [r10]

; 252  : 		*_IGnext = _Next;

	mov	QWORD PTR [r10], rcx

; 253  : 		*_IGcount = (int)(_Last - _Next);

	sub	rdx, rcx
	mov	rax, QWORD PTR [r9+80]
	sar	rdx, 1
	mov	DWORD PTR [rax], edx

; 225  : 		return (*_IGnext);

	mov	rax, QWORD PTR [r9+56]
	mov	rcx, QWORD PTR [rax]
$LN34@underflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 244  : 		}

	movzx	eax, WORD PTR [rcx]
	ret	0
$LN5@underflow:

; 231  : 			{	// no put area or read disallowed
; 232  : 			return (_Traits::eof());

	mov	eax, 65535				; 0000ffffH

; 244  : 		}

	ret	0
?underflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGXZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
_TEXT	SEGMENT
this$ = 8
_Meta$ = 16
?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 225  : 		return (*_IGnext);

	mov	rax, QWORD PTR [rcx+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 198  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	mov	r9d, 65535				; 0000ffffH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 225  : 		return (*_IGnext);

	mov	r8, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 198  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	test	r8, r8
	je	SHORT $LN3@pbackfail
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [rcx+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 198  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	cmp	r8, QWORD PTR [rax]
	jbe	SHORT $LN3@pbackfail
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 384  : 		return (_Left == _Right);

	cmp	r9w, dx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 198  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	je	SHORT $LN2@pbackfail
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 364  : 		return (_Left == _Right);

	cmp	dx, WORD PTR [r8-2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 198  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	je	SHORT $LN2@pbackfail
	test	BYTE PTR [rcx+112], 2
	jne	SHORT $LN3@pbackfail
$LN2@pbackfail:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 245  : 		*_IGcount -= _Off;

	mov	rax, QWORD PTR [rcx+80]
	inc	DWORD PTR [rax]

; 246  : 		*_IGnext += _Off;

	mov	rax, QWORD PTR [rcx+56]
	add	QWORD PTR [rax], -2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 384  : 		return (_Left == _Right);

	cmp	r9w, dx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 207  : 		if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

	je	SHORT $LN4@pbackfail
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 225  : 		return (*_IGnext);

	mov	rax, QWORD PTR [rcx+56]
	mov	rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 209  : 			*_Mysb::gptr() = _Traits::to_char_type(_Meta);

	mov	WORD PTR [rcx], dx
$LN4@pbackfail:

; 210  : 			}
; 211  : 
; 212  : 		return (_Traits::not_eof(_Meta));

	xor	eax, eax
	cmp	dx, r9w
	cmove	dx, ax
	movzx	eax, dx

; 213  : 		}

	ret	0
$LN3@pbackfail:

; 199  : 				&& !_Traits::eq(_Traits::to_char_type(_Meta), _Gptr[-1])
; 200  : 				&& (_Mystate & _Constant)))
; 201  : 			{	// can't put back, fail
; 202  : 			return (_Traits::eof());

	movzx	eax, r9w

; 213  : 		}

	ret	0
?pbackfail@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z
_TEXT	SEGMENT
this$ = 80
_Meta$ = 88
?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow, COMDAT

; 119  : 		{	// put an element to stream

$LN66:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r15
	sub	rsp, 32					; 00000020H

; 120  : 		if (_Mystate & _Constant)

	test	BYTE PTR [rcx+112], 2
	movzx	ebp, dx
	mov	rdi, rcx
	mov	r8d, 65535				; 0000ffffH
	jne	SHORT $LN10@overflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 384  : 		return (_Left == _Right);

	cmp	r8w, dx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 125  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	jne	SHORT $LN3@overflow

; 126  : 			{
; 127  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

	xor	r15d, r15d
	movzx	eax, r15w
	jmp	SHORT $LN1@overflow
$LN3@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 235  : 		return (*_IPnext);

	mov	rax, QWORD PTR [rcx+64]
	mov	rbx, QWORD PTR [rax]

; 258  : 		return (*_IPnext + *_IPcount);

	mov	rax, QWORD PTR [rcx+88]
	movsxd	rcx, DWORD PTR [rax]
	lea	rdx, QWORD PTR [rbx+rcx*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 132  : 		if (_Pptr != nullptr && _Pptr < _Epptr)

	test	rbx, rbx
	je	SHORT $LN4@overflow
	cmp	rbx, rdx
	jae	SHORT $LN4@overflow

; 133  : 			{	// room in buffer, store it
; 134  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	rcx, rdi
	call	QWORD PTR __imp_?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ
	mov	WORD PTR [rax], bp

; 135  : 			_Seekhigh = _Pptr + 1;

	lea	rax, QWORD PTR [rbx+2]
	mov	QWORD PTR [rdi+104], rax

; 136  : 			return (_Meta);

	movzx	eax, bp
	jmp	SHORT $LN1@overflow
$LN4@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [rdi+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 140  : 		size_t _Oldsize = 0;

	xor	r15d, r15d
	mov	esi, r15d
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 220  : 		return (*_IGfirst);

	mov	r13, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 142  : 		if (_Pptr != nullptr)

	test	rbx, rbx
	je	SHORT $LN64@overflow

; 143  : 			{
; 144  : 			_Oldsize = static_cast<size_t>(_Epptr - _Oldptr);

	mov	rsi, rdx
	sub	rsi, r13
	sar	rsi, 1

; 145  : 			}
; 146  : 
; 147  : 		size_t _Newsize;
; 148  : 		if (_Oldsize < _MINSIZE)

	cmp	rsi, 32					; 00000020H
	jb	SHORT $LN64@overflow

; 151  : 			}
; 152  : 		else if (_Oldsize < INT_MAX / 2)

	cmp	rsi, 1073741823				; 3fffffffH
	jae	SHORT $LN8@overflow

; 153  : 			{	// grow by 50 percent
; 154  : 			_Newsize = _Oldsize << 1;

	lea	r12, QWORD PTR [rsi+rsi]
	jmp	SHORT $LN11@overflow
$LN8@overflow:

; 155  : 			}
; 156  : 		else if (_Oldsize < INT_MAX)

	mov	r12d, 2147483647			; 7fffffffH
	cmp	rsi, r12
	jb	SHORT $LN11@overflow
$LN10@overflow:

; 157  : 			{
; 158  : 			_Newsize = INT_MAX;
; 159  : 			}
; 160  : 		else
; 161  : 			{	// buffer can't grow, fail
; 162  : 			return (_Traits::eof());

	movzx	eax, r8w
$LN1@overflow:

; 191  : 		}

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN64@overflow:

; 149  : 			{
; 150  : 			_Newsize = _MINSIZE;

	mov	r12d, 32				; 00000020H
$LN11@overflow:

; 165  : 		const auto _Newptr = _Unfancy(_Al.allocate(_Newsize));

	lea	rcx, QWORD PTR [rdi+116]
	mov	QWORD PTR [rsp+80], r14
	mov	rdx, r12
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	rbx, QWORD PTR [rsi+rsi]
	mov	rdx, r13
	mov	r8, rbx
	mov	rcx, rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 165  : 		const auto _Newptr = _Unfancy(_Al.allocate(_Newsize));

	mov	r14, rax
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	call	memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 168  : 		const auto _New_pnext = _Newptr + _Oldsize;

	lea	rdx, QWORD PTR [rbx+r14]

; 169  : 		_Seekhigh = _New_pnext + 1; // to include _Meta

	lea	rcx, QWORD PTR [rdx+2]
	mov	QWORD PTR [rdi+104], rcx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 299  : 		*_IPfirst = _First;

	mov	rcx, QWORD PTR [rdi+32]
	mov	QWORD PTR [rcx], r14

; 300  : 		*_IPnext = _Next;

	mov	rcx, QWORD PTR [rdi+64]
	mov	QWORD PTR [rcx], rdx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 171  : 		_Mysb::setp(_Newptr, _New_pnext, _Newptr + _Newsize);

	lea	rcx, QWORD PTR [r12+r12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 301  : 		*_IPcount = (int)(_Last - _Next);

	mov	rax, QWORD PTR [rdi+88]
	sub	rcx, rdx
	add	rcx, r14
	sar	rcx, 1
	mov	DWORD PTR [rax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 172  : 		if (_Mystate & _Noread)

	test	BYTE PTR [rdi+112], 4
	je	SHORT $LN12@overflow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 251  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR [rdi+24]
	mov	QWORD PTR [rax], r14

; 252  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rdi+56]

; 253  : 		*_IGcount = (int)(_Last - _Next);

	sar	r14, 1
	mov	QWORD PTR [rax], r15
	mov	rax, QWORD PTR [rdi+80]
	mov	DWORD PTR [rax], r14d
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 176  : 		else

	jmp	SHORT $LN13@overflow
$LN12@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 225  : 		return (*_IGnext);

	mov	rax, QWORD PTR [rdi+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 178  : 			_Mysb::setg(_Newptr,

	mov	r10, QWORD PTR [rdi+104]
	mov	rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 251  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR [rdi+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 178  : 			_Mysb::setg(_Newptr,

	sub	rcx, r13
	sar	rcx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 251  : 		*_IGfirst = _First;

	mov	QWORD PTR [rax], r14

; 252  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rdi+56]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 178  : 			_Mysb::setg(_Newptr,

	lea	r9, QWORD PTR [r14+rcx*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 253  : 		*_IGcount = (int)(_Last - _Next);

	sub	r10, r9
	sar	r10, 1
	mov	QWORD PTR [rax], r9
	mov	rax, QWORD PTR [rdi+80]
	mov	DWORD PTR [rax], r10d
$LN13@overflow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 183  : 		if (_Mystate & _Allocated)

	mov	eax, DWORD PTR [rdi+112]
	mov	r14, QWORD PTR [rsp+80]
	test	al, 1
	je	SHORT $LN14@overflow

; 184  : 			{
; 185  : 			_Al.deallocate(_Ptr_traits::pointer_to(*_Oldptr), _Oldsize);

	mov	r8, rsi
	lea	rcx, QWORD PTR [rdi+116]
	mov	rdx, r13
	call	?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ; std::allocator<wchar_t>::deallocate
	mov	eax, DWORD PTR [rdi+112]
$LN14@overflow:

; 186  : 			}
; 187  : 
; 188  : 		_Mystate |= _Allocated;

	or	eax, 1

; 189  : 		*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	rcx, rdi
	mov	DWORD PTR [rdi+112], eax
	call	QWORD PTR __imp_?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ
	mov	WORD PTR [rax], bp

; 190  : 		return (_Meta);

	movzx	eax, bp
	jmp	$LN1@overflow
?overflow@?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@MEAAGG@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
;	COMDAT ??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 77   : 		{	// destroy the object

$LN49:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR [rcx], rax

; 402  : 		if (_Mystate & _Allocated)

	test	BYTE PTR [rcx+112], 1
	je	SHORT $LN38@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 235  : 		return (*_IPnext);

	mov	rax, QWORD PTR [rcx+64]
	mov	rdx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 404  : 			_Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

	test	rdx, rdx
	je	SHORT $LN7@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 258  : 		return (*_IPnext + *_IPcount);

	mov	rax, QWORD PTR [rcx+88]
	movsxd	rcx, DWORD PTR [rax]
	lea	rdx, QWORD PTR [rdx+rcx*2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 404  : 			_Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

	jmp	SHORT $LN8@basic_stri
$LN7@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 240  : 		return (*_IGnext + *_IGcount);

	mov	rax, QWORD PTR [rcx+80]
	movsxd	rdx, DWORD PTR [rax]
	mov	rax, QWORD PTR [rcx+56]
	mov	rcx, QWORD PTR [rax]
	lea	rdx, QWORD PTR [rcx+rdx*2]
$LN8@basic_stri:

; 220  : 		return (*_IGfirst);

	mov	rax, QWORD PTR [rbx+24]
	mov	rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 404  : 			_Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),

	sub	rdx, rcx
	sar	rdx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	add	rdx, rdx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN37@basic_stri

; 115  : 	_Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN34@basic_stri

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, r8
$LN37@basic_stri:

; 207  : 	::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN38@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 251  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR [rbx+24]
	xor	ecx, ecx
	mov	QWORD PTR [rax], rcx

; 252  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], rcx

; 253  : 		*_IGcount = (int)(_Last - _Next);

	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], ecx

; 292  : 		*_IPfirst = _First;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rax], rcx

; 293  : 		*_IPnext = _First;

	mov	rax, QWORD PTR [rbx+64]
	mov	QWORD PTR [rax], rcx

; 294  : 		*_IPcount = (int)(_Last - _First);

	mov	rax, QWORD PTR [rbx+88]
	mov	DWORD PTR [rax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 411  : 		_Seekhigh = nullptr;

	mov	QWORD PTR [rbx+104], rcx

; 412  : 		_Mystate &= ~_Allocated;

	and	DWORD PTR [rbx+112], -2

; 79   : 		}

	mov	rcx, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN34@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN46@basic_stri:
??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
;	COMDAT ??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 80
_Str$ = 88
_Mode$ = 96
??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z PROC ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 38   : 		{	// construct character buffer from string, mode

$LN62:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rbp
	mov	QWORD PTR [rsp+104], rsi
	mov	ebx, r8d
	mov	r15, rdx
	mov	rdi, rcx
	call	QWORD PTR __imp_??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR [rdi], rax

; 431  : 		if (!(_Mode & ios_base::out))

	mov	edx, ebx
	not	edx
	and	edx, 1
	shl	edx, 2
	mov	eax, ebx

; 432  : 			{
; 433  : 			_State |= _Constant;
; 434  : 			}
; 435  : 
; 436  : 		if (_Mode & ios_base::app)

	mov	ecx, edx
	or	ecx, 2

; 398  : 		}
; 399  : 
; 400  : 	void _Tidy()
; 401  : 		{	// discard any allocated buffer and clear pointers
; 402  : 		if (_Mystate & _Allocated)
; 403  : 			{
; 404  : 			_Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),
; 405  : 				static_cast<typename allocator_traits<allocator_type>::size_type>(
; 406  : 					(_Mysb::pptr() != nullptr ? _Mysb::epptr() : _Mysb::egptr()) - _Mysb::eback()));
; 407  : 			}
; 408  : 
; 409  : 		_Mysb::setg(nullptr, nullptr, nullptr);
; 410  : 		_Mysb::setp(nullptr, nullptr);
; 411  : 		_Seekhigh = nullptr;
; 412  : 		_Mystate &= ~_Allocated;
; 413  : 		}
; 414  : 
; 415  : private:
; 416  : 	using _Ptr_traits = pointer_traits<typename allocator_traits<allocator_type>::pointer>;
; 417  : 
; 418  : 	enum
; 419  : 		{	// constant for minimum buffer size
; 420  : 		_MINSIZE = 32
; 421  : 		};
; 422  : 
; 423  : 	static int _Getstate(ios_base::openmode _Mode)
; 424  : 		{	// convert open mode to stream state bits
; 425  : 		int _State = 0;
; 426  : 		if (!(_Mode & ios_base::in))
; 427  : 			{
; 428  : 			_State |= _Noread;
; 429  : 			}
; 430  : 
; 431  : 		if (!(_Mode & ios_base::out))

	and	al, 2

; 432  : 			{
; 433  : 			_State |= _Constant;
; 434  : 			}
; 435  : 
; 436  : 		if (_Mode & ios_base::app)

	cmovne	ecx, edx
	mov	eax, ebx

; 441  : 		if (_Mode & ios_base::ate)

	mov	edx, ecx
	or	edx, 8

; 432  : 			{
; 433  : 			_State |= _Constant;
; 434  : 			}
; 435  : 
; 436  : 		if (_Mode & ios_base::app)

	and	al, 8

; 441  : 		if (_Mode & ios_base::ate)

	cmove	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3302 : 		return (this->_Get_data()._Mysize);

	mov	ebp, edx
	or	ebp, 16
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 441  : 		if (_Mode & ios_base::ate)

	and	bl, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3302 : 		return (this->_Get_data()._Mysize);

	cmove	ebp, edx
	mov	r14, QWORD PTR [r15+16]

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [r15+24], 8

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN29@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	r15, QWORD PTR [r15]
$LN29@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 362  : 		if (_Count > INT_MAX)

	cmp	r14, 2147483647				; 7fffffffH
	ja	$LN60@basic_stri

; 365  : 			}
; 366  : 
; 367  : 		if (_Count != 0 && (_State & (_Noread | _Constant)) != (_Noread | _Constant))

	test	r14, r14
	je	$LN37@basic_stri
	mov	eax, ebp
	and	eax, 6
	cmp	al, 6
	je	$LN37@basic_stri

; 368  : 			{	// finite buffer that can be read or written, set it up
; 369  : 			const auto _Pnew = _Unfancy(_Al.allocate(_Count));

	lea	rcx, QWORD PTR [rdi+116]
	mov	rdx, r14
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
	mov	rsi, rax
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	rbx, QWORD PTR [r14+r14]
	mov	r8, rbx
	mov	rdx, r15
	mov	rcx, rax
	call	memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 371  : 			_Seekhigh = _Pnew + _Count;

	lea	rcx, QWORD PTR [rbx+rsi]
	mov	QWORD PTR [rdi+104], rcx

; 372  : 
; 373  : 			if (!(_State & _Noread))

	mov	r8d, ebp
	and	r8d, 4
	jne	SHORT $LN39@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 251  : 		*_IGfirst = _First;

	mov	rcx, QWORD PTR [rdi+24]
	mov	QWORD PTR [rcx], rsi

; 252  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rdi+56]
	mov	QWORD PTR [rax], rsi

; 253  : 		*_IGcount = (int)(_Last - _Next);

	mov	rax, QWORD PTR [rdi+80]
	mov	DWORD PTR [rax], r14d
$LN39@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 378  : 			if (!(_State & _Constant))

	test	bpl, 2
	jne	SHORT $LN41@basic_stri

; 379  : 				{	// setup write buffer, and maybe read buffer
; 380  : 				_Mysb::setp(_Pnew,

	test	bpl, 24
	je	SHORT $LN43@basic_stri
	mov	rdx, QWORD PTR [rdi+104]
	mov	rcx, rdx
	jmp	SHORT $LN44@basic_stri
$LN43@basic_stri:
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rdi+104]
$LN44@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 299  : 		*_IPfirst = _First;

	mov	rax, QWORD PTR [rdi+32]
	mov	QWORD PTR [rax], rsi

; 300  : 		*_IPnext = _Next;

	mov	rax, QWORD PTR [rdi+64]
	mov	QWORD PTR [rax], rdx

; 301  : 		*_IPcount = (int)(_Last - _Next);

	sub	rcx, rdx
	sar	rcx, 1
	mov	rax, QWORD PTR [rdi+88]
	mov	DWORD PTR [rax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 384  : 				if (_State & _Noread)

	test	r8d, r8d
	je	SHORT $LN41@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\streambuf

; 251  : 		*_IGfirst = _First;

	mov	rax, QWORD PTR [rdi+24]
	mov	QWORD PTR [rax], rsi

; 252  : 		*_IGnext = _Next;

	mov	rax, QWORD PTR [rdi+56]
	mov	QWORD PTR [rax], 0

; 253  : 		*_IGcount = (int)(_Last - _Next);

	sar	rsi, 1
	mov	rax, QWORD PTR [rdi+80]
	mov	DWORD PTR [rax], esi
$LN41@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 390  : 			_State |= _Allocated;

	or	ebp, 1

; 391  : 			}
; 392  : 		else

	jmp	SHORT $LN38@basic_stri
$LN37@basic_stri:

; 393  : 			{
; 394  : 			_Seekhigh = nullptr;

	mov	QWORD PTR [rdi+104], 0
$LN38@basic_stri:

; 395  : 			}
; 396  : 
; 397  : 		_Mystate = _State;

	mov	DWORD PTR [rdi+112], ebp

; 39   : 		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
; 40   : 		}

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN60@basic_stri:

; 364  : 			_Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
	npad	1
$LN58@basic_stri:
??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z ENDP ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 80
_Str$ = 88
_Mode$ = 96
?dtor$0@?0???0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 80
_Str$ = 88
_Mode$ = 96
?dtor$0@?0???0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
;	COMDAT ??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 711  : 		{	// destroy the object

$LN15:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx
	mov	rax, QWORD PTR [rcx-152]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR [rdx+rcx-152], rax
	mov	rax, QWORD PTR [rcx-152]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	r8d, DWORD PTR [rdx-152]
	mov	DWORD PTR [rdx+rcx-156], r8d

; 712  : 		}

	add	rcx, -128				; ffffffffffffff80H
	call	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR [rbx-120]
	add	rsp, 48					; 00000030H
	pop	rbx
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
??1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$0@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???1?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
;	COMDAT ??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z PROC ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 674  : 		{	// construct character buffer from NTCS

$LN15:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T2[rsp], -2
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rbp
	mov	QWORD PTR [rsp+104], rsi
	mov	esi, r8d
	mov	rbp, rdx
	mov	rdi, rcx
	mov	DWORD PTR $T1[rsp], 0
	test	r9d, r9d
	je	SHORT $LN2@basic_stri
	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR [rcx], rax
	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR [rcx+16], rax
	lea	r9, QWORD PTR [rcx+152]
	mov	QWORD PTR this$[rsp], r9
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase

; 543  : 	__CLR_OR_THIS_CALL ios_base()

	mov	rax, QWORD PTR __imp_??_7ios_base@std@@6B@
	mov	QWORD PTR [r9], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios

; 177  : 		{	// default constructor, do nothing

	mov	rax, QWORD PTR __imp_??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
	mov	QWORD PTR [r9], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 674  : 		{	// construct character buffer from NTCS

	mov	DWORD PTR $T1[rsp], 1
$LN2@basic_stri:

; 672  : 		: _Mybase(&_Stringbuffer),

	xor	r8d, r8d
	lea	rdx, QWORD PTR [rcx+24]
	call	QWORD PTR __imp_??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QEAA@PEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
	npad	1

; 674  : 		{	// construct character buffer from NTCS

	mov	rax, QWORD PTR [rdi]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR [rdx+rdi], rax
	mov	rax, QWORD PTR [rdi]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	r8d, DWORD PTR [rdx-152]
	mov	DWORD PTR [rdx+rdi-4], r8d

; 673  : 			_Stringbuffer(_Str, _Mode)

	mov	r8d, esi
	mov	rdx, rbp
	lea	rcx, QWORD PTR [rdi+24]
	call	??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1

; 675  : 		}

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z ENDP ; std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$3@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$3
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$3@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$3
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$1@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$2@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$2@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$3@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$3
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$3@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$1@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 48
this$ = 80
_Str$ = 88
_Mode$ = 96
$initVBases$ = 104
?dtor$2@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA PROC ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$2@?0???0?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z@4HA ENDP ; `std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z
_TEXT	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z PROC ; parsePattern, COMDAT

; 525  : static int parsePattern(std::wstring str, TilePattern* pat) {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-712]
	sub	rsp, 968				; 000003c8H
	mov	QWORD PTR $T8[rbp-256], -2
	mov	r13, rdx
	mov	rsi, rcx
	xor	r14d, r14d
	mov	r15d, r14d
	mov	DWORD PTR $T1[rsp], r14d

; 526  : 	pat->rows.clear();

	lea	r12, QWORD PTR [rdx+32]
	mov	QWORD PTR this$1$[rbp-256], r12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1591 : 		_Destroy(this->_Myfirst(), this->_Mylast());

	mov	rdi, QWORD PTR [r12+8]
	mov	rbx, QWORD PTR [r12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	mov	QWORD PTR _First$12[rbp-256], rbx

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rbx, rdi
	je	SHORT $LN51@parsePatte
$LL52@parsePatte:
	lea	rcx, QWORD PTR [rbx+8]
	call	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
	add	rbx, 32					; 00000020H
	mov	QWORD PTR _First$12[rbp-256], rbx
	cmp	rbx, rdi
	jne	SHORT $LL52@parsePatte
	mov	rbx, QWORD PTR [r12]
$LN51@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [r12+8], rbx
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 527  : 	pat->heights.clear();

	add	r13, 8
	mov	QWORD PTR this$1$[rbp-256], r13
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

	mov	rax, QWORD PTR [r13]
	mov	QWORD PTR [r13+8], rax
	vpxor	xmm0, xmm0, xmm0

; 389  : 		: _Myfirst(),

	vmovdqu	XMMWORD PTR rowStrings$[rsp], xmm0

; 390  : 		_Mylast(),
; 391  : 		_Myend()

	mov	QWORD PTR rowStrings$[rsp+16], r14
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	vmovdqu	XMMWORD PTR $T4[rsp+16], xmm0

; 3976 : 		_My_data._Mysize = 0;

	vmovdqu	xmm1, XMMWORD PTR __xmm@00000000000000070000000000000000
	vmovdqu	XMMWORD PTR $T4[rsp+16], xmm1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T4[rsp], r14w
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_13CGOKJPIL@?$AA?1@
	lea	rcx, QWORD PTR $T4[rsp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 530  : 	tokenize(str, rowStrings, L"/");

	lea	r8, QWORD PTR $T4[rsp]
	lea	rdx, QWORD PTR rowStrings$[rsp]
	mov	rcx, rsi
	call	?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z ; tokenize
	npad	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

	mov	rdx, QWORD PTR $T4[rsp+24]
	cmp	rdx, 8

; 3987 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN196@parsePatte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx*2+2]
	mov	rcx, QWORD PTR $T4[rsp]
	mov	rax, rcx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN195@parsePatte

; 115  : 	_Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN195@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN195@parsePatte:

; 207  : 	::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN196@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

	vmovdqu	xmm0, XMMWORD PTR __xmm@00000000000000070000000000000000
	vmovdqu	XMMWORD PTR $T4[rsp+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T4[rsp], r14w
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 532  : 	for (int i=0; i<rowStrings.size(); i++) {		

	mov	edi, r14d
	mov	DWORD PTR i$1$[rbp-256], r14d
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rax, QWORD PTR rowStrings$[rsp+8]
	sub	rax, QWORD PTR rowStrings$[rsp]
	sar	rax, 5
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 532  : 	for (int i=0; i<rowStrings.size(); i++) {		

	test	rax, rax
	je	$LN3@parsePatte
	mov	rbx, r14
	lea	rsi, OFFSET FLAT:??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
$LL4@parsePatte:
	vpxor	xmm0, xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

	vmovdqu	XMMWORD PTR row$2[rsp], xmm0

; 390  : 		_Mylast(),
; 391  : 		_Myend()

	mov	QWORD PTR row$2[rsp+16], r14
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	mov	QWORD PTR $T3[rsp+16], r14

; 1785 : 		_Myres(0)

	mov	QWORD PTR $T3[rsp+24], r14

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR $T3[rsp+16], r14

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T3[rsp], r14w
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_13DEFPDAGF@?$AA?0@
	lea	rcx, QWORD PTR $T3[rsp]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

	shl	rbx, 5
	add	rbx, QWORD PTR rowStrings$[rsp]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 534  : 		tokenize(rowStrings[i], row, L",");

	lea	r8, QWORD PTR $T3[rsp]
	lea	rdx, QWORD PTR row$2[rsp]
	mov	rcx, rbx
	call	?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z ; tokenize
	npad	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

	mov	rdx, QWORD PTR $T3[rsp+24]
	cmp	rdx, 8

; 3987 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN309@parsePatte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx*2+2]
	mov	rcx, QWORD PTR $T3[rsp]
	mov	rax, rcx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN308@parsePatte

; 115  : 	_Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN305@parsePatte
$LN308@parsePatte:

; 207  : 	::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN309@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

	mov	QWORD PTR $T3[rsp+16], r14

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rsp+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T3[rsp], r14w
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rax, QWORD PTR row$2[rsp+8]
	mov	rbx, QWORD PTR row$2[rsp]
	sub	rax, rbx
	sar	rax, 5
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 536  : 		if (row.size() < 3)

	cmp	rax, 3
	jb	$LN1196@parsePatte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 674  : 		{	// construct character buffer from NTCS

	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR s0$11[rbp-256], rax
	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR s0$11[rbp-240], rax
	lea	rcx, QWORD PTR s0$11[rbp-104]
	call	QWORD PTR __imp_??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IEAA@XZ
	npad	1
	or	r15d, 1
	mov	DWORD PTR $T1[rsp], r15d

; 672  : 		: _Mybase(&_Stringbuffer),

	xor	r8d, r8d
	lea	rdx, QWORD PTR s0$11[rbp-232]
	lea	rcx, QWORD PTR s0$11[rbp-256]
	call	QWORD PTR __imp_??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QEAA@PEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
	npad	1

; 674  : 		{	// construct character buffer from NTCS

	mov	rax, QWORD PTR s0$11[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	QWORD PTR s0$11[rbp+rcx-256], rsi
	mov	rax, QWORD PTR s0$11[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	r8d, DWORD PTR [rcx-152]
	mov	DWORD PTR s0$11[rbp+rcx-260], r8d

; 673  : 			_Stringbuffer(_Str, _Mode)

	mov	r8d, 3
	mov	rdx, rbx
	lea	rcx, QWORD PTR s0$11[rbp-232]
	call	??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 541  : 		s0 >> offset;

	lea	rdx, QWORD PTR offset$16[rbp-256]
	lea	rcx, QWORD PTR s0$11[rbp-256]
	call	QWORD PTR __imp_??5?$basic_istream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV01@AEAN@Z
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

	mov	rbx, QWORD PTR row$2[rsp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 674  : 		{	// construct character buffer from NTCS

	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR s1$10[rbp-256], rax
	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR s1$10[rbp-240], rax
	lea	rcx, QWORD PTR s1$10[rbp-104]
	call	QWORD PTR __imp_??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IEAA@XZ
	npad	1
	or	r15d, 2
	mov	DWORD PTR $T1[rsp], r15d

; 672  : 		: _Mybase(&_Stringbuffer),

	xor	r8d, r8d
	lea	rdx, QWORD PTR s1$10[rbp-232]
	lea	rcx, QWORD PTR s1$10[rbp-256]
	call	QWORD PTR __imp_??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QEAA@PEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
	npad	1

; 674  : 		{	// construct character buffer from NTCS

	mov	rax, QWORD PTR s1$10[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	QWORD PTR s1$10[rbp+rcx-256], rsi
	mov	rax, QWORD PTR s1$10[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	r8d, DWORD PTR [rcx-152]
	mov	DWORD PTR s1$10[rbp+rcx-260], r8d

; 673  : 			_Stringbuffer(_Str, _Mode)

	mov	r8d, 3
	lea	rdx, QWORD PTR [rbx+32]
	lea	rcx, QWORD PTR s1$10[rbp-232]
	call	??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 543  : 		s1 >> height;

	lea	rdx, QWORD PTR height$7[rbp-256]
	lea	rcx, QWORD PTR s1$10[rbp-256]
	call	QWORD PTR __imp_??5?$basic_istream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV01@AEAN@Z
	vmovsd	xmm1, QWORD PTR offset$16[rbp-256]

; 544  : 
; 545  : 		TileRow r = TileRow(offset);

	vcvtpd2ps xmm1, xmm1
	vpxor	xmm0, xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

	vmovdqu	XMMWORD PTR r$5[rbp-248], xmm0

; 390  : 		_Mylast(),
; 391  : 		_Myend()

	mov	QWORD PTR r$5[rbp-232], r14
; File g:\dropbox\github\berconmaps\src\tile.h

; 58   : 	TileRow(float offset) {this->offset = offset;}

	vmovss	DWORD PTR r$5[rsp], xmm1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 547  : 		for (int j=2; j<row.size(); j++) {

	mov	esi, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rax, QWORD PTR row$2[rsp+8]
	mov	rcx, QWORD PTR row$2[rsp]
	sub	rax, rcx
	sar	rax, 5
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 547  : 		for (int j=2; j<row.size(); j++) {

	cmp	rax, rsi
	jbe	$LN6@parsePatte
	mov	edi, esi
	mov	rbx, QWORD PTR r$5[rbp-240]
	lea	r13, OFFSET FLAT:??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	lea	r12, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_istream@_WU?$char_traits@_W@std@@@1@@
	npad	5
$LL7@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

	shl	rdi, 5
	add	rdi, rcx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 674  : 		{	// construct character buffer from NTCS

	mov	QWORD PTR sn$9[rbp-256], r12
	lea	rax, OFFSET FLAT:??_8?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@7B?$basic_ostream@_WU?$char_traits@_W@std@@@1@@
	mov	QWORD PTR sn$9[rbp-240], rax
	lea	rcx, QWORD PTR sn$9[rbp-104]
	call	QWORD PTR __imp_??0?$basic_ios@_WU?$char_traits@_W@std@@@std@@IEAA@XZ
	npad	1
	or	r15d, 4
	mov	DWORD PTR $T1[rsp], r15d

; 672  : 		: _Mybase(&_Stringbuffer),

	xor	r8d, r8d
	lea	rdx, QWORD PTR sn$9[rbp-232]
	lea	rcx, QWORD PTR sn$9[rbp-256]
	call	QWORD PTR __imp_??0?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QEAA@PEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@@Z
	npad	1

; 674  : 		{	// construct character buffer from NTCS

	mov	rax, QWORD PTR sn$9[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	QWORD PTR sn$9[rbp+rcx-256], r13
	mov	rax, QWORD PTR sn$9[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	r8d, DWORD PTR [rcx-152]
	mov	DWORD PTR sn$9[rbp+rcx-260], r8d

; 673  : 			_Stringbuffer(_Str, _Mode)

	mov	r8d, 3
	mov	rdx, rdi
	lea	rcx, QWORD PTR sn$9[rbp-232]
	call	??0?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@H@Z ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 549  : 			sn >> width;

	lea	rdx, QWORD PTR width$6[rbp-256]
	lea	rcx, QWORD PTR sn$9[rbp-256]
	call	QWORD PTR __imp_??5?$basic_istream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV01@AEAN@Z
	vmovsd	xmm0, QWORD PTR width$6[rbp-256]

; 550  : 
; 551  : 			r.tiles.push_back(width);

	vcvtpd2ps xmm0, xmm0
	vmovss	DWORD PTR $T15[rbp-256], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1726 : 		return (this->_Myend() != this->_Mylast());

	cmp	r14, rbx

; 917  : 		if (_Has_unused_capacity())

	je	SHORT $LN666@parsePatte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	vmovss	DWORD PTR [rbx], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	rbx, 4
	mov	QWORD PTR r$5[rbp-240], rbx

; 919  : 			return (_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...));

	jmp	SHORT $LN665@parsePatte
$LN666@parsePatte:

; 920  : 			}
; 921  : 
; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T15[rbp-256]
	mov	rdx, rbx
	lea	rcx, QWORD PTR r$5[rbp-248]
	call	??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float const &>
	mov	r14, QWORD PTR r$5[rbp-232]
	mov	rbx, QWORD PTR r$5[rbp-240]
$LN665@parsePatte:
	lea	rax, QWORD PTR sn$9[rbp-104]
	mov	QWORD PTR this$[rbp-256], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 711  : 		{	// destroy the object

	mov	rax, QWORD PTR sn$9[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	QWORD PTR sn$9[rbp+rcx-256], r13
	mov	rax, QWORD PTR sn$9[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-152]
	mov	DWORD PTR sn$9[rbp+rcx-260], edx

; 712  : 		}

	lea	rcx, QWORD PTR sn$9[rbp-232]
	call	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR sn$9[rbp-224]
	call	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
	lea	rax, QWORD PTR sn$9[rbp-104]
	mov	QWORD PTR this$[rbp-256], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios

; 38   : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
	mov	QWORD PTR sn$9[rbp-104], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase

; 533  : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7ios_base@std@@6B@
	mov	QWORD PTR sn$9[rbp-104], rax

; 534  : 		_Ios_base_dtor(this);

	lea	rcx, QWORD PTR sn$9[rbp-104]
	call	QWORD PTR __imp_?_Ios_base_dtor@ios_base@std@@CAXPEAV12@@Z
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 547  : 		for (int j=2; j<row.size(); j++) {

	inc	esi
	movsxd	rdi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rax, QWORD PTR row$2[rsp+8]
	mov	rcx, QWORD PTR row$2[rsp]
	sub	rax, rcx
	sar	rax, 5
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 547  : 		for (int j=2; j<row.size(); j++) {

	cmp	rdi, rax
	jb	$LL7@parsePatte
	mov	r12, QWORD PTR this$1$[rbp-256]
	mov	r13, QWORD PTR this$1$[rbp-256]
	vmovss	xmm1, DWORD PTR r$5[rsp]
	mov	edi, DWORD PTR i$1$[rbp-256]
$LN6@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	rdx, QWORD PTR [r12+8]
	cmp	QWORD PTR [r12+16], rdx

; 917  : 		if (_Has_unused_capacity())

	je	SHORT $LN754@parsePatte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	QWORD PTR $T13[rbp-256], rdx
	vmovss	DWORD PTR [rdx], xmm1
	vmovss	xmm0, DWORD PTR r$5[rsp+4]
	vmovss	DWORD PTR [rdx+4], xmm0
	lea	rcx, QWORD PTR [rdx+8]
	lea	rdx, QWORD PTR r$5[rbp-248]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	QWORD PTR [r12+8], 32			; 00000020H

; 919  : 			return (_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...));

	jmp	SHORT $LN753@parsePatte
$LN754@parsePatte:

; 920  : 			}
; 921  : 
; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR r$5[rsp]
	mov	rcx, r12
	call	??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z ; std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>
$LN753@parsePatte:
	vmovsd	xmm0, QWORD PTR height$7[rbp-256]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 555  : 		pat->heights.push_back((float)height);

	vcvtpd2ps xmm0, xmm0
	vmovss	DWORD PTR $T14[rbp-256], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	rdx, QWORD PTR [r13+8]
	cmp	QWORD PTR [r13+16], rdx

; 917  : 		if (_Has_unused_capacity())

	je	SHORT $LN836@parsePatte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	vmovss	DWORD PTR [rdx], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	QWORD PTR [r13+8], 4

; 919  : 			return (_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...));

	jmp	SHORT $LN835@parsePatte
$LN836@parsePatte:

; 920  : 			}
; 921  : 
; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T14[rbp-256]
	mov	rcx, r13
	call	??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float>
	npad	1
$LN835@parsePatte:
	lea	rcx, QWORD PTR r$5[rbp-248]
	call	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
	npad	1
	lea	rax, QWORD PTR s1$10[rbp-104]
	mov	QWORD PTR this$[rbp-256], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 711  : 		{	// destroy the object

	mov	rax, QWORD PTR s1$10[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rsi, OFFSET FLAT:??_7?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@6B@
	mov	QWORD PTR s1$10[rbp+rcx-256], rsi
	mov	rax, QWORD PTR s1$10[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-152]
	mov	DWORD PTR s1$10[rbp+rcx-260], edx

; 712  : 		}

	lea	rcx, QWORD PTR s1$10[rbp-232]
	call	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR s1$10[rbp-224]
	call	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
	lea	rax, QWORD PTR s1$10[rbp-104]
	mov	QWORD PTR this$[rbp-256], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios

; 38   : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
	mov	QWORD PTR s1$10[rbp-104], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase

; 533  : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7ios_base@std@@6B@
	mov	QWORD PTR s1$10[rbp-104], rax

; 534  : 		_Ios_base_dtor(this);

	lea	rcx, QWORD PTR s1$10[rbp-104]
	call	QWORD PTR __imp_?_Ios_base_dtor@ios_base@std@@CAXPEAV12@@Z
	npad	1
	lea	rax, QWORD PTR s0$11[rbp-104]
	mov	QWORD PTR this$[rbp-256], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\sstream

; 711  : 		{	// destroy the object

	mov	rax, QWORD PTR s0$11[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	QWORD PTR s0$11[rbp+rcx-256], rsi
	mov	rax, QWORD PTR s0$11[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-152]
	mov	DWORD PTR s0$11[rbp+rcx-260], edx

; 712  : 		}

	lea	rcx, QWORD PTR s0$11[rbp-232]
	call	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR s0$11[rbp-224]
	call	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
	lea	rax, QWORD PTR s0$11[rbp-104]
	mov	QWORD PTR this$[rbp-256], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\ios

; 38   : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
	mov	QWORD PTR s0$11[rbp-104], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xiosbase

; 533  : 		{	// destroy the object

	mov	rax, QWORD PTR __imp_??_7ios_base@std@@6B@
	mov	QWORD PTR s0$11[rbp-104], rax

; 534  : 		_Ios_base_dtor(this);

	lea	rcx, QWORD PTR s0$11[rbp-104]
	call	QWORD PTR __imp_?_Ios_base_dtor@ios_base@std@@CAXPEAV12@@Z
	npad	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

	mov	rbx, QWORD PTR row$2[rsp]
	test	rbx, rbx
	je	SHORT $LN1219@parsePatte

; 1914 : 			{	// destroy and deallocate old array
; 1915 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	rdi, QWORD PTR row$2[rsp+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	cmp	rbx, rdi

; 1134 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN976@parsePatte
	npad	1
$LL977@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL977@parsePatte
	mov	rbx, QWORD PTR row$2[rsp]
$LN976@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rdx, QWORD PTR row$2[rsp+16]
	sub	rdx, rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H
	mov	rax, rbx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1034@parsePatte

; 115  : 	_Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rbx, QWORD PTR [rbx-8]
	sub	rax, rbx

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN1031@parsePatte
$LN1034@parsePatte:

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	vpxor	xmm0, xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

	vmovdqu	XMMWORD PTR row$2[rsp], xmm0

; 1919 : 			this->_Mylast() = pointer();
; 1920 : 			this->_Myend() = pointer();

	xor	r14d, r14d
	mov	QWORD PTR row$2[rsp+16], r14
	mov	edi, DWORD PTR i$1$[rbp-256]

; 1913 : 		if (this->_Myfirst() != pointer())

	jmp	SHORT $LN2@parsePatte
$LN1219@parsePatte:
	xor	r14d, r14d
$LN2@parsePatte:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 532  : 	for (int i=0; i<rowStrings.size(); i++) {		

	inc	edi
	mov	DWORD PTR i$1$[rbp-256], edi
	movsxd	rbx, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rax, QWORD PTR rowStrings$[rsp+8]
	sub	rax, QWORD PTR rowStrings$[rsp]
	sar	rax, 5
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 532  : 	for (int i=0; i<rowStrings.size(); i++) {		

	cmp	rbx, rax
	jb	$LL4@parsePatte

; 536  : 		if (row.size() < 3)

	mov	rsi, QWORD PTR str$[rbp-256]
$LN3@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

	mov	rbx, QWORD PTR rowStrings$[rsp]
	test	rbx, rbx
	je	$LN1060@parsePatte

; 1914 : 			{	// destroy and deallocate old array
; 1915 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	rdi, QWORD PTR rowStrings$[rsp+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	cmp	rbx, rdi

; 1134 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN1098@parsePatte
	npad	3
$LL1099@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL1099@parsePatte
	mov	rbx, QWORD PTR rowStrings$[rsp]
$LN1098@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rdx, QWORD PTR rowStrings$[rsp+16]
	sub	rdx, rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H
	mov	rax, rbx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	$LN1156@parsePatte

; 115  : 	_Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rbx, QWORD PTR [rbx-8]
	sub	rax, rbx

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	$LN1156@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN305@parsePatte:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN1031@parsePatte:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1196@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

	mov	rbx, QWORD PTR row$2[rsp]
	test	rbx, rbx
	je	SHORT $LN340@parsePatte

; 1914 : 			{	// destroy and deallocate old array
; 1915 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	rdi, QWORD PTR row$2[rsp+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	cmp	rbx, rdi

; 1134 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN378@parsePatte
$LL379@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL379@parsePatte
	mov	rbx, QWORD PTR row$2[rsp]
$LN378@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rdx, QWORD PTR row$2[rsp+16]
	sub	rdx, rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H
	mov	rax, rbx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN436@parsePatte

; 115  : 	_Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rbx, QWORD PTR [rbx-8]
	sub	rax, rbx

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN436@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN436@parsePatte:

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	vpxor	xmm0, xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

	vmovdqu	XMMWORD PTR row$2[rsp], xmm0

; 1919 : 			this->_Mylast() = pointer();
; 1920 : 			this->_Myend() = pointer();

	mov	QWORD PTR row$2[rsp+16], r14
$LN340@parsePatte:

; 1913 : 		if (this->_Myfirst() != pointer())

	mov	rbx, QWORD PTR rowStrings$[rsp]
	test	rbx, rbx
	je	SHORT $LN462@parsePatte

; 1914 : 			{	// destroy and deallocate old array
; 1915 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	rdi, QWORD PTR rowStrings$[rsp+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	cmp	rbx, rdi

; 1134 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN500@parsePatte
	npad	7
$LL501@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL501@parsePatte
	mov	rbx, QWORD PTR rowStrings$[rsp]
$LN500@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rdx, QWORD PTR rowStrings$[rsp+16]
	sub	rdx, rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H
	mov	rax, rbx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN558@parsePatte

; 115  : 	_Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rbx, QWORD PTR [rbx-8]
	sub	rax, rbx

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN558@parsePatte
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN558@parsePatte:

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	vpxor	xmm0, xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

	vmovdqu	XMMWORD PTR rowStrings$[rsp], xmm0

; 1919 : 			this->_Mylast() = pointer();
; 1920 : 			this->_Myend() = pointer();

	mov	QWORD PTR rowStrings$[rsp+16], r14
$LN462@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, QWORD PTR str$[rbp-256]
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 537  : 			return FALSE;	

	xor	eax, eax
	jmp	SHORT $LN1@parsePatte
$LN1156@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	vpxor	xmm0, xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

	vmovdqu	XMMWORD PTR rowStrings$[rsp], xmm0

; 1919 : 			this->_Mylast() = pointer();
; 1920 : 			this->_Myend() = pointer();

	mov	QWORD PTR rowStrings$[rsp+16], r14
$LN1060@parsePatte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rsi
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 558  : 	return TRUE;

	mov	eax, 1
$LN1@parsePatte:

; 559  : }

	add	rsp, 968				; 000003c8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN1220@parsePatte:
?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z ENDP ; parsePattern
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$0@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$0
	mov	rcx, QWORD PTR str$[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$9
	mov	rcx, QWORD PTR _First$12[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$9
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$1@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$1
	lea	rcx, QWORD PTR rowStrings$[rdx]
	jmp	??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$1@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$2@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$2
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$2@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$2
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$3@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$3
	lea	rcx, QWORD PTR row$2[rdx]
	jmp	??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$3@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$3
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$4@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$4
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$4@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$4
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$10
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN603@dtor$10
	and	DWORD PTR $T1[rbp], -2
	lea	rcx, QWORD PTR s0$11[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN603@dtor$10:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$10
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$11@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$11
	lea	rcx, QWORD PTR s0$11[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$11@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$11
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$12@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$12
	lea	rcx, QWORD PTR s0$11[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$12@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$12
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$5@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$5
	lea	rcx, QWORD PTR s0$11[rdx]
	jmp	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
?dtor$5@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$5
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$13
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN618@dtor$13
	and	DWORD PTR $T1[rbp], -3
	lea	rcx, QWORD PTR s1$10[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN618@dtor$13:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$13
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$14@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$14
	lea	rcx, QWORD PTR s1$10[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$14@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$14
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$15@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$15
	lea	rcx, QWORD PTR s1$10[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$15@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$15
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$6@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$6
	lea	rcx, QWORD PTR s1$10[rdx]
	jmp	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
?dtor$6@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$6
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$16@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$16
	lea	rcx, QWORD PTR r$5[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$16@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$16
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$7@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$7
	lea	rcx, QWORD PTR r$5[rdx]
	jmp	??1TileRow@@QEAA@XZ
?dtor$7@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$7
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$17
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN660@dtor$17
	and	DWORD PTR $T1[rbp], -5
	lea	rcx, QWORD PTR sn$9[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN660@dtor$17:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$17
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$18
	lea	rcx, QWORD PTR sn$9[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$18
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$19@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$19
	lea	rcx, QWORD PTR sn$9[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$19@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$19
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$8@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$8
	lea	rcx, QWORD PTR sn$9[rdx]
	jmp	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
?dtor$8@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$8
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$20@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$20
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$20@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$20
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$21@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$21
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$21@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$21
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$22@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$22
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$22@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$22
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$23@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$23
	mov	rcx, QWORD PTR $T13[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$23@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$23
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$24@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$24
	lea	rcx, QWORD PTR r$5[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$24@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$24
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$25@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$25
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$25@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$25
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$26
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$26
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$27@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$27
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$27@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$27
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$28
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$28
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$29@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$29
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$29@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$29
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$30@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$30
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$30@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$30
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$0@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$0
	mov	rcx, QWORD PTR str$[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$9
	mov	rcx, QWORD PTR _First$12[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$9@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$1@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$1
	lea	rcx, QWORD PTR rowStrings$[rdx]
	jmp	??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$1@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$2@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$2
	lea	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$2@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$3@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$3
	lea	rcx, QWORD PTR row$2[rdx]
	jmp	??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$3@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$4@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$4
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$4@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$10
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN603@dtor$10
	and	DWORD PTR $T1[rbp], -2
	lea	rcx, QWORD PTR s0$11[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN603@dtor$10:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$10@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$11@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$11
	lea	rcx, QWORD PTR s0$11[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$11@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$12@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$12
	lea	rcx, QWORD PTR s0$11[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$12@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$5@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$5
	lea	rcx, QWORD PTR s0$11[rdx]
	jmp	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
?dtor$5@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$13
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN618@dtor$13
	and	DWORD PTR $T1[rbp], -3
	lea	rcx, QWORD PTR s1$10[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN618@dtor$13:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$13@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$14@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$14
	lea	rcx, QWORD PTR s1$10[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$14@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$15@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$15
	lea	rcx, QWORD PTR s1$10[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$15@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$6@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$6
	lea	rcx, QWORD PTR s1$10[rdx]
	jmp	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
?dtor$6@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$16@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$16
	lea	rcx, QWORD PTR r$5[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$16@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$7@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$7
	lea	rcx, QWORD PTR r$5[rdx]
	jmp	??1TileRow@@QEAA@XZ
?dtor$7@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$17
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN660@dtor$17
	and	DWORD PTR $T1[rbp], -5
	lea	rcx, QWORD PTR sn$9[rbp]
	add	rcx, 152				; 00000098H
	call	QWORD PTR __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
$LN660@dtor$17:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$17@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$18
	lea	rcx, QWORD PTR sn$9[rdx]
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$18@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$18
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$19@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$19
	lea	rcx, QWORD PTR sn$9[rdx]
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$19@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$8@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$8
	lea	rcx, QWORD PTR sn$9[rdx]
	jmp	??_D?$basic_stringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
?dtor$8@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$20@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$20
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$20@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$21@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$21
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$21@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$22@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$22
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$22@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$23@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$23
	mov	rcx, QWORD PTR $T13[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$23@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$23
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$24@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$24
	lea	rcx, QWORD PTR r$5[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$24@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$24
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$25@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$25
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$25@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$25
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$26
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$26@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$27@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$27
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$27@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$28
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 32					; 00000020H
	rex_jmp	QWORD PTR __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UEAA@XZ
?dtor$28@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$28
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$29@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$29
	mov	rcx, QWORD PTR this$[rdx]
	sub	rcx, 152				; 00000098H
	add	rcx, 24
	jmp	??1?$basic_stringbuf@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@UEAA@XZ ; std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$29@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$29
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
row$2 = 40
rowStrings$ = 64
$T3 = 88
$T4 = 88
r$5 = 120
width$6 = 152
this$1$ = 160
this$1$ = 168
height$7 = 176
$T8 = 184
sn$9 = 192
s1$10 = 448
s0$11 = 704
str$ = 1040
i$1$ = 1048
_First$12 = 1048
pat$ = 1048
$T13 = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
this$ = 1056
$T14 = 1056
$T15 = 1056
offset$16 = 1064
?dtor$30@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA PROC ; `parsePattern'::`1'::dtor$30
	mov	rcx, QWORD PTR this$[rdx]
	rex_jmp	QWORD PTR __imp_??1ios_base@std@@UEAA@XZ
?dtor$30@?0??parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z@4HA ENDP ; `parsePattern'::`1'::dtor$30
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Orphan_range, COMDAT

; 1960 : 		}

	ret	0
?_Orphan_range@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEBAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlength, COMDAT

; 1925 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1926 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN3@Xlength:
?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy, COMDAT

; 1910 : 		{	// free all storage

$LN127:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1911 : 		this->_Orphan_all();
; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

	mov	rbx, QWORD PTR [rcx]
	mov	rdi, rcx
	test	rbx, rbx
	je	SHORT $LN2@Tidy

; 1914 : 			{	// destroy and deallocate old array
; 1915 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	QWORD PTR [rsp+48], rsi
	mov	rsi, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rbx, rsi
	je	SHORT $LN40@Tidy
$LL41@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rsi
	jne	SHORT $LL41@Tidy
	mov	rbx, QWORD PTR [rdi]
$LN40@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rdx, QWORD PTR [rdi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rsi, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	sub	rdx, rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN98@Tidy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rax, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rax

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rbx, -8
	cmp	rbx, 31
	ja	SHORT $LN95@Tidy

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rbx, rax
$LN98@Tidy:

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1919 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rdi+8], rax

; 1920 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rdi+16], rax
$LN2@Tidy:

; 1922 : 		}

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN95@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN124@Tidy:
?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Change_array, COMDAT

; 1895 : 		{	// orphan all iterators, discard old array, acquire new array

$LN127:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1896 : 		this->_Orphan_all();
; 1897 : 
; 1898 : 		if (this->_Myfirst() != pointer())

	mov	rbx, QWORD PTR [rcx]
	mov	rbp, r9
	mov	r14, r8
	mov	r15, rdx
	mov	rsi, rcx
	test	rbx, rbx
	je	SHORT $LN99@Change_arr

; 1899 : 			{	// destroy and deallocate old array
; 1900 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	QWORD PTR [rsp+64], rdi
	mov	rdi, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rbx, rdi
	je	SHORT $LN40@Change_arr
$LL41@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL41@Change_arr
	mov	rbx, QWORD PTR [rsi]
$LN40@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rdx, QWORD PTR [rsi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdi, QWORD PTR [rsp+64]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	sub	rdx, rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN98@Change_arr

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rax, QWORD PTR [rbx-8]
	add	rdx, 39					; 00000027H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rax

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rbx, -8
	cmp	rbx, 31
	ja	SHORT $LN95@Change_arr

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rbx, rax
$LN98@Change_arr:

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN99@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1907 : 		}

	mov	rbx, QWORD PTR [rsp+72]
	shl	r14, 5
	add	r14, r15
	shl	rbp, 5
	add	rbp, r15
	mov	QWORD PTR [rsi], r15
	mov	QWORD PTR [rsi+16], rbp
	mov	rbp, QWORD PTR [rsp+80]
	mov	QWORD PTR [rsi+8], r14
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN95@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN124@Change_arr:
?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K1@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEBA_K_K@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Calculate_growth, COMDAT

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	r8, QWORD PTR [rcx+16]

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	sub	r8, QWORD PTR [rcx]
	sar	r8, 5

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	r8, rax
	ja	SHORT $LN31@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow
; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rcx+r8]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

	cmp	rax, rdx
	jae	SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient

	mov	rax, rdx
$LN1@Calculate_:

; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient
; 1869 : 		}

	ret	0
?_Calculate_growth@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Destroy, COMDAT

; 1848 : 		{	// destroy [_First, _Last) using allocator

$LN38:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rdx, r8
	je	SHORT $LN35@Destroy
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1848 : 		{	// destroy [_First, _Last) using allocator

	mov	rdi, r8
	mov	rbx, rdx
$LL12@Destroy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rdi
	jne	SHORT $LL12@Destroy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1850 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN35@Destroy:
	ret	0
?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z
_TEXT	SEGMENT
$T1 = 0
_Backout$2 = 8
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove_if_noexcept, COMDAT

; 1842 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

$LN130:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR $T1[rsp], -2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 147  : 		: _First(_Dest),

	mov	QWORD PTR _Backout$2[rsp], r9

; 148  : 		_Last(_Dest),

	mov	QWORD PTR _Backout$2[rsp+8], r9

; 149  : 		_Al(_Al_)

	mov	QWORD PTR _Backout$2[rsp+16], rcx

; 230  : 	for (; _First != _Last; ++_First)

	cmp	rdx, r8
	je	SHORT $LN127@Umove_if_n
	xor	eax, eax
$LL28@Umove_if_n:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	mov	QWORD PTR [r9+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [r9+24], rax

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [r9], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rdx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

	add	r9, 32					; 00000020H
	mov	QWORD PTR _Backout$2[rsp+8], r9

; 230  : 	for (; _First != _Last; ++_First)

	add	rdx, 32					; 00000020H
	cmp	rdx, r8
	jne	SHORT $LL28@Umove_if_n
$LN127@Umove_if_n:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1845 : 		}

	mov	QWORD PTR _Backout$2[rsp], r9
	vzeroupper
	add	rsp, 40					; 00000028H
	ret	0
?_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove_if_noexcept
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$2 = 8
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?dtor$0@?0??_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove_if_noexcept'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$0@?0??_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove_if_noexcept'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$2 = 8
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?dtor$0@?0??_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove_if_noexcept'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$0@?0??_Umove_if_noexcept@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove_if_noexcept'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
$T1 = 0
_Backout$2 = 8
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
__formal$ = 80
?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove_if_noexcept1, COMDAT

; 1832 : 		{	// move [_First, _Last) to raw _Dest, using allocator

$LN128:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR $T1[rsp], -2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 147  : 		: _First(_Dest),

	mov	QWORD PTR _Backout$2[rsp], r9

; 148  : 		_Last(_Dest),

	mov	QWORD PTR _Backout$2[rsp+8], r9

; 149  : 		_Al(_Al_)

	mov	QWORD PTR _Backout$2[rsp+16], rcx

; 230  : 	for (; _First != _Last; ++_First)

	cmp	rdx, r8
	je	SHORT $LN125@Umove_if_n
	xor	eax, eax
$LL26@Umove_if_n:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	mov	QWORD PTR [r9+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [r9+24], rax

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [r9], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rdx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

	add	r9, 32					; 00000020H
	mov	QWORD PTR _Backout$2[rsp+8], r9

; 230  : 	for (; _First != _Last; ++_First)

	add	rdx, 32					; 00000020H
	cmp	rdx, r8
	jne	SHORT $LL26@Umove_if_n
$LN125@Umove_if_n:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1834 : 		}

	mov	QWORD PTR _Backout$2[rsp], r9
	vzeroupper
	add	rsp, 40					; 00000028H
	ret	0
?_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove_if_noexcept1
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$2 = 8
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
__formal$ = 80
?dtor$0@?0??_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove_if_noexcept1'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$0@?0??_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove_if_noexcept1'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$2 = 8
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
__formal$ = 80
?dtor$0@?0??_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove_if_noexcept1'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$0@?0??_Umove_if_noexcept1@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAXPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@00U?$integral_constant@_N$00@2@@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove_if_noexcept1'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z
_TEXT	SEGMENT
$T1 = 0
_Backout$2 = 8
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove, COMDAT

; 1827 : 		{	// move [_First, _Last) to raw _Dest, using allocator

$LN127:
	sub	rsp, 40					; 00000028H
	mov	QWORD PTR $T1[rsp], -2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 147  : 		: _First(_Dest),

	mov	QWORD PTR _Backout$2[rsp], r9

; 148  : 		_Last(_Dest),

	mov	QWORD PTR _Backout$2[rsp+8], r9

; 149  : 		_Al(_Al_)

	mov	QWORD PTR _Backout$2[rsp+16], rcx

; 230  : 	for (; _First != _Last; ++_First)

	cmp	rdx, r8
	je	SHORT $LN25@Umove
	xor	eax, eax
$LL26@Umove:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	mov	QWORD PTR [r9+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [r9+24], rax

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [r9], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rdx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

	add	r9, 32					; 00000020H
	mov	QWORD PTR _Backout$2[rsp+8], r9

; 230  : 	for (; _First != _Last; ++_First)

	add	rdx, 32					; 00000020H
	cmp	rdx, r8
	jne	SHORT $LL26@Umove
$LN25@Umove:

; 170  : 		_First = _Last;

	mov	QWORD PTR _Backout$2[rsp], r9
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1828 : 		return (_Uninitialized_move(_First, _Last, _Dest, this->_Getal()));

	mov	rax, r9
	vzeroupper

; 1829 : 		}

	add	rsp, 40					; 00000028H
	ret	0
?_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$2 = 8
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?dtor$0@?0??_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$0@?0??_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
_Backout$2 = 8
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?dtor$0@?0??_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z@4HA PROC ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$2[rdx]
	jmp	??1?$_Uninitialized_backout_al@PEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
?dtor$0@?0??_Umove@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@PEAV32@00@Z@4HA ENDP ; `std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Umove'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAAEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAAEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@_K@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::operator[], COMDAT

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

	shl	rdx, 5
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1737 : 		}

	ret	0
??A?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAAEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@_K@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Has_unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Has_unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEBA_NXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Has_unused_capacity, COMDAT

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], rax
	setne	al

; 1727 : 		}

	ret	0
?_Has_unused_capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AEBA_NXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Has_unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::capacity, COMDAT

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 1716 : 		}

	ret	0
?capacity@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::max_size, COMDAT

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

	ret	0
?max_size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::size, COMDAT

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 1705 : 		}

	ret	0
?size@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::push_back, COMDAT

; 936  : 		{	// insert by moving into element at end, provide strong guarantee

$LN124:
	sub	rsp, 40					; 00000028H
	mov	r8, rdx

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	rdx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], rdx

; 917  : 		if (_Has_unused_capacity())

	je	SHORT $LN6@push_back
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rdx+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rdx+24], rax

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [r8]
	vmovups	YMMWORD PTR [rdx], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [r8+16], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [r8+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [r8], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	QWORD PTR [rcx+8], 32			; 00000020H
	vzeroupper

; 937  : 		emplace_back(_STD move(_Val));
; 938  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN6@push_back:

; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	call	??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
	vzeroupper

; 937  : 		emplace_back(_STD move(_Val));
; 938  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAX$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 893  : 		{	// destroy the object

$LN130:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rsi
	mov	rdi, rcx

; 1913 : 		if (this->_Myfirst() != pointer())

	mov	rbx, QWORD PTR [rcx]
	test	rbx, rbx
	je	SHORT $LN4@vector

; 1914 : 			{	// destroy and deallocate old array
; 1915 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	rsi, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rbx, rsi
	je	SHORT $LN42@vector
	npad	3
$LL43@vector:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, rbx
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
	npad	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	add	rbx, 32					; 00000020H
	cmp	rbx, rsi
	jne	SHORT $LL43@vector
	mov	rbx, QWORD PTR [rdi]
$LN42@vector:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN100@vector

; 115  : 	_Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rax, QWORD PTR [rbx-8]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rax

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rbx, -8
	cmp	rbx, 31
	ja	SHORT $LN97@vector

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rbx, rax
$LN100@vector:

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1919 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rdi+8], rax

; 1920 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rdi+16], rax
$LN4@vector:

; 895  : 		}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN97@vector:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN127@vector:
??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 389  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 652  : 		}

	mov	rax, rcx
	ret	0
??0?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_second, COMDAT

; 307  : 		return (_Myval2);

	mov	rax, rcx

; 308  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_second, COMDAT

; 302  : 		return (_Myval2);

	mov	rax, rcx

; 303  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_first, COMDAT

; 297  : 		return (*this);

	mov	rax, rcx

; 298  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_first, COMDAT

; 292  : 		return (*this);

	mov	rax, rcx

; 293  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 389  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 393  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myend, COMDAT

; 601  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 602  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myend, COMDAT

; 596  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 597  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Mylast, COMDAT

; 591  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 592  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Mylast, COMDAT

; 586  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 587  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myfirst, COMDAT

; 581  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 582  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myfirst, COMDAT

; 576  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 577  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Get_data, COMDAT

; 560  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 561  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Get_data, COMDAT

; 555  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 556  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Getal, COMDAT

; 550  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 551  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEBAAEBV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Getal, COMDAT

; 545  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 546  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAAEAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Orphan_all, COMDAT

; 535  : 		_Get_data()._Orphan_all();
; 536  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAA@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >, COMDAT

; 389  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 423  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::max_size, COMDAT

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 893  : 		}

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocate, COMDAT

; 996  : 		{	// allocate array of _Count elements

$LN30:
	sub	rsp, 40					; 00000028H

; 25   : 	size_t _Result = _Count * _Ty_size;

	mov	rax, rdx

; 26   : 	if (_Max_possible < _Count)

	mov	rcx, 576460752303423487			; 07ffffffffffffffH
	shl	rax, 5
	mov	r8, -1
	cmp	rdx, rcx
	jbe	SHORT $LN4@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

	mov	rax, r8

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

	jmp	SHORT $LN27@allocate
$LN4@allocate:
	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN7@allocate
$LN27@allocate:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 94   : 	if (_Block_size <= _Bytes)

	cmp	rcx, rax
	cmovbe	rcx, r8

; 52   : 		return (::operator new(_Bytes));

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN16@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN16@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@allocate:

; 188  : 	if (_Bytes != 0)

	test	rax, rax
	je	SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

	mov	rcx, rax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	add	rsp, 40					; 00000028H

; 52   : 		return (::operator new(_Bytes));

	jmp	??2@YAPEAX_K@Z				; operator new
$LN8@allocate:

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:
?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate, COMDAT

; 990  : 		{	// deallocate object at _Ptr

$LN20:
	sub	rsp, 40					; 00000028H

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	shl	r8, 5
	mov	rax, rdx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]
	add	r8, 39					; 00000027H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	mov	rcx, rax

; 993  : 		}

	add	rsp, 40					; 00000028H

; 207  : 	::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAAXQEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@_K@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 72
_Matches$4 = 80
_Matches$5 = 336
str$ = 656
tokens$ = 664
delimiters$ = 672
?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z PROC ; tokenize, COMDAT

; 514  : static void tokenize(const std::wstring& str, std::vector<std::wstring>& tokens, const std::wstring& delimiters) {

	mov	rax, rsp
	mov	QWORD PTR [rax+24], r8
	mov	QWORD PTR [rax+16], rdx
	mov	QWORD PTR [rax+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-392]
	sub	rsp, 592				; 00000250H
	mov	QWORD PTR $T3[rsp], -2
	mov	QWORD PTR [rax+32], rbx
	mov	r15, r8
	mov	r14, rdx
	mov	r12, rcx
	xor	r13d, r13d
	mov	esi, r13d
	mov	DWORD PTR $T1[rsp], r13d

; 515  : 	std::wstring::size_type lastPos = str.find_first_not_of(delimiters, 0);

	xor	r8d, r8d
	mov	rdx, r15
	call	?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_not_of
	mov	rdi, rax

; 516  : 	std::wstring::size_type pos = str.find_first_of(delimiters, lastPos);

	mov	r8, rax
	mov	rdx, r15
	mov	rcx, r12
	call	?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_of
	mov	rbx, rax
$LL2@tokenize:

; 517  : 	
; 518  : 	while (std::wstring::npos != pos || std::wstring::npos != lastPos) {

	cmp	rbx, -1
	jne	SHORT $LN4@tokenize
	cmp	rdi, rbx
	je	$LN3@tokenize
$LN4@tokenize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	mov	QWORD PTR $T2[rsp+16], r13

; 1785 : 		_Myres(0)

	mov	QWORD PTR $T2[rsp+24], r13

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR $T2[rsp+16], r13

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T2[rsp+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T2[rsp], r13w
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1830 : 		if (_Mysize < _Off)

	mov	rax, QWORD PTR [r12+16]
	cmp	rax, rdi
	jb	$LN374@tokenize
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 519  : 		tokens.push_back(str.substr(lastPos, pos - lastPos));

	mov	r8, rbx
	sub	r8, rdi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1851 : 		return (_Min_value(_Size, _Mysize - _Off));

	sub	rax, rdi
	cmp	rax, r8
	cmovb	r8, rax

; 1814 : 		const value_type * _Result = _Bx._Buf;

	mov	rax, r12

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [r12+24], 8

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN413@tokenize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	rax, QWORD PTR [r12]
$LN413@tokenize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2635 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

	lea	rdx, QWORD PTR [rax+rdi*2]
	lea	rcx, QWORD PTR $T2[rsp]
	vzeroupper
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 3756 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

	or	esi, 1
	mov	DWORD PTR $T1[rsp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	rdx, QWORD PTR [r14+8]
	cmp	QWORD PTR [r14+16], rdx

; 917  : 		if (_Has_unused_capacity())

	je	SHORT $LN66@tokenize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	mov	QWORD PTR [rdx+16], r13

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rdx+24], r13

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR $T2[rsp]
	vmovups	YMMWORD PTR [rdx], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR $T2[rsp+16], r13

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T2[rsp+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T2[rsp], r13w
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	QWORD PTR [r14+8], 32			; 00000020H

; 919  : 			return (_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...));

	jmp	SHORT $LN65@tokenize
$LN66@tokenize:

; 920  : 			}
; 921  : 
; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T2[rsp]
	mov	rcx, r14
	call	??$_Emplace_reallocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QEAAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
$LN65@tokenize:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 519  : 		tokens.push_back(str.substr(lastPos, pos - lastPos));

	and	esi, -2
	mov	DWORD PTR $T1[rsp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

	mov	rdx, QWORD PTR $T2[rsp+24]
	cmp	rdx, 8

; 3987 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN224@tokenize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx*2+2]
	mov	rcx, QWORD PTR $T2[rsp]
	mov	rax, rcx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN223@tokenize

; 115  : 	_Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN220@tokenize
$LN223@tokenize:

; 207  : 	::operator delete(_Ptr, _Bytes);

	vzeroupper
	call	??3@YAXPEAX_K@Z				; operator delete
$LN224@tokenize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

	mov	QWORD PTR $T2[rsp+16], r13

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T2[rsp+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T2[rsp], r13w
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

	mov	rsi, r15

; 1825 : 		return (_BUF_SIZE <= _Myres);

	mov	r13, QWORD PTR [r15+24]
	cmp	r13, 8

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN249@tokenize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	rsi, QWORD PTR [r15]
$LN249@tokenize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

	mov	r14, r12

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [r12+24], 8

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN256@tokenize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	r14, QWORD PTR [r12]
$LN256@tokenize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3675 : 		return (static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,

	mov	r15, QWORD PTR [r15+16]
	mov	r12, QWORD PTR [r12+16]

; 354  : 	if (_Start_at < _Hay_size)

	cmp	rbx, r12
	jae	$LN264@tokenize
	xor	edx, edx
	mov	r8d, 256				; 00000100H
	lea	rcx, QWORD PTR _Matches$4[rsp]
	vzeroupper
	call	memset

; 355  : 		{	// room for match, look for it
; 356  : 		_String_bitmap<typename _Traits::char_type> _Matches;
; 357  : 		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))

	mov	rcx, rsi
	lea	rdx, QWORD PTR [rsi+r15*2]

; 198  : 		for (; _First != _Last; ++_First)

	mov	r8d, 256				; 00000100H
	cmp	rsi, rdx
	je	SHORT $LN267@tokenize
$LL275@tokenize:

; 199  : 			{
; 200  : 			const auto _Ch = *_First;

	movzx	eax, WORD PTR [rcx]

; 201  : 			if (_Ch >= 256U)

	cmp	ax, r8w
	jae	SHORT $LN402@tokenize

; 202  : 				{
; 203  : 				return (false);
; 204  : 				}
; 205  : 
; 206  : 			_Matches[static_cast<unsigned char>(_Ch)] = true;

	movzx	eax, al
	mov	BYTE PTR _Matches$4[rsp+rax], 1

; 198  : 		for (; _First != _Last; ++_First)

	add	rcx, 2
	cmp	rcx, rdx
	jne	SHORT $LL275@tokenize
$LN267@tokenize:

; 363  : 		const auto _End = _Haystack + _Hay_size;

	lea	rcx, QWORD PTR [r14+r12*2]

; 364  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	rdi, QWORD PTR [r14+rbx*2]
$LN419@tokenize:

; 365  : 			{
; 366  : 			if (!_Matches._Match(*_Match_try))

	cmp	rdi, rcx
	jae	SHORT $LN264@tokenize
	movzx	eax, WORD PTR [rdi]

; 214  : 		return (_Ch < 256U && _Matches[_Ch]);

	cmp	ax, r8w
	jae	SHORT $LN369@tokenize
	movzx	eax, ax
	cmp	BYTE PTR _Matches$4[rsp+rax], 0
	je	SHORT $LN369@tokenize

; 364  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	rdi, 2
	jmp	SHORT $LN419@tokenize
$LN402@tokenize:

; 335  : 		const auto _End = _Haystack + _Hay_size;

	lea	r8, QWORD PTR [r14+r12*2]

; 336  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	rdi, QWORD PTR [r14+rbx*2]
$LN417@tokenize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 339  : 		return (reinterpret_cast<const _Elem *>(_CSTD wmemchr(

	cmp	rdi, r8
	jae	SHORT $LN264@tokenize
	mov	rcx, r15
	mov	rax, rsi
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 203  :         for (; 0 < _N; ++_S, --_N)

	test	r15, r15
	je	SHORT $LN369@tokenize

; 204  :             if (*_S == _C)

	movzx	edx, WORD PTR [rdi]
$LL290@tokenize:
	cmp	WORD PTR [rax], dx
	je	SHORT $LN367@tokenize

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rax, 2
	sub	rcx, 1
	jne	SHORT $LL290@tokenize
$LN369@tokenize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

	sub	rdi, r14
	sar	rdi, 1
	jmp	SHORT $LN262@tokenize
$LN367@tokenize:

; 336  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	rdi, 2
	jmp	SHORT $LN417@tokenize
$LN264@tokenize:

; 1814 : 		const value_type * _Result = _Bx._Buf;

	mov	rdi, -1
$LN262@tokenize:
	mov	rax, QWORD PTR delimiters$[rbp-256]
	mov	rsi, rax

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	r13, 8

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN308@tokenize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	rsi, QWORD PTR [rax]
$LN308@tokenize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

	mov	rax, QWORD PTR str$[rbp-256]
	mov	r14, rax

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rax+24], 8

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN315@tokenize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	r14, QWORD PTR [rax]
$LN315@tokenize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 248  : 	if (_Needle_size != 0 && _Start_at < _Hay_size)

	test	r15, r15
	je	$LN323@tokenize
	cmp	rdi, r12
	jae	$LN323@tokenize

; 249  : 		{	// room for match, look for it
; 250  : 		_String_bitmap<typename _Traits::char_type> _Matches;
; 251  : 		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))

	mov	r13d, 256				; 00000100H
	mov	r8d, r13d
	xor	edx, edx
	lea	rcx, QWORD PTR _Matches$5[rbp-256]
	vzeroupper
	call	memset
	mov	rcx, rsi
	lea	rdx, QWORD PTR [rsi+r15*2]

; 198  : 		for (; _First != _Last; ++_First)

	cmp	rsi, rdx
	je	SHORT $LN326@tokenize
$LL334@tokenize:

; 199  : 			{
; 200  : 			const auto _Ch = *_First;

	movzx	eax, WORD PTR [rcx]

; 201  : 			if (_Ch >= 256U)

	cmp	ax, r13w
	jae	SHORT $LN403@tokenize

; 202  : 				{
; 203  : 				return (false);
; 204  : 				}
; 205  : 
; 206  : 			_Matches[static_cast<unsigned char>(_Ch)] = true;

	movzx	eax, al
	mov	BYTE PTR _Matches$5[rbp+rax-256], 1

; 198  : 		for (; _First != _Last; ++_First)

	add	rcx, 2
	cmp	rcx, rdx
	jne	SHORT $LL334@tokenize
$LN326@tokenize:

; 257  : 		const auto _End = _Haystack + _Hay_size;

	lea	rcx, QWORD PTR [r14+r12*2]

; 258  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	rbx, QWORD PTR [r14+rdi*2]
$LN423@tokenize:

; 259  : 			{
; 260  : 			if (_Matches._Match(*_Match_try))

	cmp	rbx, rcx
	jae	SHORT $LN323@tokenize
	movzx	eax, WORD PTR [rbx]

; 214  : 		return (_Ch < 256U && _Matches[_Ch]);

	cmp	ax, r13w
	jae	SHORT $LN354@tokenize
	movzx	eax, ax
	cmp	BYTE PTR _Matches$5[rbp+rax-256], 0
	jne	SHORT $LN373@tokenize
$LN354@tokenize:

; 258  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	rbx, 2
	jmp	SHORT $LN423@tokenize
$LN403@tokenize:

; 229  : 		const auto _End = _Haystack + _Hay_size;

	lea	r8, QWORD PTR [r14+r12*2]

; 230  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	rbx, QWORD PTR [r14+rdi*2]
$LN421@tokenize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 339  : 		return (reinterpret_cast<const _Elem *>(_CSTD wmemchr(

	cmp	rbx, r8
	jae	SHORT $LN323@tokenize
	mov	rcx, r15
	mov	rax, rsi
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 203  :         for (; 0 < _N; ++_S, --_N)

	test	r15, r15
	je	SHORT $LN348@tokenize

; 204  :             if (*_S == _C)

	movzx	edx, WORD PTR [rbx]
	npad	4
$LL349@tokenize:
	cmp	WORD PTR [rax], dx
	je	SHORT $LN373@tokenize

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rax, 2
	sub	rcx, 1
	jne	SHORT $LL349@tokenize
$LN348@tokenize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 230  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	rbx, 2
	jmp	SHORT $LN421@tokenize
$LN373@tokenize:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 522  : 	}

	sub	rbx, r14
	sar	rbx, 1
	jmp	SHORT $LN321@tokenize
$LN323@tokenize:
	mov	rbx, -1
$LN321@tokenize:
	mov	r12, QWORD PTR str$[rbp-256]
	mov	r15, QWORD PTR delimiters$[rbp-256]
	mov	esi, DWORD PTR $T1[rsp]
	mov	r14, QWORD PTR tokens$[rbp-256]
	xor	r13d, r13d
	jmp	$LL2@tokenize
$LN220@tokenize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	vzeroupper
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@tokenize:
	vzeroupper
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 523  : }

	mov	rbx, QWORD PTR [rsp+680]
	add	rsp, 592				; 00000250H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN374@tokenize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1832 : 			_Xran();

	vzeroupper
	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	int	3
$LN415@tokenize:
?tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z ENDP ; tokenize
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 72
_Matches$4 = 80
_Matches$5 = 336
str$ = 656
tokens$ = 664
delimiters$ = 672
?dtor$1@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA PROC ; `tokenize'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN10@dtor$1
	and	DWORD PTR $T1[rbp], -2
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN10@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA ENDP ; `tokenize'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 72
_Matches$4 = 80
_Matches$5 = 336
str$ = 656
tokens$ = 664
delimiters$ = 672
?dtor$1@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA PROC ; `tokenize'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN10@dtor$1
	and	DWORD PTR $T1[rbp], -2
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN10@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??tokenize@@YAXAEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAV?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@0@Z@4HA ENDP ; `tokenize'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z
_TEXT	SEGMENT
low$ = 240
high$ = 248
id$ = 256
pos$ = 264
total$ = 272
tv790 = 280
arr$ = 280
tv803 = 288
size$ = 288
var$ = 296
rand$ = 304
?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z PROC ; rowcol, COMDAT

; 326  : static int rowcol(float& low, float& high, int& id, float pos, float total, std::vector<float>& arr, float size, float var, float rand) {

	mov	rax, rsp
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 192				; 000000c0H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	r15, QWORD PTR arr$[rsp]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 326  : static int rowcol(float& low, float& high, int& id, float pos, float total, std::vector<float>& arr, float size, float var, float rand) {

	mov	r14, r8
	vmovaps	XMMWORD PTR [rax-56], xmm6
	mov	rdi, rdx
	vmovaps	XMMWORD PTR [rax-72], xmm7
	mov	rsi, rcx
	vmovaps	XMMWORD PTR [rax-88], xmm8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	r9, QWORD PTR [r15]
	mov	rax, QWORD PTR [r15+8]
	sub	rax, r9
	vmovaps	XMMWORD PTR [rsp+96], xmm11
	sar	rax, 2
	vxorps	xmm4, xmm4, xmm4
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 326  : static int rowcol(float& low, float& high, int& id, float pos, float total, std::vector<float>& arr, float size, float var, float rand) {

	vmovaps	xmm11, xmm3

; 327  : 	float num = arr.size();

	vcvtsi2ss xmm4, xmm4, rax
	test	rax, rax
	jns	SHORT $LN103@rowcol
	vaddss	xmm4, xmm4, DWORD PTR __real@5f800000
$LN103@rowcol:

; 328  : 	float h = total * size;

	vmovss	xmm7, DWORD PTR size$[rsp]
	vmulss	xmm2, xmm7, DWORD PTR total$[rsp]

; 329  : 	float y = pos / h;

	vdivss	xmm1, xmm11, xmm2
	vcvttss2si ecx, xmm1
	vxorps	xmm8, xmm8, xmm8

; 330  : 	float yi = float(FASTFLOOR(y)); // group ID

	vcomiss	xmm8, xmm1
	vxorps	xmm5, xmm5, xmm5
	lea	eax, DWORD PTR [rcx-1]
	mov	QWORD PTR [rsp+248], r12
	cmovbe	eax, ecx

; 331  : 	y = pos - yi * h; // pos within group
; 332  : 
; 333  : 	float sumY = 0.f;
; 334  : 	float tileHeight = 0.f;
; 335  : 	int cur = 0;	

	xor	ebx, ebx

; 336  : 	while (cur < num) {		

	vcomiss	xmm4, xmm8
	vcvtsi2ss xmm5, xmm5, eax
	vmulss	xmm2, xmm5, xmm2
	vsubss	xmm1, xmm11, xmm2
	vxorps	xmm3, xmm3, xmm3
	vxorps	xmm6, xmm6, xmm6
	jbe	SHORT $LN102@rowcol
$LL2@rowcol:

; 337  : 		tileHeight = arr[cur] * size;

	vmulss	xmm6, xmm7, DWORD PTR [r9]

; 338  : 		if (y < sumY + tileHeight)

	vaddss	xmm0, xmm6, xmm3
	vcomiss	xmm0, xmm1
	ja	SHORT $LN98@rowcol

; 339  : 			break;		
; 340  : 		sumY += tileHeight;

	vmovaps	xmm3, xmm0

; 341  : 		cur++;

	inc	ebx
	add	r9, 4
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, ebx
	vcomiss	xmm4, xmm0
	ja	SHORT $LL2@rowcol
$LN98@rowcol:

; 342  : 	}
; 343  : 	if (cur < 0 || cur >= num) // Necessary due floating point error

	test	ebx, ebx
	js	$LN6@rowcol
$LN102@rowcol:
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, ebx
	vcomiss	xmm1, xmm4
	mov	r12d, ebx
	jae	$LN6@rowcol

; 345  : 
; 346  : 	id = yi * num + cur;

	mov	QWORD PTR [rsp+240], rbp
	mov	QWORD PTR [rsp+256], r13
	vmovaps	XMMWORD PTR [rsp+128], xmm9
	vmovaps	XMMWORD PTR [rsp+112], xmm10

; 347  : 
; 348  : 	// Variance
; 349  : 	// ----------- To determine max var
; 350  : 	// ----------- If we rose
; 351  : 	// ----------- eTop -> neTop
; 352  : 	//    x
; 353  : 	// ----------- eBot -> neBot
; 354  : 	// ----------- If we droped
; 355  : 	// ----------- To determine max var
; 356  : 
; 357  : 	float eBot = yi * h + sumY;	
; 358  : 	float eTop = eBot + tileHeight;
; 359  : 
; 360  : 	if (var > 0.0001f) {

	vmovss	xmm10, DWORD PTR var$[rsp]
	vcomiss	xmm10, DWORD PTR __real@38d1b717
	vmovaps	XMMWORD PTR [rsp+80], xmm12
	vmovaps	XMMWORD PTR [rsp+64], xmm13
	vmulss	xmm0, xmm5, xmm4
	vaddss	xmm1, xmm0, xmm1
	vcvttss2si eax, xmm1
	vaddss	xmm9, xmm2, xmm3
	vmovaps	XMMWORD PTR [rsp+48], xmm14
	vmovaps	XMMWORD PTR [rsp+32], xmm15
	mov	DWORD PTR [r8], eax
	vaddss	xmm12, xmm9, xmm6
	jbe	$LN7@rowcol
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

	mov	rcx, QWORD PTR [r15]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 35   : 	if (n-1 < 0) return m-1;

	lea	edx, DWORD PTR [rbx-1]
	vmovss	xmm1, DWORD PTR rand$[rsp]

; 361  : 		float n;
; 362  : 		
; 363  : 		float bTileHeight = arr[STEPDOWN(cur, num)]*size;

	test	edx, edx

; 35   : 	if (n-1 < 0) return m-1;

	mov	DWORD PTR tv803[rsp], edx
	vcvttss2si ebp, xmm4

; 361  : 		float n;
; 362  : 		
; 363  : 		float bTileHeight = arr[STEPDOWN(cur, num)]*size;

	mov	eax, ebp
	cmovns	eax, ebx
	cdqe

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm1, xmm1, xmm1
	vcvtss2sd xmm0, xmm9, xmm9
	vmulsd	xmm0, xmm0, QWORD PTR __real@403f666666666666

; 361  : 		float n;
; 362  : 		
; 363  : 		float bTileHeight = arr[STEPDOWN(cur, num)]*size;

	vmulss	xmm14, xmm7, DWORD PTR [rcx+rax*4-4]

; 28   : 	return (n + 1) % m;

	lea	eax, DWORD PTR [rbx+1]
	cdq
	idiv	ebp

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vmovsd	QWORD PTR tv790[rsp], xmm1

; 28   : 	return (n + 1) % m;

	movsxd	r13, edx

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vaddsd	xmm1, xmm0, xmm1
	vcvtsd2ss xmm0, xmm1, xmm1

; 364  : 		float tTileHeight = arr[STEPUP(cur, num)]*size;

	vmulss	xmm13, xmm7, DWORD PTR [rcx+r13*4]

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 365  : 
; 366  : 		n = noise(eBot, rand);
; 367  : 		float neBot = eBot + (n>0 ? tileHeight : bTileHeight) * n * var;		

	vcmpltss xmm1, xmm8, xmm0
	vblendvps xmm1, xmm14, xmm6, xmm1
	vmulss	xmm0, xmm1, xmm0
	vmulss	xmm2, xmm0, xmm10

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm1, xmm12, xmm12
	vmulsd	xmm0, xmm1, QWORD PTR __real@403f666666666666

; 365  : 
; 366  : 		n = noise(eBot, rand);
; 367  : 		float neBot = eBot + (n>0 ? tileHeight : bTileHeight) * n * var;		

	vaddss	xmm15, xmm2, xmm9

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vaddsd	xmm2, xmm0, QWORD PTR tv790[rsp]
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 368  : 		n = noise(eTop, rand);
; 369  : 		float neTop = eTop + (n<0 ? tileHeight : tTileHeight) * n * var;
; 370  : 
; 371  : 		if (pos < neBot) { // We droped one cur down

	vcomiss	xmm15, xmm11
	vcmpltss xmm1, xmm0, xmm8
	vblendvps xmm1, xmm13, xmm6, xmm1
	vmulss	xmm0, xmm1, xmm0
	vmulss	xmm2, xmm0, xmm10
	vaddss	xmm6, xmm2, xmm12
	jbe	SHORT $LN9@rowcol

; 372  : 			id--;

	dec	DWORD PTR [r14]

; 373  : 			cur = STEPDOWN(cur, num);
; 374  : 			low = eBot-bTileHeight;

	mov	ebx, ebp
	cmp	DWORD PTR tv803[rsp], 0
	vsubss	xmm0, xmm9, xmm14
	vmovss	DWORD PTR [rsi], xmm0

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm1, xmm0, QWORD PTR __real@403f666666666666
	vaddsd	xmm2, xmm1, QWORD PTR tv790[rsp]

; 373  : 			cur = STEPDOWN(cur, num);
; 374  : 			low = eBot-bTileHeight;

	cmovge	ebx, r12d

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtsd2ss xmm0, xmm2, xmm2

; 373  : 			cur = STEPDOWN(cur, num);
; 374  : 			low = eBot-bTileHeight;

	dec	ebx

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 375  : 			n = noise(low, rand);
; 376  : 			low += (n>0 ? bTileHeight : arr[STEPDOWN(cur, num)]*size) * n * var;

	vcomiss	xmm0, xmm8
	ja	SHORT $LN17@rowcol

; 35   : 	if (n-1 < 0) return m-1;

	lea	eax, DWORD PTR [rbx-1]

; 375  : 			n = noise(low, rand);
; 376  : 			low += (n>0 ? bTileHeight : arr[STEPDOWN(cur, num)]*size) * n * var;

	test	eax, eax
	mov	rax, QWORD PTR [r15]
	cmovns	ebp, ebx
	movsxd	rcx, ebp
	vmulss	xmm14, xmm7, DWORD PTR [rax+rcx*4-4]
$LN17@rowcol:
	vmulss	xmm0, xmm14, xmm0
	vmulss	xmm1, xmm0, xmm10
	vaddss	xmm2, xmm1, DWORD PTR [rsi]
	vmovss	DWORD PTR [rsi], xmm2

; 377  : 			high = neBot;				

	vmovss	DWORD PTR [rdi], xmm15
	jmp	SHORT $LN8@rowcol
$LN9@rowcol:

; 378  : 
; 379  : 		} else if (pos > neTop) { // We rose one cur up

	vcomiss	xmm11, xmm6
	jbe	SHORT $LN11@rowcol

; 380  : 			id++;

	inc	DWORD PTR [r14]

; 381  : 			cur = STEPUP(cur, num);

	mov	ebx, r13d

; 382  : 			high = eTop+tTileHeight;

	vaddss	xmm0, xmm13, xmm12
	vmovss	DWORD PTR [rdi], xmm0

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm1, xmm0, QWORD PTR __real@403f666666666666
	vaddsd	xmm2, xmm1, QWORD PTR tv790[rsp]
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 383  : 			n = noise(high, rand);
; 384  : 			high += (n<0 ? tTileHeight : arr[STEPUP(cur, num)]*size) * n * var;

	vcomiss	xmm8, xmm0
	ja	SHORT $LN19@rowcol

; 28   : 	return (n + 1) % m;

	lea	eax, DWORD PTR [r13+1]
	cdq
	idiv	ebp

; 383  : 			n = noise(high, rand);
; 384  : 			high += (n<0 ? tTileHeight : arr[STEPUP(cur, num)]*size) * n * var;

	mov	rax, QWORD PTR [r15]
	movsxd	rcx, edx
	vmulss	xmm13, xmm7, DWORD PTR [rax+rcx*4]
$LN19@rowcol:
	vmulss	xmm0, xmm13, xmm0
	vmulss	xmm1, xmm0, xmm10
	vaddss	xmm2, xmm1, DWORD PTR [rdi]
	vmovss	DWORD PTR [rdi], xmm2

; 385  : 			low = neTop;		

	vmovss	DWORD PTR [rsi], xmm6

; 386  : 
; 387  : 		} else { // Still in the same cur

	jmp	SHORT $LN8@rowcol
$LN11@rowcol:

; 388  : 			low = neBot;

	vmovss	DWORD PTR [rsi], xmm15

; 389  : 			high = neTop;				

	vmovss	DWORD PTR [rdi], xmm6

; 390  : 		}
; 391  : 	} else {

	jmp	SHORT $LN8@rowcol
$LN7@rowcol:

; 392  : 		low = eBot;

	vmovss	DWORD PTR [rsi], xmm9

; 393  : 		high = eTop;

	vmovss	DWORD PTR [rdx], xmm12
$LN8@rowcol:

; 394  : 	}
; 395  : 
; 396  : 	return cur;

	vmovaps	xmm15, XMMWORD PTR [rsp+32]
	mov	eax, ebx
	vmovaps	xmm14, XMMWORD PTR [rsp+48]
	vmovaps	xmm13, XMMWORD PTR [rsp+64]
	vmovaps	xmm12, XMMWORD PTR [rsp+80]
	vmovaps	xmm10, XMMWORD PTR [rsp+112]
	vmovaps	xmm9, XMMWORD PTR [rsp+128]
	mov	r13, QWORD PTR [rsp+256]
	mov	rbp, QWORD PTR [rsp+240]
	jmp	SHORT $LN1@rowcol
$LN6@rowcol:

; 344  : 		return -1;

	mov	eax, -1
$LN1@rowcol:
	mov	r12, QWORD PTR [rsp+248]

; 397  : }

	lea	r11, QWORD PTR [rsp+192]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm11, XMMWORD PTR [r11-96]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z ENDP ; rowcol
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?offsetEdges@@YAXQEAMMM@Z
_TEXT	SEGMENT
edges$ = 8
x$ = 16
y$ = 24
?offsetEdges@@YAXQEAMMM@Z PROC				; offsetEdges, COMDAT

; 262  : 	edges[0] += x;

	vaddss	xmm0, xmm1, DWORD PTR [rcx]
	vmovss	DWORD PTR [rcx], xmm0

; 263  : 	edges[2] += x;

	vaddss	xmm0, xmm1, DWORD PTR [rcx+8]
	vmovss	DWORD PTR [rcx+8], xmm0

; 264  : 	edges[3] += y;

	vaddss	xmm0, xmm2, DWORD PTR [rcx+12]
	vmovss	DWORD PTR [rcx+12], xmm0

; 265  : 	edges[1] += y;

	vaddss	xmm0, xmm2, DWORD PTR [rcx+4]
	vmovss	DWORD PTR [rcx+4], xmm0

; 266  : }

	ret	0
?offsetEdges@@YAXQEAMMM@Z ENDP				; offsetEdges
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?getAngle@@YAMHM@Z
_TEXT	SEGMENT
type$ = 64
amount$ = 72
?getAngle@@YAMHM@Z PROC					; getAngle, COMDAT

; 123  : inline static float getAngle(int type, float amount) {

	sub	rsp, 56					; 00000038H
	vmovaps	XMMWORD PTR [rsp+32], xmm6
	vmovaps	xmm6, xmm1

; 124  : 	switch (type) {

	test	ecx, ecx
	je	$LN6@getAngle
	sub	ecx, 1
	je	$LN7@getAngle
	cmp	ecx, 1
	jne	SHORT $LN4@getAngle

; 130  : 			return 0.f;
; 131  : 		case 2: // 90
; 132  : 			switch (rand() % 4) {

	call	QWORD PTR __imp_rand
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN18@getAngle
	dec	eax
	or	eax, -4
	inc	eax
$LN18@getAngle:
	test	eax, eax
	je	$LN6@getAngle
	sub	eax, 1
	je	SHORT $LN11@getAngle
	sub	eax, 1
	je	SHORT $LN16@getAngle
	cmp	eax, 1
	jne	SHORT $LN4@getAngle

; 137  : 				case 2:
; 138  : 					return (float)pi;
; 139  : 				case 3:
; 140  : 					return (float)pi*1.5f;

	vmovss	xmm0, DWORD PTR __real@4096cbe4

; 144  : 	}
; 145  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 56					; 00000038H
	ret	0
$LN11@getAngle:

; 133  : 				case 0:
; 134  : 					return 0.f;
; 135  : 				case 1: 
; 136  : 					return (float)pi*.5f;

	vmovss	xmm0, DWORD PTR __real@3fc90fdb

; 144  : 	}
; 145  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 56					; 00000038H
	ret	0
$LN4@getAngle:

; 141  : 			}			
; 142  : 		default: // Amount	
; 143  : 			return UFRAND() * amount;

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm1, xmm0, QWORD PTR __real@40dfffc000000000
	vaddsd	xmm2, xmm1, xmm1
	vsubsd	xmm3, xmm2, QWORD PTR __real@3ff0000000000000
	vcvtss2sd xmm0, xmm6, xmm6
	vmulsd	xmm1, xmm3, xmm0
	vcvtsd2ss xmm0, xmm1, xmm1

; 144  : 	}
; 145  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 56					; 00000038H
	ret	0
$LN7@getAngle:

; 125  : 		case 0:
; 126  : 			return 0.f;
; 127  : 		case 1: // 180
; 128  : 			if (rand() % 2)

	call	QWORD PTR __imp_rand
	and	eax, -2147483647			; ffffffff80000001H
	jge	SHORT $LN17@getAngle
	dec	eax
	or	eax, -2
	inc	eax
$LN17@getAngle:
	test	eax, eax
	je	SHORT $LN6@getAngle
$LN16@getAngle:

; 129  : 				return (float)pi;

	vmovss	xmm0, DWORD PTR __real@40490fdb

; 144  : 	}
; 145  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 56					; 00000038H
	ret	0
$LN6@getAngle:
	vmovaps	xmm6, XMMWORD PTR [rsp+32]
	vxorps	xmm0, xmm0, xmm0
	add	rsp, 56					; 00000038H
	ret	0
?getAngle@@YAMHM@Z ENDP					; getAngle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?STEPDOWN@@YAHHH@Z
_TEXT	SEGMENT
n$ = 8
m$ = 16
?STEPDOWN@@YAHHH@Z PROC					; STEPDOWN, COMDAT

; 35   : 	if (n-1 < 0) return m-1;

	lea	eax, DWORD PTR [rcx-1]
	test	eax, eax
	jns	SHORT $LN2@STEPDOWN
	lea	eax, DWORD PTR [rdx-1]
$LN2@STEPDOWN:

; 36   : 	return n-1;
; 37   : }

	ret	0
?STEPDOWN@@YAHHH@Z ENDP					; STEPDOWN
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?rotate270@@YAXAEAM0@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
?rotate270@@YAXAEAM0@Z PROC				; rotate270, COMDAT

; 32   : inline static void rotate270(float& x, float& y) { float temp = x; x = y; y = -temp; }

	vmovss	xmm0, DWORD PTR [rcx]
	mov	eax, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	DWORD PTR [rcx], eax
	vmovss	DWORD PTR [rdx], xmm0
	ret	0
?rotate270@@YAXAEAM0@Z ENDP				; rotate270
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?rotate90@@YAXAEAM0@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
?rotate90@@YAXAEAM0@Z PROC				; rotate90, COMDAT

; 31   : inline static void rotate90(float& x, float& y)  { float temp = y; y = x; x = -temp; }

	vmovss	xmm0, DWORD PTR [rdx]
	mov	eax, DWORD PTR [rcx]
	vxorps	xmm0, xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	DWORD PTR [rdx], eax
	vmovss	DWORD PTR [rcx], xmm0
	ret	0
?rotate90@@YAXAEAM0@Z ENDP				; rotate90
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?STEPUP@@YAHHH@Z
_TEXT	SEGMENT
n$ = 8
m$ = 16
?STEPUP@@YAHHH@Z PROC					; STEPUP, COMDAT

; 27   : inline static int STEPUP(int n, int m) {

	mov	r8d, edx

; 28   : 	return (n + 1) % m;

	lea	eax, DWORD PTR [rcx+1]
	cdq
	idiv	r8d
	mov	eax, edx

; 29   : }

	ret	0
?STEPUP@@YAHHH@Z ENDP					; STEPUP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?noise@@YAMMM@Z
_TEXT	SEGMENT
x$ = 8
rand$ = 16
?noise@@YAMMM@Z PROC					; noise, COMDAT

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm2, xmm0, xmm0
	vmulsd	xmm3, xmm2, QWORD PTR __real@403f666666666666
	vcvtss2sd xmm0, xmm1, xmm1
	vaddsd	xmm1, xmm3, xmm0
	vcvtsd2ss xmm0, xmm1, xmm1
	jmp	?snoise@Perlin@@SAMM@Z			; Perlin::snoise
?noise@@YAMMM@Z ENDP					; noise
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?generateID@@YAHHH@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
?generateID@@YAHHH@Z PROC				; generateID, COMDAT

; 23   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	lea	eax, DWORD PTR [rdx-101]
	imul	eax, eax, 1000				; 000003e8H
	add	eax, ecx
	ret	0
?generateID@@YAHHH@Z ENDP				; generateID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
_TEXT	SEGMENT
$T2 = 80
$T3 = 80
edges$4 = 96
edges$5 = 96
__$ReturnUdt$ = 224
p$ = 232
id$6 = 240
t$ = 240
id2$7 = 248
?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z PROC ; Tile::draw, COMDAT

; 508  : TilePoint Tile::draw(Point3 p, TileParam& t) {	

$LN82:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	push	rbp
	push	rsi
	push	rdi
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 192				; 000000c0H

; 509  : 	if (t.tilingType == 1)

	cmp	DWORD PTR [r8], 1
	mov	rsi, r8
	vmovaps	XMMWORD PTR [rax-40], xmm6
	mov	rbx, rcx
	vmovaps	XMMWORD PTR [rax-56], xmm7
	vmovss	xmm7, DWORD PTR [rdx]
	vmovaps	XMMWORD PTR [rax-72], xmm8
	vmovss	xmm8, DWORD PTR [rdx+4]
	vmovaps	XMMWORD PTR [rax-88], xmm9
	vmovss	xmm9, DWORD PTR [rdx+8]
	jne	$LN2@draw

; 459  : 	float s = t.tileWidth * 2.f;	

	vmovss	xmm6, DWORD PTR [r8+8]

; 460  : 	float h = t.tileWidth * .5f;

	vmulss	xmm4, xmm6, DWORD PTR __real@3f000000
	vaddss	xmm3, xmm6, xmm6
	vxorps	xmm1, xmm1, xmm1

; 461  : 	float x = p.x / s;

	vdivss	xmm0, xmm7, xmm3

; 462  : 	float y = p.y / s;
; 463  : 	int xi = FASTFLOOR(x);
; 464  : 	int yi = FASTFLOOR(y);

	vcomiss	xmm1, xmm0
	vmovaps	XMMWORD PTR [rax-104], xmm11
	vcvttss2si eax, xmm0
	vdivss	xmm2, xmm8, xmm3
	vxorps	xmm0, xmm0, xmm0
	lea	r8d, DWORD PTR [rax-1]
	cmovbe	r8d, eax

; 465  : 	x = xi * s;

	vcomiss	xmm1, xmm2
	vcvttss2si eax, xmm2
	vcvtsi2ss xmm0, xmm0, r8d
	vxorps	xmm1, xmm1, xmm1
	vmulss	xmm5, xmm0, xmm3
	lea	r9d, DWORD PTR [rax-1]
	cmovbe	r9d, eax

; 466  : 	y = yi * s;

	vcvtsi2ss xmm1, xmm1, r9d
	vmulss	xmm11, xmm1, xmm3

; 468  : 	int y_id = (int)((p.y - y) / h) % 4;	

	vsubss	xmm0, xmm8, xmm11
	vdivss	xmm2, xmm0, xmm4
	vcvttss2si ecx, xmm2
	and	ecx, -2147483645			; ffffffff80000003H
	jge	SHORT $LN77@draw
	dec	ecx
	or	ecx, -4
	inc	ecx
$LN77@draw:

; 467  : 	int x_id = (int)((p.x - x) / h) % 4;

	vsubss	xmm0, xmm7, xmm5
	vdivss	xmm1, xmm0, xmm4
	vcvttss2si eax, xmm1
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN76@draw
	dec	eax
	or	eax, -4
	inc	eax
$LN76@draw:

; 469  : 	int id = x_id + 4 * y_id;
; 470  : 
; 471  : 	//Point3 center = Point3(pat_herring_x[id]*h+x, pat_herring_y[id]*h+y, p.z);
; 472  : 
; 473  : 	float edges[4];
; 474  : 
; 475  : 	if (!pat_herring_dir[id]) {

	lea	r10, OFFSET FLAT:__ImageBase
	xor	edi, edi
	lea	eax, DWORD PTR [rax+rcx*4]
	movsxd	rcx, eax
	movzx	edx, BYTE PTR ?pat_herring_dir@@3PAEA[rcx+r10]
	vmovss	xmm0, DWORD PTR ?pat_herring_x@@3PAMA[r10+rcx*4]
	vmovss	xmm3, DWORD PTR ?pat_herring_y@@3PAMA[r10+rcx*4]
	test	dl, dl
	jne	SHORT $LN7@draw

; 476  : 		edges[0] = (pat_herring_x[id]-1.f) * h + x;

	vsubss	xmm0, xmm0, DWORD PTR __real@3f800000
	vmulss	xmm1, xmm0, xmm4
	vaddss	xmm2, xmm1, xmm5

; 477  : 		edges[2] = edges[0] + t.tileWidth;
; 478  : 		edges[3] = (pat_herring_y[id]-.5f) * h + y;

	vsubss	xmm1, xmm3, DWORD PTR __real@3f000000
	vaddss	xmm0, xmm6, xmm2
	vmovss	DWORD PTR edges$5[rbp-113], xmm0
	vmovss	DWORD PTR edges$5[rbp-121], xmm2
	vmulss	xmm2, xmm1, xmm4
	vaddss	xmm0, xmm2, xmm11
	vmovss	DWORD PTR edges$5[rbp-109], xmm0

; 482  : 		edges[2] = edges[0] + h;
; 483  : 		edges[3] = (pat_herring_y[id]-1.f) * h + y;
; 484  : 		edges[1] = edges[3] + t.tileWidth;	
; 485  : 	}
; 486  : 
; 487  : 	int tid = generateID(xi*4 + (pat_herring_dir[id] ? 0 : pat_herring_id[id]),

	mov	eax, edi
	movzx	edi, BYTE PTR ?pat_herring_id@@3PAEA[rcx+r10]
	vaddss	xmm0, xmm0, xmm4
	jmp	SHORT $LN78@draw
$LN7@draw:

; 479  : 		edges[1] = edges[3] + h;
; 480  : 	} else {
; 481  : 		edges[0] = (pat_herring_x[id]-.5f) * h + x;

	vsubss	xmm0, xmm0, DWORD PTR __real@3f000000

; 482  : 		edges[2] = edges[0] + h;
; 483  : 		edges[3] = (pat_herring_y[id]-1.f) * h + y;
; 484  : 		edges[1] = edges[3] + t.tileWidth;	
; 485  : 	}
; 486  : 
; 487  : 	int tid = generateID(xi*4 + (pat_herring_dir[id] ? 0 : pat_herring_id[id]),

	movzx	eax, BYTE PTR ?pat_herring_id@@3PAEA[rcx+r10]
	vmulss	xmm1, xmm0, xmm4
	vaddss	xmm2, xmm1, xmm5
	vsubss	xmm1, xmm3, DWORD PTR __real@3f800000
	vaddss	xmm0, xmm2, xmm4
	vmovss	DWORD PTR edges$5[rbp-113], xmm0
	vmovss	DWORD PTR edges$5[rbp-121], xmm2
	vmulss	xmm2, xmm1, xmm4
	vaddss	xmm0, xmm2, xmm11
	vmovss	DWORD PTR edges$5[rbp-109], xmm0
	vaddss	xmm0, xmm6, xmm0
$LN78@draw:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	lea	eax, DWORD PTR [rax+r9*4]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 490  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	movzx	edx, dl
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	add	eax, -101				; ffffffffffffff9bH
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 490  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	mov	DWORD PTR [rsp+40], edx

; 23   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	imul	ecx, eax, 250				; 000000faH

; 490  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	lea	rdx, QWORD PTR $T3[rbp-121]
	mov	r9, rsi
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR edges$5[rbp-117], xmm0
	vmovss	DWORD PTR $T3[rbp-121], xmm7
	vmovss	DWORD PTR $T3[rbp-117], xmm8
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 23   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	add	ecx, r8d

; 490  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	lea	r8, QWORD PTR edges$5[rbp-121]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T3[rbp-113], xmm9
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 23   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	lea	eax, DWORD PTR [rdi+rcx*4]

; 490  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	mov	rcx, rbx
	mov	DWORD PTR [rsp+32], eax
	call	?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z ; Tile::drawTile

; 510  : 		return pat_herring(p, t);

	vmovaps	xmm11, XMMWORD PTR [rsp+112]
	jmp	$LN79@draw
$LN2@draw:
	mov	QWORD PTR [rsp+224], r14

; 402  : 	if (!pat) return TilePoint();

	xor	edi, edi
	mov	r14, QWORD PTR [r8+112]
	test	r14, r14
	jne	SHORT $LN25@draw
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	mov	QWORD PTR [rcx], rdi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File g:\dropbox\github\berconmaps\src\tile.h

; 165  : 	TilePoint() {d = -1.f;}	

	mov	DWORD PTR [rcx+24], -1082130432		; bf800000H
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 402  : 	if (!pat) return TilePoint();

	jmp	$LN24@draw
$LN25@draw:

; 403  : 
; 404  : 	float edges[4];
; 405  : 	int id = 0;
; 406  : 	int id2 = 0;
; 407  : 	
; 408  : 	// Tile top and bottom
; 409  : 	float rand = 3.14f;
; 410  : 	int row = rowcol(edges[3], edges[1], id, p.y, pat->totalHeight, pat->heights, t.tileHeight, t.tileHeightVar, rand);

	vmovss	xmm1, DWORD PTR [r8+20]
	vmovss	xmm0, DWORD PTR __real@4048f5c3
	vmovss	DWORD PTR [rsp+64], xmm0
	vmovss	xmm0, DWORD PTR [r8+4]
	vmovss	DWORD PTR [rsp+56], xmm1
	vmovss	xmm1, DWORD PTR [r14]
	vmovss	DWORD PTR [rsp+48], xmm0
	lea	rax, QWORD PTR [r14+8]
	mov	DWORD PTR id$6[rbp-121], edi
	mov	QWORD PTR [rsp+40], rax
	lea	r8, QWORD PTR id$6[rbp-121]
	vmovaps	xmm3, xmm8
	lea	rdx, QWORD PTR edges$4[rbp-117]
	mov	DWORD PTR id2$7[rbp-121], edi
	lea	rcx, QWORD PTR edges$4[rbp-109]
	vmovss	DWORD PTR [rsp+32], xmm1
	call	?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z ; rowcol

; 411  : 	if (row == -1) return TilePoint();

	cmp	eax, -1
	jne	SHORT $LN26@draw
$LN80@draw:

; 511  : 	return pat_xBond(p, t);

	mov	QWORD PTR [rbx], rdi
	mov	QWORD PTR [rbx+8], rdi
	mov	QWORD PTR [rbx+16], rdi
	mov	DWORD PTR [rbx+24], -1082130432		; bf800000H
	jmp	$LN24@draw
$LN26@draw:

; 414  : 	rand = edges[3] * 1.325f + 31.41213f;

	vmovss	xmm0, DWORD PTR edges$4[rbp-109]
	vmulss	xmm1, xmm0, DWORD PTR __real@3fa9999a

; 415  : 	float offset = pat->rows[row].offset * t.tileWidth;

	mov	rdx, QWORD PTR [r14+32]
	vaddss	xmm2, xmm1, DWORD PTR __real@41fb4c0b
	vmovss	xmm1, DWORD PTR [rsi+8]

; 416  : 	if (offset < 0) offset *= -id;

	mov	r14d, DWORD PTR id$6[rbp-121]
	movsxd	rcx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

	shl	rcx, 5
	vxorps	xmm0, xmm0, xmm0
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 415  : 	float offset = pat->rows[row].offset * t.tileWidth;

	vmulss	xmm6, xmm1, DWORD PTR [rcx+rdx]

; 416  : 	if (offset < 0) offset *= -id;

	vcomiss	xmm0, xmm6
	jbe	SHORT $LN27@draw
	mov	eax, r14d
	neg	eax
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vmulss	xmm6, xmm6, xmm0
$LN27@draw:

; 417  : 
; 418  : 	row = rowcol(edges[0], edges[2], id2, p.x + offset, pat->rows[row].totalWidth, pat->rows[row].tiles, t.tileWidth, t.tileWidthVar, rand);		

	vmovss	xmm0, DWORD PTR [rsi+24]
	vmovss	DWORD PTR [rsp+64], xmm2
	vmovss	DWORD PTR [rsp+56], xmm0
	vmovss	xmm0, DWORD PTR [rcx+rdx+4]
	lea	rax, QWORD PTR [rdx+8]
	add	rax, rcx
	lea	rdx, QWORD PTR edges$4[rbp-113]
	vmovss	DWORD PTR [rsp+48], xmm1
	mov	QWORD PTR [rsp+40], rax
	lea	rcx, QWORD PTR edges$4[rbp-121]
	vaddss	xmm3, xmm7, xmm6
	lea	r8, QWORD PTR id2$7[rbp-121]
	vmovss	DWORD PTR [rsp+32], xmm0
	call	?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z ; rowcol

; 419  : 	if (row == -1) return TilePoint();

	cmp	eax, -1
	je	$LN80@draw

; 420  : 
; 421  : 	edges[0] -= offset;

	vmovss	xmm0, DWORD PTR edges$4[rbp-121]

; 422  : 	edges[2] -= offset;

	vmovss	xmm2, DWORD PTR edges$4[rbp-113]
	vsubss	xmm1, xmm0, xmm6

; 23   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	lea	eax, DWORD PTR [r14-101]

; 427  : 	return drawTile(p, edges, t, id);	

	mov	DWORD PTR [rsp+40], edi

; 23   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	imul	ecx, eax, 1000				; 000003e8H

; 427  : 	return drawTile(p, edges, t, id);	

	lea	r8, QWORD PTR edges$4[rbp-121]
	vsubss	xmm0, xmm2, xmm6
	mov	r9, rsi
	lea	rdx, QWORD PTR $T2[rbp-121]
	vmovss	DWORD PTR edges$4[rbp-121], xmm1
	vmovss	DWORD PTR edges$4[rbp-113], xmm0

; 23   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	add	ecx, DWORD PTR id2$7[rbp-121]

; 427  : 	return drawTile(p, edges, t, id);	

	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, rbx
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T2[rbp-121], xmm7
	vmovss	DWORD PTR $T2[rbp-117], xmm8
	vmovss	DWORD PTR $T2[rbp-113], xmm9
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 427  : 	return drawTile(p, edges, t, id);	

	call	?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z ; Tile::drawTile
$LN24@draw:

; 511  : 	return pat_xBond(p, t);

	mov	r14, QWORD PTR [rsp+224]
$LN79@draw:

; 512  : }

	lea	r11, QWORD PTR [rsp+192]
	mov	rax, rbx
	mov	rbx, QWORD PTR [r11+40]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm9, XMMWORD PTR [r11-64]
	mov	rsp, r11
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?draw@Tile@@SA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ENDP ; Tile::draw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
_TEXT	SEGMENT
$T1 = 48
edges$ = 64
__$ReturnUdt$ = 160
p$ = 168
t$ = 176
?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z PROC ; Tile::pat_herring, COMDAT

; 458  : TilePoint Tile::pat_herring(Point3 p, TileParam& t) {

$LN21:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 144				; 00000090H
	vmovaps	XMMWORD PTR [rax-24], xmm6
	mov	rbx, rcx

; 459  : 	float s = t.tileWidth * 2.f;	
; 460  : 	float h = t.tileWidth * .5f;
; 461  : 	float x = p.x / s;

	vmovss	xmm6, DWORD PTR [rdx]
	vmovaps	XMMWORD PTR [rax-40], xmm7
	mov	rdi, r8
	vmovss	xmm7, DWORD PTR [r8+8]
	vmulss	xmm4, xmm7, DWORD PTR __real@3f000000
	vaddss	xmm3, xmm7, xmm7
	vmovaps	XMMWORD PTR [rax-56], xmm9
	mov	r11, rdx
	vxorps	xmm1, xmm1, xmm1
	vdivss	xmm0, xmm6, xmm3

; 462  : 	float y = p.y / s;
; 463  : 	int xi = FASTFLOOR(x);
; 464  : 	int yi = FASTFLOOR(y);

	vcomiss	xmm1, xmm0
	vmovaps	XMMWORD PTR [rax-72], xmm10
	vmovss	xmm10, DWORD PTR [rdx+4]
	vcvttss2si eax, xmm0
	vdivss	xmm2, xmm10, xmm3
	vxorps	xmm0, xmm0, xmm0
	lea	r9d, DWORD PTR [rax-1]
	cmovbe	r9d, eax

; 465  : 	x = xi * s;

	vcomiss	xmm1, xmm2
	vcvttss2si eax, xmm2
	vcvtsi2ss xmm0, xmm0, r9d
	vxorps	xmm1, xmm1, xmm1
	vmulss	xmm5, xmm0, xmm3
	lea	r10d, DWORD PTR [rax-1]
	cmovbe	r10d, eax

; 466  : 	y = yi * s;

	vcvtsi2ss xmm1, xmm1, r10d
	vmulss	xmm9, xmm1, xmm3

; 468  : 	int y_id = (int)((p.y - y) / h) % 4;	

	vsubss	xmm0, xmm10, xmm9
	vdivss	xmm2, xmm0, xmm4
	vcvttss2si ecx, xmm2
	and	ecx, -2147483645			; ffffffff80000003H
	jge	SHORT $LN18@pat_herrin
	dec	ecx
	or	ecx, -4
	inc	ecx
$LN18@pat_herrin:

; 467  : 	int x_id = (int)((p.x - x) / h) % 4;

	vsubss	xmm0, xmm6, xmm5
	vdivss	xmm1, xmm0, xmm4
	vcvttss2si eax, xmm1
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN17@pat_herrin
	dec	eax
	or	eax, -4
	inc	eax
$LN17@pat_herrin:

; 469  : 	int id = x_id + 4 * y_id;
; 470  : 
; 471  : 	//Point3 center = Point3(pat_herring_x[id]*h+x, pat_herring_y[id]*h+y, p.z);
; 472  : 
; 473  : 	float edges[4];
; 474  : 
; 475  : 	if (!pat_herring_dir[id]) {

	lea	rsi, OFFSET FLAT:__ImageBase
	xor	r8d, r8d
	lea	eax, DWORD PTR [rax+rcx*4]
	movsxd	rcx, eax
	movzx	edx, BYTE PTR ?pat_herring_dir@@3PAEA[rcx+rsi]
	vmovss	xmm0, DWORD PTR ?pat_herring_x@@3PAMA[rsi+rcx*4]
	vmovss	xmm3, DWORD PTR ?pat_herring_y@@3PAMA[rsi+rcx*4]
	test	dl, dl
	jne	SHORT $LN2@pat_herrin

; 476  : 		edges[0] = (pat_herring_x[id]-1.f) * h + x;

	vsubss	xmm0, xmm0, DWORD PTR __real@3f800000
	vmulss	xmm1, xmm0, xmm4
	vaddss	xmm2, xmm1, xmm5

; 477  : 		edges[2] = edges[0] + t.tileWidth;
; 478  : 		edges[3] = (pat_herring_y[id]-.5f) * h + y;

	vsubss	xmm1, xmm3, DWORD PTR __real@3f000000
	vaddss	xmm0, xmm2, xmm7
	vmovss	DWORD PTR edges$[rsp+8], xmm0
	vmovss	DWORD PTR edges$[rsp], xmm2
	vmulss	xmm2, xmm1, xmm4
	vaddss	xmm0, xmm2, xmm9
	vmovss	DWORD PTR edges$[rsp+12], xmm0

; 482  : 		edges[2] = edges[0] + h;
; 483  : 		edges[3] = (pat_herring_y[id]-1.f) * h + y;
; 484  : 		edges[1] = edges[3] + t.tileWidth;	
; 485  : 	}
; 486  : 
; 487  : 	int tid = generateID(xi*4 + (pat_herring_dir[id] ? 0 : pat_herring_id[id]),

	mov	eax, r8d
	movzx	r8d, BYTE PTR ?pat_herring_id@@3PAEA[rcx+rsi]
	vaddss	xmm0, xmm0, xmm4
	jmp	SHORT $LN19@pat_herrin
$LN2@pat_herrin:

; 479  : 		edges[1] = edges[3] + h;
; 480  : 	} else {
; 481  : 		edges[0] = (pat_herring_x[id]-.5f) * h + x;

	vsubss	xmm0, xmm0, DWORD PTR __real@3f000000

; 482  : 		edges[2] = edges[0] + h;
; 483  : 		edges[3] = (pat_herring_y[id]-1.f) * h + y;
; 484  : 		edges[1] = edges[3] + t.tileWidth;	
; 485  : 	}
; 486  : 
; 487  : 	int tid = generateID(xi*4 + (pat_herring_dir[id] ? 0 : pat_herring_id[id]),

	movzx	eax, BYTE PTR ?pat_herring_id@@3PAEA[rcx+rsi]
	vmulss	xmm1, xmm0, xmm4
	vaddss	xmm2, xmm1, xmm5
	vsubss	xmm1, xmm3, DWORD PTR __real@3f800000
	vaddss	xmm0, xmm2, xmm4
	vmovss	DWORD PTR edges$[rsp+8], xmm0
	vmovss	DWORD PTR edges$[rsp], xmm2
	vmulss	xmm2, xmm1, xmm4
	vaddss	xmm0, xmm2, xmm9
	vmovss	DWORD PTR edges$[rsp+12], xmm0
	vaddss	xmm0, xmm0, xmm7
$LN19@pat_herrin:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	lea	eax, DWORD PTR [rax+r10*4]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 490  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	movzx	edx, dl
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	add	eax, -101				; ffffffffffffff9bH
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 490  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	mov	DWORD PTR [rsp+40], edx

; 23   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	imul	ecx, eax, 250				; 000000faH

; 490  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	lea	rdx, QWORD PTR $T1[rsp]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR edges$[rsp+4], xmm0
	vmovss	xmm0, DWORD PTR [r11+8]
	vmovss	DWORD PTR $T1[rsp], xmm6
	vmovss	DWORD PTR $T1[rsp+4], xmm10
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 23   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	add	ecx, r9d

; 490  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	mov	r9, rdi
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T1[rsp+8], xmm0
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 23   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	lea	eax, DWORD PTR [r8+rcx*4]

; 490  : 	return drawTile(p, edges, t, tid, pat_herring_dir[id]);

	mov	rcx, rbx
	lea	r8, QWORD PTR edges$[rsp]
	mov	DWORD PTR [rsp+32], eax
	call	?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z ; Tile::drawTile

; 491  : }

	vmovaps	xmm7, XMMWORD PTR [rsp+112]
	lea	r11, QWORD PTR [rsp+144]
	mov	rsi, QWORD PTR [r11+24]
	mov	rax, rbx
	mov	rbx, QWORD PTR [r11+16]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm9, XMMWORD PTR [r11-48]
	vmovaps	xmm10, XMMWORD PTR [r11-64]
	mov	rsp, r11
	pop	rdi
	ret	0
?pat_herring@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ENDP ; Tile::pat_herring
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z
_TEXT	SEGMENT
$T1 = 80
edges$ = 96
__$ReturnUdt$ = 160
p$ = 168
id$ = 176
t$ = 176
id2$ = 184
?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z PROC ; Tile::pat_xBond, COMDAT

; 399  : TilePoint Tile::pat_xBond(Point3 p, TileParam& t) {

$LN57:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 128				; 00000080H

; 400  : 	TilePattern* pat = t.pattern;

	mov	rbp, QWORD PTR [r8+112]

; 402  : 	if (!pat) return TilePoint();

	xor	edi, edi
	mov	rsi, r8
	mov	r14, rdx
	mov	rbx, rcx
	test	rbp, rbp
	jne	SHORT $LN2@pat_xBond
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	mov	QWORD PTR [rcx], rdi
	mov	QWORD PTR [rcx+8], rdi
	mov	QWORD PTR [rcx+16], rdi
; File g:\dropbox\github\berconmaps\src\tile.h

; 165  : 	TilePoint() {d = -1.f;}	

	mov	DWORD PTR [rcx+24], -1082130432		; bf800000H
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 402  : 	if (!pat) return TilePoint();

	jmp	$LN55@pat_xBond
$LN2@pat_xBond:

; 403  : 
; 404  : 	float edges[4];
; 405  : 	int id = 0;
; 406  : 	int id2 = 0;
; 407  : 	
; 408  : 	// Tile top and bottom
; 409  : 	float rand = 3.14f;
; 410  : 	int row = rowcol(edges[3], edges[1], id, p.y, pat->totalHeight, pat->heights, t.tileHeight, t.tileHeightVar, rand);

	vmovss	xmm1, DWORD PTR [r8+20]
	vmovss	xmm0, DWORD PTR __real@4048f5c3
	vmovss	xmm3, DWORD PTR [rdx+4]
	vmovss	DWORD PTR [rsp+64], xmm0
	vmovss	xmm0, DWORD PTR [r8+4]
	vmovss	DWORD PTR [rsp+56], xmm1
	vmovss	xmm1, DWORD PTR [rbp]
	vmovss	DWORD PTR [rsp+48], xmm0
	lea	rax, QWORD PTR [rbp+8]
	mov	DWORD PTR id$[rsp], edi
	mov	QWORD PTR [rsp+40], rax
	lea	r8, QWORD PTR id$[rsp]
	lea	rdx, QWORD PTR edges$[rsp+4]
	mov	DWORD PTR id2$[rsp], edi
	lea	rcx, QWORD PTR edges$[rsp+12]
	vmovss	DWORD PTR [rsp+32], xmm1
	call	?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z ; rowcol

; 411  : 	if (row == -1) return TilePoint();

	cmp	eax, -1
	jne	SHORT $LN3@pat_xBond
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	mov	QWORD PTR [rbx], rdi
	mov	QWORD PTR [rbx+8], rdi
	mov	QWORD PTR [rbx+16], rdi
; File g:\dropbox\github\berconmaps\src\tile.h

; 165  : 	TilePoint() {d = -1.f;}	

	mov	DWORD PTR [rbx+24], -1082130432		; bf800000H
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 411  : 	if (row == -1) return TilePoint();

	jmp	$LN55@pat_xBond
$LN3@pat_xBond:

; 412  : 
; 413  : 	// Tile sides
; 414  : 	rand = edges[3] * 1.325f + 31.41213f;

	vmovss	xmm0, DWORD PTR edges$[rsp+12]
	vmulss	xmm1, xmm0, DWORD PTR __real@3fa9999a

; 415  : 	float offset = pat->rows[row].offset * t.tileWidth;

	mov	rdx, QWORD PTR [rbp+32]
	vaddss	xmm2, xmm1, DWORD PTR __real@41fb4c0b
	vmovss	xmm1, DWORD PTR [rsi+8]

; 416  : 	if (offset < 0) offset *= -id;

	mov	ebp, DWORD PTR id$[rsp]
	movsxd	rcx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

	shl	rcx, 5
	vmovaps	XMMWORD PTR [rsp+112], xmm6
	vxorps	xmm0, xmm0, xmm0
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 415  : 	float offset = pat->rows[row].offset * t.tileWidth;

	vmulss	xmm6, xmm1, DWORD PTR [rcx+rdx]

; 416  : 	if (offset < 0) offset *= -id;

	vcomiss	xmm0, xmm6
	jbe	SHORT $LN4@pat_xBond
	mov	eax, ebp
	neg	eax
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vmulss	xmm6, xmm6, xmm0
$LN4@pat_xBond:

; 417  : 
; 418  : 	row = rowcol(edges[0], edges[2], id2, p.x + offset, pat->rows[row].totalWidth, pat->rows[row].tiles, t.tileWidth, t.tileWidthVar, rand);		

	vmovss	xmm0, DWORD PTR [rsi+24]
	vaddss	xmm3, xmm6, DWORD PTR [r14]
	vmovss	DWORD PTR [rsp+64], xmm2
	vmovss	DWORD PTR [rsp+56], xmm0
	vmovss	xmm0, DWORD PTR [rcx+rdx+4]
	lea	rax, QWORD PTR [rdx+8]
	add	rax, rcx
	lea	rdx, QWORD PTR edges$[rsp+8]
	vmovss	DWORD PTR [rsp+48], xmm1
	mov	QWORD PTR [rsp+40], rax
	lea	rcx, QWORD PTR edges$[rsp]
	lea	r8, QWORD PTR id2$[rsp]
	vmovss	DWORD PTR [rsp+32], xmm0
	call	?rowcol@@YAHAEAM0AEAHMMAEAV?$vector@MV?$allocator@M@std@@@std@@MMM@Z ; rowcol

; 419  : 	if (row == -1) return TilePoint();

	cmp	eax, -1
	jne	SHORT $LN5@pat_xBond
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	mov	QWORD PTR [rbx], rdi
	mov	QWORD PTR [rbx+8], rdi
	mov	QWORD PTR [rbx+16], rdi
; File g:\dropbox\github\berconmaps\src\tile.h

; 165  : 	TilePoint() {d = -1.f;}	

	mov	DWORD PTR [rbx+24], -1082130432		; bf800000H
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 419  : 	if (row == -1) return TilePoint();

	jmp	SHORT $LN54@pat_xBond
$LN5@pat_xBond:

; 420  : 
; 421  : 	edges[0] -= offset;

	vmovss	xmm0, DWORD PTR edges$[rsp]

; 422  : 	edges[2] -= offset;

	vmovss	xmm2, DWORD PTR edges$[rsp+8]
	vsubss	xmm1, xmm0, xmm6
	vsubss	xmm0, xmm2, xmm6
	vmovss	DWORD PTR edges$[rsp+8], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR [r14]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 23   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	lea	eax, DWORD PTR [rbp-101]

; 427  : 	return drawTile(p, edges, t, id);	

	mov	DWORD PTR [rsp+40], edi

; 23   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	imul	ecx, eax, 1000				; 000003e8H

; 427  : 	return drawTile(p, edges, t, id);	

	lea	r8, QWORD PTR edges$[rsp]
	vmovss	DWORD PTR edges$[rsp], xmm1
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm1, DWORD PTR [r14+4]
	vmovss	DWORD PTR $T1[rsp], xmm0
	vmovss	xmm0, DWORD PTR [r14+8]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 23   : inline static int generateID(int x, int y) { return (y-101) * 1000 + x; }

	add	ecx, DWORD PTR id2$[rsp]

; 427  : 	return drawTile(p, edges, t, id);	

	lea	rdx, QWORD PTR $T1[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9, rsi
	mov	rcx, rbx
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T1[rsp+4], xmm1
	vmovss	DWORD PTR $T1[rsp+8], xmm0
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 427  : 	return drawTile(p, edges, t, id);	

	call	?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z ; Tile::drawTile
$LN54@pat_xBond:
	vmovaps	xmm6, XMMWORD PTR [rsp+112]
$LN55@pat_xBond:

; 428  : }

	lea	r11, QWORD PTR [rsp+128]
	mov	rax, rbx
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?pat_xBond@Tile@@CA?AVTilePoint@@VPoint3@@AEAVTileParam@@@Z ENDP ; Tile::pat_xBond
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
tp$ = 64
__$ReturnUdt$ = 240
p$ = 248
edges$ = 256
t$ = 264
id$ = 272
dir$ = 280
?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z PROC ; Tile::drawTile, COMDAT

; 268  : TilePoint Tile::drawTile(Point3 p, float edges[4], TileParam& t, int id, int dir) {

$LN130:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-79]
	sub	rsp, 192				; 000000c0H

; 269  : 	float hEdgeW = t.edgeWidth * .5f;
; 270  : 	float hEdgeH = t.edgeHeight * .5f;
; 271  : 			
; 272  : 	float randomSeed = (float)id * 1.23f + 0.1234f;
; 273  : 	if (dir) {

	cmp	DWORD PTR dir$[rbp-153], 0
	mov	rdi, r9
	vmovss	xmm0, DWORD PTR [r9+16]
	vmovaps	XMMWORD PTR [rax-56], xmm6
	mov	rsi, r8
	vmovaps	XMMWORD PTR [rax-72], xmm7
	mov	r13, rdx
	vmovaps	XMMWORD PTR [rax-88], xmm8
	mov	rbx, rcx
	vmovaps	XMMWORD PTR [rax-104], xmm9
	vmovsd	xmm9, QWORD PTR __real@403f666666666666
	vmovaps	XMMWORD PTR [rsp+96], xmm11
	vmovss	xmm11, DWORD PTR __real@3f000000
	vmulss	xmm7, xmm0, xmm11
	vmovss	xmm0, DWORD PTR [r9+12]
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, DWORD PTR id$[rbp-153]
	vmulss	xmm6, xmm0, xmm11
	vmulss	xmm0, xmm1, DWORD PTR __real@3f9d70a4
	vaddss	xmm2, xmm0, DWORD PTR __real@3dfcb924
	vmovaps	XMMWORD PTR [rax-120], xmm10
	vmovss	xmm10, DWORD PTR __real@3f800000
	vcvtss2sd xmm8, xmm2, xmm2
	je	$LN2@drawTile

; 274  : 		edges[0] += t.eH_var ? hEdgeH * (1.f + noise(edges[0], randomSeed) * t.edgeHeightVar) : hEdgeH;

	cmp	BYTE PTR [r9+37], 0
	je	SHORT $LN17@drawTile
	vmovss	xmm0, DWORD PTR [r8]

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm1, xmm0, xmm9
	vaddsd	xmm2, xmm1, xmm8
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 274  : 		edges[0] += t.eH_var ? hEdgeH * (1.f + noise(edges[0], randomSeed) * t.edgeHeightVar) : hEdgeH;

	vmulss	xmm0, xmm0, DWORD PTR [rdi+28]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm2, xmm1, xmm6
	jmp	SHORT $LN18@drawTile
$LN17@drawTile:
	vmovaps	xmm2, xmm6
$LN18@drawTile:
	vaddss	xmm0, xmm2, DWORD PTR [rsi]
	vmovss	DWORD PTR [rsi], xmm0

; 275  : 		edges[2] -= t.eH_var ? hEdgeH * (1.f + noise(edges[2], randomSeed) * t.edgeHeightVar) : hEdgeH;

	cmp	BYTE PTR [rdi+37], 0
	lea	r15, QWORD PTR [rsi+8]
	je	SHORT $LN19@drawTile
	vmovss	xmm0, DWORD PTR [r15]

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm1, xmm0, xmm9
	vaddsd	xmm2, xmm1, xmm8
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 275  : 		edges[2] -= t.eH_var ? hEdgeH * (1.f + noise(edges[2], randomSeed) * t.edgeHeightVar) : hEdgeH;

	vmulss	xmm0, xmm0, DWORD PTR [rdi+28]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm6, xmm1, xmm6
$LN19@drawTile:
	vmovss	xmm0, DWORD PTR [r15]
	vsubss	xmm1, xmm0, xmm6
	vmovss	DWORD PTR [r15], xmm1

; 276  : 		edges[3] += t.eW_var ? hEdgeW * (1.f + noise(edges[3], randomSeed) * t.edgeWidthVar) : hEdgeW;

	cmp	BYTE PTR [rdi+36], 0
	lea	r12, QWORD PTR [rsi+12]
	je	SHORT $LN21@drawTile
	vmovss	xmm0, DWORD PTR [r12]

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm1, xmm0, xmm9
	vaddsd	xmm2, xmm1, xmm8
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 276  : 		edges[3] += t.eW_var ? hEdgeW * (1.f + noise(edges[3], randomSeed) * t.edgeWidthVar) : hEdgeW;

	vmulss	xmm0, xmm0, DWORD PTR [rdi+32]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm2, xmm1, xmm7
	jmp	SHORT $LN22@drawTile
$LN21@drawTile:
	vmovaps	xmm2, xmm7
$LN22@drawTile:
	vaddss	xmm0, xmm2, DWORD PTR [r12]
	vmovss	DWORD PTR [r12], xmm0

; 277  : 		edges[1] -= t.eW_var ? hEdgeW * (1.f + noise(edges[1], randomSeed) * t.edgeWidthVar) : hEdgeW;

	cmp	BYTE PTR [rdi+36], 0
	lea	r14, QWORD PTR [rsi+4]
	je	SHORT $LN23@drawTile
	vmovss	xmm0, DWORD PTR [r14]

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm1, xmm0, xmm9
	vaddsd	xmm2, xmm1, xmm8
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 277  : 		edges[1] -= t.eW_var ? hEdgeW * (1.f + noise(edges[1], randomSeed) * t.edgeWidthVar) : hEdgeW;

	vmulss	xmm0, xmm0, DWORD PTR [rdi+32]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm7, xmm1, xmm7
$LN23@drawTile:
	vmovss	xmm0, DWORD PTR [r14]
	vsubss	xmm1, xmm0, xmm7

; 278  : 	} else {

	jmp	$LN127@drawTile
$LN2@drawTile:

; 279  : 		edges[0] += t.eW_var ? hEdgeW * (1.f + noise(edges[0], randomSeed) * t.edgeWidthVar) : hEdgeW;

	cmp	BYTE PTR [r9+36], 0
	je	SHORT $LN25@drawTile
	vmovss	xmm0, DWORD PTR [r8]

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm1, xmm0, xmm9
	vaddsd	xmm2, xmm1, xmm8
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 279  : 		edges[0] += t.eW_var ? hEdgeW * (1.f + noise(edges[0], randomSeed) * t.edgeWidthVar) : hEdgeW;

	vmulss	xmm0, xmm0, DWORD PTR [rdi+32]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm2, xmm1, xmm7
	jmp	SHORT $LN26@drawTile
$LN25@drawTile:
	vmovaps	xmm2, xmm7
$LN26@drawTile:
	vaddss	xmm0, xmm2, DWORD PTR [rsi]
	vmovss	DWORD PTR [rsi], xmm0

; 280  : 		edges[2] -= t.eW_var ? hEdgeW * (1.f + noise(edges[2], randomSeed) * t.edgeWidthVar) : hEdgeW;

	cmp	BYTE PTR [rdi+36], 0
	je	SHORT $LN27@drawTile
	vmovss	xmm0, DWORD PTR [rsi+8]

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm1, xmm0, xmm9
	vaddsd	xmm2, xmm1, xmm8
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 280  : 		edges[2] -= t.eW_var ? hEdgeW * (1.f + noise(edges[2], randomSeed) * t.edgeWidthVar) : hEdgeW;

	vmulss	xmm0, xmm0, DWORD PTR [rdi+32]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm7, xmm1, xmm7
$LN27@drawTile:
	lea	r15, QWORD PTR [rsi+8]
	vmovss	xmm0, DWORD PTR [r15]
	vsubss	xmm1, xmm0, xmm7
	vmovss	DWORD PTR [r15], xmm1

; 281  : 		edges[3] += t.eH_var ? hEdgeH * (1.f + noise(edges[3], randomSeed) * t.edgeHeightVar) : hEdgeH;

	cmp	BYTE PTR [rdi+37], 0
	je	SHORT $LN29@drawTile
	vmovss	xmm0, DWORD PTR [rsi+12]

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm1, xmm0, xmm9
	vaddsd	xmm2, xmm1, xmm8
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 281  : 		edges[3] += t.eH_var ? hEdgeH * (1.f + noise(edges[3], randomSeed) * t.edgeHeightVar) : hEdgeH;

	vmulss	xmm0, xmm0, DWORD PTR [rdi+28]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm2, xmm1, xmm6
	jmp	SHORT $LN30@drawTile
$LN29@drawTile:
	vmovaps	xmm2, xmm6
$LN30@drawTile:
	lea	r12, QWORD PTR [rsi+12]
	vaddss	xmm0, xmm2, DWORD PTR [r12]
	vmovss	DWORD PTR [r12], xmm0

; 282  : 		edges[1] -= t.eH_var ? hEdgeH * (1.f + noise(edges[1], randomSeed) * t.edgeHeightVar) : hEdgeH;

	cmp	BYTE PTR [rdi+37], 0
	je	SHORT $LN31@drawTile
	vmovss	xmm0, DWORD PTR [rsi+4]

; 25   : inline static float noise(float x, float rand) { return Perlin::snoise(x * 31.4 + rand); }

	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm1, xmm0, xmm9
	vaddsd	xmm2, xmm1, xmm8
	vcvtsd2ss xmm0, xmm2, xmm2
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 282  : 		edges[1] -= t.eH_var ? hEdgeH * (1.f + noise(edges[1], randomSeed) * t.edgeHeightVar) : hEdgeH;

	vmulss	xmm0, xmm0, DWORD PTR [rdi+28]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm6, xmm1, xmm6
$LN31@drawTile:
	lea	r14, QWORD PTR [rsi+4]
	vmovss	xmm0, DWORD PTR [r14]
	vsubss	xmm1, xmm0, xmm6
$LN127@drawTile:

; 283  : 	}
; 284  : 
; 285  : 	if (p.x < edges[0]) return TilePoint();

	vmovss	xmm3, DWORD PTR [rsi]
	vmovaps	xmm10, XMMWORD PTR [rsp+112]
	vmovss	DWORD PTR [r14], xmm1
	vmovss	xmm0, DWORD PTR [r13]
	vcomiss	xmm3, xmm0
	ja	$LN9@drawTile

; 286  : 	if (p.x > edges[2]) return TilePoint();

	vmovss	xmm5, DWORD PTR [r15]
	vcomiss	xmm0, xmm5
	ja	$LN9@drawTile

; 287  : 	if (p.y < edges[3]) return TilePoint();

	vmovss	xmm2, DWORD PTR [r13+4]
	vmovss	xmm4, DWORD PTR [r12]
	vcomiss	xmm4, xmm2
	ja	$LN9@drawTile

; 288  : 	if (p.y > edges[1]) return TilePoint();

	vcomiss	xmm2, xmm1
	ja	$LN9@drawTile

; 289  : 
; 290  : 	float width = edges[2] - edges[0];

	vsubss	xmm7, xmm5, xmm3
	vxorps	xmm6, xmm6, xmm6

; 291  : 	float height = edges[1] - edges[3];
; 292  : 	if (width < 0 || height < 0) return TilePoint();

	vcomiss	xmm6, xmm7
	vsubss	xmm5, xmm1, xmm4
	ja	$LN9@drawTile
	vcomiss	xmm6, xmm5
	ja	$LN9@drawTile

; 293  : 
; 294  : 	TilePoint tp = corner(p.x - edges[0], p.y - edges[3], width, height, t);	

	vsubss	xmm1, xmm0, xmm3
	vmovaps	xmm3, xmm7
	vsubss	xmm2, xmm2, xmm4
	mov	QWORD PTR [rsp+40], rdi
	lea	rcx, QWORD PTR tp$[rbp-153]
	vmovss	DWORD PTR [rsp+32], xmm5
	call	?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z ; Tile::corner

; 295  : 	if (tp.d < 0) return tp; // On edge

	vmovss	xmm8, DWORD PTR tp$[rbp-129]
	vcomiss	xmm6, xmm8
	jbe	SHORT $LN10@drawTile
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR tp$[rbp-153]
	vmovss	xmm1, DWORD PTR tp$[rbp-149]
	vmovss	DWORD PTR [rbx], xmm0
	vmovss	xmm0, DWORD PTR tp$[rbp-145]
	lea	rcx, QWORD PTR [rbx+12]
	lea	rdx, QWORD PTR tp$[rbp-141]
	vmovss	DWORD PTR [rbx+8], xmm0
	vmovss	DWORD PTR [rbx+4], xmm1
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	vmovss	xmm0, DWORD PTR tp$[rbp-129]
	mov	eax, DWORD PTR tp$[rbp-125]
	vmovss	DWORD PTR [rbx+24], xmm0
	mov	DWORD PTR [rbx+28], eax
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 295  : 	if (tp.d < 0) return tp; // On edge

	jmp	$LN128@drawTile
$LN10@drawTile:

; 296  : 
; 297  : 	//if (t.tileID || t.mapUV)
; 298  : 		tp.id = id;
; 299  : 
; 300  : 	if (t.center || (t.mapUV && dir))

	cmp	DWORD PTR [rdi+104], 0
	mov	eax, DWORD PTR id$[rbp-153]
	vmovss	xmm9, DWORD PTR __xmm@80000000800000008000000080000000
	mov	DWORD PTR tp$[rbp-125], eax
	jne	SHORT $LN124@drawTile
	cmp	DWORD PTR [rdi+60], 0
	je	SHORT $LN123@drawTile
	mov	eax, DWORD PTR dir$[rbp-153]
	test	eax, eax
	je	$LN125@drawTile
$LN124@drawTile:

; 301  : 		tp.center = Point3(edges[0] + (edges[2] - edges[0]) * .5f,

	vmovss	xmm0, DWORD PTR [r15]
	vsubss	xmm1, xmm0, DWORD PTR [rsi]
	vmovss	xmm0, DWORD PTR [r14]
	vmulss	xmm2, xmm1, xmm11
	vsubss	xmm1, xmm0, DWORD PTR [r12]
	vaddss	xmm5, xmm2, DWORD PTR [rsi]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR [r13+8]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 301  : 		tp.center = Point3(edges[0] + (edges[2] - edges[0]) * .5f,

	vmulss	xmm2, xmm1, xmm11
	vaddss	xmm3, xmm2, DWORD PTR [r12]
	vunpcklps xmm1, xmm5, xmm3
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T2[rbp-145], xmm0
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 301  : 		tp.center = Point3(edges[0] + (edges[2] - edges[0]) * .5f,

	mov	eax, DWORD PTR $T2[rbp-145]
	vmovsd	QWORD PTR tp$[rbp-153], xmm1
	mov	DWORD PTR tp$[rbp-145], eax
$LN123@drawTile:

; 304  : 	if (dir) {

	mov	eax, DWORD PTR dir$[rbp-153]
	test	eax, eax
	je	$LN125@drawTile

; 264  : 	edges[3] += y;

	vmovss	xmm1, DWORD PTR [r12]

; 305  : 		offsetEdges(edges, -tp.center.x, -tp.center.y);

	vmovss	xmm5, DWORD PTR tp$[rbp-149]
	vmovss	xmm6, DWORD PTR tp$[rbp-153]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 261  :    x -= a.x;   y -= a.y;   z -= a.z;

	vmovss	xmm7, DWORD PTR tp$[rbp-145]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 305  : 		offsetEdges(edges, -tp.center.x, -tp.center.y);

	vxorps	xmm2, xmm5, xmm9

; 265  : 	edges[1] += y;

	vaddss	xmm3, xmm2, DWORD PTR [r14]
	vaddss	xmm1, xmm2, xmm1

; 31   : inline static void rotate90(float& x, float& y)  { float temp = y; y = x; x = -temp; }

	vxorps	xmm2, xmm1, xmm9

; 305  : 		offsetEdges(edges, -tp.center.x, -tp.center.y);

	vxorps	xmm0, xmm6, xmm9

; 263  : 	edges[2] += x;

	vaddss	xmm4, xmm0, DWORD PTR [r15]
	vaddss	xmm0, xmm0, DWORD PTR [rsi]

; 31   : inline static void rotate90(float& x, float& y)  { float temp = y; y = x; x = -temp; }

	vmovss	DWORD PTR [r12], xmm0
	vmovss	DWORD PTR [rsi], xmm2
	vmovss	DWORD PTR [r14], xmm4
	vxorps	xmm0, xmm3, xmm9
	vmovss	DWORD PTR [r15], xmm0

; 262  : 	edges[0] += x;

	vaddss	xmm1, xmm6, DWORD PTR [rsi]

; 263  : 	edges[2] += x;

	vaddss	xmm0, xmm6, DWORD PTR [r15]
	vmovss	DWORD PTR [rsi], xmm1

; 264  : 	edges[3] += y;

	vaddss	xmm1, xmm5, DWORD PTR [r12]
	vmovss	DWORD PTR [r15], xmm0

; 265  : 	edges[1] += y;

	vaddss	xmm0, xmm5, DWORD PTR [r14]
	vmovss	DWORD PTR [r12], xmm1
	vmovss	DWORD PTR [r14], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 261  :    x -= a.x;   y -= a.y;   z -= a.z;

	vmovss	xmm0, DWORD PTR [r13+4]
	vmovss	xmm3, DWORD PTR [r13]
	vsubss	xmm1, xmm0, xmm5

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vsubss	xmm2, xmm6, xmm1

; 261  :    x -= a.x;   y -= a.y;   z -= a.z;

	vsubss	xmm0, xmm3, xmm6

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vaddss	xmm1, xmm0, xmm5
	vmovss	DWORD PTR [r13], xmm2

; 261  :    x -= a.x;   y -= a.y;   z -= a.z;

	vmovss	xmm2, DWORD PTR [r13+8]
	vsubss	xmm0, xmm2, xmm7

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vmovss	DWORD PTR [r13+4], xmm1
	vaddss	xmm1, xmm0, xmm7
	vmovss	DWORD PTR [r13+8], xmm1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 304  : 	if (dir) {

	jmp	SHORT $LN122@drawTile
$LN125@drawTile:
	vmovss	xmm7, DWORD PTR tp$[rbp-145]
	vmovss	xmm5, DWORD PTR tp$[rbp-149]
	vmovss	xmm6, DWORD PTR tp$[rbp-153]
$LN122@drawTile:

; 306  : 		rotate90(edges[0], edges[3]);
; 307  : 		rotate90(edges[2], edges[1]);
; 308  : 		offsetEdges(edges, tp.center.x, tp.center.y);
; 309  : 		p -= tp.center; rotate90(p.x, p.y); p += tp.center;
; 310  : 	}
; 311  : 	
; 312  : 	if (t.mapUV)

	cmp	DWORD PTR [rdi+60], 0
	je	SHORT $LN126@drawTile
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR [r13]
	vmovss	xmm1, DWORD PTR [r13+4]
	vmovss	DWORD PTR $T1[rbp-153], xmm0
	vmovss	xmm0, DWORD PTR [r13+8]
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 313  : 		uvMapping(tp, p, edges, t, dir);

	mov	r9, rdi
	mov	DWORD PTR [rsp+32], eax
	mov	r8, rsi
	lea	rdx, QWORD PTR $T1[rbp-153]
	lea	rcx, QWORD PTR tp$[rbp-153]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T1[rbp-145], xmm0
	vmovss	DWORD PTR $T1[rbp-149], xmm1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 313  : 		uvMapping(tp, p, edges, t, dir);

	call	?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z ; Tile::uvMapping
	mov	eax, DWORD PTR tp$[rbp-125]
	vmovss	xmm5, DWORD PTR tp$[rbp-149]
	vmovss	xmm8, DWORD PTR tp$[rbp-129]
	vmovss	xmm7, DWORD PTR tp$[rbp-145]
	vmovss	xmm6, DWORD PTR tp$[rbp-153]
	jmp	SHORT $LN14@drawTile
$LN126@drawTile:

; 306  : 		rotate90(edges[0], edges[3]);
; 307  : 		rotate90(edges[2], edges[1]);
; 308  : 		offsetEdges(edges, tp.center.x, tp.center.y);
; 309  : 		p -= tp.center; rotate90(p.x, p.y); p += tp.center;
; 310  : 	}
; 311  : 	
; 312  : 	if (t.mapUV)

	mov	eax, DWORD PTR id$[rbp-153]
$LN14@drawTile:

; 314  : 
; 315  : 	if (dir) {

	cmp	DWORD PTR dir$[rbp-153], 0
	je	$LN15@drawTile

; 262  : 	edges[0] += x;

	vmovss	xmm1, DWORD PTR [rsi]

; 316  : 		offsetEdges(edges, -tp.center.x, -tp.center.y);

	vxorps	xmm2, xmm6, xmm9

; 263  : 	edges[2] += x;

	vaddss	xmm4, xmm2, DWORD PTR [r15]
	vaddss	xmm1, xmm2, xmm1

; 32   : inline static void rotate270(float& x, float& y) { float temp = x; x = y; y = -temp; }

	vxorps	xmm2, xmm1, xmm9

; 316  : 		offsetEdges(edges, -tp.center.x, -tp.center.y);

	vxorps	xmm0, xmm5, xmm9

; 265  : 	edges[1] += y;

	vaddss	xmm3, xmm0, DWORD PTR [r14]
	vaddss	xmm0, xmm0, DWORD PTR [r12]

; 32   : inline static void rotate270(float& x, float& y) { float temp = x; x = y; y = -temp; }

	vmovss	DWORD PTR [rsi], xmm0
	vmovss	DWORD PTR [r12], xmm2
	vmovss	DWORD PTR [r15], xmm3
	vxorps	xmm0, xmm4, xmm9
	vmovss	DWORD PTR [r14], xmm0

; 262  : 	edges[0] += x;

	vaddss	xmm1, xmm6, DWORD PTR [rsi]

; 263  : 	edges[2] += x;

	vaddss	xmm0, xmm6, DWORD PTR [r15]
	vmovss	DWORD PTR [rsi], xmm1

; 264  : 	edges[3] += y;

	vaddss	xmm1, xmm5, DWORD PTR [r12]
	vmovss	DWORD PTR [r15], xmm0

; 265  : 	edges[1] += y;

	vaddss	xmm0, xmm5, DWORD PTR [r14]
	vmovss	DWORD PTR [r12], xmm1
	vmovss	DWORD PTR [r14], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 261  :    x -= a.x;   y -= a.y;   z -= a.z;

	vmovss	xmm0, DWORD PTR [r13+4]
	vmovss	xmm3, DWORD PTR [r13]
	vsubss	xmm1, xmm0, xmm5

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vaddss	xmm2, xmm1, xmm6

; 261  :    x -= a.x;   y -= a.y;   z -= a.z;

	vsubss	xmm0, xmm3, xmm6

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vsubss	xmm1, xmm5, xmm0
	vmovss	DWORD PTR [r13], xmm2

; 261  :    x -= a.x;   y -= a.y;   z -= a.z;

	vmovss	xmm2, DWORD PTR [r13+8]
	vsubss	xmm0, xmm2, xmm7

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vmovss	DWORD PTR [r13+4], xmm1
	vaddss	xmm1, xmm0, xmm7
	vmovss	DWORD PTR [r13+8], xmm1
$LN15@drawTile:

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR tp$[rbp-141]
	vmovss	xmm1, DWORD PTR tp$[rbp-137]
	vmovss	DWORD PTR [rbx], xmm6
	vmovss	DWORD PTR [rbx+4], xmm5
	vmovss	DWORD PTR [rbx+8], xmm7
	vmovss	DWORD PTR [rbx+12], xmm0
	vmovss	xmm0, DWORD PTR tp$[rbp-133]
	vmovss	DWORD PTR [rbx+20], xmm0
	vmovss	DWORD PTR [rbx+16], xmm1
	vmovss	DWORD PTR [rbx+24], xmm8
	mov	DWORD PTR [rbx+28], eax
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 323  : 	return tp;	

	jmp	SHORT $LN128@drawTile
$LN9@drawTile:

; 324  : }

	xor	eax, eax
	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rax
	mov	QWORD PTR [rbx+16], rax
	mov	DWORD PTR [rbx+24], -1082130432		; bf800000H
$LN128@drawTile:
	lea	r11, QWORD PTR [rsp+192]
	mov	rax, rbx
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm9, XMMWORD PTR [r11-64]
	vmovaps	xmm11, XMMWORD PTR [r11-96]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?drawTile@Tile@@CA?AVTilePoint@@VPoint3@@QEAMAEAVTileParam@@HH@Z ENDP ; Tile::drawTile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z
_TEXT	SEGMENT
uvw$ = 32
tp$ = 208
p$ = 216
edges$ = 224
t$ = 232
dir$ = 240
?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z PROC ; Tile::uvMapping, COMDAT

; 163  : void Tile::uvMapping(TilePoint& tp, Point3 p, float edges[4], TileParam& t, int dir) {

$LN67:
	mov	rax, rsp
	push	rsi
	sub	rsp, 192				; 000000c0H

; 164  : 	float w = edges[2] - edges[0];

	vmovss	xmm0, DWORD PTR [r8+8]

; 165  : 	float h = edges[1] - edges[3];

	vmovss	xmm1, DWORD PTR [r8+4]
	vmovaps	XMMWORD PTR [rax-56], xmm8
	mov	rsi, rcx
	vmovaps	XMMWORD PTR [rax-72], xmm9
	vsubss	xmm9, xmm0, DWORD PTR [r8]

; 166  : 		
; 167  : 	// Center uvw
; 168  : 	Point3 uvw;
; 169  : 	uvw.x = p.x - edges[0] - w * .5f;

	vmovss	xmm0, DWORD PTR [rdx]
	vsubss	xmm2, xmm0, DWORD PTR [r8]

; 170  : 	uvw.y = p.y - edges[3] - h * .5f;

	vmovss	xmm0, DWORD PTR [rdx+4]
	mov	QWORD PTR [rax+8], rbx
	mov	rbx, r9
	mov	QWORD PTR [rax+16], rdi
	vmovaps	XMMWORD PTR [rax-24], xmm6
	vmovaps	XMMWORD PTR [rax-40], xmm7
	vmovaps	XMMWORD PTR [rax-88], xmm10
	vmovaps	XMMWORD PTR [rax-104], xmm11
	vmovaps	XMMWORD PTR [rax-120], xmm12
	vmovaps	XMMWORD PTR [rsp+64], xmm14
	vsubss	xmm14, xmm1, DWORD PTR [r8+12]
	vmulss	xmm1, xmm9, DWORD PTR __real@3f000000
	vsubss	xmm11, xmm2, xmm1
	vsubss	xmm2, xmm0, DWORD PTR [r8+12]

; 171  : 	uvw.z = p.z;

	vmovss	xmm0, DWORD PTR [rdx+8]

; 172  : 
; 173  : 	// Prime randomness
; 174  : 	srand(tp.id*(tp.id*tp.id*15731 + 789221));

	mov	edx, DWORD PTR [rcx+28]
	mov	eax, edx
	vmulss	xmm1, xmm14, DWORD PTR __real@3f000000
	imul	eax, edx
	vsubss	xmm8, xmm2, xmm1
	vmovss	DWORD PTR uvw$[rsp], xmm11
	vmovss	DWORD PTR uvw$[rsp+4], xmm8
	vmovss	DWORD PTR uvw$[rsp+8], xmm0
	imul	ecx, eax, 15731				; 00003d73H
	vmovaps	XMMWORD PTR [rsp+48], xmm15
	add	ecx, 789221				; 000c0ae5H
	imul	ecx, edx
	call	QWORD PTR __imp_srand

; 124  : 	switch (type) {

	mov	ecx, DWORD PTR [rbx+84]

; 175  : 
; 176  : 	// Angle
; 177  : 	float angle = getAngle(t.rotUV, t.randRot);

	vmovss	xmm6, DWORD PTR [rbx+88]

; 124  : 	switch (type) {

	vmovsd	xmm15, QWORD PTR __real@40dfffc000000000
	vmovss	xmm1, DWORD PTR __real@3fc90fdb
	vxorps	xmm12, xmm12, xmm12
	test	ecx, ecx
	je	SHORT $LN34@uvMapping
	sub	ecx, 1
	je	$LN35@uvMapping
	cmp	ecx, 1
	jne	$LN32@uvMapping

; 131  : 		case 2: // 90
; 132  : 			switch (rand() % 4) {

	call	QWORD PTR __imp_rand
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN64@uvMapping
	dec	eax
	or	eax, -4
	inc	eax
$LN64@uvMapping:
	test	eax, eax
	je	SHORT $LN38@uvMapping
	sub	eax, 1
	je	SHORT $LN39@uvMapping
	sub	eax, 1
	je	SHORT $LN40@uvMapping
	cmp	eax, 1
	jne	$LN32@uvMapping

; 139  : 				case 3:
; 140  : 					return (float)pi*1.5f;

	vmovss	xmm10, DWORD PTR __real@4096cbe4
	vmovss	xmm1, DWORD PTR __real@3fc90fdb
	jmp	SHORT $LN29@uvMapping
$LN40@uvMapping:

; 137  : 				case 2:
; 138  : 					return (float)pi;

	vmovss	xmm10, DWORD PTR __real@40490fdb
	vmovss	xmm1, DWORD PTR __real@3fc90fdb
	jmp	SHORT $LN29@uvMapping
$LN39@uvMapping:

; 135  : 				case 1: 
; 136  : 					return (float)pi*.5f;

	vmovss	xmm1, DWORD PTR __real@3fc90fdb
	vmovaps	xmm10, xmm1
	jmp	SHORT $LN29@uvMapping
$LN38@uvMapping:

; 133  : 				case 0:
; 134  : 					return 0.f;

	vmovss	xmm1, DWORD PTR __real@3fc90fdb
$LN34@uvMapping:

; 178  : 
; 179  : 	// Random scale
; 180  : 	float scaleX = 0, scaleY = 0;			//avoid error C4701
; 181  : 	switch (t.autoScale) {

	vxorps	xmm10, xmm10, xmm10
$LN29@uvMapping:
	mov	edi, DWORD PTR [rbx+56]
	mov	ecx, edi
	vxorps	xmm6, xmm6, xmm6
	vxorps	xmm7, xmm7, xmm7
	sub	ecx, 1
	je	$LN4@uvMapping
	sub	ecx, 1
	je	$LN5@uvMapping
	sub	ecx, 1
	je	$LN6@uvMapping
	sub	ecx, 1
	je	$LN7@uvMapping
	cmp	ecx, 1
	je	$LN8@uvMapping

; 200  : 			break; }		
; 201  : 	}
; 202  : 
; 203  : 	// Calculate scaling required to fit UVs tightly around the tile
; 204  : 	if ((t.autoScale == 2 || t.autoScale == 3) && t.rotUV) { // Scale based on rotation so whole tile stays inside 0..1 space

	lea	eax, DWORD PTR [rdi-2]
	cmp	eax, 1
	ja	$LN9@uvMapping
	jmp	$LN10@uvMapping
$LN32@uvMapping:

; 143  : 			return UFRAND() * amount;

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm1, xmm0, xmm15
	vaddsd	xmm2, xmm1, xmm1
	vsubsd	xmm3, xmm2, QWORD PTR __real@3ff0000000000000
	vcvtss2sd xmm0, xmm6, xmm6
	vmulsd	xmm1, xmm3, xmm0
	vcvtsd2ss xmm10, xmm1, xmm1
	vmovss	xmm1, DWORD PTR __real@3fc90fdb
	jmp	SHORT $LN29@uvMapping
$LN35@uvMapping:

; 125  : 		case 0:
; 126  : 			return 0.f;
; 127  : 		case 1: // 180
; 128  : 			if (rand() % 2)

	call	QWORD PTR __imp_rand
	and	eax, -2147483647			; ffffffff80000001H
	jge	SHORT $LN63@uvMapping
	dec	eax
	or	eax, -2
	inc	eax
$LN63@uvMapping:
	xor	ecx, ecx
	vmovd	xmm1, ecx
	vmovd	xmm0, eax
	vpcmpeqd xmm2, xmm0, xmm1
	vmovss	xmm1, DWORD PTR __real@40490fdb
	vblendvps xmm10, xmm1, xmm12, xmm2

; 129  : 				return (float)pi;
; 130  : 			return 0.f;

	vmovss	xmm1, DWORD PTR __real@3fc90fdb
	jmp	$LN29@uvMapping
$LN8@uvMapping:

; 196  : 		case 5: { // UV Norm. Keep aspect
; 197  : 			float s = MAX(t.tileMaxWidth, t.tileMaxHeight);		

	vmovss	xmm0, DWORD PTR [rbx+124]
	vmaxss	xmm6, xmm0, DWORD PTR [rbx+120]

; 198  : 			scaleX = s;
; 199  : 			scaleY = s;

	vmovaps	xmm7, xmm6
	jmp	SHORT $LN9@uvMapping
$LN7@uvMapping:

; 192  : 		case 4: { // UV Norm.
; 193  : 			scaleX = t.tileMaxWidth;

	vmovss	xmm6, DWORD PTR [rbx+124]

; 194  : 			scaleY = t.tileMaxHeight;

	vmovss	xmm7, DWORD PTR [rbx+120]

; 195  : 			break; }

	jmp	SHORT $LN59@uvMapping
$LN6@uvMapping:
	vmaxss	xmm6, xmm9, xmm14

; 187  : 			break; }
; 188  : 		case 3: { // UV Fit Keep aspect
; 189  : 			float s = MAX(w, h);		
; 190  : 			scaleX = s; scaleY = s;

	vmovaps	xmm7, xmm6

; 191  : 			break; }

	jmp	SHORT $LN10@uvMapping
$LN5@uvMapping:

; 184  : 			break; }		
; 185  : 		case 2: { // UV Fit
; 186  : 			scaleX = w; scaleY = h; // Same as UV, but with additiona scaling below

	vmovaps	xmm6, xmm9
	vmovaps	xmm7, xmm14
$LN10@uvMapping:

; 200  : 			break; }		
; 201  : 	}
; 202  : 
; 203  : 	// Calculate scaling required to fit UVs tightly around the tile
; 204  : 	if ((t.autoScale == 2 || t.autoScale == 3) && t.rotUV) { // Scale based on rotation so whole tile stays inside 0..1 space

	cmp	DWORD PTR [rbx+84], 0
	je	SHORT $LN9@uvMapping

; 205  : 		float scale = 2.f * SQRTHALF * cos(fmod(angle > 0 ? -angle : angle, HALFPI) + QUATPI);

	vandps	xmm0, xmm10, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	vxorps	xmm0, xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 144  : 	return (_CSTD fmodf(_Xx, _Yx));

	call	fmodf
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 205  : 		float scale = 2.f * SQRTHALF * cos(fmod(angle > 0 ? -angle : angle, HALFPI) + QUATPI);

	vaddss	xmm0, xmm0, DWORD PTR __real@3f490fdb
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 78   : 	return (_CSTD cosf(_Xx));

	call	cosf
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 205  : 		float scale = 2.f * SQRTHALF * cos(fmod(angle > 0 ? -angle : angle, HALFPI) + QUATPI);

	vmulss	xmm1, xmm0, DWORD PTR __real@3fb504f3

; 206  : 		scaleX *= scale;

	vmulss	xmm6, xmm6, xmm1

; 207  : 		scaleY *= scale;

	vmulss	xmm7, xmm7, xmm1
	jmp	SHORT $LN9@uvMapping
$LN4@uvMapping:

; 182  : 		case 1: { // UV
; 183  : 			scaleX = w; scaleY = h;

	vmovaps	xmm6, xmm9
	vmovaps	xmm7, xmm14
$LN9@uvMapping:

; 208  : 	}	
; 209  : 
; 210  : 	// Apply auto scale
; 211  : 	if (t.autoScale) {

	test	edi, edi
	je	SHORT $LN11@uvMapping
$LN59@uvMapping:

; 212  : 		uvw.x /= scaleX;

	vdivss	xmm11, xmm11, xmm6

; 213  : 		uvw.y /= scaleY;

	vdivss	xmm8, xmm8, xmm7
	vmovss	DWORD PTR uvw$[rsp], xmm11
	vmovss	DWORD PTR uvw$[rsp+4], xmm8
$LN11@uvMapping:

; 214  : 	}
; 215  : 
; 216  : 	// Flip
; 217  : 	if (t.flipX) if (rand() % 2) uvw.x = -uvw.x;

	cmp	DWORD PTR [rbx+92], 0
	vmovaps	xmm14, XMMWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+216]
	vmovaps	xmm9, xmm11
	je	SHORT $LN13@uvMapping
	call	QWORD PTR __imp_rand
	and	eax, -2147483647			; ffffffff80000001H
	jge	SHORT $LN62@uvMapping
	dec	eax
	or	eax, -2
	inc	eax
$LN62@uvMapping:
	test	eax, eax
	je	SHORT $LN13@uvMapping
	vxorps	xmm9, xmm11, DWORD PTR __xmm@80000000800000008000000080000000
	vmovss	DWORD PTR uvw$[rsp], xmm9
$LN13@uvMapping:

; 218  : 	if (t.flipY) if (rand() % 2) uvw.y = -uvw.y;

	cmp	DWORD PTR [rbx+96], 0
	vmovaps	xmm11, XMMWORD PTR [rsp+96]
	je	SHORT $LN15@uvMapping
	call	QWORD PTR __imp_rand
	and	eax, -2147483647			; ffffffff80000001H
	jge	SHORT $LN61@uvMapping
	dec	eax
	or	eax, -2
	inc	eax
$LN61@uvMapping:
	test	eax, eax
	je	SHORT $LN15@uvMapping
	vxorps	xmm8, xmm8, DWORD PTR __xmm@80000000800000008000000080000000
	vmovss	DWORD PTR uvw$[rsp+4], xmm8
$LN15@uvMapping:

; 219  : 	
; 220  : 	// Random scale
; 221  : 	if (t.randScale) {

	cmp	BYTE PTR [rbx+128], 0
	je	$LN65@uvMapping

; 222  : 		if (t.lock) {

	cmp	DWORD PTR [rbx+80], 0
	je	SHORT $LN17@uvMapping

; 223  : 			float s = 1.f + SFRAND() * t.randSX;

	call	QWORD PTR __imp_rand
	vmovss	xmm1, DWORD PTR [rbx+72]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm2, xmm0, xmm15
	vcvtss2sd xmm1, xmm1, xmm1
	vmulsd	xmm3, xmm1, xmm2

; 224  : 			scaleX = s;
; 225  : 			scaleY = s;

	vmovaps	xmm0, xmm3

; 226  : 		} else {

	jmp	SHORT $LN18@uvMapping
$LN17@uvMapping:

; 227  : 			scaleX = 1.f + SFRAND() * t.randSX;

	call	QWORD PTR __imp_rand
	vmovss	xmm6, DWORD PTR [rbx+72]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm7, xmm0, xmm15

; 228  : 			scaleY = 1.f + SFRAND() * t.randSY;

	call	QWORD PTR __imp_rand
	vmovss	xmm1, DWORD PTR [rbx+76]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm2, xmm0, xmm15
	vcvtss2sd xmm0, xmm6, xmm6
	vcvtss2sd xmm1, xmm1, xmm1
	vmulsd	xmm0, xmm0, xmm7
	vmulsd	xmm3, xmm1, xmm2
$LN18@uvMapping:

; 229  : 		}
; 230  : 
; 231  : 		if (scaleX < 0) scaleX = 0.f;

	vmovsd	xmm6, QWORD PTR __real@3ff0000000000000
	vaddsd	xmm0, xmm0, xmm6
	vcvtsd2ss xmm1, xmm0, xmm0
	vmaxss	xmm1, xmm12, xmm1

; 232  : 		if (scaleY < 0) scaleY = 0.f;

	vdivss	xmm9, xmm9, xmm1
	vaddsd	xmm0, xmm3, xmm6
	vcvtsd2ss xmm1, xmm0, xmm0
	vmaxss	xmm1, xmm12, xmm1

; 233  : 
; 234  : 		uvw.x /= scaleX;	 
; 235  : 		uvw.y /= scaleY;

	vdivss	xmm8, xmm8, xmm1
	vmovss	DWORD PTR uvw$[rsp+4], xmm8
	vmovss	DWORD PTR uvw$[rsp], xmm9
	jmp	SHORT $LN16@uvMapping
$LN65@uvMapping:

; 219  : 	
; 220  : 	// Random scale
; 221  : 	if (t.randScale) {

	vmovsd	xmm6, QWORD PTR __real@3ff0000000000000
$LN16@uvMapping:

; 236  : 	}
; 237  : 
; 238  : 	// Offset
; 239  : 	if (t.randOffset) {

	cmp	BYTE PTR [rbx+129], 0
	vmovaps	xmm12, XMMWORD PTR [rsp+80]
	vmovaps	xmm7, XMMWORD PTR [rsp+160]
	je	SHORT $LN21@uvMapping

; 240  : 		uvw.x += UFRAND() * t.randX;

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm1, xmm0, xmm15
	vmovss	xmm0, DWORD PTR [rbx+64]
	vaddsd	xmm2, xmm1, xmm1
	vsubsd	xmm3, xmm2, xmm6
	vcvtss2sd xmm1, xmm9, xmm9
	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm4, xmm3, xmm0
	vaddsd	xmm2, xmm4, xmm1
	vcvtsd2ss xmm9, xmm2, xmm2
	vmovss	DWORD PTR uvw$[rsp], xmm9

; 241  : 		uvw.y += UFRAND() * t.randY;

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2sd xmm0, xmm0, eax
	vdivsd	xmm1, xmm0, xmm15
	vmovss	xmm0, DWORD PTR [rbx+68]
	vaddsd	xmm2, xmm1, xmm1
	vsubsd	xmm3, xmm2, xmm6
	vcvtss2sd xmm1, xmm8, xmm8
	vcvtss2sd xmm0, xmm0, xmm0
	vmulsd	xmm4, xmm3, xmm0
	vaddsd	xmm2, xmm4, xmm1
	vcvtsd2ss xmm8, xmm2, xmm2
	vmovss	DWORD PTR uvw$[rsp+4], xmm8
$LN21@uvMapping:

; 242  : 	}
; 243  : 
; 244  : 	// Rotate
; 245  : 	if (t.rotUV)

	cmp	DWORD PTR [rbx+84], 0
	vmovaps	xmm15, XMMWORD PTR [rsp+48]
	je	SHORT $LN22@uvMapping
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 78   : 	return (_CSTD cosf(_Xx));

	vmovaps	xmm0, xmm10
	call	cosf
	vmovaps	xmm6, xmm0

; 285  : 	return (_CSTD sinf(_Xx));

	vmovaps	xmm0, xmm10
	call	sinf
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 117  : 	float rotX = (cos(angle)*d.x - sin(angle)*d.y);

	vmulss	xmm1, xmm0, xmm8

; 118  : 	float rotY = (sin(angle)*d.x + cos(angle)*d.y);

	vmulss	xmm0, xmm0, xmm9
	vmulss	xmm2, xmm6, xmm9
	vsubss	xmm4, xmm2, xmm1
	vmulss	xmm3, xmm6, xmm8
	vaddss	xmm8, xmm3, xmm0
	vmovss	DWORD PTR uvw$[rsp+4], xmm8

; 119  : 	d.x = rotX;

	vmovss	DWORD PTR uvw$[rsp], xmm4

; 120  : 	d.y = rotY;

	vmovaps	xmm9, xmm4
$LN22@uvMapping:

; 246  : 		rotatePoint2(uvw, angle);
; 247  : 
; 248  : 	// Offset to 0..1
; 249  : 	if (t.autoScale) {

	cmp	DWORD PTR [rbx+56], 0
	mov	rbx, QWORD PTR [rsp+208]
	vmovaps	xmm10, XMMWORD PTR [rsp+112]
	vmovaps	xmm6, XMMWORD PTR [rsp+176]
	je	SHORT $LN23@uvMapping

; 250  : 		uvw.x += .5f;

	vaddss	xmm0, xmm9, DWORD PTR __real@3f000000

; 251  : 		uvw.y += .5f;

	vaddss	xmm1, xmm8, DWORD PTR __real@3f000000
	vmovss	DWORD PTR uvw$[rsp], xmm0
	vmovss	DWORD PTR uvw$[rsp+4], xmm1
$LN23@uvMapping:

; 252  : 	}
; 253  : 
; 254  : 	// Return
; 255  : 	tp.uvw = uvw;

	vmovsd	xmm0, QWORD PTR uvw$[rsp]
	mov	eax, DWORD PTR uvw$[rsp+8]

; 256  : }

	lea	r11, QWORD PTR [rsp+192]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm9, XMMWORD PTR [r11-64]
	vmovsd	QWORD PTR [rsi+12], xmm0
	mov	DWORD PTR [rsi+20], eax
	mov	rsp, r11
	pop	rsi
	ret	0
?uvMapping@Tile@@CAXAEAVTilePoint@@VPoint3@@QEAMAEAVTileParam@@H@Z ENDP ; Tile::uvMapping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?rotateUV@Tile@@CAXHMAEAVPoint3@@@Z
_TEXT	SEGMENT
rotUV$ = 8
var$ = 16
d$ = 24
?rotateUV@Tile@@CAXHMAEAVPoint3@@@Z PROC		; Tile::rotateUV, COMDAT

; 113  : 
; 114  : }

	ret	0
?rotateUV@Tile@@CAXHMAEAVPoint3@@@Z ENDP		; Tile::rotateUV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z
_TEXT	SEGMENT
d$ = 96
angle$ = 104
?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z PROC		; Tile::rotatePoint2, COMDAT

; 116  : void Tile::rotatePoint2(Point3& d, float angle) {

$LN12:
	push	rbx
	sub	rsp, 80					; 00000050H
	vmovaps	XMMWORD PTR [rsp+64], xmm6
	mov	rbx, rcx
	vmovaps	XMMWORD PTR [rsp+48], xmm7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 78   : 	return (_CSTD cosf(_Xx));

	vmovaps	xmm0, xmm1
	vmovaps	XMMWORD PTR [rsp+32], xmm8
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 116  : void Tile::rotatePoint2(Point3& d, float angle) {

	vmovaps	xmm6, xmm1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 78   : 	return (_CSTD cosf(_Xx));

	call	cosf
	vmovaps	xmm8, xmm0

; 285  : 	return (_CSTD sinf(_Xx));

	vmovaps	xmm0, xmm6
	call	sinf
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 117  : 	float rotX = (cos(angle)*d.x - sin(angle)*d.y);

	vmulss	xmm1, xmm0, DWORD PTR [rbx+4]

; 118  : 	float rotY = (sin(angle)*d.x + cos(angle)*d.y);

	vmovss	xmm3, DWORD PTR [rbx]

; 119  : 	d.x = rotX;
; 120  : 	d.y = rotY;
; 121  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+64]
	vmovaps	xmm7, XMMWORD PTR [rsp+48]
	vmulss	xmm2, xmm8, xmm3
	vmulss	xmm3, xmm0, xmm3
	vmulss	xmm0, xmm8, DWORD PTR [rbx+4]
	vmovaps	xmm8, XMMWORD PTR [rsp+32]
	vsubss	xmm2, xmm2, xmm1
	vaddss	xmm1, xmm3, xmm0
	vmovss	DWORD PTR [rbx+4], xmm1
	vmovss	DWORD PTR [rbx], xmm2
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?rotatePoint2@Tile@@CAXAEAVPoint3@@M@Z ENDP		; Tile::rotatePoint2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
$T4 = 48
__$ReturnUdt$ = 192
rX$ = 200
rY$ = 208
w$ = 216
h$ = 224
t$ = 232
?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z PROC ; Tile::corner, COMDAT

; 51   : TilePoint Tile::corner(float rX, float rY, float w, float h, TileParam& t) {	

$LN90:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rdi
	push	rbp
	lea	rbp, QWORD PTR [rax-79]
	sub	rsp, 176				; 000000b0H

; 52   : 	// Evaluate	maps
; 53   : 	if (t.tileRound) {

	mov	rdi, QWORD PTR t$[rbp-105]
	mov	rbx, rcx
	vmovaps	XMMWORD PTR [rax-24], xmm6
	vmovaps	XMMWORD PTR [rax-40], xmm7
	vmovaps	XMMWORD PTR [rax-56], xmm8
	cmp	DWORD PTR [rdi+40], 0
	vmovaps	XMMWORD PTR [rax-72], xmm9
	vmovss	xmm9, DWORD PTR h$[rbp-105]
	vmovaps	XMMWORD PTR [rax-88], xmm10
	vmovaps	XMMWORD PTR [rax-104], xmm11
	vmovaps	xmm11, xmm3
	vmovaps	xmm7, xmm2
	vmovaps	xmm8, xmm1
	vxorps	xmm10, xmm10, xmm10
	je	$LN14@corner

; 54   : 		bool inCorner = false;
; 55   : 		float cX=0.0f, cY=0.0f;
; 56   : 		// Detect corner
; 57   : 		if (rX < t.tileCrnrRad) { 

	vmovss	xmm6, DWORD PTR [rdi+52]
	xor	al, al
	vcomiss	xmm6, xmm8
	vxorps	xmm2, xmm2, xmm2
	vxorps	xmm1, xmm1, xmm1
	jbe	SHORT $LN3@corner

; 58   : 			if (rY < t.tileCrnrRad) { // Bottom left

	vcomiss	xmm6, xmm7
	jbe	SHORT $LN5@corner

; 59   : 				cX = t.tileCrnrRad - rX;

	vsubss	xmm2, xmm6, xmm8

; 60   : 				cY = t.tileCrnrRad - rY; 				

	vsubss	xmm1, xmm6, xmm7

; 61   : 				inCorner = true;

	jmp	SHORT $LN83@corner
$LN5@corner:

; 62   : 			} else if (rY > h - t.tileCrnrRad) { // Top left

	vsubss	xmm0, xmm9, xmm6
	vcomiss	xmm7, xmm0
	jbe	SHORT $LN11@corner

; 63   : 				cX = t.tileCrnrRad - rX;
; 64   : 				cY = h - rY - t.tileCrnrRad; 				

	vsubss	xmm0, xmm9, xmm7
	vsubss	xmm1, xmm0, xmm6
	vsubss	xmm2, xmm6, xmm8

; 65   : 				inCorner = true;
; 66   : 			}

	jmp	SHORT $LN83@corner
$LN3@corner:

; 67   : 		} else if (rX > w - t.tileCrnrRad) {

	vsubss	xmm0, xmm11, xmm6
	vcomiss	xmm8, xmm0
	jbe	SHORT $LN11@corner

; 68   : 			if (rY < t.tileCrnrRad) { // Bottom right

	vcomiss	xmm6, xmm7
	jbe	SHORT $LN9@corner

; 69   : 				cX = w - rX - t.tileCrnrRad;
; 70   : 				cY = t.tileCrnrRad - rY; 				

	vsubss	xmm1, xmm6, xmm7

; 71   : 				inCorner = true;

	jmp	SHORT $LN84@corner
$LN9@corner:

; 72   : 			} else if (rY > h - t.tileCrnrRad) { // Top right

	vsubss	xmm0, xmm9, xmm6
	vcomiss	xmm7, xmm0
	jbe	SHORT $LN11@corner

; 73   : 				cX = w - rX - t.tileCrnrRad;
; 74   : 				cY = h - rY - t.tileCrnrRad;

	vsubss	xmm1, xmm9, xmm7
	vsubss	xmm1, xmm1, xmm6
$LN84@corner:

; 75   : 				inCorner = true;
; 76   : 			}
; 77   : 		}
; 78   : 		float d = cY*cY + cX*cX;

	vsubss	xmm0, xmm11, xmm8
	vsubss	xmm2, xmm0, xmm6
$LN83@corner:
	mov	al, 1
$LN11@corner:
	vmulss	xmm1, xmm1, xmm1
	vmulss	xmm0, xmm2, xmm2
	vaddss	xmm3, xmm1, xmm0

; 79   : 		if (inCorner) {

	test	al, al
	je	$LN14@corner

; 80   : 			if (d > t.tileCrnrRad*t.tileCrnrRad)

	vmulss	xmm0, xmm6, xmm6
	vcomiss	xmm3, xmm0
	jbe	SHORT $LN13@corner
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File g:\dropbox\github\berconmaps\src\tile.h

; 165  : 	TilePoint() {d = -1.f;}	

	mov	DWORD PTR [rcx+24], -1082130432		; bf800000H
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 81   : 				return TilePoint();

	jmp	$LN85@corner
$LN13@corner:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 295  : 	return (_CSTD sqrtf(_Xx));

	vmovaps	xmm0, xmm3
	call	sqrtf
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 84   : 			if (t.tileBlur > 0 && d <t. tileBlurRad)

	mov	ecx, DWORD PTR [rdi+44]
	vsubss	xmm3, xmm6, xmm0
	test	ecx, ecx
	jle	SHORT $LN14@corner
	vmovss	xmm0, DWORD PTR [rdi+48]
	vcomiss	xmm0, xmm3
	jbe	SHORT $LN14@corner

; 41   : 	switch (type) {		

	sub	ecx, 1
	je	SHORT $LN37@corner
	sub	ecx, 1
	je	SHORT $LN38@corner
	cmp	ecx, 1
	je	SHORT $LN39@corner

; 47   : 		default: return 1.f;

	vmovss	xmm3, DWORD PTR __real@3f800000
	jmp	SHORT $LN34@corner
$LN39@corner:

; 46   : 		case 3: return smooth(d, 0.f, r); // Smooth					

	vmovaps	xmm2, xmm0
	vmovaps	xmm0, xmm3
	vxorps	xmm1, xmm1, xmm1
	call	?smooth@@YAMMMM@Z			; smooth
	vmovaps	xmm3, xmm0
	jmp	SHORT $LN34@corner
$LN38@corner:

; 43   : 		case 2: // Cubic
; 44   : 			d = 1.f - (d/r);

	vmovss	xmm2, DWORD PTR __real@3f800000
	vdivss	xmm0, xmm3, xmm0
	vsubss	xmm0, xmm2, xmm0

; 45   : 			return sqrt(1-d*d);

	vmulss	xmm1, xmm0, xmm0
	vsubss	xmm0, xmm2, xmm1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 295  : 	return (_CSTD sqrtf(_Xx));

	call	sqrtf
	vmovaps	xmm3, xmm0
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 45   : 			return sqrt(1-d*d);

	jmp	SHORT $LN34@corner
$LN37@corner:

; 42   : 		case 1: return d/r; // Linear

	vdivss	xmm3, xmm3, xmm0
$LN34@corner:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	xor	eax, eax
	mov	QWORD PTR [rbx], rax
	mov	DWORD PTR [rbx+8], eax
	mov	QWORD PTR [rbx+16], rax
; File g:\dropbox\github\berconmaps\src\tile.h

; 168  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	vmovss	DWORD PTR [rbx+24], xmm3
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 85   : 				return TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(d, t.tileBlurRad, t.tileBlur));

	jmp	$LN86@corner
$LN14@corner:

; 86   : 		}
; 87   : 	} 
; 88   : 	if (t.tileBlur) {		

	mov	r8d, DWORD PTR [rdi+44]
	test	r8d, r8d
	je	$LN22@corner

; 89   : 		bool inCorner = false;
; 90   : 		float dX = rX;
; 91   : 		float dY = rY;
; 92   : 		// Distance to vertical walls
; 93   : 		if (rX < t.tileBlurRad) {

	vmovss	xmm4, DWORD PTR [rdi+48]
	xor	al, al
	vcomiss	xmm4, xmm8
	vmovaps	xmm5, xmm8
	vmovaps	xmm3, xmm7
	ja	SHORT $LN87@corner

; 94   : 			inCorner = true;
; 95   : 		} else if (rX > w - t.tileBlurRad) {

	vsubss	xmm0, xmm11, xmm4
	vcomiss	xmm8, xmm0
	jbe	SHORT $LN18@corner

; 96   : 			dX = w - rX;

	vsubss	xmm5, xmm11, xmm8
$LN87@corner:

; 97   : 			inCorner = true;
; 98   : 		}
; 99   : 		// Distance to horizontal walls
; 100  : 		if (rY < t.tileBlurRad) {

	mov	al, 1
$LN18@corner:
	vcomiss	xmm4, xmm7
	ja	SHORT $LN82@corner

; 101  : 			inCorner = true;
; 102  : 		} else if (rY > h - t.tileBlurRad) {

	vsubss	xmm0, xmm9, xmm4
	vcomiss	xmm7, xmm0
	jbe	SHORT $LN21@corner

; 103  : 			dY = h - rY;

	vsubss	xmm3, xmm9, xmm7

; 104  : 			inCorner = true;
; 105  : 		}
; 106  : 		if (inCorner)

	jmp	SHORT $LN82@corner
$LN21@corner:
	test	al, al
	je	$LN22@corner
$LN82@corner:

; 107  : 			return dX<dY?TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dX, t.tileBlurRad, t.tileBlur)):TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dY, t.tileBlurRad, t.tileBlur));

	vcomiss	xmm3, xmm5
	vmovss	DWORD PTR $T2[rbp-97], xmm10
	mov	eax, DWORD PTR $T2[rbp-97]
	mov	DWORD PTR $T4[rbp-85], eax
	vmovss	DWORD PTR $T4[rbp-105], xmm10
	vmovss	DWORD PTR $T4[rbp-101], xmm10
	vdivss	xmm0, xmm8, xmm11
	vdivss	xmm1, xmm7, xmm9
	jbe	SHORT $LN24@corner
; File g:\dropbox\github\berconmaps\src\tile.h

; 168  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	vunpcklps xmm2, xmm0, xmm1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 107  : 			return dX<dY?TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dX, t.tileBlurRad, t.tileBlur)):TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dY, t.tileBlurRad, t.tileBlur));

	vmovaps	xmm1, xmm4
	vmovaps	xmm0, xmm5
; File g:\dropbox\github\berconmaps\src\tile.h

; 168  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	vmovsd	QWORD PTR $T4[rbp-93], xmm2
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	vmovss	DWORD PTR $T4[rbp-97], xmm10
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 107  : 			return dX<dY?TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dX, t.tileBlurRad, t.tileBlur)):TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dY, t.tileBlurRad, t.tileBlur));

	call	?edgeBlur@Tile@@CAMMMH@Z		; Tile::edgeBlur
	vxorps	xmm6, xmm6, xmm6
	jmp	SHORT $LN88@corner
$LN24@corner:
; File g:\dropbox\github\berconmaps\src\tile.h

; 168  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	vunpcklps xmm1, xmm0, xmm1
	vmovsd	QWORD PTR $T3[rbp-93], xmm1
	vxorps	xmm6, xmm6, xmm6
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 107  : 			return dX<dY?TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dX, t.tileBlurRad, t.tileBlur)):TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dY, t.tileBlurRad, t.tileBlur));

	vmovaps	xmm1, xmm4
	vmovaps	xmm0, xmm3
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	vmovss	DWORD PTR $T3[rbp-97], xmm6
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 107  : 			return dX<dY?TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dX, t.tileBlurRad, t.tileBlur)):TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dY, t.tileBlurRad, t.tileBlur));

	call	?edgeBlur@Tile@@CAMMMH@Z		; Tile::edgeBlur
$LN88@corner:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	mov	edx, DWORD PTR $T3[rbp-77]
	lea	rcx, QWORD PTR $T3[rbp-93]
	vmovss	DWORD PTR [rbx+4], xmm10
	vmovss	DWORD PTR [rbx+8], xmm6
	xor	eax, eax
	mov	DWORD PTR [rbx], eax
	vmovss	DWORD PTR $T3[rbp-81], xmm0
	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rbx+12], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+16], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+20], eax
	vmovss	DWORD PTR [rbx+24], xmm0
	mov	DWORD PTR [rbx+28], edx
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 107  : 			return dX<dY?TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dX, t.tileBlurRad, t.tileBlur)):TilePoint(Point3(rX/w, rY/h, 0.f), edgeBlur(dY, t.tileBlurRad, t.tileBlur));

	jmp	SHORT $LN85@corner
$LN22@corner:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	xor	eax, eax
	mov	QWORD PTR [rbx], rax
	mov	DWORD PTR [rbx+8], eax
	mov	QWORD PTR [rbx+16], rax
; File g:\dropbox\github\berconmaps\src\tile.h

; 168  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	mov	DWORD PTR [rbx+24], 1065353216		; 3f800000H
$LN86@corner:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 110  : }

	vdivss	xmm0, xmm7, xmm9
	vdivss	xmm1, xmm8, xmm11
	vunpcklps xmm0, xmm1, xmm0
	vmovss	DWORD PTR $T1[rbp-97], xmm10
	mov	eax, DWORD PTR $T1[rbp-97]
	vmovsd	QWORD PTR [rbx+12], xmm0
	mov	DWORD PTR [rbx+20], eax
$LN85@corner:
	lea	r11, QWORD PTR [rsp+176]
	mov	rax, rbx
	mov	rbx, QWORD PTR [r11+16]
	mov	rdi, QWORD PTR [r11+24]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm9, XMMWORD PTR [r11-64]
	vmovaps	xmm10, XMMWORD PTR [r11-80]
	vmovaps	xmm11, XMMWORD PTR [r11-96]
	mov	rsp, r11
	pop	rbp
	ret	0
?corner@Tile@@CA?AVTilePoint@@MMMMAEAVTileParam@@@Z ENDP ; Tile::corner
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?edgeBlur@Tile@@CAMMMH@Z
_TEXT	SEGMENT
d$ = 8
r$ = 16
type$ = 24
?edgeBlur@Tile@@CAMMMH@Z PROC				; Tile::edgeBlur, COMDAT

; 41   : 	switch (type) {		

	sub	r8d, 1
	je	SHORT $LN4@edgeBlur
	sub	r8d, 1
	je	SHORT $LN5@edgeBlur
	cmp	r8d, 1
	je	SHORT $LN6@edgeBlur

; 47   : 		default: return 1.f;

	vmovss	xmm0, DWORD PTR __real@3f800000

; 48   : 	}	
; 49   : }

	ret	0
$LN6@edgeBlur:

; 46   : 		case 3: return smooth(d, 0.f, r); // Smooth					

	vmovaps	xmm2, xmm1
	vxorps	xmm1, xmm1, xmm1
	jmp	?smooth@@YAMMMM@Z			; smooth
$LN5@edgeBlur:

; 43   : 		case 2: // Cubic
; 44   : 			d = 1.f - (d/r);

	vmovss	xmm2, DWORD PTR __real@3f800000
	vdivss	xmm0, xmm0, xmm1
	vsubss	xmm0, xmm2, xmm0

; 45   : 			return sqrt(1-d*d);

	vmulss	xmm1, xmm0, xmm0
	vsubss	xmm0, xmm2, xmm1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 295  : 	return (_CSTD sqrtf(_Xx));

	jmp	sqrtf
$LN4@edgeBlur:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 42   : 		case 1: return d/r; // Linear

	vdivss	xmm0, xmm0, xmm1

; 48   : 	}	
; 49   : }

	ret	0
?edgeBlur@Tile@@CAMMMH@Z ENDP				; Tile::edgeBlur
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
;	COMDAT ??0TilePoint@@QEAA@$$QEAV0@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0TilePoint@@QEAA@$$QEAV0@@Z PROC			; TilePoint::TilePoint, COMDAT

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rcx+12], eax
	mov	eax, DWORD PTR [rdx+16]
	mov	DWORD PTR [rcx+16], eax
	mov	eax, DWORD PTR [rdx+20]
	mov	DWORD PTR [rcx+20], eax
	mov	eax, DWORD PTR [rdx+24]
	mov	DWORD PTR [rcx+24], eax
	mov	eax, DWORD PTR [rdx+28]
	mov	DWORD PTR [rcx+28], eax
	mov	rax, rcx
	ret	0
??0TilePoint@@QEAA@$$QEAV0@@Z ENDP			; TilePoint::TilePoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
;	COMDAT ??0TilePoint@@QEAA@VPoint3@@M@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
??0TilePoint@@QEAA@VPoint3@@M@Z PROC			; TilePoint::TilePoint, COMDAT
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File g:\dropbox\github\berconmaps\src\tile.h

; 168  : 	TilePoint(Point3 x, float y) {uvw = x; d = y;}

	vmovsd	xmm0, QWORD PTR [rdx]
	vmovsd	QWORD PTR [rcx+12], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+20], eax
	mov	rax, rcx
	vmovss	DWORD PTR [rcx+24], xmm2
	ret	0
??0TilePoint@@QEAA@VPoint3@@M@Z ENDP			; TilePoint::TilePoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\tile.h
;	COMDAT ??0TilePoint@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0TilePoint@@QEAA@XZ PROC				; TilePoint::TilePoint, COMDAT
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File g:\dropbox\github\berconmaps\src\tile.h

; 165  : 	TilePoint() {d = -1.f;}	

	mov	rax, rcx
	mov	DWORD PTR [rcx+24], -1082130432		; bf800000H
	ret	0
??0TilePoint@@QEAA@XZ ENDP				; TilePoint::TilePoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?setPreset@TilePattern@@QEAAXH@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?setPreset@TilePattern@@QEAAXH@Z PROC			; TilePattern::setPreset, COMDAT

; 493  : void TilePattern::setPreset(int preset) {

$LN270:

; 494  : 	switch (preset) {

	cmp	edx, 9
	ja	$LN266@setPreset
	push	rbp
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H
	mov	QWORD PTR $T1[rbp-80], -2
	mov	QWORD PTR [rsp+96], rbx

; 493  : void TilePattern::setPreset(int preset) {

	mov	rbx, rcx

; 494  : 	switch (preset) {

	movsxd	rax, edx
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	edx, DWORD PTR $LN265@setPreset[rcx+rax*4]
	add	rdx, rcx
	jmp	rdx
$LN4@setPreset:

; 495  : 		case 0: setPattern(L"0, 1, 1"); break; // Stack

	lea	rax, QWORD PTR $T11[rbp-80]
	mov	QWORD PTR $T21[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR $T11[rbp-64], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T11[rbp-56], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T11[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	lea	r8d, QWORD PTR [rax+7]
	lea	rdx, OFFSET FLAT:??_C@_1BA@HLCPMHKJ@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1@
	lea	rcx, QWORD PTR $T11[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 495  : 		case 0: setPattern(L"0, 1, 1"); break; // Stack

	jmp	$LN267@setPreset
$LN5@setPreset:

; 496  : 		case 1: setPattern(L"0, 1, 1 / 0.5, 1, 1"); break; // Stretcher

	lea	rax, QWORD PTR $T10[rbp-80]
	mov	QWORD PTR $T20[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR $T10[rbp-64], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T10[rbp-56], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T10[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	lea	r8d, QWORD PTR [rax+19]
	lea	rdx, OFFSET FLAT:??_C@_1CI@MGOLCOH@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?5?$AA?1?$AA?5?$AA0?$AA?4?$AA5?$AA?0?$AA?5@
	lea	rcx, QWORD PTR $T10[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 496  : 		case 1: setPattern(L"0, 1, 1 / 0.5, 1, 1"); break; // Stretcher

	jmp	$LN267@setPreset
$LN6@setPreset:

; 497  : 		case 2: setPattern(L".25, 1, 1, .5 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1"); break; // Flemish Strecher

	lea	rax, QWORD PTR $T9[rbp-80]
	mov	QWORD PTR $T19[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR $T9[rbp-64], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T9[rbp-56], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T9[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	lea	r8d, QWORD PTR [rax+61]
	lea	rdx, OFFSET FLAT:??_C@_1HM@KFKBNDNL@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1@
	lea	rcx, QWORD PTR $T9[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 497  : 		case 2: setPattern(L".25, 1, 1, .5 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1"); break; // Flemish Strecher

	jmp	$LN267@setPreset
$LN7@setPreset:

; 498  : 		case 3: setPattern(L".25, 1, .5 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1"); break; // Common

	lea	rax, QWORD PTR $T8[rbp-80]
	mov	QWORD PTR $T18[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR $T8[rbp-64], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T8[rbp-56], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T8[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	lea	r8d, QWORD PTR [rax+58]
	lea	rdx, OFFSET FLAT:??_C@_1HG@LGFFBGEF@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4@
	lea	rcx, QWORD PTR $T8[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 498  : 		case 3: setPattern(L".25, 1, .5 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1 / -.5, 1, 1"); break; // Common

	jmp	$LN267@setPreset
$LN8@setPreset:

; 499  : 		case 4: setPattern(L"0, 1, 1, .5 / .75, 1, 1, .5"); break; // Flemish

	lea	rax, QWORD PTR $T7[rbp-80]
	mov	QWORD PTR $T17[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR $T7[rbp-64], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T7[rbp-56], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T7[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	lea	r8d, QWORD PTR [rax+27]
	lea	rdx, OFFSET FLAT:??_C@_1DI@OGPGLDJP@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?4@
	lea	rcx, QWORD PTR $T7[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 499  : 		case 4: setPattern(L"0, 1, 1, .5 / .75, 1, 1, .5"); break; // Flemish

	jmp	$LN267@setPreset
$LN9@setPreset:

; 500  : 		case 5: setPattern(L"0, 1, 1, 1, .5 / 1.25, 1, 1, 1, .5"); break; // Monk Bond

	lea	rax, QWORD PTR $T6[rbp-80]
	mov	QWORD PTR $T16[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR $T6[rbp-64], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T6[rbp-56], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T6[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	lea	r8d, QWORD PTR [rax+34]
	lea	rdx, OFFSET FLAT:??_C@_1EG@NKHPAEJM@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5@
	lea	rcx, QWORD PTR $T6[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 500  : 		case 5: setPattern(L"0, 1, 1, 1, .5 / 1.25, 1, 1, 1, .5"); break; // Monk Bond

	jmp	$LN267@setPreset
$LN10@setPreset:

; 501  : 		case 6: setPattern(L"0, 1, 1, 1, 1, .5 / 1.75, 1, 1, 1, 1, .5"); break; // Flemish Garden Wall

	lea	rax, QWORD PTR $T5[rbp-80]
	mov	QWORD PTR $T15[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR $T5[rbp-64], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T5[rbp-56], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T5[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	lea	r8d, QWORD PTR [rax+40]
	lea	rdx, OFFSET FLAT:??_C@_1FC@MFPKJHBG@?$AA0?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA1?$AA?0?$AA?5@
	lea	rcx, QWORD PTR $T5[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 501  : 		case 6: setPattern(L"0, 1, 1, 1, 1, .5 / 1.75, 1, 1, 1, 1, .5"); break; // Flemish Garden Wall

	jmp	$LN267@setPreset
$LN11@setPreset:

; 502  : 		case 7: setPattern(L".25, 1, .5 / 0, 1, 1"); break; // English

	lea	rax, QWORD PTR $T4[rbp-80]
	mov	QWORD PTR $T14[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR $T4[rbp-64], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T4[rbp-56], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T4[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	lea	r8d, QWORD PTR [rax+20]
	lea	rdx, OFFSET FLAT:??_C@_1CK@FBIPLABB@?$AA?4?$AA2?$AA5?$AA?0?$AA?5?$AA1?$AA?0?$AA?5?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA0?$AA?0@
	lea	rcx, QWORD PTR $T4[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 502  : 		case 7: setPattern(L".25, 1, .5 / 0, 1, 1"); break; // English

	jmp	SHORT $LN267@setPreset
$LN12@setPreset:

; 503  : 		case 8: setPattern(L"0,1,1 / -.25,1,.5 / -.25,1,1 / -.25,1,.5"); break; // English Cross

	lea	rax, QWORD PTR $T3[rbp-80]
	mov	QWORD PTR $T13[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR $T3[rbp-64], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T3[rbp-56], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T3[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	lea	r8d, QWORD PTR [rax+40]
	lea	rdx, OFFSET FLAT:??_C@_1FC@LEIJMHNO@?$AA0?$AA?0?$AA1?$AA?0?$AA1?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1?$AA?0@
	lea	rcx, QWORD PTR $T3[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 503  : 		case 8: setPattern(L"0,1,1 / -.25,1,.5 / -.25,1,1 / -.25,1,.5"); break; // English Cross

	jmp	SHORT $LN267@setPreset
$LN13@setPreset:

; 504  : 		case 9: setPattern(L"0,1,.5 / -.25,1,.5 / -.25,1,1 / -.25,1,1"); break; // Double English Cross

	lea	rax, QWORD PTR $T2[rbp-80]
	mov	QWORD PTR $T12[rbp-80], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR $T2[rbp-64], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T2[rbp-56], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR $T2[rbp-80], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	lea	r8d, QWORD PTR [rax+40]
	lea	rdx, OFFSET FLAT:??_C@_1FC@DKDGEDND@?$AA0?$AA?0?$AA1?$AA?0?$AA?4?$AA5?$AA?5?$AA?1?$AA?5?$AA?9?$AA?4?$AA2?$AA5?$AA?0?$AA1@
	lea	rcx, QWORD PTR $T2[rbp-80]
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1
$LN267@setPreset:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 506  : }

	lea	rdx, QWORD PTR $T2[rbp-80]
	mov	rcx, rbx
	call	?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; TilePattern::setPattern
$LN2@setPreset:
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rbp
$LN266@setPreset:
	ret	0
	npad	1
$LN265@setPreset:
	DD	$LN4@setPreset
	DD	$LN5@setPreset
	DD	$LN6@setPreset
	DD	$LN7@setPreset
	DD	$LN8@setPreset
	DD	$LN9@setPreset
	DD	$LN10@setPreset
	DD	$LN11@setPreset
	DD	$LN12@setPreset
	DD	$LN13@setPreset
?setPreset@TilePattern@@QEAAXH@Z ENDP			; TilePattern::setPreset
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$0@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$0
	mov	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$1@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$1
	mov	rcx, QWORD PTR $T20[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$1
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$2@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$2
	mov	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$2@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$2
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$3@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$3
	mov	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$3@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$3
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$4@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$4
	mov	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$4@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$4
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$5@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$5
	mov	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$5@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$5
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$6@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$6
	mov	rcx, QWORD PTR $T15[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$6@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$6
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$7@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$7
	mov	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$7@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$7
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$8@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$8
	mov	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$8@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$8
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$9@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$9
	mov	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$9@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$0@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$0
	mov	rcx, QWORD PTR $T21[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$1@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$1
	mov	rcx, QWORD PTR $T20[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$2@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$2
	mov	rcx, QWORD PTR $T19[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$2@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$3@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$3
	mov	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$3@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$4@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$4
	mov	rcx, QWORD PTR $T17[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$4@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$5@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$5
	mov	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$5@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$6@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$6
	mov	rcx, QWORD PTR $T15[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$6@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$7@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$7
	mov	rcx, QWORD PTR $T14[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$7@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$8@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$8
	mov	rcx, QWORD PTR $T13[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$8@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T3 = 40
$T4 = 40
$T5 = 40
$T6 = 40
$T7 = 40
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
this$ = 96
preset$ = 104
$T12 = 112
$T13 = 112
$T14 = 112
$T15 = 112
$T16 = 112
$T17 = 112
$T18 = 112
$T19 = 112
$T20 = 112
$T21 = 112
?dtor$9@?0??setPreset@TilePattern@@QEAAXH@Z@4HA PROC	; `TilePattern::setPreset'::`1'::dtor$9
	mov	rcx, QWORD PTR $T12[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$9@?0??setPreset@TilePattern@@QEAAXH@Z@4HA ENDP	; `TilePattern::setPreset'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
;	COMDAT ?update@TilePattern@@QEAAXXZ
_TEXT	SEGMENT
this$ = 16
?update@TilePattern@@QEAAXXZ PROC			; TilePattern::update, COMDAT

; 82   : 	void update() {

$LN74:
	mov	QWORD PTR [rsp+24], rbp
	push	rdi

; 83   : 		totalHeight = 0.f;

	xor	ebp, ebp
	mov	r11, rcx
	mov	DWORD PTR [rcx], ebp

; 84   : 		for (int i=0; i<rows.size(); i++) {

	mov	edi, ebp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rdx, QWORD PTR [rcx+32]
	mov	rax, QWORD PTR [rcx+40]
	sub	rax, rdx
	sar	rax, 5
; File g:\dropbox\github\berconmaps\src\tile.h

; 84   : 		for (int i=0; i<rows.size(); i++) {

	test	rax, rax
	je	$LN3@update
	mov	QWORD PTR [rsp+16], rbx
	mov	r8d, ebp
	mov	QWORD PTR [rsp+24], rsi
	mov	esi, ebp
	npad	10
$LL4@update:

; 65   : 		totalWidth = 0.f;

	mov	DWORD PTR [r8+rdx+4], ebp

; 66   : 		for (int i=0; i<tiles.size(); i++)

	mov	r10d, ebp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rbx, QWORD PTR [r8+rdx+8]
	mov	rax, QWORD PTR [r8+rdx+16]
	sub	rax, rbx
	sar	rax, 2
; File g:\dropbox\github\berconmaps\src\tile.h

; 66   : 		for (int i=0; i<tiles.size(); i++)

	test	rax, rax
	je	SHORT $LN72@update
	vxorps	xmm0, xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

	mov	r9, rbp
	npad	11
$LL31@update:
; File g:\dropbox\github\berconmaps\src\tile.h

; 67   : 			totalWidth += tiles[i];

	vaddss	xmm0, xmm0, DWORD PTR [r9+rbx]
	inc	r10d
	lea	r9, QWORD PTR [r9+4]
	vmovss	DWORD PTR [r8+rdx+4], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rcx, QWORD PTR [r8+rdx+16]
	sub	rcx, rbx
; File g:\dropbox\github\berconmaps\src\tile.h

; 66   : 		for (int i=0; i<tiles.size(); i++)

	movsxd	rax, r10d
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	sar	rcx, 2
; File g:\dropbox\github\berconmaps\src\tile.h

; 66   : 		for (int i=0; i<tiles.size(); i++)

	cmp	rax, rcx
	jb	SHORT $LL31@update
$LN72@update:

; 85   : 			rows[i].update();
; 86   : 			totalHeight += heights[i];

	mov	rax, QWORD PTR [r11+8]
	inc	edi
	add	r8, 32					; 00000020H
	vmovss	xmm0, DWORD PTR [rsi+rax]
	vaddss	xmm1, xmm0, DWORD PTR [r11]
	vmovss	DWORD PTR [r11], xmm1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rdx, QWORD PTR [r11+32]
; File g:\dropbox\github\berconmaps\src\tile.h

; 84   : 		for (int i=0; i<rows.size(); i++) {

	add	rsi, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rcx, QWORD PTR [r11+40]
	sub	rcx, rdx
; File g:\dropbox\github\berconmaps\src\tile.h

; 84   : 		for (int i=0; i<rows.size(); i++) {

	movsxd	rax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	sar	rcx, 5
; File g:\dropbox\github\berconmaps\src\tile.h

; 84   : 		for (int i=0; i<rows.size(); i++) {

	cmp	rax, rcx
	jb	$LL4@update
	mov	rsi, QWORD PTR [rsp+24]
	mov	rbx, QWORD PTR [rsp+16]
$LN3@update:

; 87   : 		}
; 88   : 	}

	mov	rbp, QWORD PTR [rsp+32]
	pop	rdi
	ret	0
?update@TilePattern@@QEAAXXZ ENDP			; TilePattern::update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
$T2 = 128
this$ = 128
s$ = 136
?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; TilePattern::setPattern, COMDAT

; 561  : void TilePattern::setPattern(std::wstring s) {

$LN164:
	mov	r11, rsp
	mov	QWORD PTR [r11+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	QWORD PTR [r11-88], -2
	mov	QWORD PTR [r11+24], rbx
	mov	r14, rdx
	mov	rdi, rcx

; 562  : 	parsePattern(s, this);

	lea	rax, QWORD PTR [r11-80]
	mov	QWORD PTR [r11+8], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

	xor	r15d, r15d
	mov	QWORD PTR [r11-64], r15

; 1785 : 		_Myres(0)

	mov	QWORD PTR [r11-56], r15

; 2399 : 		const size_type _Right_size = _Right_data._Mysize;

	mov	rsi, QWORD PTR [rdx+16]

; 1814 : 		const value_type * _Result = _Bx._Buf;

	mov	rbp, rdx

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rdx+24], 8

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN35@setPattern
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	rbp, QWORD PTR [rdx]
$LN35@setPattern:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2401 : 		if (_Right_size < this->_BUF_SIZE)

	cmp	rsi, 8
	jae	SHORT $LN24@setPattern
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	vmovups	xmm0, XMMWORD PTR [rbp]
	vmovups	XMMWORD PTR $T1[rsp], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2405 : 			_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T1[rsp+24], 7

; 2406 : 			return;

	jmp	SHORT $LN161@setPattern
$LN24@setPattern:

; 2407 : 			}
; 2408 : 
; 2409 : 		auto& _Al = this->_Getal();
; 2410 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

	mov	rbx, rsi
	or	rbx, 7
	mov	rax, 9223372036854775806		; 7ffffffffffffffeH
	cmp	rbx, rax
	cmova	rbx, rax

; 2411 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbx+1]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	QWORD PTR $T1[rsp], rax
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	r8, QWORD PTR [rsi*2+2]
	mov	rdx, rbp
	mov	rcx, rax
	call	memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2415 : 		_My_data._Myres = _New_capacity;

	mov	QWORD PTR $T1[rsp+24], rbx
$LN161@setPattern:
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 562  : 	parsePattern(s, this);

	mov	QWORD PTR $T1[rsp+16], rsi
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T1[rsp]
	call	?parsePattern@@YAHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVTilePattern@@@Z ; parsePattern
; File g:\dropbox\github\berconmaps\src\tile.h

; 83   : 		totalHeight = 0.f;

	mov	DWORD PTR [rdi], r15d

; 84   : 		for (int i=0; i<rows.size(); i++) {

	mov	ebx, r15d
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rdx, QWORD PTR [rdi+32]
	mov	rax, QWORD PTR [rdi+40]
	sub	rax, rdx
	sar	rax, 5
; File g:\dropbox\github\berconmaps\src\tile.h

; 84   : 		for (int i=0; i<rows.size(); i++) {

	test	rax, rax
	je	$LN81@setPattern
	mov	rsi, r15
	mov	r8, r15
	npad	3
$LL82@setPattern:

; 65   : 		totalWidth = 0.f;

	mov	DWORD PTR [r8+rdx+4], r15d

; 66   : 		for (int i=0; i<tiles.size(); i++)

	mov	r10d, r15d
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	r11, QWORD PTR [r8+rdx+8]
	mov	rax, QWORD PTR [r8+rdx+16]
	sub	rax, r11
	sar	rax, 2
; File g:\dropbox\github\berconmaps\src\tile.h

; 66   : 		for (int i=0; i<tiles.size(); i++)

	test	rax, rax
	je	SHORT $LN160@setPattern
	vxorps	xmm0, xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

	mov	r9, r15
	npad	11
$LL109@setPattern:
; File g:\dropbox\github\berconmaps\src\tile.h

; 67   : 			totalWidth += tiles[i];

	vaddss	xmm0, xmm0, DWORD PTR [r9+r11]
	vmovss	DWORD PTR [r8+rdx+4], xmm0

; 66   : 		for (int i=0; i<tiles.size(); i++)

	inc	r10d
	lea	r9, QWORD PTR [r9+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rcx, QWORD PTR [r8+rdx+16]
	sub	rcx, r11
	sar	rcx, 2
; File g:\dropbox\github\berconmaps\src\tile.h

; 66   : 		for (int i=0; i<tiles.size(); i++)

	movsxd	rax, r10d
	cmp	rax, rcx
	jb	SHORT $LL109@setPattern
$LN160@setPattern:

; 86   : 			totalHeight += heights[i];

	mov	rax, QWORD PTR [rdi+8]
	vmovss	xmm0, DWORD PTR [rax+rsi]
	vaddss	xmm1, xmm0, DWORD PTR [rdi]
	vmovss	DWORD PTR [rdi], xmm1

; 84   : 		for (int i=0; i<rows.size(); i++) {

	inc	ebx
	add	r8, 32					; 00000020H
	add	rsi, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rdx, QWORD PTR [rdi+32]
	mov	rcx, QWORD PTR [rdi+40]
	sub	rcx, rdx
	sar	rcx, 5
; File g:\dropbox\github\berconmaps\src\tile.h

; 84   : 		for (int i=0; i<rows.size(); i++) {

	movsxd	rax, ebx
	cmp	rax, rcx
	jb	$LL82@setPattern
$LN81@setPattern:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	mov	rcx, r14
; File g:\dropbox\github\berconmaps\src\tile.cpp

; 564  : }

	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

	jmp	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
?setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; TilePattern::setPattern
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 128
this$ = 128
s$ = 136
?dtor$0@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA PROC ; `TilePattern::setPattern'::`1'::dtor$0
	mov	rcx, QWORD PTR s$[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA ENDP ; `TilePattern::setPattern'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 128
this$ = 128
s$ = 136
?dtor$1@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA PROC ; `TilePattern::setPattern'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA ENDP ; `TilePattern::setPattern'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 128
this$ = 128
s$ = 136
?dtor$0@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA PROC ; `TilePattern::setPattern'::`1'::dtor$0
	mov	rcx, QWORD PTR s$[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA ENDP ; `TilePattern::setPattern'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 128
this$ = 128
s$ = 136
?dtor$1@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA PROC ; `TilePattern::setPattern'::`1'::dtor$1
	mov	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0??setPattern@TilePattern@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA ENDP ; `TilePattern::setPattern'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_range@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEBAXPEAVTileRow@@0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEBAXPEAVTileRow@@0@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Orphan_range, COMDAT

; 1960 : 		}

	ret	0
?_Orphan_range@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEBAXPEAVTileRow@@0@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xlength@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@CAXXZ PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Xlength, COMDAT

; 1925 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1926 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN3@Xlength:
?_Xlength@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@CAXXZ ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z
_TEXT	SEGMENT
$T1 = 32
_First$2 = 80
this$ = 80
_Newvec$ = 88
_Newsize$ = 96
_Newcapacity$ = 104
?_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Change_array, COMDAT

; 1895 : 		{	// orphan all iterators, discard old array, acquire new array

$LN120:
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rbp
	mov	QWORD PTR [rsp+104], rsi
	mov	rbp, r9
	mov	r14, r8
	mov	r15, rdx
	mov	rsi, rcx

; 1896 : 		this->_Orphan_all();
; 1897 : 
; 1898 : 		if (this->_Myfirst() != pointer())

	mov	rbx, QWORD PTR [rcx]
	test	rbx, rbx
	je	SHORT $LN92@Change_arr

; 1899 : 			{	// destroy and deallocate old array
; 1900 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	rdi, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	mov	QWORD PTR _First$2[rsp], rbx

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rbx, rdi
	je	SHORT $LN40@Change_arr
$LL41@Change_arr:
	lea	rcx, QWORD PTR [rbx+8]
	call	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
	add	rbx, 32					; 00000020H
	mov	QWORD PTR _First$2[rsp], rbx
	cmp	rbx, rdi
	jne	SHORT $LL41@Change_arr
	mov	rbx, QWORD PTR [rsi]
$LN40@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rdx, QWORD PTR [rsi+16]
	sub	rdx, rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -32				; ffffffffffffffe0H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN91@Change_arr

; 115  : 	_Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rax, QWORD PTR [rbx-8]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rax

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rbx, -8
	cmp	rbx, 31
	ja	SHORT $LN88@Change_arr

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rbx, rax
$LN91@Change_arr:

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN92@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

	mov	QWORD PTR [rsi], r15

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

	shl	r14, 5
	add	r14, r15
	mov	QWORD PTR [rsi+8], r14

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

	shl	rbp, 5
	add	rbp, r15
	mov	QWORD PTR [rsi+16], rbp

; 1907 : 		}

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN88@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN117@Change_arr:
?_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Change_array
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$2 = 80
this$ = 80
_Newvec$ = 88
_Newsize$ = 96
_Newcapacity$ = 104
?dtor$0@?0??_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Change_array'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Change_array'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$2 = 80
this$ = 80
_Newvec$ = 88
_Newsize$ = 96
_Newcapacity$ = 104
?dtor$0@?0??_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Change_array'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??_Change_array@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXQEAVTileRow@@_K1@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Change_array'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Calculate_growth@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Calculate_growth, COMDAT

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	r8, QWORD PTR [rcx+16]

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	sub	r8, QWORD PTR [rcx]
	sar	r8, 5

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	r8, rax
	ja	SHORT $LN31@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow
; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rcx+r8]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

	cmp	rax, rdx
	jae	SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient

	mov	rax, rdx
$LN1@Calculate_:

; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient
; 1869 : 		}

	ret	0
?_Calculate_growth@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_First$ = 72
_First$ = 72
_Last$ = 80
?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Destroy, COMDAT

; 1848 : 		{	// destroy [_First, _Last) using allocator

$LN31:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rdx, r8
	je	SHORT $LN28@Destroy
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+64], rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1848 : 		{	// destroy [_First, _Last) using allocator

	mov	rbx, r8
	mov	rdi, rdx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	mov	QWORD PTR _First$[rsp], rdx
$LL12@Destroy:
	lea	rcx, QWORD PTR [rdi+8]
	call	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >

; 1134 : 	for (; _First != _Last; ++_First)

	add	rdi, 32					; 00000020H
	mov	QWORD PTR _First$[rsp], rdi
	cmp	rdi, rbx
	jne	SHORT $LL12@Destroy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1850 : 		}

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
$LN28@Destroy:
	ret	0
?_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Destroy
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_First$ = 72
_First$ = 72
_Last$ = 80
?dtor$0@?0??_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Destroy'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Destroy'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_First$ = 72
_First$ = 72
_Last$ = 80
?dtor$0@?0??_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::_Destroy'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??_Destroy@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@0@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::_Destroy'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove_if_noexcept@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@00@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Umove_if_noexcept, COMDAT

; 1842 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

	mov	rax, r9
	mov	r10, r8
	mov	r11, rdx

; 1833 : 		_Uninitialized_move(_First, _Last, _Dest, this->_Getal());

	mov	r9, rcx
	mov	r8, rax
	mov	rdx, r10
	mov	rcx, r11
	jmp	??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z ; std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >
?_Umove_if_noexcept@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@00@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$ = 40
?_Umove_if_noexcept1@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Umove_if_noexcept1, COMDAT

; 1832 : 		{	// move [_First, _Last) to raw _Dest, using allocator

	mov	rax, r9
	mov	r10, r8
	mov	r11, rdx

; 1833 : 		_Uninitialized_move(_First, _Last, _Dest, this->_Getal());

	mov	r9, rcx
	mov	r8, rax
	mov	rdx, r10
	mov	rcx, r11
	jmp	??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z ; std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >
?_Umove_if_noexcept1@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAXPEAVTileRow@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAPEAVTileRow@@PEAV3@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAPEAVTileRow@@PEAV3@00@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Umove, COMDAT

; 1827 : 		{	// move [_First, _Last) to raw _Dest, using allocator

	mov	rax, r9
	mov	r10, r8
	mov	r11, rdx

; 1828 : 		return (_Uninitialized_move(_First, _Last, _Dest, this->_Getal()));

	mov	r9, rcx
	mov	r8, rax
	mov	rdx, r10
	mov	rcx, r11
	jmp	??$_Uninitialized_move@PEAVTileRow@@PEAV1@V?$allocator@VTileRow@@@std@@@std@@YAPEAVTileRow@@QEAV1@0PEAV1@AEAV?$allocator@VTileRow@@@0@@Z ; std::_Uninitialized_move<TileRow *,TileRow *,std::allocator<TileRow> >
?_Umove@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEAAPEAVTileRow@@PEAV3@00@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??A?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAAEAVTileRow@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAAEAVTileRow@@_K@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::operator[], COMDAT

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

	shl	rdx, 5
	add	rdx, QWORD PTR [rcx]
	mov	rax, rdx

; 1737 : 		}

	ret	0
??A?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAAEAVTileRow@@_K@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Has_unused_capacity@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Has_unused_capacity@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEBA_NXZ PROC ; std::vector<TileRow,std::allocator<TileRow> >::_Has_unused_capacity, COMDAT

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], rax
	setne	al

; 1727 : 		}

	ret	0
?_Has_unused_capacity@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@AEBA_NXZ ENDP ; std::vector<TileRow,std::allocator<TileRow> >::_Has_unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?capacity@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ PROC ; std::vector<TileRow,std::allocator<TileRow> >::capacity, COMDAT

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 1716 : 		}

	ret	0
?capacity@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<TileRow,std::allocator<TileRow> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?max_size@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ PROC ; std::vector<TileRow,std::allocator<TileRow> >::max_size, COMDAT

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

	ret	0
?max_size@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<TileRow,std::allocator<TileRow> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?size@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ PROC ; std::vector<TileRow,std::allocator<TileRow> >::size, COMDAT

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 5

; 1705 : 		}

	ret	0
?size@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<TileRow,std::allocator<TileRow> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_First$2 = 64
this$ = 64
?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ PROC ; std::vector<TileRow,std::allocator<TileRow> >::clear, COMDAT

; 1589 : 		{	// erase all

$LN65:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rsi
	mov	rdi, rcx

; 1590 : 		this->_Orphan_all();
; 1591 : 		_Destroy(this->_Myfirst(), this->_Mylast());

	mov	rsi, QWORD PTR [rcx+8]
	mov	rbx, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

	mov	QWORD PTR _First$2[rsp], rbx

; 1134 : 	for (; _First != _Last; ++_First)

	cmp	rbx, rsi
	je	SHORT $LN62@clear
	npad	3
$LL34@clear:
	lea	rcx, QWORD PTR [rbx+8]
	call	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
	npad	1
	add	rbx, 32					; 00000020H
	mov	QWORD PTR _First$2[rsp], rbx
	cmp	rbx, rsi
	jne	SHORT $LL34@clear
	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rdi+8], rax

; 1593 : 		}

	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN62@clear:

; 1592 : 		this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rcx+8], rbx

; 1593 : 		}

	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ ENDP ; std::vector<TileRow,std::allocator<TileRow> >::clear
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$2 = 64
this$ = 64
?dtor$0@?0??clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::clear'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::clear'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$2 = 64
this$ = 64
?dtor$0@?0??clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::clear'::`1'::dtor$0
	mov	rcx, QWORD PTR _First$2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??clear@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXXZ@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::clear'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
this$ = 64
_Val$ = 72
?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z PROC ; std::vector<TileRow,std::allocator<TileRow> >::push_back, COMDAT

; 931  : 		{	// insert element at end, provide strong guarantee

$LN83:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	r9, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], r9

; 917  : 		if (_Has_unused_capacity())

	je	SHORT $LN4@push_back
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	QWORD PTR $T2[rsp], r9
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r9], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [r9+4], eax
	add	rdx, 8
	lea	rcx, QWORD PTR [r9+8]
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	QWORD PTR [rbx+8], 32			; 00000020H

; 932  : 		emplace_back(_Val);
; 933  : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN4@push_back:

; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, r9

; 932  : 		emplace_back(_Val);
; 933  : 		}

	add	rsp, 48					; 00000030H
	pop	rbx

; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBVTileRow@@@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAPEAVTileRow@@QEAV2@AEBV2@@Z ; std::vector<TileRow,std::allocator<TileRow> >::_Emplace_reallocate<TileRow const &>
?push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z ENDP ; std::vector<TileRow,std::allocator<TileRow> >::push_back
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
this$ = 64
_Val$ = 72
?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 64
this$ = 64
_Val$ = 72
?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA PROC ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$0
	mov	rcx, QWORD PTR $T2[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0??push_back@?$vector@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@QEAAXAEBVTileRow@@@Z@4HA ENDP ; `std::vector<TileRow,std::allocator<TileRow> >::push_back'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@VTileRow@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@VTileRow@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<TileRow>,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_second, COMDAT

; 307  : 		return (_Myval2);

	mov	rax, rcx

; 308  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@VTileRow@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<TileRow>,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@VTileRow@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@VTileRow@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<TileRow>,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_second, COMDAT

; 302  : 		return (_Myval2);

	mov	rax, rcx

; 303  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@VTileRow@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<TileRow>,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@VTileRow@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEBAAEBV?$allocator@VTileRow@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@VTileRow@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEBAAEBV?$allocator@VTileRow@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<TileRow>,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_first, COMDAT

; 297  : 		return (*this);

	mov	rax, rcx

; 298  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@VTileRow@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEBAAEBV?$allocator@VTileRow@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<TileRow>,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@VTileRow@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEAAAEAV?$allocator@VTileRow@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@VTileRow@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEAAAEAV?$allocator@VTileRow@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<TileRow>,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_first, COMDAT

; 292  : 		return (*this);

	mov	rax, rcx

; 293  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@VTileRow@@@std@@V?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@$00@std@@QEAAAEAV?$allocator@VTileRow@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<TileRow>,std::_Vector_val<std::_Simple_types<TileRow> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myend, COMDAT

; 601  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 602  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myend, COMDAT

; 596  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 597  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Mylast, COMDAT

; 591  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 592  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Mylast, COMDAT

; 586  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 587  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myfirst, COMDAT

; 581  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 582  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBQEAVTileRow@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myfirst, COMDAT

; 576  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 577  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAPEAVTileRow@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Get_data, COMDAT

; 560  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 561  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Get_data, COMDAT

; 555  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 556  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@VTileRow@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBV?$allocator@VTileRow@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBV?$allocator@VTileRow@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Getal, COMDAT

; 550  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 551  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEBAAEBV?$allocator@VTileRow@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAV?$allocator@VTileRow@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAV?$allocator@VTileRow@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Getal, COMDAT

; 545  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 546  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAAEAV?$allocator@VTileRow@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Orphan_all, COMDAT

; 535  : 		_Get_data()._Orphan_all();
; 536  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@VTileRow@@V?$allocator@VTileRow@@@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<TileRow,std::allocator<TileRow> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SA_KAEBV?$allocator@VTileRow@@@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SA_KAEBV?$allocator@VTileRow@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<TileRow> >::max_size, COMDAT

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 893  : 		}

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@VTileRow@@@std@@@std@@SA_KAEBV?$allocator@VTileRow@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<TileRow> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z PROC ; std::allocator<TileRow>::allocate, COMDAT

; 996  : 		{	// allocate array of _Count elements

$LN30:
	sub	rsp, 40					; 00000028H

; 25   : 	size_t _Result = _Count * _Ty_size;

	mov	rax, rdx

; 26   : 	if (_Max_possible < _Count)

	mov	rcx, 576460752303423487			; 07ffffffffffffffH
	shl	rax, 5
	mov	r8, -1
	cmp	rdx, rcx
	jbe	SHORT $LN4@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

	mov	rax, r8

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

	jmp	SHORT $LN27@allocate
$LN4@allocate:
	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN7@allocate
$LN27@allocate:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 94   : 	if (_Block_size <= _Bytes)

	cmp	rcx, rax
	cmovbe	rcx, r8

; 52   : 		return (::operator new(_Bytes));

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN16@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN16@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@allocate:

; 188  : 	if (_Bytes != 0)

	test	rax, rax
	je	SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

	mov	rcx, rax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	add	rsp, 40					; 00000028H

; 52   : 		return (::operator new(_Bytes));

	jmp	??2@YAPEAX_K@Z				; operator new
$LN8@allocate:

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:
?allocate@?$allocator@VTileRow@@@std@@QEAAPEAVTileRow@@_K@Z ENDP ; std::allocator<TileRow>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@VTileRow@@@std@@QEAAXQEAVTileRow@@_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@VTileRow@@@std@@QEAAXQEAVTileRow@@_K@Z PROC ; std::allocator<TileRow>::deallocate, COMDAT

; 990  : 		{	// deallocate object at _Ptr

$LN20:
	sub	rsp, 40					; 00000028H

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	shl	r8, 5
	mov	rax, rdx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]
	add	r8, 39					; 00000027H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	mov	rcx, rax

; 993  : 		}

	add	rsp, 40					; 00000028H

; 207  : 	::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@VTileRow@@@std@@QEAAXQEAVTileRow@@_K@Z ENDP ; std::allocator<TileRow>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GTileRow@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_GTileRow@@QEAAPEAXI@Z PROC				; TileRow::`scalar deleting destructor', COMDAT
$LN10:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	ebx, edx
	mov	rdi, rcx
	add	rcx, 8
	call	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
	npad	1
	test	bl, 1
	je	SHORT $LN7@scalar
	mov	edx, 32					; 00000020H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN7@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??_GTileRow@@QEAAPEAXI@Z ENDP				; TileRow::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
?dtor$0@?0???_GTileRow@@QEAAPEAXI@Z@4HA PROC		; `TileRow::`scalar deleting destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???_GTileRow@@QEAAPEAXI@Z@4HA ENDP		; `TileRow::`scalar deleting destructor''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
?dtor$0@?0???_GTileRow@@QEAAPEAXI@Z@4HA PROC		; `TileRow::`scalar deleting destructor''::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???_GTileRow@@QEAAPEAXI@Z@4HA ENDP		; `TileRow::`scalar deleting destructor''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0TileRow@@QEAA@$$QEAV0@@Z
_TEXT	SEGMENT
$T1 = 0
this$ = 32
__that$ = 40
??0TileRow@@QEAA@$$QEAV0@@Z PROC			; TileRow::TileRow, COMDAT
$LN94:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	QWORD PTR $T1[rsp], -2
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax

; 389  : 		: _Myfirst(),

	xor	r8d, r8d
	mov	QWORD PTR [rcx+8], r8

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+16], r8

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+24], r8

; 765  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 766  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 767  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [rdx+24]
	mov	QWORD PTR [rcx+24], rax

; 768  : 
; 769  : 		_Right._Myfirst() = pointer();

	mov	QWORD PTR [rdx+8], r8

; 770  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [rdx+16], r8

; 771  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [rdx+24], r8
	mov	rax, rcx
	add	rsp, 24
	ret	0
??0TileRow@@QEAA@$$QEAV0@@Z ENDP			; TileRow::TileRow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
__that$ = 40
?dtor$0@?0???0TileRow@@QEAA@$$QEAV0@@Z@4HA PROC		; `TileRow::TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0TileRow@@QEAA@$$QEAV0@@Z@4HA ENDP		; `TileRow::TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
__that$ = 40
?dtor$0@?0???0TileRow@@QEAA@$$QEAV0@@Z@4HA PROC		; `TileRow::TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0TileRow@@QEAA@$$QEAV0@@Z@4HA ENDP		; `TileRow::TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0TileRow@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__that$ = 72
??0TileRow@@QEAA@AEBV0@@Z PROC				; TileRow::TileRow, COMDAT
$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	add	rdx, 8
	add	rcx, 8
	call	??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
	npad	1
	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0TileRow@@QEAA@AEBV0@@Z ENDP				; TileRow::TileRow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__that$ = 72
?dtor$0@?0???0TileRow@@QEAA@AEBV0@@Z@4HA PROC		; `TileRow::TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0TileRow@@QEAA@AEBV0@@Z@4HA ENDP		; `TileRow::TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__that$ = 72
?dtor$0@?0???0TileRow@@QEAA@AEBV0@@Z@4HA PROC		; `TileRow::TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0TileRow@@QEAA@AEBV0@@Z@4HA ENDP		; `TileRow::TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1TileRow@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1TileRow@@QEAA@XZ PROC				; TileRow::~TileRow, COMDAT
$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	add	rcx, 8
	add	rsp, 56					; 00000038H
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
??1TileRow@@QEAA@XZ ENDP				; TileRow::~TileRow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1TileRow@@QEAA@XZ@4HA PROC			; `TileRow::~TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???1TileRow@@QEAA@XZ@4HA ENDP			; `TileRow::~TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1TileRow@@QEAA@XZ@4HA PROC			; `TileRow::~TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???1TileRow@@QEAA@XZ@4HA ENDP			; `TileRow::~TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
;	COMDAT ?update@TileRow@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?update@TileRow@@QEAAXXZ PROC				; TileRow::update, COMDAT

; 65   : 		totalWidth = 0.f;

	xor	r8d, r8d
	mov	rdx, rcx
	mov	DWORD PTR [rcx+4], r8d
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	r10, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+16]
	sub	rax, r10
	sar	rax, 2
; File g:\dropbox\github\berconmaps\src\tile.h

; 66   : 		for (int i=0; i<tiles.size(); i++)

	test	rax, rax
	je	SHORT $LN3@update
	vxorps	xmm0, xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

	mov	r9d, r8d
	npad	11
$LL4@update:
; File g:\dropbox\github\berconmaps\src\tile.h

; 67   : 			totalWidth += tiles[i];

	vaddss	xmm0, xmm0, DWORD PTR [r9+r10]
	inc	r8d
	lea	r9, QWORD PTR [r9+4]
	vmovss	DWORD PTR [rdx+4], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rcx, QWORD PTR [rdx+16]
	sub	rcx, r10
; File g:\dropbox\github\berconmaps\src\tile.h

; 66   : 		for (int i=0; i<tiles.size(); i++)

	movsxd	rax, r8d
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	sar	rcx, 2
; File g:\dropbox\github\berconmaps\src\tile.h

; 66   : 		for (int i=0; i<tiles.size(); i++)

	cmp	rax, rcx
	jb	SHORT $LL4@update
$LN3@update:

; 68   : 	}

	ret	0
?update@TileRow@@QEAAXXZ ENDP				; TileRow::update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@AEBAXPEAM0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@AEBAXPEAM0@Z PROC ; std::vector<float,std::allocator<float> >::_Orphan_range, COMDAT

; 1960 : 		}

	ret	0
?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@AEBAXPEAM0@Z ENDP ; std::vector<float,std::allocator<float> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ PROC ; std::vector<float,std::allocator<float> >::_Xlength, COMDAT

; 1925 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1926 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN3@Xlength:
?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ENDP ; std::vector<float,std::allocator<float> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@AEAAXXZ PROC	; std::vector<float,std::allocator<float> >::_Tidy, COMDAT

; 1910 : 		{	// free all storage

$LN102:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1911 : 		this->_Orphan_all();
; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN78@Tidy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN75@Tidy

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, r8
$LN78@Tidy:

; 207  : 	::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1919 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1920 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 1922 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN75@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN100@Tidy:
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@AEAAXXZ ENDP	; std::vector<float,std::allocator<float> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z PROC ; std::vector<float,std::allocator<float> >::_Change_array, COMDAT

; 1895 : 		{	// orphan all iterators, discard old array, acquire new array

$LN102:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 1896 : 		this->_Orphan_all();
; 1897 : 
; 1898 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN79@Change_arr

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN78@Change_arr

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN75@Change_arr

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, r8
$LN78@Change_arr:

; 207  : 	::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN79@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*4]
	mov	QWORD PTR [rbx], rdi

; 1907 : 		}

	mov	rbp, QWORD PTR [rsp+56]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*4]
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN75@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN100@Change_arr:
?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AEAAXQEAM_K1@Z ENDP ; std::vector<float,std::allocator<float> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Buy@?$vector@MV?$allocator@M@std@@@std@@AEAA_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy@?$vector@MV?$allocator@M@std@@@std@@AEAA_N_K@Z PROC ; std::vector<float,std::allocator<float> >::_Buy, COMDAT

; 1872 : 		{	// allocate array with _Newcapacity elements

$LN72:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1873 : 		this->_Myfirst() = pointer();

	xor	eax, eax
	mov	rdi, rdx
	mov	QWORD PTR [rcx], rax
	mov	rbx, rcx

; 1874 : 		this->_Mylast() = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1875 : 		this->_Myend() = pointer();

	mov	QWORD PTR [rcx+16], rax

; 1876 : 
; 1877 : 		if (_Newcapacity == 0)

	test	rdx, rdx
	je	SHORT $LN1@Buy

; 1878 : 			{
; 1879 : 			return (false);
; 1880 : 			}
; 1881 : 
; 1882 : 		if (_Newcapacity > max_size())

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN71@Buy

; 1885 : 			}
; 1886 : 
; 1887 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate
	mov	QWORD PTR [rbx], rax

; 1888 : 		this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rbx+8], rax

; 1889 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	lea	rax, QWORD PTR [rax+rdi*4]
	mov	QWORD PTR [rbx+16], rax

; 1890 : 
; 1891 : 		return (true);

	mov	al, 1
$LN1@Buy:

; 1892 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN71@Buy:

; 1883 : 			{
; 1884 : 			_Xlength();

	call	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
	int	3
$LN69@Buy:
?_Buy@?$vector@MV?$allocator@M@std@@@std@@AEAA_N_K@Z ENDP ; std::vector<float,std::allocator<float> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Calculate_growth@?$vector@MV?$allocator@M@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@MV?$allocator@M@std@@@std@@AEBA_K_K@Z PROC ; std::vector<float,std::allocator<float> >::_Calculate_growth, COMDAT

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	r8, QWORD PTR [rcx+16]

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	sub	r8, QWORD PTR [rcx]
	sar	r8, 2

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	r8, rax
	ja	SHORT $LN31@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow
; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rcx+r8]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

	cmp	rax, rdx
	jae	SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient

	mov	rax, rdx
$LN1@Calculate_:

; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient
; 1869 : 		}

	ret	0
?_Calculate_growth@?$vector@MV?$allocator@M@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<float,std::allocator<float> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@AEAAXPEAM0@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@AEAAXPEAM0@Z PROC ; std::vector<float,std::allocator<float> >::_Destroy, COMDAT

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1850 : 		}

	ret	0
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@AEAAXPEAM0@Z ENDP ; std::vector<float,std::allocator<float> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@MV?$allocator@M@std@@@std@@AEAAXPEAM00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove_if_noexcept@?$vector@MV?$allocator@M@std@@@std@@AEAAXPEAM00@Z PROC ; std::vector<float,std::allocator<float> >::_Umove_if_noexcept, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	jmp	memmove
?_Umove_if_noexcept@?$vector@MV?$allocator@M@std@@@std@@AEAAXPEAM00@Z ENDP ; std::vector<float,std::allocator<float> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@MV?$allocator@M@std@@@std@@AEAAXPEAM00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$ = 40
?_Umove_if_noexcept1@?$vector@MV?$allocator@M@std@@@std@@AEAAXPEAM00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<float,std::allocator<float> >::_Umove_if_noexcept1, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	jmp	memmove
?_Umove_if_noexcept1@?$vector@MV?$allocator@M@std@@@std@@AEAAXPEAM00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<float,std::allocator<float> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM00@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM00@Z PROC ; std::vector<float,std::allocator<float> >::_Umove, COMDAT

; 1827 : 		{	// move [_First, _Last) to raw _Dest, using allocator

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	sub	rbx, rdx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1827 : 		{	// move [_First, _Last) to raw _Dest, using allocator

	mov	rdi, r9
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1829 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Umove@?$vector@MV?$allocator@M@std@@@std@@AEAAPEAMPEAM00@Z ENDP ; std::vector<float,std::allocator<float> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??A?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z PROC ; std::vector<float,std::allocator<float> >::operator[], COMDAT

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*4]

; 1737 : 		}

	ret	0
??A?$vector@MV?$allocator@M@std@@@std@@QEAAAEAM_K@Z ENDP ; std::vector<float,std::allocator<float> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Has_unused_capacity@?$vector@MV?$allocator@M@std@@@std@@AEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Has_unused_capacity@?$vector@MV?$allocator@M@std@@@std@@AEBA_NXZ PROC ; std::vector<float,std::allocator<float> >::_Has_unused_capacity, COMDAT

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], rax
	setne	al

; 1727 : 		}

	ret	0
?_Has_unused_capacity@?$vector@MV?$allocator@M@std@@@std@@AEBA_NXZ ENDP ; std::vector<float,std::allocator<float> >::_Has_unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?capacity@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ PROC ; std::vector<float,std::allocator<float> >::capacity, COMDAT

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1716 : 		}

	ret	0
?capacity@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ ENDP ; std::vector<float,std::allocator<float> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?max_size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ PROC ; std::vector<float,std::allocator<float> >::max_size, COMDAT

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

	ret	0
?max_size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ ENDP ; std::vector<float,std::allocator<float> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ PROC	; std::vector<float,std::allocator<float> >::size, COMDAT

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1705 : 		}

	ret	0
?size@?$vector@MV?$allocator@M@std@@@std@@QEBA_KXZ ENDP	; std::vector<float,std::allocator<float> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?clear@?$vector@MV?$allocator@M@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@MV?$allocator@M@std@@@std@@QEAAXXZ PROC	; std::vector<float,std::allocator<float> >::clear, COMDAT

; 1590 : 		this->_Orphan_all();
; 1591 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1592 : 		this->_Mylast() = this->_Myfirst();

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1593 : 		}

	ret	0
?clear@?$vector@MV?$allocator@M@std@@@std@@QEAAXXZ ENDP	; std::vector<float,std::allocator<float> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAM@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAM@Z PROC ; std::vector<float,std::allocator<float> >::push_back, COMDAT

; 936  : 		{	// insert by moving into element at end, provide strong guarantee

	mov	r8, rdx

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	rdx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], rdx

; 917  : 		if (_Has_unused_capacity())

	je	SHORT $LN6@push_back
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	QWORD PTR [rcx+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	DWORD PTR [rdx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 938  : 		}

	ret	0
$LN6@push_back:

; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@M@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAM$$QEAM@Z ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float>
?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAX$$QEAM@Z ENDP ; std::vector<float,std::allocator<float> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAXAEBM@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAXAEBM@Z PROC ; std::vector<float,std::allocator<float> >::push_back, COMDAT

; 931  : 		{	// insert element at end, provide strong guarantee

	mov	r8, rdx

; 1726 : 		return (this->_Myend() != this->_Mylast());

	mov	rdx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], rdx

; 917  : 		if (_Has_unused_capacity())

	je	SHORT $LN4@push_back
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

	add	QWORD PTR [rcx+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	DWORD PTR [rdx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 933  : 		}

	ret	0
$LN4@push_back:

; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBM@?$vector@MV?$allocator@M@std@@@std@@QEAAPEAMQEAMAEBM@Z ; std::vector<float,std::allocator<float> >::_Emplace_reallocate<float const &>
?push_back@?$vector@MV?$allocator@M@std@@@std@@QEAAXAEBM@Z ENDP ; std::vector<float,std::allocator<float> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ PROC	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >, COMDAT

; 893  : 		{	// destroy the object

$LN106:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx

; 1913 : 		if (this->_Myfirst() != pointer())

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN80@vector

; 115  : 	_Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN77@vector

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, r8
$LN80@vector:

; 207  : 	::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1919 : 			this->_Mylast() = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1920 : 			this->_Myend() = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 895  : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN77@vector:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN103@vector:
??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ENDP	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT

; 389  : 		: _Myfirst(),

	xor	r8d, r8d
	mov	QWORD PTR [rcx], r8

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], r8

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+16], r8

; 765  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 766  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 767  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 790  : 		_Move_from(_STD move(_Right), true_type{});
; 791  : 		}

	mov	rax, rcx

; 769  : 		_Right._Myfirst() = pointer();

	mov	QWORD PTR [rdx], r8

; 770  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [rdx+8], r8

; 771  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [rdx+16], r8

; 790  : 		_Move_from(_STD move(_Right), true_type{});
; 791  : 		}

	ret	0
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Move_from@?$vector@MV?$allocator@M@std@@@std@@AEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$ = 24
?_Move_from@?$vector@MV?$allocator@M@std@@@std@@AEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<float,std::allocator<float> >::_Move_from, COMDAT

; 763  : 		this->_Swap_all(_Right);
; 764  : 
; 765  : 		this->_Myfirst() = _Right._Myfirst();

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 766  : 		this->_Mylast() = _Right._Mylast();

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 767  : 		this->_Myend() = _Right._Myend();

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 768  : 
; 769  : 		_Right._Myfirst() = pointer();

	xor	eax, eax
	mov	QWORD PTR [rdx], rax

; 770  : 		_Right._Mylast() = pointer();

	mov	QWORD PTR [rdx+8], rax

; 771  : 		_Right._Myend() = pointer();

	mov	QWORD PTR [rdx+16], rax

; 772  : 		}

	ret	0
?_Move_from@?$vector@MV?$allocator@M@std@@@std@@AEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<float,std::allocator<float> >::_Move_from
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT

; 734  : 		{	// construct by copying _Right

$LN162:
	mov	QWORD PTR [rsp+8], rcx
	push	r14
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	mov	r14, rdx
	mov	rsi, rcx

; 389  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

	mov	rbx, QWORD PTR [rdx+8]
	sub	rbx, QWORD PTR [rdx]
	sar	rbx, 2

; 1877 : 		if (_Newcapacity == 0)

	test	rbx, rbx
	je	SHORT $LN7@vector

; 1878 : 			{
; 1879 : 			return (false);
; 1880 : 			}
; 1881 : 
; 1882 : 		if (_Newcapacity > max_size())

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rbx, rax
	ja	SHORT $LN161@vector

; 1885 : 			}
; 1886 : 
; 1887 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	rdx, rbx
	call	?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ; std::allocator<float>::allocate
	mov	QWORD PTR [rsi], rax

; 1888 : 		this->_Mylast() = this->_Myfirst();

	mov	QWORD PTR [rsi+8], rax

; 1889 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	lea	rax, QWORD PTR [rax+rbx*4]
	mov	QWORD PTR [rsi+16], rax

; 738  : 			this->_Mylast() = _Ucopy(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());

	mov	rdi, QWORD PTR [rsi]
	mov	rbx, QWORD PTR [r14+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 211  : 	const auto _UFirst = _Get_unwrapped(_First);

	mov	rdx, QWORD PTR [r14]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	rax, QWORD PTR [rbx+rdi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 738  : 			this->_Mylast() = _Ucopy(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());

	mov	QWORD PTR [rsi+8], rax
$LN7@vector:

; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 			}
; 744  : 		}

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
$LN161@vector:

; 1884 : 			_Xlength();

	call	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
	int	3
$LN159@vector:
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >'::`1'::catch$0

; 739  : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z$0:

; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@AEAAXXZ ; std::vector<float,std::allocator<float> >::_Tidy

; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >'::`1'::catch$0

; 739  : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z$0:

; 740  : 			_Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@AEAAXXZ ; std::vector<float,std::allocator<float> >::_Tidy

; 741  : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???0?$vector@MV?$allocator@M@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ PROC	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT

; 389  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 652  : 		}

	mov	rax, rcx
	ret	0
??0?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ENDP	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second, COMDAT

; 307  : 		return (_Myval2);

	mov	rax, rcx

; 308  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second, COMDAT

; 302  : 		return (_Myval2);

	mov	rax, rcx

; 303  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEBAAEBV?$allocator@M@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEBAAEBV?$allocator@M@2@XZ PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first, COMDAT

; 297  : 		return (*this);

	mov	rax, rcx

; 298  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEBAAEBV?$allocator@M@2@XZ ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAAAEAV?$allocator@M@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAAAEAV?$allocator@M@2@XZ PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first, COMDAT

; 292  : 		return (*this);

	mov	rax, rcx

; 293  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QEAAAEAV?$allocator@M@2@XZ ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<float> >::_Vector_val<std::_Simple_types<float> >, COMDAT

; 389  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 393  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<float> >::_Vector_val<std::_Simple_types<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend, COMDAT

; 601  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 602  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend, COMDAT

; 596  : 		return (_Get_data()._Myend);

	lea	rax, QWORD PTR [rcx+16]

; 597  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast, COMDAT

; 591  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 592  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast, COMDAT

; 586  : 		return (_Get_data()._Mylast);

	lea	rax, QWORD PTR [rcx+8]

; 587  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst, COMDAT

; 581  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 582  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBQEAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst, COMDAT

; 576  : 		return (_Get_data()._Myfirst);

	mov	rax, rcx

; 577  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAPEAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data, COMDAT

; 560  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 561  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data, COMDAT

; 555  : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 556  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBV?$allocator@M@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBV?$allocator@M@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal, COMDAT

; 550  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 551  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEBAAEBV?$allocator@M@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAV?$allocator@M@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAV?$allocator@M@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal, COMDAT

; 545  : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 546  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAAEAV?$allocator@M@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAXAEAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Swap_all, COMDAT

; 540  : 		_Get_data()._Swap_all(_Right._Get_data());
; 541  : 		}

	ret	0
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Orphan_all, COMDAT

; 535  : 		_Get_data()._Orphan_all();
; 536  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >, COMDAT

; 389  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+8], rax

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+16], rax

; 423  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SA?AV?$allocator@M@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SA?AV?$allocator@M@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<float> >::select_on_container_copy_construction, COMDAT

; 897  : 		return (_Al);

	mov	rax, rcx

; 898  : 		}

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SA?AV?$allocator@M@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<float> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SA_KAEBV?$allocator@M@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SA_KAEBV?$allocator@M@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<float> >::max_size, COMDAT

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 893  : 		}

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SA_KAEBV?$allocator@M@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<float> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@M@std@@QEAAPEAM_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@M@std@@QEAAPEAM_K@Z PROC		; std::allocator<float>::allocate, COMDAT

; 996  : 		{	// allocate array of _Count elements

$LN30:
	sub	rsp, 40					; 00000028H

; 26   : 	if (_Max_possible < _Count)

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	lea	rax, QWORD PTR [rdx*4]
	mov	r8, -1
	cmp	rdx, rcx
	jbe	SHORT $LN4@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

	mov	rax, r8

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

	jmp	SHORT $LN27@allocate
$LN4@allocate:
	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN7@allocate
$LN27@allocate:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 94   : 	if (_Block_size <= _Bytes)

	cmp	rcx, rax
	cmovbe	rcx, r8

; 52   : 		return (::operator new(_Bytes));

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN16@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN16@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@allocate:

; 188  : 	if (_Bytes != 0)

	test	rax, rax
	je	SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

	mov	rcx, rax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	add	rsp, 40					; 00000028H

; 52   : 		return (::operator new(_Bytes));

	jmp	??2@YAPEAX_K@Z				; operator new
$LN8@allocate:

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:
?allocate@?$allocator@M@std@@QEAAPEAM_K@Z ENDP		; std::allocator<float>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@M@std@@QEAAXQEAM_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@M@std@@QEAAXQEAM_K@Z PROC	; std::allocator<float>::deallocate, COMDAT

; 990  : 		{	// deallocate object at _Ptr

$LN20:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*4]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 993  : 		}

	add	rsp, 40					; 00000028H

; 207  : 	::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@M@std@@QEAAXQEAM_K@Z ENDP	; std::allocator<float>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@M@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@M@std@@QEAA@XZ PROC			; std::allocator<float>::allocator<float>, COMDAT

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@M@std@@QEAA@XZ ENDP			; std::allocator<float>::allocator<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\dropbox\github\berconmaps\src\tile.h
;	COMDAT ??0TileRow@@QEAA@M@Z
_TEXT	SEGMENT
$T1 = 0
this$ = 32
offset$ = 40
??0TileRow@@QEAA@M@Z PROC				; TileRow::TileRow, COMDAT

; 58   : 	TileRow(float offset) {this->offset = offset;}

$LN16:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	QWORD PTR $T1[rsp], -2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

	xor	eax, eax
	mov	QWORD PTR [rcx+8], rax

; 390  : 		_Mylast(),

	mov	QWORD PTR [rcx+16], rax

; 391  : 		_Myend()

	mov	QWORD PTR [rcx+24], rax
; File g:\dropbox\github\berconmaps\src\tile.h

; 58   : 	TileRow(float offset) {this->offset = offset;}

	vmovss	DWORD PTR [rcx], xmm1
	mov	rax, rcx
	add	rsp, 24
	ret	0
??0TileRow@@QEAA@M@Z ENDP				; TileRow::TileRow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
offset$ = 40
?dtor$0@?0???0TileRow@@QEAA@M@Z@4HA PROC		; `TileRow::TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0TileRow@@QEAA@M@Z@4HA ENDP		; `TileRow::TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
offset$ = 40
?dtor$0@?0???0TileRow@@QEAA@M@Z@4HA PROC		; `TileRow::TileRow'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$vector@MV?$allocator@M@std@@@std@@QEAA@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
?dtor$0@?0???0TileRow@@QEAA@M@Z@4HA ENDP		; `TileRow::TileRow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$ = 72
??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor', COMDAT
$LN17:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+64], rbx
	mov	ebx, edx
	mov	rdi, rcx

; 2460 : 		_Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
	npad	1
	test	bl, 1
	je	SHORT $LN14@scalar
	mov	edx, 32					; 00000020H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN14@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEAXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen, COMDAT

; 4003 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 4004 : 		_Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	int	3
$LN3@Xlen:
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT

; 3984 : 		{	// initialize buffer, deallocating any storage

$LN48:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1825 : 		return (_BUF_SIZE <= _Myres);

	mov	rdx, QWORD PTR [rcx+24]

; 3984 : 		{	// initialize buffer, deallocating any storage

	mov	rbx, rcx

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	rdx, 8

; 3985 : 		this->_Orphan_all();
; 3986 : 		auto& _My_data = this->_Get_data();
; 3987 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN41@Tidy_deall
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx*2+2]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN40@Tidy_deall

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN37@Tidy_deall

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, r8
$LN40@Tidy_deall:

; 207  : 	::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN41@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

	xor	eax, eax

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7
	mov	QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rbx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 4000 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN37@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN46@Tidy_deall:
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init, COMDAT

; 3975 : 		auto& _My_data = this->_Get_data();
; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7
	mov	QWORD PTR [rcx+16], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rcx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3981 : 		}

	ret	0
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Requested$ = 16
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 3867 : 		const size_type _Max = max_size();
; 3868 : 		auto& _My_data = this->_Get_data();
; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	or	rdx, 7
	mov	r9, 9223372036854775806			; 7ffffffffffffffeH
	cmp	rdx, r9

; 3870 : 		if (_Masked > _Max)

	ja	SHORT $LN25@Calculate_

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);
; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;

	mov	r8, QWORD PTR [rcx+24]

; 3876 : 		if (_Old > _Max - _Old / 2)

	mov	rax, r9
	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	r8, rax
	ja	SHORT $LN25@Calculate_

; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	lea	rax, QWORD PTR [rcx+r8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	rdx, rax
	cmovb	rdx, rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	mov	rax, rdx

; 3882 : 		}

	ret	0
$LN25@Calculate_:

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);

	mov	rax, r9

; 3882 : 		}

	ret	0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_K_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::get_allocator, COMDAT

; 3862 : 		return (static_cast<allocator_type>(this->_Getal()));

	mov	rax, rdx

; 3863 : 		}

	ret	0
?get_allocator@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
__$ReturnUdt$ = 72
_Off$ = 80
_Count$ = 88
?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr, COMDAT

; 3755 : 		{	// return [_Off, _Off + _Count) as new string

$LN58:
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T2[rsp], -2
	mov	rbx, rdx
	xor	eax, eax
	mov	DWORD PTR $T1[rsp], eax

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rdx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1830 : 		if (_Mysize < _Off)

	mov	rax, QWORD PTR [rcx+16]
	cmp	rax, r8
	jb	SHORT $LN56@substr

; 1851 : 		return (_Min_value(_Size, _Mysize - _Off));

	sub	rax, r8
	cmp	rax, r9
	cmovb	r9, rax

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rcx+24], 8

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN46@substr
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN46@substr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2635 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

	lea	rdx, QWORD PTR [rcx+r8*2]
	mov	r8, r9
	mov	rcx, rbx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	npad	1

; 3756 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

	mov	DWORD PTR $T1[rsp], 1
	mov	rax, rbx

; 3757 : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN56@substr:

; 1832 : 			_Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	int	3
$LN54@substr:
?substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
__$ReturnUdt$ = 72
_Off$ = 80
_Count$ = 88
?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
__$ReturnUdt$ = 72
_Off$ = 80
_Count$ = 88
?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??substr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV12@_K0@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::substr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z
_TEXT	SEGMENT
_Matches$1 = 32
this$ = 320
_Right$ = 328
_Off$ = 336
?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_not_of, COMDAT

; 3672 : 		{	// look for none of _Right at or after _Off

$LN86:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 288				; 00000120H

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rdx+24], 8

; 3672 : 		{	// look for none of _Right at or after _Off

	mov	rdi, r8

; 1814 : 		const value_type * _Result = _Bx._Buf;

	mov	r14, rdx

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN12@find_first
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	r14, QWORD PTR [rdx]
$LN12@find_first:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rcx+24], 8

; 1814 : 		const value_type * _Result = _Bx._Buf;

	mov	r15, rcx

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN19@find_first
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	r15, QWORD PTR [rcx]
$LN19@find_first:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3675 : 		return (static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,

	mov	rbx, QWORD PTR [rcx+16]
	mov	rsi, QWORD PTR [rdx+16]
	mov	QWORD PTR [rsp+320], rbp

; 354  : 	if (_Start_at < _Hay_size)

	cmp	rdi, rbx
	jae	SHORT $LN27@find_first

; 355  : 		{	// room for match, look for it
; 356  : 		_String_bitmap<typename _Traits::char_type> _Matches;
; 357  : 		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))

	mov	ebp, 256				; 00000100H
	lea	rcx, QWORD PTR _Matches$1[rsp]
	mov	r8d, ebp
	xor	edx, edx
	call	memset
	lea	rdx, QWORD PTR [r14+rsi*2]
	mov	rcx, r14

; 198  : 		for (; _First != _Last; ++_First)

	cmp	r14, rdx
	je	SHORT $LN30@find_first
$LL38@find_first:

; 199  : 			{
; 200  : 			const auto _Ch = *_First;

	movzx	eax, WORD PTR [rcx]

; 201  : 			if (_Ch >= 256U)

	cmp	ax, bp
	jae	SHORT $LN80@find_first

; 202  : 				{
; 203  : 				return (false);
; 204  : 				}
; 205  : 
; 206  : 			_Matches[static_cast<unsigned char>(_Ch)] = true;

	movzx	eax, al
	add	rcx, 2
	mov	BYTE PTR _Matches$1[rsp+rax], 1
	cmp	rcx, rdx
	jne	SHORT $LL38@find_first
$LN30@find_first:

; 363  : 		const auto _End = _Haystack + _Hay_size;

	lea	rdx, QWORD PTR [r15+rbx*2]

; 364  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	rcx, QWORD PTR [r15+rdi*2]
	cmp	rcx, rdx
	jae	SHORT $LN27@find_first
	npad	2
$LL28@find_first:

; 365  : 			{
; 366  : 			if (!_Matches._Match(*_Match_try))

	movzx	eax, WORD PTR [rcx]

; 214  : 		return (_Ch < 256U && _Matches[_Ch]);

	cmp	ax, bp
	jae	$LN67@find_first
	movzx	eax, ax
	cmp	BYTE PTR _Matches$1[rsp+rax], 0
	je	SHORT $LN67@find_first

; 364  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	rcx, 2
	cmp	rcx, rdx
	jb	SHORT $LL28@find_first
$LN27@find_first:

; 369  : 				}
; 370  : 			}
; 371  : 		}
; 372  : 
; 373  : 	return (static_cast<size_t>(-1));	// no match

	mov	rax, -1
$LN25@find_first:
	mov	rbp, QWORD PTR [rsp+320]

; 3676 : 			_Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{})));
; 3677 : 		}

	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN80@find_first:

; 335  : 		const auto _End = _Haystack + _Hay_size;

	lea	r9, QWORD PTR [r15+rbx*2]

; 336  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	rdx, QWORD PTR [r15+rdi*2]
	cmp	rdx, r9
	jae	SHORT $LN43@find_first
$LL44@find_first:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 339  : 		return (reinterpret_cast<const _Elem *>(_CSTD wmemchr(

	mov	rcx, rsi
	mov	rax, r14
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 203  :         for (; 0 < _N; ++_S, --_N)

	test	rsi, rsi
	je	SHORT $LN66@find_first

; 204  :             if (*_S == _C)

	movzx	r8d, WORD PTR [rdx]
$LL53@find_first:
	cmp	WORD PTR [rax], r8w
	je	SHORT $LN65@find_first

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rax, 2
	sub	rcx, 1
	jne	SHORT $LL53@find_first
$LN66@find_first:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 340  : 				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match

	sub	rdx, r15
	sar	rdx, 1

; 3675 : 		return (static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,

	mov	rax, rdx

; 359  : 			return (_Traits_find_first_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,

	jmp	SHORT $LN25@find_first
$LN65@find_first:

; 336  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	rdx, 2
	cmp	rdx, r9
	jb	SHORT $LL44@find_first
$LN43@find_first:

; 341  : 				}
; 342  : 			}
; 343  : 		}
; 344  : 
; 345  : 	return (static_cast<size_t>(-1));	// no match

	mov	rdx, -1

; 3675 : 		return (static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,

	mov	rax, rdx

; 359  : 			return (_Traits_find_first_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,

	jmp	SHORT $LN25@find_first
$LN67@find_first:

; 367  : 				{
; 368  : 				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match

	sub	rcx, r15
	sar	rcx, 1

; 3675 : 		return (static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,

	mov	rax, rcx

; 368  : 				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match

	jmp	SHORT $LN25@find_first
?find_first_not_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_not_of
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z
_TEXT	SEGMENT
_Matches$1 = 32
this$ = 320
_Right$ = 328
_Off$ = 336
?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_of, COMDAT

; 3583 : 		{	// look for one of _Right at or after _Off

$LN87:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 288				; 00000120H

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rdx+24], 8

; 3583 : 		{	// look for one of _Right at or after _Off

	mov	rsi, r8

; 1814 : 		const value_type * _Result = _Bx._Buf;

	mov	r14, rdx

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN12@find_first
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	r14, QWORD PTR [rdx]
$LN12@find_first:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rcx+24], 8

; 1814 : 		const value_type * _Result = _Bx._Buf;

	mov	r15, rcx

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN19@find_first
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	r15, QWORD PTR [rcx]
$LN19@find_first:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3586 : 		return (static_cast<size_type>(_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,

	mov	rbx, QWORD PTR [rdx+16]
	mov	rdi, QWORD PTR [rcx+16]
	mov	QWORD PTR [rsp+320], rbp

; 248  : 	if (_Needle_size != 0 && _Start_at < _Hay_size)

	test	rbx, rbx
	je	SHORT $LN27@find_first
	cmp	rsi, rdi
	jae	SHORT $LN27@find_first

; 249  : 		{	// room for match, look for it
; 250  : 		_String_bitmap<typename _Traits::char_type> _Matches;
; 251  : 		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))

	mov	ebp, 256				; 00000100H
	lea	rcx, QWORD PTR _Matches$1[rsp]
	mov	r8d, ebp
	xor	edx, edx
	call	memset
	lea	rdx, QWORD PTR [r14+rbx*2]
	mov	rcx, r14

; 198  : 		for (; _First != _Last; ++_First)

	cmp	r14, rdx
	je	SHORT $LN30@find_first
	npad	3
$LL38@find_first:

; 199  : 			{
; 200  : 			const auto _Ch = *_First;

	movzx	eax, WORD PTR [rcx]

; 201  : 			if (_Ch >= 256U)

	cmp	ax, bp
	jae	SHORT $LN80@find_first

; 202  : 				{
; 203  : 				return (false);
; 204  : 				}
; 205  : 
; 206  : 			_Matches[static_cast<unsigned char>(_Ch)] = true;

	movzx	eax, al
	add	rcx, 2
	mov	BYTE PTR _Matches$1[rsp+rax], 1
	cmp	rcx, rdx
	jne	SHORT $LL38@find_first
$LN30@find_first:

; 257  : 		const auto _End = _Haystack + _Hay_size;

	lea	rdx, QWORD PTR [r15+rdi*2]

; 258  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	rcx, QWORD PTR [r15+rsi*2]
	cmp	rcx, rdx
	jae	SHORT $LN27@find_first
$LL28@find_first:

; 259  : 			{
; 260  : 			if (_Matches._Match(*_Match_try))

	movzx	eax, WORD PTR [rcx]

; 214  : 		return (_Ch < 256U && _Matches[_Ch]);

	cmp	ax, bp
	jae	SHORT $LN58@find_first
	movzx	eax, ax
	cmp	BYTE PTR _Matches$1[rsp+rax], 0
	jne	$LN67@find_first
$LN58@find_first:

; 258  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	rcx, 2
	cmp	rcx, rdx
	jb	SHORT $LL28@find_first
$LN27@find_first:

; 263  : 				}
; 264  : 			}
; 265  : 		}
; 266  : 
; 267  : 	return (static_cast<size_t>(-1));	// no match

	mov	rax, -1
$LN25@find_first:
	mov	rbp, QWORD PTR [rsp+320]

; 3587 : 			_Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{})));
; 3588 : 		}

	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN80@find_first:

; 229  : 		const auto _End = _Haystack + _Hay_size;

	lea	r9, QWORD PTR [r15+rdi*2]

; 230  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	lea	rdx, QWORD PTR [r15+rsi*2]
	cmp	rdx, r9
	jae	SHORT $LN43@find_first
	npad	6
$LL44@find_first:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 339  : 		return (reinterpret_cast<const _Elem *>(_CSTD wmemchr(

	mov	rcx, rbx
	mov	rax, r14
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 203  :         for (; 0 < _N; ++_S, --_N)

	test	rbx, rbx
	je	SHORT $LN52@find_first

; 204  :             if (*_S == _C)

	movzx	r8d, WORD PTR [rdx]
	npad	1
$LL53@find_first:
	cmp	WORD PTR [rax], r8w
	je	SHORT $LN66@find_first

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rax, 2
	sub	rcx, 1
	jne	SHORT $LL53@find_first
$LN52@find_first:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 230  : 		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)

	add	rdx, 2
	cmp	rdx, r9
	jb	SHORT $LL44@find_first
$LN43@find_first:

; 235  : 				}
; 236  : 			}
; 237  : 		}
; 238  : 
; 239  : 	return (static_cast<size_t>(-1));	// no match

	mov	rdx, -1

; 3586 : 		return (static_cast<size_type>(_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,

	mov	rax, rdx

; 253  : 			return (_Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,

	jmp	SHORT $LN25@find_first
$LN66@find_first:

; 234  : 				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match

	sub	rdx, r15
	sar	rdx, 1

; 3586 : 		return (static_cast<size_type>(_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,

	mov	rax, rdx

; 253  : 			return (_Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,

	jmp	SHORT $LN25@find_first
$LN67@find_first:

; 261  : 				{
; 262  : 				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match

	sub	rcx, r15
	sar	rcx, 1

; 3586 : 		return (static_cast<size_type>(_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,

	mov	rax, rcx

; 262  : 				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match

	jmp	SHORT $LN25@find_first
?find_first_of@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find_first_of
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT

; 3307 : 		const size_type _Alloc_max = _Alty_traits::max_size(this->_Getal());
; 3308 : 		const size_type _Storage_max = // can always store small string
; 3309 : 			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));
; 3310 : 		return (_Min_value(

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH

; 3311 : 			static_cast<size_type>((numeric_limits<difference_type>::max)()),
; 3312 : 			_Storage_max - 1 // -1 is for null terminator and/or npos
; 3313 : 			));
; 3314 : 
; 3315 : 		}

	ret	0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT

; 3302 : 		return (this->_Get_data()._Mysize);

	mov	rax, QWORD PTR [rcx+16]

; 3303 : 		}

	ret	0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rcx+24], 8

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN14@c_str

; 3280 : 		return (this->_Get_data()._Myptr());

	mov	rax, QWORD PTR [rcx]

; 3281 : 		}

	ret	0
$LN14@c_str:

; 3280 : 		return (this->_Get_data()._Myptr());

	mov	rax, rcx

; 3281 : 		}

	ret	0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 307  : 		return (_CSTD wcslen(reinterpret_cast<const wchar_t *>(_First)));

	mov	r8, -1
	npad	9
$LL7@assign:
	inc	r8
	cmp	WORD PTR [rdx+r8*2], 0
	jne	SHORT $LL7@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	jmp	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
_Count$ = 80
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT

; 2657 : 		{	// assign [_Ptr, _Ptr + _Count)

$LN115:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2658 : 		auto& _My_data = this->_Get_data();
; 2659 : 		if (_Count <= _My_data._Myres)

	mov	rsi, QWORD PTR [rcx+24]
	mov	r14, r8
	mov	r15, rdx
	mov	rdi, rcx
	cmp	r8, rsi
	ja	SHORT $LN2@assign

; 1803 : 		value_type * _Result = _Bx._Buf;

	mov	rbp, rcx

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	rsi, 8

; 1804 : 		if (_Large_string_engaged())

	jb	SHORT $LN9@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	rbp, QWORD PTR [rcx]
$LN9@assign:
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	lea	rbx, QWORD PTR [r8+r8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2662 : 			_My_data._Mysize = _Count;

	mov	QWORD PTR [rcx+16], r14
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	mov	r8, rbx
	mov	rcx, rbp
	call	memmove
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [rbx+rbp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2665 : 			return (*this);

	jmp	$LN112@assign
$LN2@assign:

; 3889 : 		if (_New_size > max_size())

	mov	rbx, 9223372036854775806		; 7ffffffffffffffeH
	cmp	r14, rbx
	ja	$LN114@assign

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	rcx, r14
	or	rcx, 7
	cmp	rcx, rbx

; 3870 : 		if (_Masked > _Max)

	ja	SHORT $LN44@assign

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);
; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;
; 3876 : 		if (_Old > _Max - _Old / 2)

	mov	rdx, rsi
	mov	rax, rbx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rsi, rax
	ja	SHORT $LN44@assign

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);
; 3879 : 			}
; 3880 : 
; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	lea	rax, QWORD PTR [rdx+rsi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	mov	rbx, rcx
	cmp	rcx, rax
	cmovb	rbx, rax
$LN44@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3898 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbx+1]
	mov	rcx, rdi
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate

; 3901 : 		_My_data._Myres = _New_capacity;

	mov	QWORD PTR [rdi+24], rbx
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	rdx, r15
	lea	rbx, QWORD PTR [r14+r14]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3900 : 		_My_data._Mysize = _New_size;

	mov	QWORD PTR [rdi+16], r14
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	r8, rbx
	mov	rcx, rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3898 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	mov	rbp, rax
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	call	memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [rbx+rbp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3903 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	rsi, 8
	jb	SHORT $LN23@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR [rsi*2+2]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN98@assign

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN95@assign

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rcx, r8
$LN98@assign:

; 207  : 	::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN23@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2668 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

	mov	QWORD PTR [rdi], rbp
$LN112@assign:

; 2669 : 			_Traits::copy(_New_ptr, _Ptr, _Count);
; 2670 : 			_Traits::assign(_New_ptr[_Count], _Elem());
; 2671 : 			}, _Ptr));
; 2672 : 		}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rdi
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN95@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN114@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3891 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
	int	3
$LN111@assign:
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
_Roff$ = 64
_Count$ = 72
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT

; 2631 : 		{	// assign _Right [_Roff, _Roff + _Count)

$LN25:
	sub	rsp, 40					; 00000028H

; 1830 : 		if (_Mysize < _Off)

	mov	rax, QWORD PTR [rdx+16]
	cmp	rax, r8
	jb	SHORT $LN24@assign

; 1851 : 		return (_Min_value(_Size, _Mysize - _Off));

	sub	rax, r8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	cmp	rax, r9
	cmovb	r9, rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rdx+24], 8

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN16@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN16@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2635 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

	lea	rdx, QWORD PTR [rdx+r8*2]
	mov	r8, r9

; 2636 : 		}

	add	rsp, 40					; 00000028H

; 2635 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

	jmp	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN24@assign:

; 1832 : 			_Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	int	3
$LN22@assign:
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2459 : 		{	// destroy the string

$LN13:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2

; 2460 : 		_Tidy_deallocate();

	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
	npad	1

; 2461 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEBV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEBV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents, COMDAT

; 2394 : 		{	// assign by copying data stored in _Right

$LN58:
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rdx+24], 8

; 2394 : 		{	// assign by copying data stored in _Right

	mov	rdi, rdx

; 2395 : 			// pre: this != &_Right
; 2396 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2397 : 		auto& _My_data = this->_Get_data();
; 2398 : 		auto& _Right_data = _Right._Get_data();
; 2399 : 		const size_type _Right_size = _Right_data._Mysize;

	mov	rbp, QWORD PTR [rdx+16]
	mov	rsi, rcx

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN13@Construct_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	rdi, QWORD PTR [rdx]
$LN13@Construct_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2401 : 		if (_Right_size < this->_BUF_SIZE)

	cmp	rbp, 8
	jae	SHORT $LN2@Construct_
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	vmovups	xmm0, XMMWORD PTR [rdi]
	vmovups	XMMWORD PTR [rcx], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2416 : 		}

	mov	QWORD PTR [rcx+16], rbp
	mov	QWORD PTR [rcx+24], 7
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Construct_:
	mov	QWORD PTR [rsp+48], rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2410 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

	mov	rbx, rbp
	or	rbx, 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	cmp	rbx, rax
	cmova	rbx, rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2411 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rbx+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	r8, QWORD PTR [rbp*2+2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	QWORD PTR [rsi], rax
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	rdx, rdi
	mov	rcx, rax
	call	memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2416 : 		}

	mov	QWORD PTR [rsi+16], rbp
	mov	QWORD PTR [rsi+24], rbx
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEBV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$ = 24
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT

; 2345 : 			// pre: this != &_Right
; 2346 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2347 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2348 : 		auto& _Right_data = _Right._Get_data();
; 2349 : 
; 2350 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2351 : 		if (_Right_data._Large_string_engaged())
; 2352 : 			{	// take ownership of _Right's iterators along with its buffer
; 2353 : 			this->_Swap_all(_Right);
; 2354 : 			}
; 2355 : 		else
; 2356 : 			{
; 2357 : 			_Right._Orphan_all();
; 2358 : 			}
; 2359 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2360 : 
; 2361 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2362 : 			+ _Memcpy_move_offset;
; 2363 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2364 : 			+ _Memcpy_move_offset;
; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [rcx], ymm0

; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7
	mov	QWORD PTR [rdx+16], rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rdx], ax
	vzeroupper
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2367 : 		}

	ret	0
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv_contents_with_alloc_always_equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 1784 : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [rcx], ymm0

; 3976 : 		_My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rdx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2270 : 		}

	mov	rax, rcx
	vzeroupper
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2183 : 		{	// construct from [_Ptr, <null>)

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H

; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7
	mov	QWORD PTR [rcx+16], rax

; 2183 : 		{	// construct from [_Ptr, <null>)

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rcx], ax

; 307  : 		return (_CSTD wcslen(reinterpret_cast<const wchar_t *>(_First)));

	mov	r8, -1
$LL25@basic_stri:
	inc	r8
	cmp	WORD PTR [rdx+r8*2], ax
	jne	SHORT $LL25@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 2184 : 		_Tidy_init();
; 2185 : 		assign(_Ptr);
; 2186 : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
_Roff$ = 64
_Count$ = 72
_Al$ = 80
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2161 : 		{	// construct from _Right [_Roff, _Roff + _Count)

$LN47:
	push	rbx
	sub	rsp, 32					; 00000020H

; 3976 : 		_My_data._Mysize = 0;

	xor	eax, eax

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7
	mov	QWORD PTR [rcx+16], rax

; 2161 : 		{	// construct from _Right [_Roff, _Roff + _Count)

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 359  : 		_Left = _Right;

	mov	WORD PTR [rcx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1830 : 		if (_Mysize < _Off)

	mov	rax, QWORD PTR [rdx+16]
	cmp	rax, r8
	jb	SHORT $LN45@basic_stri

; 1851 : 		return (_Min_value(_Size, _Mysize - _Off));

	sub	rax, r8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	cmp	rax, r9
	cmovb	r9, rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rdx+24], 8

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN36@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN36@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2635 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

	lea	rdx, QWORD PTR [rdx+r8*2]
	mov	r8, r9
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 2162 : 		_Tidy_init();
; 2163 : 		assign(_Right, _Roff, _Count);
; 2164 : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN45@basic_stri:

; 1832 : 			_Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	int	3
$LN43@basic_stri:
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@_W@1@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2130 : 		{	// construct by copying _Right

$LN77:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1784 : 		_Mysize(0),

	xor	eax, eax

; 2130 : 		{	// construct by copying _Right

	mov	rdi, rdx

; 1784 : 		_Mysize(0),

	mov	QWORD PTR [rcx+16], rax

; 2130 : 		{	// construct by copying _Right

	mov	rbx, rcx

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rdx+24], 8

; 2399 : 		const size_type _Right_size = _Right_data._Mysize;

	mov	rbp, QWORD PTR [rdx+16]

; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN31@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

	mov	rdi, QWORD PTR [rdx]
$LN31@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2401 : 		if (_Right_size < this->_BUF_SIZE)

	cmp	rbp, 8
	jae	SHORT $LN20@basic_stri
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	vmovups	xmm0, XMMWORD PTR [rdi]
	vmovups	XMMWORD PTR [rcx], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2405 : 			_My_data._Myres = this->_BUF_SIZE - 1;

	mov	esi, 7

; 2406 : 			return;

	jmp	SHORT $LN19@basic_stri
$LN20@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2410 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

	mov	rsi, rbp
	or	rsi, 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	cmp	rsi, rax
	cmova	rsi, rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2411 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rsi+1]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	r8, QWORD PTR [rbp*2+2]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	QWORD PTR [rbx], rax
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	rdx, rdi
	mov	rcx, rax
	call	memcpy
$LN19@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2132 : 		}

	mov	QWORD PTR [rbx+16], rbp
	mov	rax, rbx
	mov	QWORD PTR [rbx+24], rsi
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
	ret	0
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
	ret	0
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT

; 307  : 		return (_Myval2);

	mov	rax, rcx

; 308  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT

; 302  : 		return (_Myval2);

	mov	rax, rcx

; 303  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 297  : 		return (*this);

	mov	rax, rcx

; 298  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 292  : 		return (*this);

	mov	rax, rcx

; 293  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT

; 2048 : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 2049 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT

; 2043 : 		return (_Mypair._Get_second());

	mov	rax, rcx

; 2044 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEBV?$allocator@_W@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT

; 2038 : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 2039 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEBAAEBV?$allocator@_W@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAV?$allocator@_W@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT

; 2033 : 		return (_Mypair._Get_first());

	mov	rax, rcx

; 2034 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAAEAV?$allocator@_W@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all, COMDAT

; 2023 : 		_Get_data()._Orphan_all();
; 2024 : 		}

	ret	0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT

; 1784 : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax

; 1911 : 		}

	mov	rax, rcx
	ret	0
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
	ret	0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT

; 1862 : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT

; 1857 : 			{	// user-provided, for fancy pointers
; 1858 : 			}

	mov	rax, rcx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_K_K0@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
_Size$ = 24
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_K_K0@Z PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Clamp_suffix_size, COMDAT

; 1851 : 		return (_Min_value(_Size, _Mysize - _Off));

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, rdx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	cmp	rax, r8
	cmovb	r8, rax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1851 : 		return (_Min_value(_Size, _Mysize - _Off));

	mov	rax, r8

; 1852 : 		}

	ret	0
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_K_K0@Z ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran, COMDAT

; 1845 : 		{	// report an out_of_range error

$LN4:
	sub	rsp, 40					; 00000028H

; 1846 : 		_Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	?_Xout_of_range@std@@YAXPEBD@Z		; std::_Xout_of_range
	int	3
$LN3@Xran:
?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Check_offset, COMDAT

; 1829 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

$LN7:
	sub	rsp, 40					; 00000028H

; 1830 : 		if (_Mysize < _Off)

	cmp	QWORD PTR [rcx+16], rdx
	jb	SHORT $LN6@Check_offs

; 1833 : 			}
; 1834 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Check_offs:

; 1831 : 			{
; 1832 : 			_Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
	int	3
$LN4@Check_offs:
?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged, COMDAT

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rcx+24], 8
	setae	al

; 1826 : 		}

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rcx+24], 8

; 1814 : 		const value_type * _Result = _Bx._Buf;
; 1815 : 		if (_Large_string_engaged())

	jb	SHORT $LN8@Myptr

; 1816 : 			{
; 1817 : 			_Result = _Unfancy(_Bx._Ptr);
; 1818 : 			}
; 1819 : 
; 1820 : 		return (_Result);

	mov	rax, QWORD PTR [rcx]

; 1821 : 		}

	ret	0
$LN8@Myptr:

; 1816 : 			{
; 1817 : 			_Result = _Unfancy(_Bx._Ptr);
; 1818 : 			}
; 1819 : 
; 1820 : 		return (_Result);

	mov	rax, rcx

; 1821 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT

; 1825 : 		return (_BUF_SIZE <= _Myres);

	cmp	QWORD PTR [rcx+24], 8

; 1803 : 		value_type * _Result = _Bx._Buf;
; 1804 : 		if (_Large_string_engaged())

	jb	SHORT $LN8@Myptr

; 1805 : 			{
; 1806 : 			_Result = _Unfancy(_Bx._Ptr);
; 1807 : 			}
; 1808 : 
; 1809 : 		return (_Result);

	mov	rax, QWORD PTR [rcx]

; 1810 : 		}

	ret	0
$LN8@Myptr:

; 1805 : 			{
; 1806 : 			_Result = _Unfancy(_Bx._Ptr);
; 1807 : 			}
; 1808 : 
; 1809 : 		return (_Result);

	mov	rax, rcx

; 1810 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT

; 1784 : 		_Mysize(0),

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 1785 : 		_Myres(0)

	mov	QWORD PTR [rcx+24], rax

; 1787 : 		}

	mov	rax, rcx
	ret	0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 897  : 		return (_Al);

	mov	rax, rcx

; 898  : 		}

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 893  : 		}

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z PROC	; std::allocator<wchar_t>::allocate, COMDAT

; 996  : 		{	// allocate array of _Count elements

$LN30:
	sub	rsp, 40					; 00000028H

; 26   : 	if (_Max_possible < _Count)

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	lea	rax, QWORD PTR [rdx+rdx]
	mov	r8, -1
	cmp	rdx, rcx
	jbe	SHORT $LN4@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

	mov	rax, r8

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

	jmp	SHORT $LN27@allocate
$LN4@allocate:
	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN7@allocate
$LN27@allocate:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 94   : 	if (_Block_size <= _Bytes)

	cmp	rcx, rax
	cmovbe	rcx, r8

; 52   : 		return (::operator new(_Bytes));

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN16@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN16@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@allocate:

; 188  : 	if (_Bytes != 0)

	test	rax, rax
	je	SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

	mov	rcx, rax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	add	rsp, 40					; 00000028H

; 52   : 		return (::operator new(_Bytes));

	jmp	??2@YAPEAX_K@Z				; operator new
$LN8@allocate:

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ENDP	; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT

; 990  : 		{	// deallocate object at _Ptr

$LN20:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 993  : 		}

	add	rsp, 40					; 00000028H

; 207  : 	::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@_W@std@@QEAA@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

	mov	rax, rcx
	ret	0
??0?$allocator@_W@std@@QEAA@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ
text$di	SEGMENT
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ PROC	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId'', COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR ?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A, xmm0

; 32   : 		static AssetId kInvalidId;

	ret	0
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ENDP	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ PROC		; MaxSDK::AssetManagement::AssetId::AssetId, COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR [rcx], xmm0
	mov	rax, rcx
	ret	0
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ ENDP		; MaxSDK::AssetManagement::AssetId::AssetId
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z PROC		; std::_Min_value<unsigned __int64>, COMDAT

; 24   : 	return (_Right < _Left ? _Right : _Left);

	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rdx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 25   : 	}

	ret	0
??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z ENDP		; std::_Min_value<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Convert_size@_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K@std@@YA_K_K@Z PROC			; std::_Convert_size<unsigned __int64>, COMDAT

; 1204 : 	return (_Len);

	mov	rax, rcx

; 1205 : 	}

	ret	0
??$_Convert_size@_K@std@@YA_K_K@Z ENDP			; std::_Convert_size<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 114  : 	{	// adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete

$LN13:
	sub	rsp, 40					; 00000028H

; 115  : 	_Bytes += _Non_user_size;

	add	QWORD PTR [rdx], 39			; 00000027H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax-8]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rdx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN7@Adjust_man

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	QWORD PTR [rcx], rdx

; 134  : 	}

	add	rsp, 40					; 00000028H
	ret	0
$LN7@Adjust_man:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@Adjust_man:
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 8
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 52   : 		return (::operator new(_Bytes));

	jmp	??2@YAPEAX_K@Z				; operator new
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Swap_all@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Swap_all@_Container_base0@std@@QEAAXAEAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT

; 47   : 		}

	ret	0
?_Swap_all@_Container_base0@std@@QEAAXAEAU12@@Z ENDP	; std::_Container_base0::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 43   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?eof@?$_WChar_traits@_W@std@@SAGXZ
_TEXT	SEGMENT
?eof@?$_WChar_traits@_W@std@@SAGXZ PROC			; std::_WChar_traits<wchar_t>::eof, COMDAT

; 394  : 		return (WEOF);

	mov	eax, 65535				; 0000ffffH

; 395  : 		}

	ret	0
?eof@?$_WChar_traits@_W@std@@SAGXZ ENDP			; std::_WChar_traits<wchar_t>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?not_eof@?$_WChar_traits@_W@std@@SAGAEBG@Z
_TEXT	SEGMENT
_Meta$ = 8
?not_eof@?$_WChar_traits@_W@std@@SAGAEBG@Z PROC		; std::_WChar_traits<wchar_t>::not_eof, COMDAT

; 388  : 		{	// return anything but EOF

	movzx	eax, WORD PTR [rcx]

; 389  : 		return (_Meta != eof() ? _Meta : static_cast<int_type>(!eof()));

	mov	edx, 65535				; 0000ffffH
	xor	ecx, ecx
	cmp	ax, dx
	cmove	ax, cx

; 390  : 		}

	ret	0
?not_eof@?$_WChar_traits@_W@std@@SAGAEBG@Z ENDP		; std::_WChar_traits<wchar_t>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z PROC	; std::_WChar_traits<wchar_t>::eq_int_type, COMDAT

; 384  : 		return (_Left == _Right);

	movzx	eax, WORD PTR [rdx]
	cmp	WORD PTR [rcx], ax
	sete	al

; 385  : 		}

	ret	0
?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z ENDP	; std::_WChar_traits<wchar_t>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?to_int_type@?$_WChar_traits@_W@std@@SAGAEB_W@Z
_TEXT	SEGMENT
_Ch$ = 8
?to_int_type@?$_WChar_traits@_W@std@@SAGAEB_W@Z PROC	; std::_WChar_traits<wchar_t>::to_int_type, COMDAT

; 379  : 		return (_Ch);

	movzx	eax, WORD PTR [rcx]

; 380  : 		}

	ret	0
?to_int_type@?$_WChar_traits@_W@std@@SAGAEB_W@Z ENDP	; std::_WChar_traits<wchar_t>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?to_char_type@?$_WChar_traits@_W@std@@SA_WAEBG@Z
_TEXT	SEGMENT
_Meta$ = 8
?to_char_type@?$_WChar_traits@_W@std@@SA_WAEBG@Z PROC	; std::_WChar_traits<wchar_t>::to_char_type, COMDAT

; 374  : 		return (_Meta);

	movzx	eax, WORD PTR [rcx]

; 375  : 		}

	ret	0
?to_char_type@?$_WChar_traits@_W@std@@SA_WAEBG@Z ENDP	; std::_WChar_traits<wchar_t>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?eq@?$_WChar_traits@_W@std@@SA_NAEB_W0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq@?$_WChar_traits@_W@std@@SA_NAEB_W0@Z PROC		; std::_WChar_traits<wchar_t>::eq, COMDAT

; 364  : 		return (_Left == _Right);

	movzx	eax, WORD PTR [rdx]
	cmp	WORD PTR [rcx], ax
	sete	al

; 365  : 		}

	ret	0
?eq@?$_WChar_traits@_W@std@@SA_NAEB_W0@Z ENDP		; std::_WChar_traits<wchar_t>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z PROC	; std::_WChar_traits<wchar_t>::assign, COMDAT

; 359  : 		_Left = _Right;

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax

; 360  : 		}

	ret	0
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ENDP	; std::_WChar_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?move@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z
_TEXT	SEGMENT
_First1$ = 8
_First2$ = 16
_Count$ = 24
?move@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z PROC ; std::_WChar_traits<wchar_t>::move, COMDAT
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	add	r8, r8
	jmp	memmove
?move@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z ENDP ; std::_WChar_traits<wchar_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?find@?$_WChar_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Ch$ = 24
?find@?$_WChar_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z PROC ; std::_WChar_traits<wchar_t>::find, COMDAT
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 203  :         for (; 0 < _N; ++_S, --_N)

	test	rdx, rdx
	je	SHORT $LN5@find

; 204  :             if (*_S == _C)

	movzx	eax, WORD PTR [r8]
	npad	7
$LL6@find:
	cmp	WORD PTR [rcx], ax
	je	SHORT $LN10@find

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rcx, 2
	sub	rdx, 1
	jne	SHORT $LL6@find
$LN5@find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 339  : 		return (reinterpret_cast<const _Elem *>(_CSTD wmemchr(

	xor	eax, eax

; 340  : 			reinterpret_cast<const wchar_t *>(_First), _Ch, _Count)));
; 341  : #endif /* _HAS_CXX17 */
; 342  : 		}

	ret	0
$LN10@find:

; 339  : 		return (reinterpret_cast<const _Elem *>(_CSTD wmemchr(

	mov	rax, rcx

; 340  : 			reinterpret_cast<const wchar_t *>(_First), _Ch, _Count)));
; 341  : #endif /* _HAS_CXX17 */
; 342  : 		}

	ret	0
?find@?$_WChar_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z ENDP ; std::_WChar_traits<wchar_t>::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?copy@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z PROC ; std::_WChar_traits<wchar_t>::copy, COMDAT

; 313  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	add	r8, r8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 313  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	mov	rbx, rcx
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	call	memcpy
	mov	rax, rbx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 316  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?copy@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z ENDP ; std::_WChar_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z PROC	; std::_WChar_traits<wchar_t>::length, COMDAT

; 297  : #if _HAS_CXX17
; 298  : 		if constexpr (is_same_v<_Elem, wchar_t>)
; 299  : 			{
; 300  : 			return (__builtin_wcslen(_First));
; 301  : 			}
; 302  : 		else
; 303  : 			{
; 304  : 			return (_Char_traits<_Elem, unsigned short>::length(_First));
; 305  : 			}
; 306  : #else /* _HAS_CXX17 */
; 307  : 		return (_CSTD wcslen(reinterpret_cast<const wchar_t *>(_First)));

	mov	rax, -1
	npad	9
$LL3@length:
	inc	rax
	cmp	WORD PTR [rcx+rax*2], 0
	jne	SHORT $LL3@length

; 308  : #endif /* _HAS_CXX17 */
; 309  : 		}

	ret	0
?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z ENDP	; std::_WChar_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 894  : 		return (LLONG_MAX);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 895  : 		}

	ret	0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 8
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 295  : 	return (_CSTD sqrtf(_Xx));

	jmp	sqrtf
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 8
?sin@@YAMM@Z PROC					; sin, COMDAT

; 285  : 	return (_CSTD sinf(_Xx));

	jmp	sinf
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?fmod@@YAMMM@Z
_TEXT	SEGMENT
_Xx$ = 8
_Yx$ = 16
?fmod@@YAMMM@Z PROC					; fmod, COMDAT

; 144  : 	return (_CSTD fmodf(_Xx, _Yx));

	jmp	fmodf
?fmod@@YAMMM@Z ENDP					; fmod
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 8
?cos@@YAMM@Z PROC					; cos, COMDAT

; 78   : 	return (_CSTD cosf(_Xx));

	jmp	cosf
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\maxtypes.h
;	COMDAT ??0Class_ID@@QEAA@KK@Z
_TEXT	SEGMENT
this$ = 8
aa$ = 16
bb$ = 24
??0Class_ID@@QEAA@KK@Z PROC				; Class_ID::Class_ID, COMDAT

; 160  : 	Class_ID(ulong aa, ulong bb) { a = aa; b = bb; }

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	DWORD PTR [rcx+4], r8d
	ret	0
??0Class_ID@@QEAA@KK@Z ENDP				; Class_ID::Class_ID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 186  :         (void)_Size;
; 187  :         return _Where;

	mov	rax, rdx

; 188  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
;	COMDAT wmemmove
_TEXT	SEGMENT
_S1$ = 8
_S2$ = 16
_N$ = 24
wmemmove PROC						; COMDAT

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	add	r8, r8
	jmp	memmove
wmemmove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
;	COMDAT wmemcpy
_TEXT	SEGMENT
_S1$ = 48
_S2$ = 56
_N$ = 64
wmemcpy	PROC						; COMDAT

; 231  :     {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	add	r8, r8
	mov	rbx, rcx
	call	memcpy
	mov	rax, rbx

; 235  :         #pragma warning(pop)
; 236  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
wmemcpy	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10586.0\ucrt\wchar.h
;	COMDAT wmemchr
_TEXT	SEGMENT
_S$ = 8
_C$ = 16
_N$ = 24
wmemchr	PROC						; COMDAT

; 203  :         for (; 0 < _N; ++_S, --_N)

	test	r8, r8
	je	SHORT $LN3@wmemchr
$LL4@wmemchr:

; 204  :             if (*_S == _C)

	cmp	WORD PTR [rcx], dx
	je	SHORT $LN8@wmemchr

; 203  :         for (; 0 < _N; ++_S, --_N)

	add	rcx, 2
	sub	r8, 1
	jne	SHORT $LL4@wmemchr
$LN3@wmemchr:

; 206  : 
; 207  :         return 0;

	xor	eax, eax

; 208  :     }

	ret	0
$LN8@wmemchr:

; 205  :                 return (wchar_t _CONST_RETURN*)_S;

	mov	rax, rcx

; 208  :     }

	ret	0
wmemchr	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\tile.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 8
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
__t$ = 48
__s$ = 56
__n$ = 64
__f$ = 72
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN12:
	test	r8, r8
	je	SHORT $LN10@vector
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r9
	mov	rbx, r8
	mov	rbp, rdx
	mov	rdi, rcx
$LL2@vector:
	mov	rcx, rdi
	call	rsi
	add	rdi, rbp
	sub	rbx, 1
	jne	SHORT $LL2@vector
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN10@vector:
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
