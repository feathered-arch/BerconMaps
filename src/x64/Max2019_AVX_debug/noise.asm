; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27031.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	WinbaseIsolationAwarePrivateT_UnPgpgk
PUBLIC	IsolationAwarePrivateT_SqbjaYRiRY
PUBLIC	IsolationAwarePrivateT_SAbnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
PUBLIC	?__LINE__Var@?0???0Class_ID@@QEAA@KK@Z@4JA	; `Class_ID::Class_ID'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0???0AssetId@AssetManagement@MaxSDK@@QEAA@XZ@4JA ; `MaxSDK::AssetManagement::AssetId::AssetId'::`1'::__LINE__Var
EXTRN	GUID_NULL:BYTE
;	COMDAT IsolationAwarePrivateT_SqbjaYRiRY
_BSS	SEGMENT
IsolationAwarePrivateT_SqbjaYRiRY DD 01H DUP (?)
_BSS	ENDS
;	COMDAT IsolationAwarePrivateT_SAbnPgpgk
_BSS	SEGMENT
IsolationAwarePrivateT_SAbnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?__LINE__Var@?0???0AssetId@AssetManagement@MaxSDK@@QEAA@XZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0???0AssetId@AssetManagement@MaxSDK@@QEAA@XZ@4JA DD 01dH ; `MaxSDK::AssetManagement::AssetId::AssetId'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0???0Class_ID@@QEAA@KK@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0???0Class_ID@@QEAA@KK@Z@4JA DD 0a0H	; `Class_ID::Class_ID'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_UnPgpgk
_DATA	SEGMENT
WinbaseIsolationAwarePrivateT_UnPgpgk DQ ffffffffffffffffH
_DATA	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z	; Noise::noise
PUBLIC	?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z	; Noise::noise
PUBLIC	?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Noise::worleyWrapper
PUBLIC	?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z ; Noise::wood
PUBLIC	?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z	; Noise::wood
PUBLIC	?alterUVW@Noise@@SAXAEAVPoint3@@H@Z		; Noise::alterUVW
PUBLIC	?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Noise::limitedNoise
PUBLIC	?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z ; Noise::limitedNoise
PUBLIC	?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z	; Fractal::f
PUBLIC	?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z	; Fractal::f
PUBLIC	__real@38d1b717
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3f900000
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@4049999a
PUBLIC	__real@40b00000
PUBLIC	__real@40e33333
PUBLIC	__real@4129999a
PUBLIC	__real@41700000
PUBLIC	__real@439d1127
PUBLIC	__real@b8d1b717
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__imp_fmaxf:PROC
EXTRN	__imp_??0Point3@@QEAA@MMM@Z:PROC
EXTRN	__imp_??0Point3@@QEAA@AEBV0@@Z:PROC
EXTRN	__imp_?Length@Point3@@QEBAMXZ:PROC
EXTRN	__imp_?threshold@@YAMMMM@Z:PROC
EXTRN	?noise@Worley@@SAXQEBNHPEANH@Z:PROC		; Worley::noise
EXTRN	?smooth@@YAMM@Z:PROC				; smooth
EXTRN	?smooth@@YAMMMM@Z:PROC				; smooth
EXTRN	?noise@Perlin@@SAMMM@Z:PROC			; Perlin::noise
EXTRN	?noise@Perlin@@SAMMMM@Z:PROC			; Perlin::noise
EXTRN	?noise@Perlin@@SAMMMMM@Z:PROC			; Perlin::noise
EXTRN	?snoise@Perlin@@SAMM@Z:PROC			; Perlin::snoise
EXTRN	?snoise@Perlin@@SAMMM@Z:PROC			; Perlin::snoise
EXTRN	?snoise@Perlin@@SAMMMM@Z:PROC			; Perlin::snoise
EXTRN	?snoise@Perlin@@SAMMMMM@Z:PROC			; Perlin::snoise
EXTRN	?fnoise2D@Perlin@@SAMMMM@Z:PROC			; Perlin::fnoise2D
EXTRN	?fnoise3D@Perlin@@SAMMMMM@Z:PROC		; Perlin::fnoise3D
EXTRN	?fnoise4D@Perlin@@SAMMMMMM@Z:PROC		; Perlin::fnoise4D
EXTRN	?fsnoise2D@Perlin@@SAMMMM@Z:PROC		; Perlin::fsnoise2D
EXTRN	?fsnoise3D@Perlin@@SAMMMMM@Z:PROC		; Perlin::fsnoise3D
EXTRN	?fsnoise4D@Perlin@@SAMMMMMM@Z:PROC		; Perlin::fsnoise4D
EXTRN	?fractal@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::fractal
EXTRN	?turbulence@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::turbulence
EXTRN	?fBm@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::fBm
EXTRN	?fBmTurb@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::fBmTurb
EXTRN	?heteroTerrain@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::heteroTerrain
EXTRN	?hybridMultiFractal@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::hybridMultiFractal
EXTRN	?ridgedMultiFractal@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z:PROC ; Fractal::ridgedMultiFractal
EXTRN	?fractal@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z:PROC ; Fractal::fractal
EXTRN	?turbulence@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z:PROC ; Fractal::turbulence
EXTRN	?fBm@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z:PROC ; Fractal::fBm
EXTRN	?fBmTurb@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z:PROC ; Fractal::fBmTurb
EXTRN	?hybridMultiFractal@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z:PROC ; Fractal::hybridMultiFractal
EXTRN	?ridgedMultiFractal@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z:PROC ; Fractal::ridgedMultiFractal
EXTRN	__CxxFrameHandler3:PROC
EXTRN	cosf:PROC
EXTRN	sinf:PROC
EXTRN	sqrtf:PROC
EXTRN	__ImageBase:BYTE
EXTRN	_fltused:DWORD
_BSS	SEGMENT
?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A DB 010H DUP (?) ; MaxSDK::AssetManagement::kInvalidId
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fmax@@YAMMM@Z DD imagerel $LN5
	DD	imagerel $LN5+25
	DD	imagerel $unwind$?fmax@@YAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D@YA?AVPoint3@@MAEBV0@@Z DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??D@YA?AVPoint3@@MAEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D@YA?AVPoint3@@AEBV0@M@Z DD imagerel $LN4
	DD	imagerel $LN4+42
	DD	imagerel $unwind$??D@YA?AVPoint3@@AEBV0@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z DD imagerel $LN15
	DD	imagerel $LN15+256
	DD	imagerel $unwind$?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z DD imagerel $LN15
	DD	imagerel $LN15+284
	DD	imagerel $unwind$?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z DD imagerel $LN19
	DD	imagerel $LN19+414
	DD	imagerel $unwind$?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z DD imagerel $LN39
	DD	imagerel $LN39+1063
	DD	imagerel $unwind$?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z DD imagerel $LN70
	DD	imagerel $LN70+865
	DD	imagerel $unwind$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z DD imagerel $LN70+865
	DD	imagerel $LN70+1645
	DD	imagerel $chain$3$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z DD imagerel $LN70+1645
	DD	imagerel $LN70+1726
	DD	imagerel $chain$4$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?alterUVW@Noise@@SAXAEAVPoint3@@H@Z DD imagerel $LN14
	DD	imagerel $LN14+115
	DD	imagerel $unwind$?alterUVW@Noise@@SAXAEAVPoint3@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z DD imagerel $LN7
	DD	imagerel $LN7+99
	DD	imagerel $unwind$?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z DD imagerel $LN9
	DD	imagerel $LN9+180
	DD	imagerel $unwind$?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z DD imagerel $LN28
	DD	imagerel $LN28+600
	DD	imagerel $unwind$?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z DD imagerel $LN28
	DD	imagerel $LN28+716
	DD	imagerel $unwind$?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?kInvalidId$initializer$@AssetManagement@MaxSDK@@3P6AXXZEA DQ FLAT:??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ; MaxSDK::AssetManagement::kInvalidId$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@b8d1b717
CONST	SEGMENT
__real@b8d1b717 DD 0b8d1b717r			; -0.0001
CONST	ENDS
;	COMDAT __real@439d1127
CONST	SEGMENT
__real@439d1127 DD 0439d1127r			; 314.134
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@4129999a
CONST	SEGMENT
__real@4129999a DD 04129999ar			; 10.6
CONST	ENDS
;	COMDAT __real@40e33333
CONST	SEGMENT
__real@40e33333 DD 040e33333r			; 7.1
CONST	ENDS
;	COMDAT __real@40b00000
CONST	SEGMENT
__real@40b00000 DD 040b00000r			; 5.5
CONST	ENDS
;	COMDAT __real@4049999a
CONST	SEGMENT
__real@4049999a DD 04049999ar			; 3.15
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f900000
CONST	SEGMENT
__real@3f900000 DD 03f900000r			; 1.125
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
_DATA	SEGMENT
?kTriObjNormalXTCID@@3VClass_ID@@B DD 0730a33d7H	; kTriObjNormalXTCID
	DD	027246c55H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z DD 061701H
	DD	056817H
	DD	0e340aH
	DD	07006b20aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z DD 081801H
	DD	036818H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?alterUVW@Noise@@SAXAEAVPoint3@@H@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z DD 021H
	DD	imagerel $LN70
	DD	imagerel $LN70+865
	DD	imagerel $unwind$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z DD 082321H
	DD	08f823H
	DD	09e81aH
	DD	0ad811H
	DD	02fd408H
	DD	imagerel $LN70
	DD	imagerel $LN70+865
	DD	imagerel $unwind$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z DD 0175301H
	DD	0bc853H
	DD	0cb84bH
	DD	0da840H
	DD	0e9835H
	DD	0f882dH
	DD	0107825H
	DD	011681dH
	DD	0240118H
	DD	0e00bf00dH
	DD	07007c009H
	DD	030056006H
	DD	05004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z DD 0116101H
	DD	05a861H
	DD	06985cH
	DD	078854H
	DD	087839H
	DD	096829H
	DD	0176413H
	DD	0163413H
	DD	0140113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z DD 040a01H
	DD	0e340aH
	DD	07006b20aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D@YA?AVPoint3@@AEBV0@M@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D@YA?AVPoint3@@MAEBV0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?fmax@@YAMMM@Z DD imagerel ?fmax@@YAMMM@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?fmax@@YAMMM@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?fmax@@YAMMM@Z
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fmax@@YAMMM@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?fmax@@YAMMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 081901H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	070153219H
xdata	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\fractal.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File g:\dropbox\github\berconmaps\src\fractal.h
;	COMDAT ?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 64
$T3 = 64
$T4 = 64
$T5 = 64
$T6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
p$ = 112
d$ = 120
np$ = 128
?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z PROC	; Fractal::f, COMDAT

; 64   : 	static float f(Point3 p, float d, NoiseParams &np) {

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 96					; 00000060H

; 65   : 		switch (np.fractalFunction) {

	movsxd	rax, DWORD PTR [r8+4]
	mov	rbx, r8
	vmovaps	XMMWORD PTR [rsp+80], xmm6
	vmovaps	xmm6, xmm1
	cmp	eax, 7
	ja	$LN2@f
	lea	rdi, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN26@f[rdi+rax*4]
	add	rax, rdi
	jmp	rax
$LN4@f:

; 66   : 			case 0: return (1.0f + Noise::noise(p, d, np)) * .5f;

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 52   : 	switch (np.noiseFunction) {

	movsxd	rcx, DWORD PTR [rbx]
	cmp	ecx, 6
	ja	$LN23@f
	mov	edx, DWORD PTR $LN25@f[rdi+rcx*4]
	add	rdx, rdi
	jmp	rdx
$LN16@f:

; 53   : 		case 0: return Perlin::fnoise2D(p.x, p.y, d);

	vmovss	xmm1, DWORD PTR [rax+4]
	vmovss	xmm0, DWORD PTR [rax]
	vmovaps	xmm2, xmm6
	call	?fnoise2D@Perlin@@SAMMMM@Z		; Perlin::fnoise2D
	jmp	$LN13@f
$LN17@f:

; 54   : 		case 1: return Perlin::fnoise3D(p.x, p.y, p.z, d);

	vmovss	xmm2, DWORD PTR [rax+8]
	vmovss	xmm1, DWORD PTR [rax+4]
	vmovss	xmm0, DWORD PTR [rax]
	vmovaps	xmm3, xmm6
	call	?fnoise3D@Perlin@@SAMMMMM@Z		; Perlin::fnoise3D
	jmp	$LN13@f
$LN18@f:

; 55   : 		case 2: return Perlin::fnoise4D(p.x, p.y, p.z, np.phase, d);		

	vmovss	xmm3, DWORD PTR [rbx+12]
	vmovss	xmm2, DWORD PTR [rax+8]
	vmovss	xmm1, DWORD PTR [rax+4]
	vmovss	xmm0, DWORD PTR [rax]
	vmovss	DWORD PTR [rsp+32], xmm6
	call	?fnoise4D@Perlin@@SAMMMMMM@Z		; Perlin::fnoise4D
	jmp	SHORT $LN13@f
$LN19@f:

; 56   : 		case 3: return Perlin::fsnoise2D(p.x, p.y, d);

	vmovss	xmm1, DWORD PTR [rax+4]
	vmovss	xmm0, DWORD PTR [rax]
	vmovaps	xmm2, xmm6
	call	?fsnoise2D@Perlin@@SAMMMM@Z		; Perlin::fsnoise2D
	jmp	SHORT $LN13@f
$LN20@f:

; 57   : 		case 4: return Perlin::fsnoise3D(p.x, p.y, p.z, d);

	vmovss	xmm2, DWORD PTR [rax+8]
	vmovss	xmm1, DWORD PTR [rax+4]
	vmovss	xmm0, DWORD PTR [rax]
	vmovaps	xmm3, xmm6
	call	?fsnoise3D@Perlin@@SAMMMMM@Z		; Perlin::fsnoise3D
	jmp	SHORT $LN13@f
$LN21@f:

; 58   : 		case 5: return Perlin::fsnoise4D(p.x, p.y, p.z, np.phase, d);		

	vmovss	xmm3, DWORD PTR [rbx+12]
	vmovss	xmm2, DWORD PTR [rax+8]
	vmovss	xmm1, DWORD PTR [rax+4]
	vmovss	xmm0, DWORD PTR [rax]
	vmovss	DWORD PTR [rsp+32], xmm6
	call	?fsnoise4D@Perlin@@SAMMMMMM@Z		; Perlin::fsnoise4D
	jmp	SHORT $LN13@f
$LN22@f:

; 59   : 		case 6: return worleyWrapper(p, np);

	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Noise::worleyWrapper
	jmp	SHORT $LN13@f
$LN23@f:
	vxorps	xmm0, xmm0, xmm0
$LN13@f:
; File g:\dropbox\github\berconmaps\src\fractal.h

; 66   : 			case 0: return (1.0f + Noise::noise(p, d, np)) * .5f;

	vaddss	xmm0, xmm0, DWORD PTR __real@3f800000
	vmulss	xmm0, xmm0, DWORD PTR __real@3f000000

; 74   : 		}
; 75   : 		return 0;
; 76   : 	}

	mov	rbx, QWORD PTR [rsp+112]
	vmovaps	xmm6, XMMWORD PTR [rsp+80]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN5@f:

; 67   : 			case 1: return fractal(p, d, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T9[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	r8, rbx
	vmovaps	xmm1, xmm6
	call	?fractal@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::fractal

; 74   : 		}
; 75   : 		return 0;
; 76   : 	}

	mov	rbx, QWORD PTR [rsp+112]
	vmovaps	xmm6, XMMWORD PTR [rsp+80]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN6@f:

; 68   : 			case 2: return turbulence(p, d, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T8[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	r8, rbx
	vmovaps	xmm1, xmm6
	call	?turbulence@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::turbulence

; 74   : 		}
; 75   : 		return 0;
; 76   : 	}

	mov	rbx, QWORD PTR [rsp+112]
	vmovaps	xmm6, XMMWORD PTR [rsp+80]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN7@f:

; 69   : 			case 3: return fBm(p, d, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T7[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	r8, rbx
	vmovaps	xmm1, xmm6
	call	?fBm@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::fBm

; 74   : 		}
; 75   : 		return 0;
; 76   : 	}

	mov	rbx, QWORD PTR [rsp+112]
	vmovaps	xmm6, XMMWORD PTR [rsp+80]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN8@f:

; 70   : 			case 4: return fBmTurb(p, d, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T6[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	r8, rbx
	vmovaps	xmm1, xmm6
	call	?fBmTurb@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::fBmTurb

; 74   : 		}
; 75   : 		return 0;
; 76   : 	}

	mov	rbx, QWORD PTR [rsp+112]
	vmovaps	xmm6, XMMWORD PTR [rsp+80]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN9@f:

; 71   : 			case 5: return heteroTerrain(p, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T5[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	?heteroTerrain@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::heteroTerrain

; 74   : 		}
; 75   : 		return 0;
; 76   : 	}

	mov	rbx, QWORD PTR [rsp+112]
	vmovaps	xmm6, XMMWORD PTR [rsp+80]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN10@f:

; 72   : 			case 6: return hybridMultiFractal(p, d, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T4[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	r8, rbx
	vmovaps	xmm1, xmm6
	call	?hybridMultiFractal@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::hybridMultiFractal

; 74   : 		}
; 75   : 		return 0;
; 76   : 	}

	mov	rbx, QWORD PTR [rsp+112]
	vmovaps	xmm6, XMMWORD PTR [rsp+80]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN11@f:

; 73   : 			case 7: return ridgedMultiFractal(p, d, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	r8, rbx
	vmovaps	xmm1, xmm6
	call	?ridgedMultiFractal@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::ridgedMultiFractal

; 74   : 		}
; 75   : 		return 0;
; 76   : 	}

	mov	rbx, QWORD PTR [rsp+112]
	vmovaps	xmm6, XMMWORD PTR [rsp+80]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN2@f:
	mov	rbx, QWORD PTR [rsp+112]
	vmovaps	xmm6, XMMWORD PTR [rsp+80]
	vxorps	xmm0, xmm0, xmm0
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN26@f:
	DD	$LN4@f
	DD	$LN5@f
	DD	$LN6@f
	DD	$LN7@f
	DD	$LN8@f
	DD	$LN9@f
	DD	$LN10@f
	DD	$LN11@f
$LN25@f:
	DD	$LN16@f
	DD	$LN17@f
	DD	$LN18@f
	DD	$LN19@f
	DD	$LN20@f
	DD	$LN21@f
	DD	$LN22@f
?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ENDP	; Fractal::f
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\fractal.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File g:\dropbox\github\berconmaps\src\fractal.h
;	COMDAT ?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
$T9 = 48
p$ = 80
np$ = 88
?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z PROC	; Fractal::f, COMDAT

; 50   : 	static float f(Point3 p, NoiseParams &np) {

$LN28:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 51   : 		switch (np.fractalFunction) {

	movsxd	rax, DWORD PTR [rdx+4]
	mov	rbx, rdx
	cmp	eax, 7
	ja	$LN2@f
	lea	rdi, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN26@f[rdi+rax*4]
	add	rax, rdi
	jmp	rax
$LN4@f:

; 52   : 			case 0: return (1.0f + Noise::noise(p, np)) * .5f;

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 39   : 	switch (np.noiseFunction) {

	movsxd	rcx, DWORD PTR [rbx]
	cmp	ecx, 6
	ja	$LN23@f
	mov	edx, DWORD PTR $LN25@f[rdi+rcx*4]
	add	rdx, rdi
	jmp	rdx
$LN16@f:

; 40   : 		case 0: return Perlin::noise(p.x, p.y);						//Perlin 2d

	vmovss	xmm1, DWORD PTR [rax+4]
	vmovss	xmm0, DWORD PTR [rax]
	call	?noise@Perlin@@SAMMM@Z			; Perlin::noise
	jmp	$LN13@f
$LN17@f:

; 41   : 		case 1: return Perlin::noise(p.x, p.y, p.z);				//Perlin 3d

	vmovss	xmm2, DWORD PTR [rax+8]
	vmovss	xmm1, DWORD PTR [rax+4]
	vmovss	xmm0, DWORD PTR [rax]
	call	?noise@Perlin@@SAMMMM@Z			; Perlin::noise
	jmp	SHORT $LN13@f
$LN18@f:

; 42   : 		case 2: return Perlin::noise(p.x, p.y, p.z, np.phase);		//Perlin 4D

	vmovss	xmm3, DWORD PTR [rbx+12]
	vmovss	xmm2, DWORD PTR [rax+8]
	vmovss	xmm1, DWORD PTR [rax+4]
	vmovss	xmm0, DWORD PTR [rax]
	call	?noise@Perlin@@SAMMMMM@Z		; Perlin::noise
	jmp	SHORT $LN13@f
$LN19@f:

; 43   : 		case 3: return Perlin::snoise(p.x, p.y);					//Simplex 2D

	vmovss	xmm1, DWORD PTR [rax+4]
	vmovss	xmm0, DWORD PTR [rax]
	call	?snoise@Perlin@@SAMMM@Z			; Perlin::snoise
	jmp	SHORT $LN13@f
$LN20@f:

; 44   : 		case 4: return Perlin::snoise(p.x, p.y, p.z);				//Simplex 3D

	vmovss	xmm2, DWORD PTR [rax+8]
	vmovss	xmm1, DWORD PTR [rax+4]
	vmovss	xmm0, DWORD PTR [rax]
	call	?snoise@Perlin@@SAMMMM@Z		; Perlin::snoise
	jmp	SHORT $LN13@f
$LN21@f:

; 45   : 		case 5: return Perlin::snoise(p.x, p.y, p.z, np.phase);		//Simplex 4D

	vmovss	xmm3, DWORD PTR [rbx+12]
	vmovss	xmm2, DWORD PTR [rax+8]
	vmovss	xmm1, DWORD PTR [rax+4]
	vmovss	xmm0, DWORD PTR [rax]
	call	?snoise@Perlin@@SAMMMMM@Z		; Perlin::snoise
	jmp	SHORT $LN13@f
$LN22@f:

; 46   : 		case 6: return worleyWrapper(p, np);						//Worley(Voronoi)

	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Noise::worleyWrapper
	jmp	SHORT $LN13@f
$LN23@f:
	vxorps	xmm0, xmm0, xmm0
$LN13@f:
; File g:\dropbox\github\berconmaps\src\fractal.h

; 52   : 			case 0: return (1.0f + Noise::noise(p, np)) * .5f;

	vaddss	xmm0, xmm0, DWORD PTR __real@3f800000
	vmulss	xmm0, xmm0, DWORD PTR __real@3f000000

; 60   : 		}
; 61   : 		return 0;
; 62   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN5@f:

; 53   : 			case 1: return fractal(p, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T9[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	?fractal@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::fractal

; 60   : 		}
; 61   : 		return 0;
; 62   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN6@f:

; 54   : 			case 2: return turbulence(p, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T8[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	?turbulence@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::turbulence

; 60   : 		}
; 61   : 		return 0;
; 62   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN7@f:

; 55   : 			case 3: return fBm(p, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T7[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	?fBm@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::fBm

; 60   : 		}
; 61   : 		return 0;
; 62   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN8@f:

; 56   : 			case 4: return fBmTurb(p, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T6[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	?fBmTurb@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::fBmTurb

; 60   : 		}
; 61   : 		return 0;
; 62   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN9@f:

; 57   : 			case 5: return heteroTerrain(p, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T5[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	?heteroTerrain@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::heteroTerrain

; 60   : 		}
; 61   : 		return 0;
; 62   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN10@f:

; 58   : 			case 6: return hybridMultiFractal(p, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T4[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	?hybridMultiFractal@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::hybridMultiFractal

; 60   : 		}
; 61   : 		return 0;
; 62   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN11@f:

; 59   : 			case 7: return ridgedMultiFractal(p, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	?ridgedMultiFractal@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::ridgedMultiFractal

; 60   : 		}
; 61   : 		return 0;
; 62   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN2@f:
	mov	rbx, QWORD PTR [rsp+80]
	vxorps	xmm0, xmm0, xmm0
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
	npad	3
$LN26@f:
	DD	$LN4@f
	DD	$LN5@f
	DD	$LN6@f
	DD	$LN7@f
	DD	$LN8@f
	DD	$LN9@f
	DD	$LN10@f
	DD	$LN11@f
$LN25@f:
	DD	$LN16@f
	DD	$LN17@f
	DD	$LN18@f
	DD	$LN19@f
	DD	$LN20@f
	DD	$LN21@f
	DD	$LN22@f
?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ENDP	; Fractal::f
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\noise.cpp
;	COMDAT ?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z
_TEXT	SEGMENT
$T1 = 32
p$ = 80
dpdx$ = 88
dpdy$ = 96
np$ = 104
?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z PROC ; Noise::limitedNoise, COMDAT

; 230  : float Noise::limitedNoise(Point3 p, Point3 dpdx, Point3 dpdy, NoiseParams &np) {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rcx
	vmovaps	XMMWORD PTR [rsp+48], xmm6

; 231  : 	float lx = dpdx.Length();

	mov	rcx, rdx
	mov	rsi, r9
	mov	rbx, r8
	call	QWORD PTR __imp_?Length@Point3@@QEBAMXZ

; 232  : 	float ly = dpdy.Length();

	mov	rcx, rbx
	vmovaps	xmm6, xmm0
	call	QWORD PTR __imp_?Length@Point3@@QEBAMXZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 134  : 	return (_CSTD fmaxf(_Xx, _Yx));

	vmovaps	xmm1, xmm0
	vmovaps	xmm0, xmm6
	call	QWORD PTR __imp_fmaxf
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 234  : 	float res = Fractal::f(p, lx, np);	

	mov	rdx, rdi
	lea	rcx, QWORD PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 134  : 	return (_CSTD fmaxf(_Xx, _Yx));

	vmovaps	xmm6, xmm0
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 234  : 	float res = Fractal::f(p, lx, np);	

	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	r8, rsi
	vmovaps	xmm1, xmm6
	call	?f@Fractal@@SAMVPoint3@@MAEAVNoiseParams@@@Z ; Fractal::f

; 235  : 	if (np.low<np.high) res = threshold(res,np.low,np.high);		

	vmovss	xmm1, DWORD PTR [rsi+60]
	vmovss	xmm2, DWORD PTR [rsi+64]
	vcomiss	xmm2, xmm1
	vmovaps	xmm3, xmm0
	jbe	SHORT $LN2@limitedNoi
	call	QWORD PTR __imp_?threshold@@YAMMMM@Z
	vmovaps	xmm3, xmm0
$LN2@limitedNoi:

; 236  : 	if (res < 0) return 0.0f;

	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm3
	ja	SHORT $LN4@limitedNoi

; 237  : 	if (res > 1) return 1.0f;

	vmovss	xmm1, DWORD PTR __real@3f800000
	vcmpltss xmm0, xmm1, xmm3
	vblendvps xmm0, xmm3, xmm1, xmm0
$LN4@limitedNoi:

; 238  : 	return res;
; 239  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	vmovaps	xmm6, XMMWORD PTR [rsp+48]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?limitedNoise@Noise@@SAMVPoint3@@00AEAVNoiseParams@@@Z ENDP ; Noise::limitedNoise
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\noise.cpp
;	COMDAT ?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z
_TEXT	SEGMENT
$T1 = 32
p$ = 64
np$ = 72
?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z PROC ; Noise::limitedNoise, COMDAT

; 222  : float Noise::limitedNoise(Point3 p, NoiseParams &np) {

$LN7:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 223  : 	float res = Fractal::f(p, np);	

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	?f@Fractal@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Fractal::f

; 224  : 	if (np.low<np.high) res = threshold(res,np.low,np.high);		

	vmovss	xmm1, DWORD PTR [rbx+60]
	vmovss	xmm2, DWORD PTR [rbx+64]
	vcomiss	xmm2, xmm1
	vmovaps	xmm3, xmm0
	jbe	SHORT $LN2@limitedNoi
	call	QWORD PTR __imp_?threshold@@YAMMMM@Z
	vmovaps	xmm3, xmm0
$LN2@limitedNoi:

; 225  : 	if (res < 0) return 0.0f;

	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm3
	ja	SHORT $LN4@limitedNoi

; 226  : 	if (res > 1) return 1.0f;

	vmovss	xmm1, DWORD PTR __real@3f800000
	vcmpltss xmm0, xmm1, xmm3
	vblendvps xmm0, xmm3, xmm1, xmm0
$LN4@limitedNoi:

; 227  : 	return res;
; 228  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?limitedNoise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ENDP ; Noise::limitedNoise
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\noise.cpp
;	COMDAT ?alterUVW@Noise@@SAXAEAVPoint3@@H@Z
_TEXT	SEGMENT
p$ = 48
type$ = 56
?alterUVW@Noise@@SAXAEAVPoint3@@H@Z PROC		; Noise::alterUVW, COMDAT

; 22   : void Noise::alterUVW(Point3& p, int type) {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 23   : 	switch (type) {

	sub	edx, 1
	je	SHORT $LN5@alterUVW
	cmp	edx, 1
	jne	SHORT $LN2@alterUVW

; 29   : 			break;
; 30   : 		case 2:	
; 31   : 			p.x = sqrt(p.x * p.x + p.y * p.y + p.z * p.z);

	vmovss	xmm0, DWORD PTR [rcx]
	vmovss	xmm2, DWORD PTR [rcx+4]
	vmovss	xmm3, DWORD PTR [rcx+8]
	vmulss	xmm1, xmm0, xmm0
	vmulss	xmm0, xmm2, xmm2
	vaddss	xmm2, xmm1, xmm0
	vmulss	xmm1, xmm3, xmm3
	vaddss	xmm0, xmm2, xmm1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 295  : 	return (_CSTD sqrtf(_Xx));

	call	sqrtf
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 32   : 			p.y = 0.f;			

	xor	eax, eax
	mov	QWORD PTR [rbx+4], rax

; 33   : 			p.z = 0.f;
; 34   : 			break;
; 35   : 	}
; 36   : }

	vmovss	DWORD PTR [rbx], xmm0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@alterUVW:

; 24   : 		case 0:
; 25   : 		break;
; 26   : 		case 1: 
; 27   : 			p.x = sqrt(p.x * p.x + p.y * p.y);

	vmovss	xmm0, DWORD PTR [rcx]
	vmovss	xmm1, DWORD PTR [rcx+4]
	vmulss	xmm2, xmm0, xmm0
	vmulss	xmm1, xmm1, xmm1
	vaddss	xmm0, xmm2, xmm1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 295  : 	return (_CSTD sqrtf(_Xx));

	call	sqrtf
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 28   : 			p.y = 0.f;

	xor	eax, eax
	mov	DWORD PTR [rbx+4], eax

; 33   : 			p.z = 0.f;
; 34   : 			break;
; 35   : 	}
; 36   : }

	vmovss	DWORD PTR [rbx], xmm0
$LN2@alterUVW:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?alterUVW@Noise@@SAXAEAVPoint3@@H@Z ENDP		; Noise::alterUVW
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\noise.cpp
;	COMDAT ?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 48
$T5 = 60
$T6 = 60
$T7 = 60
$T8 = 60
$T9 = 72
$T10 = 72
$T11 = 72
fp$ = 88
$T12 = 104
$T13 = 104
samplesf$1$ = 352
p$ = 352
i$1$ = 360
dPdx$ = 360
angNoise$1$ = 368
dPdy$ = 368
g$ = 376
total$1$ = 384
wp$ = 384
?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z PROC	; Noise::wood, COMDAT

; 147  : {

$LN70:
	mov	rax, rsp
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-88]
	sub	rsp, 288				; 00000120H
	vmovaps	XMMWORD PTR [rax-72], xmm6
	mov	rdi, rcx
	vmovaps	XMMWORD PTR [rax-88], xmm7

; 148  : 	// Filtered noises are only intrested in maximum change in X, Y and Z axis.
; 149  : 	float lx = dPdx.Length();

	mov	rcx, rdx
	vmovaps	XMMWORD PTR [rax-104], xmm8
	mov	rbx, r9
	vmovaps	XMMWORD PTR [rax-120], xmm9
	mov	rsi, r8
	vmovaps	XMMWORD PTR [rax-136], xmm10
	mov	r14, rdx
	vmovaps	XMMWORD PTR [rax-152], xmm11
	vmovaps	XMMWORD PTR [rax-168], xmm12
	call	QWORD PTR __imp_?Length@Point3@@QEBAMXZ

; 150  : 	float ly = dPdy.Length();

	mov	rcx, rsi
	vmovaps	xmm6, xmm0
	call	QWORD PTR __imp_?Length@Point3@@QEBAMXZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 134  : 	return (_CSTD fmaxf(_Xx, _Yx));

	vmovaps	xmm1, xmm0
	vmovaps	xmm0, xmm6
	call	QWORD PTR __imp_fmaxf
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 153  : 	p.x += Perlin::fsnoise4D(p.x * wp.radialFreq, p.y * wp.radialFreq, p.z * wp.radialZ, wp.randSeed - 1.125f,

	mov	r15, QWORD PTR wp$[rbp-256]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 134  : 	return (_CSTD fmaxf(_Xx, _Yx));

	vmovaps	xmm11, xmm0
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 153  : 	p.x += Perlin::fsnoise4D(p.x * wp.radialFreq, p.y * wp.radialFreq, p.z * wp.radialZ, wp.randSeed - 1.125f,

	vmovss	xmm9, DWORD PTR [r15+44]
	vmovss	xmm12, DWORD PTR [r15+4]
	vmovss	xmm7, DWORD PTR [r15+48]
	vsubss	xmm3, xmm12, DWORD PTR __real@3f900000
	vmulss	xmm2, xmm7, DWORD PTR [rdi+8]
	vmulss	xmm1, xmm9, DWORD PTR [rdi+4]
	vmulss	xmm10, xmm9, xmm0
	vmulss	xmm0, xmm9, DWORD PTR [rdi]
	vmovss	DWORD PTR [rsp+32], xmm10
	call	?fsnoise4D@Perlin@@SAMMMMMM@Z		; Perlin::fsnoise4D
	vmulss	xmm1, xmm0, DWORD PTR [r15+40]
	vaddss	xmm4, xmm1, DWORD PTR [rdi]

; 154  : 	                         filter * wp.radialFreq) * wp.radialStr;
; 155  : 	p.y += Perlin::fsnoise4D(p.x * wp.radialFreq, p.y * wp.radialFreq, p.z * wp.radialZ, wp.randSeed + 1.125f,

	vaddss	xmm3, xmm12, DWORD PTR __real@3f900000
	vmulss	xmm2, xmm7, DWORD PTR [rdi+8]
	vmulss	xmm1, xmm9, DWORD PTR [rdi+4]
	vmulss	xmm0, xmm9, xmm4
	vmovss	DWORD PTR [rdi], xmm4
	vmovss	DWORD PTR [rsp+32], xmm10
	call	?fsnoise4D@Perlin@@SAMMMMMM@Z		; Perlin::fsnoise4D
	vmulss	xmm1, xmm0, DWORD PTR [r15+40]
	vaddss	xmm2, xmm1, DWORD PTR [rdi+4]

; 156  : 	                         filter * wp.radialFreq) * wp.radialStr;
; 157  : 	g = p; // Store radial component for gain

	vmovsd	xmm0, QWORD PTR [rdi]

; 158  : 	// Trunk wobble		
; 159  : 	float angle = Perlin::fsnoise2D(p.z * wp.trunkFreq, wp.randSeed + 3.f, filter * wp.trunkFreq) * (float)pi;

	vmovss	xmm6, DWORD PTR [r15+36]
	vaddss	xmm1, xmm12, DWORD PTR __real@40400000
	vinsertps xmm0, xmm0, xmm2, 16
	vmovsd	QWORD PTR [rdi], xmm0
	vmovsd	QWORD PTR [rbx], xmm0
	mov	eax, DWORD PTR [rdi+8]
	mov	DWORD PTR [rbx+8], eax
	vmulss	xmm0, xmm6, DWORD PTR [rdi+8]
	vmulss	xmm7, xmm6, xmm11
	vmovaps	xmm2, xmm7
	call	?fsnoise2D@Perlin@@SAMMMM@Z		; Perlin::fsnoise2D
	vmulss	xmm8, xmm0, DWORD PTR __real@40490fdb

; 160  : 	p += Point3(cos(angle), sin(angle), 0.f) * Perlin::fsnoise2D(p.z * wp.trunkFreq, wp.randSeed - 5.5f,

	vmulss	xmm0, xmm6, DWORD PTR [rdi+8]
	vsubss	xmm1, xmm12, DWORD PTR __real@40b00000
	vmovaps	xmm2, xmm7
	call	?fsnoise2D@Perlin@@SAMMMM@Z		; Perlin::fsnoise2D
	vmovaps	xmm7, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 285  : 	return (_CSTD sinf(_Xx));

	vmovaps	xmm0, xmm8
	call	sinf
	vmovaps	xmm6, xmm0

; 78   : 	return (_CSTD cosf(_Xx));

	vmovaps	xmm0, xmm8
	call	cosf
	vmovaps	xmm1, xmm0
	vxorps	xmm3, xmm3, xmm3
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 160  : 	p += Point3(cos(angle), sin(angle), 0.f) * Perlin::fsnoise2D(p.z * wp.trunkFreq, wp.randSeed - 5.5f,

	vmovaps	xmm2, xmm6
	lea	rcx, QWORD PTR $T13[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	lea	rcx, QWORD PTR $T4[rsp]
	vmulss	xmm3, xmm7, DWORD PTR [rax+8]
	vmulss	xmm2, xmm7, DWORD PTR [rax+4]
	vmulss	xmm1, xmm7, DWORD PTR [rax]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 160  : 	p += Point3(cos(angle), sin(angle), 0.f) * Perlin::fsnoise2D(p.z * wp.trunkFreq, wp.randSeed - 5.5f,

	vmovss	xmm4, DWORD PTR [r15+32]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm3, xmm4, DWORD PTR $T4[rsp+8]
	vmulss	xmm2, xmm4, DWORD PTR $T4[rsp+4]
	vmulss	xmm1, xmm4, DWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vmovss	xmm0, DWORD PTR $T8[rsp]
	vaddss	xmm4, xmm0, DWORD PTR [rdi]
	vmovss	xmm1, DWORD PTR $T8[rsp+4]
	vaddss	xmm2, xmm1, DWORD PTR [rdi+4]

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmovss	xmm7, DWORD PTR __real@3f000000

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vmovss	xmm0, DWORD PTR $T8[rsp+8]
	vaddss	xmm1, xmm0, DWORD PTR [rdi+8]
	vmovss	DWORD PTR [rdi+8], xmm1

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm3, xmm1, xmm7

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vmovss	DWORD PTR [rdi+4], xmm2

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm1, xmm4, xmm7
	vmulss	xmm2, xmm2, xmm7
	lea	rcx, QWORD PTR $T7[rsp]

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vmovss	DWORD PTR [rdi], xmm4

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	vmulss	xmm3, xmm7, DWORD PTR [rbx+8]
	vmulss	xmm2, xmm7, DWORD PTR [rbx+4]
	vmulss	xmm1, xmm7, DWORD PTR [rbx]
	lea	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vmovss	xmm0, DWORD PTR $T7[rsp+8]
	vmovss	xmm1, DWORD PTR $T7[rsp+4]
	vaddss	xmm3, xmm0, DWORD PTR $T3[rsp+8]
	vmovss	xmm0, DWORD PTR $T7[rsp]
	vaddss	xmm2, xmm1, DWORD PTR $T3[rsp+4]
	vaddss	xmm1, xmm0, DWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR $T11[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 164  : 	float angNoise = Perlin::fnoise4D(p.x * wp.angleFreq, p.y * wp.angleFreq, p.z * wp.angleFreq * .5f,

	vmovss	xmm4, DWORD PTR [r15+56]
	vmovsd	xmm0, QWORD PTR $T11[rsp]
	mov	eax, DWORD PTR $T11[rsp+8]
	vaddss	xmm3, xmm12, DWORD PTR __real@4129999a
	vmovsd	QWORD PTR [rbx], xmm0
	mov	DWORD PTR [rbx+8], eax
	vmulss	xmm0, xmm4, DWORD PTR [rdi+8]
	vmulss	xmm1, xmm4, DWORD PTR [rdi+4]
	vmulss	xmm2, xmm0, xmm7
	vmulss	xmm0, xmm4, DWORD PTR [rdi]
	vmulss	xmm5, xmm4, xmm11
	vmovss	DWORD PTR [rsp+32], xmm5
	call	?fnoise4D@Perlin@@SAMMMMMM@Z		; Perlin::fnoise4D

; 167  : 	auto samplesf = (float)wp.samples;

	mov	r12d, DWORD PTR [r15+8]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	lea	rcx, QWORD PTR $T10[rsp]
	vmulss	xmm3, xmm7, DWORD PTR [rsi+8]
	vmulss	xmm2, xmm7, DWORD PTR [rsi+4]
	vxorps	xmm1, xmm1, xmm1
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 167  : 	auto samplesf = (float)wp.samples;

	vcvtsi2ss xmm1, xmm1, r12d
	vmovss	DWORD PTR samplesf$1$[rbp-256], xmm1
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm1, xmm7, DWORD PTR [rsi]
	vxorps	xmm6, xmm6, xmm6
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 164  : 	float angNoise = Perlin::fnoise4D(p.x * wp.angleFreq, p.y * wp.angleFreq, p.z * wp.angleFreq * .5f,

	vmovss	DWORD PTR angNoise$1$[rbp-256], xmm0

; 168  : 	float total = 0.f;

	vmovss	DWORD PTR total$1$[rbp-256], xmm6
	vxorps	xmm11, xmm11, xmm11
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	vmulss	xmm3, xmm7, DWORD PTR [r14+8]
	vmulss	xmm2, xmm7, DWORD PTR [r14+4]
	vmulss	xmm1, xmm7, DWORD PTR [r14]
	lea	rcx, QWORD PTR $T6[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z

; 293  :    return(Point3(x-b.x,y-b.y,z-b.z));

	vmovss	xmm0, DWORD PTR [rdi+8]
	vmovss	xmm1, DWORD PTR [rdi+4]
	vsubss	xmm3, xmm0, DWORD PTR $T6[rsp+8]
	vmovss	xmm0, DWORD PTR [rdi]
	vsubss	xmm2, xmm1, DWORD PTR $T6[rsp+4]
	vsubss	xmm1, xmm0, DWORD PTR $T6[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	vmovss	xmm0, DWORD PTR $T2[rsp+8]
	vmovss	xmm1, DWORD PTR $T2[rsp+4]
	vsubss	xmm3, xmm0, DWORD PTR $T10[rsp+8]
	vmovss	xmm0, DWORD PTR $T2[rsp]
	vsubss	xmm2, xmm1, DWORD PTR $T10[rsp+4]
	vsubss	xmm1, xmm0, DWORD PTR $T10[rsp]
	lea	rcx, QWORD PTR fp$[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 170  : 	for (int i = 0; i < wp.samples; i++)

	xor	eax, eax
	mov	DWORD PTR i$1$[rbp-256], eax
	test	r12d, r12d
	jle	$LN3@wood

; 171  : 		for (int j = 0; j < wp.samples; j++)

	vmovss	xmm9, DWORD PTR __real@3f800000
	vmovss	xmm8, DWORD PTR __real@3d4ccccd
	mov	QWORD PTR [rsp+376], r13
	vmovaps	XMMWORD PTR [rsp+160], xmm13
	vmovaps	XMMWORD PTR [rsp+144], xmm14
	vmovaps	XMMWORD PTR [rsp+128], xmm15
	vmovss	xmm15, DWORD PTR __real@41700000
	npad	4
$LL4@wood:
	xor	ebx, ebx
	test	r12d, r12d
	jle	$LN2@wood

; 175  : 			// Distance	
; 176  : 			float dist = 0.f;
; 177  : 			switch (wp.woodType)

	vmovss	xmm2, DWORD PTR samplesf$1$[rbp-256]
	mov	r13d, DWORD PTR [r15]

; 192  : 			// We need FAST and continous random function here, 1D Simplex does fairly well
; 193  : 			// Angular noise
; 194  : 			float d = dist;
; 195  : 			if (d > wp.angleRad) d = wp.angleRad;

	vmovss	xmm14, DWORD PTR [r15+60]

; 200  : 			// Skew
; 201  : 			if (dist < wp.skew)

	vmovss	xmm10, DWORD PTR [r15+20]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vaddss	xmm1, xmm0, xmm7
	vdivss	xmm13, xmm1, xmm2
	npad	1
$LL7@wood:

; 174  : 			p = fp + dPdx * ((float(i) + .5f) / samplesf) + dPdy * ((float(j) + .5f) / samplesf);

	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, ebx
	vaddss	xmm1, xmm0, xmm7
	vdivss	xmm4, xmm1, xmm2
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm3, xmm4, DWORD PTR [rsi+8]
	vmulss	xmm2, xmm4, DWORD PTR [rsi+4]
	vmulss	xmm1, xmm4, DWORD PTR [rsi]
	lea	rcx, QWORD PTR $T5[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	vmulss	xmm3, xmm13, DWORD PTR [r14+8]
	vmulss	xmm2, xmm13, DWORD PTR [r14+4]
	vmulss	xmm1, xmm13, DWORD PTR [r14]
	lea	rcx, QWORD PTR $T9[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vmovss	xmm0, DWORD PTR $T9[rsp+8]
	vmovss	xmm1, DWORD PTR $T9[rsp+4]
	vaddss	xmm3, xmm0, DWORD PTR fp$[rsp+8]
	vmovss	xmm0, DWORD PTR $T9[rsp]
	vaddss	xmm2, xmm1, DWORD PTR fp$[rsp+4]
	vaddss	xmm1, xmm0, DWORD PTR fp$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	vmovss	xmm0, DWORD PTR $T5[rsp+8]
	vmovss	xmm1, DWORD PTR $T5[rsp+4]
	vaddss	xmm3, xmm0, DWORD PTR $T1[rsp+8]
	vmovss	xmm0, DWORD PTR $T5[rsp]
	vaddss	xmm2, xmm1, DWORD PTR $T1[rsp+4]
	vaddss	xmm1, xmm0, DWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T12[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 174  : 			p = fp + dPdx * ((float(i) + .5f) / samplesf) + dPdy * ((float(j) + .5f) / samplesf);

	mov	eax, DWORD PTR $T12[rsp+8]

; 175  : 			// Distance	
; 176  : 			float dist = 0.f;
; 177  : 			switch (wp.woodType)

	mov	ecx, r13d
	vmovsd	xmm0, QWORD PTR $T12[rsp]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	DWORD PTR [rdi+8], eax
	vmovaps	xmm6, xmm11
	test	r13d, r13d
	je	$LN10@wood
	sub	ecx, 1
	je	SHORT $LN11@wood
	sub	ecx, 1
	je	SHORT $LN12@wood
	cmp	ecx, 1
	jne	$LN8@wood

; 187  : 			case 3: dist = p.x < 0.f ? -p.x : p.x;

	vmovss	xmm6, DWORD PTR [rdi]
	vcomiss	xmm11, xmm6
	jbe	$LN8@wood
	vxorps	xmm6, xmm6, DWORD PTR __xmm@80000000800000008000000080000000
	jmp	$LN8@wood
$LN12@wood:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 271  :    x *= f;   y *= f; z *= f;

	vmulss	xmm0, xmm8, DWORD PTR [rdi]
	vmulss	xmm1, xmm8, DWORD PTR [rdi+4]
	vmulss	xmm2, xmm8, DWORD PTR [rdi+8]
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 185  : 				dist = (Perlin::snoise(p.x, p.y, p.z, wp.randSeed + 3.15f) + 1.f) / .5f * 15.f;

	vaddss	xmm3, xmm12, DWORD PTR __real@4049999a
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 271  :    x *= f;   y *= f; z *= f;

	vmovss	DWORD PTR [rdi], xmm0
	vmovss	DWORD PTR [rdi+4], xmm1
	vmovss	DWORD PTR [rdi+8], xmm2
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 185  : 				dist = (Perlin::snoise(p.x, p.y, p.z, wp.randSeed + 3.15f) + 1.f) / .5f * 15.f;

	call	?snoise@Perlin@@SAMMMMM@Z		; Perlin::snoise
	vaddss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vmulss	xmm6, xmm2, xmm15

; 186  : 				break;

	jmp	SHORT $LN8@wood
$LN11@wood:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 271  :    x *= f;   y *= f; z *= f;

	vmulss	xmm0, xmm8, DWORD PTR [rdi]
	vmulss	xmm1, xmm8, DWORD PTR [rdi+4]
	vmulss	xmm2, xmm8, DWORD PTR [rdi+8]
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 182  : 				dist = (Perlin::noise(p.x, p.y, p.z, wp.randSeed - 7.1f) + 1.f) / .5f * 15.f;

	vsubss	xmm3, xmm12, DWORD PTR __real@40e33333
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 271  :    x *= f;   y *= f; z *= f;

	vmovss	DWORD PTR [rdi], xmm0
	vmovss	DWORD PTR [rdi+4], xmm1
	vmovss	DWORD PTR [rdi+8], xmm2
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 182  : 				dist = (Perlin::noise(p.x, p.y, p.z, wp.randSeed - 7.1f) + 1.f) / .5f * 15.f;

	call	?noise@Perlin@@SAMMMMM@Z		; Perlin::noise
	vaddss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vmulss	xmm6, xmm2, xmm15

; 183  : 				break;

	jmp	SHORT $LN8@wood
$LN10@wood:

; 178  : 			{
; 179  : 			case 0: dist = sqrt(p.x * p.x + p.y * p.y);

	vmovss	xmm1, DWORD PTR [rdi+4]
	vmovss	xmm0, DWORD PTR [rdi]
	vmulss	xmm2, xmm0, xmm0
	vmulss	xmm1, xmm1, xmm1
	vaddss	xmm0, xmm2, xmm1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 295  : 	return (_CSTD sqrtf(_Xx));

	call	sqrtf
	vmovaps	xmm6, xmm0
$LN8@wood:
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 191  : 			dist += Perlin::snoise(dist + wp.randSeed * 2.f) * wp.widthVar;

	vaddss	xmm0, xmm12, xmm12
	vaddss	xmm0, xmm0, xmm6
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise
	vmulss	xmm1, xmm0, DWORD PTR [r15+24]
	vaddss	xmm6, xmm6, xmm1

; 192  : 			// We need FAST and continous random function here, 1D Simplex does fairly well
; 193  : 			// Angular noise
; 194  : 			float d = dist;
; 195  : 			if (d > wp.angleRad) d = wp.angleRad;

	vminss	xmm2, xmm14, xmm6

; 196  : 			dist += smooth(d / wp.angleRad) * angNoise * wp.angleStr;

	vdivss	xmm0, xmm2, xmm14
	call	?smooth@@YAMM@Z				; smooth
	vmulss	xmm1, xmm0, DWORD PTR angNoise$1$[rbp-256]
	vmulss	xmm2, xmm1, DWORD PTR [r15+52]
	vaddss	xmm3, xmm6, xmm2

; 197  : 			// Mod
; 198  : 			auto ipart = float(int(dist));

	vcvttss2si eax, xmm3
	vxorps	xmm11, xmm11, xmm11
	vcvtsi2ss xmm11, xmm11, eax

; 199  : 			dist -= ipart;

	vsubss	xmm2, xmm3, xmm11

; 200  : 			// Skew
; 201  : 			if (dist < wp.skew)

	vcomiss	xmm10, xmm2
	jbe	SHORT $LN15@wood

; 202  : 				dist *= .5f / wp.skew;

	vdivss	xmm0, xmm7, xmm10
	vmulss	xmm1, xmm2, xmm0

; 203  : 			else

	jmp	SHORT $LN16@wood
$LN15@wood:

; 204  : 				dist = dist * .5f / (1.f - wp.skew) - wp.skew * (.5f / (1.f - wp.skew)) + .5f;

	vmulss	xmm0, xmm2, xmm7
	vsubss	xmm1, xmm9, xmm10
	vdivss	xmm2, xmm0, xmm1
	vdivss	xmm1, xmm7, xmm1
	vmulss	xmm0, xmm1, xmm10
	vsubss	xmm2, xmm2, xmm0
	vaddss	xmm1, xmm2, xmm7
$LN16@wood:

; 205  : 			// Reverse
; 206  : 			dist *= 2.f;

	vaddss	xmm0, xmm1, xmm1

; 207  : 			if (dist > 1.f)

	vcomiss	xmm0, xmm9
	jbe	SHORT $LN17@wood

; 208  : 				dist = 2.f - dist;

	vmovss	xmm1, DWORD PTR __real@40000000
	vsubss	xmm0, xmm1, xmm0
$LN17@wood:

; 209  : 			// Smooth and scale
; 210  : 			dist = smooth(dist, wp.lowTresh, wp.highTresh);

	vmovss	xmm2, DWORD PTR [r15+16]
	vmovss	xmm1, DWORD PTR [r15+12]
	call	?smooth@@YAMMMM@Z			; smooth

; 211  : 			// Gain variation				
; 212  : 			float const gain = (Perlin::snoise((ipart + wp.randSeed) * 314.134f) + 1.f) * .5f;

	vaddss	xmm1, xmm12, xmm11
	vmovaps	xmm6, xmm0
	vmulss	xmm0, xmm1, DWORD PTR __real@439d1127
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise
	vaddss	xmm1, xmm0, xmm9

; 213  : 			// Again we need FAST random function, in this case it doesn't have to be continous		
; 214  : 			dist *= (1.f - wp.gainVar) + gain * wp.gainVar;

	vsubss	xmm0, xmm9, DWORD PTR [r15+28]
	vmulss	xmm2, xmm1, xmm7
	vmulss	xmm3, xmm2, DWORD PTR [r15+28]
	vmovss	xmm2, DWORD PTR samplesf$1$[rbp-256]
	vaddss	xmm4, xmm3, xmm0
	vmulss	xmm0, xmm4, xmm6

; 215  : 			// Add to total value
; 216  : 			total += dist;

	vaddss	xmm6, xmm0, DWORD PTR total$1$[rbp-256]
	inc	ebx
	vmovss	DWORD PTR total$1$[rbp-256], xmm6
	vxorps	xmm11, xmm11, xmm11
	cmp	ebx, r12d
	jl	$LL7@wood
	mov	eax, DWORD PTR i$1$[rbp-256]
$LN2@wood:

; 170  : 	for (int i = 0; i < wp.samples; i++)

	inc	eax
	mov	DWORD PTR i$1$[rbp-256], eax
	cmp	eax, r12d
	jl	$LL4@wood
	vmovaps	xmm15, XMMWORD PTR [rsp+128]
	vmovaps	xmm14, XMMWORD PTR [rsp+144]
	vmovaps	xmm13, XMMWORD PTR [rsp+160]
	mov	r13, QWORD PTR [rsp+376]
$LN3@wood:

; 217  : 		}
; 218  : 	// Return final value, just need to divide sum with number of samples taken
; 219  : 	return total / (float)(wp.samples * wp.samples);
; 220  : }

	lea	r11, QWORD PTR [rsp+288]
	imul	r12d, r12d
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm9, XMMWORD PTR [r11-64]
	vmovaps	xmm10, XMMWORD PTR [r11-80]
	vmovaps	xmm11, XMMWORD PTR [r11-96]
	vmovaps	xmm12, XMMWORD PTR [r11-112]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, r12d
	vdivss	xmm0, xmm6, xmm0
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?wood@Noise@@SAMVPoint3@@00AEAV2@VWoodParam@@@Z ENDP	; Noise::wood
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\noise.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
; File g:\dropbox\github\berconmaps\src\noise.cpp
;	COMDAT ?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 44
$T4 = 44
$T5 = 56
$T6 = 56
p$ = 176
g$ = 184
wp$ = 192
?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z PROC	; Noise::wood, COMDAT

; 90   : float Noise::wood(Point3 p, Point3 &g, WoodParam &wp) {

$LN39:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 160				; 000000a0H

; 91   : 	// Radial noise
; 92   : 	p.x += Perlin::snoise(p.x*wp.radialFreq, p.y*wp.radialFreq, p.z*wp.radialZ, wp.randSeed-1.125f) * wp.radialStr;

	vmovss	xmm0, DWORD PTR [r8+4]
	vmovss	xmm4, DWORD PTR [r8+44]
	vmulss	xmm1, xmm4, DWORD PTR [rcx+4]
	vmovaps	XMMWORD PTR [rax-24], xmm6
	mov	rsi, r8
	vmovss	xmm6, DWORD PTR __real@3f900000
	vmovaps	XMMWORD PTR [rax-40], xmm7
	mov	rbx, rdx
	vsubss	xmm3, xmm0, xmm6
	vmovss	xmm0, DWORD PTR [rcx+8]
	vmulss	xmm2, xmm0, DWORD PTR [r8+48]
	vmulss	xmm0, xmm4, DWORD PTR [rcx]
	vmovaps	XMMWORD PTR [rax-56], xmm8
	mov	rdi, rcx
	vmovaps	XMMWORD PTR [rax-72], xmm9
	vmovaps	XMMWORD PTR [rax-88], xmm10
	call	?snoise@Perlin@@SAMMMMM@Z		; Perlin::snoise
	vmulss	xmm1, xmm0, DWORD PTR [rsi+40]
	vaddss	xmm5, xmm1, DWORD PTR [rdi]

; 93   : 	p.y += Perlin::snoise(p.x*wp.radialFreq, p.y*wp.radialFreq, p.z*wp.radialZ, wp.randSeed+1.125f) * wp.radialStr;

	vmovss	xmm1, DWORD PTR [rdi+8]
	vmovss	DWORD PTR [rdi], xmm5
	vmovss	xmm4, DWORD PTR [rsi+44]
	vmulss	xmm2, xmm1, DWORD PTR [rsi+48]
	vmulss	xmm1, xmm4, DWORD PTR [rdi+4]
	vaddss	xmm3, xmm6, DWORD PTR [rsi+4]
	vmulss	xmm0, xmm4, xmm5
	call	?snoise@Perlin@@SAMMMMM@Z		; Perlin::snoise
	vmulss	xmm1, xmm0, DWORD PTR [rsi+40]
	vaddss	xmm2, xmm1, DWORD PTR [rdi+4]

; 94   : 	g = p; // Store radial component for gain

	vmovsd	xmm0, QWORD PTR [rdi]
	vinsertps xmm0, xmm0, xmm2, 16
	vmovsd	QWORD PTR [rdi], xmm0
	vmovsd	QWORD PTR [rbx], xmm0
	mov	eax, DWORD PTR [rdi+8]
	mov	DWORD PTR [rbx+8], eax

; 95   : 	// Trunk wobble		
; 96   : 	float angle = Perlin::snoise(p.z*wp.trunkFreq, wp.randSeed+3.f) * float(pi); // Offset so we dont get the same value as below

	vmovss	xmm0, DWORD PTR [rsi+4]
	vmovss	xmm2, DWORD PTR [rdi+8]
	vaddss	xmm1, xmm0, DWORD PTR __real@40400000
	vmulss	xmm0, xmm2, DWORD PTR [rsi+36]
	call	?snoise@Perlin@@SAMMM@Z			; Perlin::snoise

; 97   : 	p += Point3(cos(angle), sin(angle), 0.f) * Perlin::snoise(p.z*wp.trunkFreq, wp.randSeed-5.5f) * wp.trunkStr;		

	vmovss	xmm1, DWORD PTR [rsi+4]
	vmovss	xmm2, DWORD PTR [rdi+8]
	vmulss	xmm7, xmm0, DWORD PTR __real@40490fdb
	vsubss	xmm1, xmm1, DWORD PTR __real@40b00000
	vmulss	xmm0, xmm2, DWORD PTR [rsi+36]
	call	?snoise@Perlin@@SAMMM@Z			; Perlin::snoise
	vmovaps	xmm8, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 285  : 	return (_CSTD sinf(_Xx));

	vmovaps	xmm0, xmm7
	call	sinf
	vmovaps	xmm6, xmm0

; 78   : 	return (_CSTD cosf(_Xx));

	vmovaps	xmm0, xmm7
	call	cosf
	vmovaps	xmm1, xmm0
	vxorps	xmm3, xmm3, xmm3
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 97   : 	p += Point3(cos(angle), sin(angle), 0.f) * Perlin::snoise(p.z*wp.trunkFreq, wp.randSeed-5.5f) * wp.trunkStr;		

	vmovaps	xmm2, xmm6
	lea	rcx, QWORD PTR $T6[rsp]
	vxorps	xmm7, xmm7, xmm7
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	lea	rcx, QWORD PTR $T2[rsp]
	vmulss	xmm3, xmm8, DWORD PTR [rax+8]
	vmulss	xmm2, xmm8, DWORD PTR [rax+4]
	vmulss	xmm1, xmm8, DWORD PTR [rax]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 97   : 	p += Point3(cos(angle), sin(angle), 0.f) * Perlin::snoise(p.z*wp.trunkFreq, wp.randSeed-5.5f) * wp.trunkStr;		

	vmovss	xmm4, DWORD PTR [rsi+32]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm3, xmm4, DWORD PTR $T2[rsp+8]
	vmulss	xmm2, xmm4, DWORD PTR $T2[rsp+4]
	vmulss	xmm1, xmm4, DWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vmovss	xmm0, DWORD PTR $T4[rsp]
	vaddss	xmm4, xmm0, DWORD PTR [rdi]
	vmovss	xmm1, DWORD PTR $T4[rsp+4]
	vaddss	xmm2, xmm1, DWORD PTR [rdi+4]

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmovss	xmm9, DWORD PTR __real@3f000000

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vmovss	xmm0, DWORD PTR $T4[rsp+8]
	vaddss	xmm1, xmm0, DWORD PTR [rdi+8]
	vmovss	DWORD PTR [rdi+4], xmm2
	vmovss	DWORD PTR [rdi+8], xmm1

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm3, xmm1, xmm9

; 266  :    x += a.x;   y += a.y;   z += a.z;

	vmovss	DWORD PTR [rdi], xmm4

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm2, xmm2, xmm9
	vmulss	xmm1, xmm4, xmm9
	lea	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	vmulss	xmm3, xmm9, DWORD PTR [rbx+8]
	vmulss	xmm2, xmm9, DWORD PTR [rbx+4]
	vmulss	xmm1, xmm9, DWORD PTR [rbx]
	lea	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vmovss	xmm0, DWORD PTR $T3[rsp+8]
	vmovss	xmm1, DWORD PTR $T3[rsp+4]
	vaddss	xmm3, xmm0, DWORD PTR $T1[rsp+8]
	vmovss	xmm0, DWORD PTR $T3[rsp]
	vaddss	xmm2, xmm1, DWORD PTR $T1[rsp+4]
	vaddss	xmm1, xmm0, DWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 98   : 	g = .5f*g + .5f*p; // We don't want trunk wobble to affect too much to grain

	vmovsd	xmm0, QWORD PTR $T5[rsp]
	mov	eax, DWORD PTR $T5[rsp+8]

; 99   : 	// Distance
; 100  : 	float dist = 0.f;
; 101  : 	switch (wp.woodType) {

	vmovss	xmm10, DWORD PTR __real@3f800000
	vmovsd	QWORD PTR [rbx], xmm0
	mov	DWORD PTR [rbx+8], eax
	mov	ecx, DWORD PTR [rsi]
	test	ecx, ecx
	je	$LN4@wood
	sub	ecx, 1
	je	SHORT $LN5@wood
	sub	ecx, 1
	je	SHORT $LN6@wood
	cmp	ecx, 1
	jne	$LN2@wood

; 105  : 		case 3: dist = p.x<0.f?-p.x:p.x; break;

	vmovss	xmm0, DWORD PTR [rdi]
	vcomiss	xmm7, xmm0
	jbe	$LN13@wood
	vxorps	xmm7, xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	jmp	$LN2@wood
$LN6@wood:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 271  :    x *= f;   y *= f; z *= f;

	vmovss	xmm3, DWORD PTR __real@3d4ccccd
	vmulss	xmm0, xmm3, DWORD PTR [rdi]
	vmulss	xmm1, xmm3, DWORD PTR [rdi+4]
	vmulss	xmm2, xmm3, DWORD PTR [rdi+8]
	vmovss	DWORD PTR [rdi], xmm0
	vmovss	DWORD PTR [rdi+4], xmm1
	vmovss	DWORD PTR [rdi+8], xmm2
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 104  : 		case 2: p*=.05f; dist = (Perlin::snoise(p.x, p.y, p.z, wp.randSeed+3.15f)+1.f) / .5f * 15.f; break;

	vmovss	xmm3, DWORD PTR [rsi+4]
	vaddss	xmm3, xmm3, DWORD PTR __real@4049999a
	call	?snoise@Perlin@@SAMMMMM@Z		; Perlin::snoise
	jmp	SHORT $LN37@wood
$LN5@wood:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 271  :    x *= f;   y *= f; z *= f;

	vmovss	xmm3, DWORD PTR __real@3d4ccccd
	vmulss	xmm0, xmm3, DWORD PTR [rdi]
	vmulss	xmm1, xmm3, DWORD PTR [rdi+4]
	vmulss	xmm2, xmm3, DWORD PTR [rdi+8]
	vmovss	DWORD PTR [rdi], xmm0
	vmovss	DWORD PTR [rdi+4], xmm1
	vmovss	DWORD PTR [rdi+8], xmm2
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 103  : 		case 1: p*=.05f; dist = (Perlin::noise(p.x, p.y, p.z, wp.randSeed-7.1f)+1.f) / .5f * 15.f; break;

	vmovss	xmm3, DWORD PTR [rsi+4]
	vsubss	xmm3, xmm3, DWORD PTR __real@40e33333
	call	?noise@Perlin@@SAMMMMM@Z		; Perlin::noise
$LN37@wood:

; 108  : 	dist += Perlin::snoise(dist+wp.randSeed*2.f) * wp.widthVar;

	vaddss	xmm1, xmm0, xmm10
	vaddss	xmm2, xmm1, xmm1
	vmulss	xmm7, xmm2, DWORD PTR __real@41700000
	jmp	SHORT $LN2@wood
$LN4@wood:

; 102  : 		case 0: dist = sqrt(p.x*p.x+p.y*p.y); break;

	vmovss	xmm1, DWORD PTR [rdi+4]
	vmovss	xmm0, DWORD PTR [rdi]
	vmulss	xmm2, xmm0, xmm0
	vmulss	xmm1, xmm1, xmm1
	vaddss	xmm0, xmm2, xmm1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath

; 295  : 	return (_CSTD sqrtf(_Xx));

	call	sqrtf
$LN13@wood:
; File g:\dropbox\github\berconmaps\src\noise.cpp

; 108  : 	dist += Perlin::snoise(dist+wp.randSeed*2.f) * wp.widthVar;

	vmovaps	xmm7, xmm0
$LN2@wood:
	vmovss	xmm1, DWORD PTR [rsi+4]
	vaddss	xmm2, xmm1, xmm1
	vaddss	xmm0, xmm2, xmm7
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise
	vmulss	xmm1, xmm0, DWORD PTR [rsi+24]

; 109  : 	// Angular noise
; 110  : 	float d = dist;
; 111  : 	if (d > wp.angleRad) d = wp.angleRad;	
; 112  : 	dist += smooth(d/wp.angleRad) * Perlin::noise(p.x*wp.angleFreq, p.y*wp.angleFreq, p.z*wp.angleFreq*.5f, wp.randSeed+10.6f) * wp.angleStr;

	vmovss	xmm4, DWORD PTR [rsi+56]
	vmovss	xmm0, DWORD PTR [rsi+60]
	vaddss	xmm8, xmm7, xmm1
	vmovss	xmm1, DWORD PTR [rsi+4]
	vaddss	xmm3, xmm1, DWORD PTR __real@4129999a
	vmulss	xmm1, xmm4, DWORD PTR [rdi+4]
	vminss	xmm7, xmm0, xmm8
	vmulss	xmm0, xmm4, DWORD PTR [rdi+8]
	vmulss	xmm2, xmm0, xmm9
	vmulss	xmm0, xmm4, DWORD PTR [rdi]
	call	?noise@Perlin@@SAMMMMM@Z		; Perlin::noise
	vmovaps	xmm6, xmm0
	vdivss	xmm0, xmm7, DWORD PTR [rsi+60]
	call	?smooth@@YAMM@Z				; smooth

; 113  : 	// Mod
; 114  : 	auto ipart = (float)(int)dist;		
; 115  : 	dist -= ipart;
; 116  : 	// Skew
; 117  : 	if (dist < wp.skew)

	vmovss	xmm3, DWORD PTR [rsi+20]
	vmulss	xmm1, xmm6, xmm0
	vmulss	xmm1, xmm1, DWORD PTR [rsi+52]
	vaddss	xmm0, xmm8, xmm1
	vcvttss2si eax, xmm0
	vxorps	xmm7, xmm7, xmm7
	vcvtsi2ss xmm7, xmm7, eax
	vsubss	xmm2, xmm0, xmm7
	vcomiss	xmm3, xmm2
	jbe	SHORT $LN9@wood

; 118  : 		dist *= .5f / wp.skew;

	vdivss	xmm0, xmm9, xmm3
	vmulss	xmm1, xmm2, xmm0

; 119  : 	else

	jmp	SHORT $LN10@wood
$LN9@wood:

; 120  : 		dist = dist * .5f / (1.f-wp.skew) - wp.skew * (.5f/(1.f-wp.skew)) + .5f;	

	vmulss	xmm0, xmm2, xmm9
	vsubss	xmm1, xmm10, xmm3
	vdivss	xmm2, xmm0, xmm1
	vdivss	xmm1, xmm9, xmm1
	vmulss	xmm0, xmm1, xmm3
	vsubss	xmm2, xmm2, xmm0
	vaddss	xmm1, xmm2, xmm9
$LN10@wood:

; 121  : 	// Reverse
; 122  : 	dist *= 2.f;

	vaddss	xmm0, xmm1, xmm1

; 123  : 	if (dist > 1.f)

	vcomiss	xmm0, xmm10
	jbe	SHORT $LN11@wood

; 124  : 		dist = 2.f-dist;

	vmovss	xmm1, DWORD PTR __real@40000000
	vsubss	xmm0, xmm1, xmm0
$LN11@wood:

; 125  : 	// Smooth and scale
; 126  : 	dist = smooth(dist, wp.lowTresh, wp.highTresh);	

	vmovss	xmm2, DWORD PTR [rsi+16]
	vmovss	xmm1, DWORD PTR [rsi+12]
	call	?smooth@@YAMMMM@Z			; smooth

; 127  : 	// Gain variation		
; 128  : 	float gain = (Perlin::snoise((ipart + wp.randSeed) * 314.134f) + 1.f) * .5f;

	vaddss	xmm1, xmm7, DWORD PTR [rsi+4]
	vmovaps	xmm6, xmm0
	vmulss	xmm0, xmm1, DWORD PTR __real@439d1127
	call	?snoise@Perlin@@SAMM@Z			; Perlin::snoise

; 129  : 	dist *= (1.f-wp.gainVar) + gain * wp.gainVar;
; 130  : 	// Return	
; 131  : 	return dist;
; 132  : }

	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+16]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vaddss	xmm1, xmm0, xmm10
	vmulss	xmm2, xmm1, xmm9
	vsubss	xmm1, xmm10, DWORD PTR [rsi+28]
	vmulss	xmm4, xmm2, DWORD PTR [rsi+28]
	mov	rsi, QWORD PTR [r11+24]
	vmovaps	xmm9, XMMWORD PTR [r11-64]
	vmovaps	xmm10, XMMWORD PTR [r11-80]
	vaddss	xmm2, xmm4, xmm1
	vmulss	xmm0, xmm2, xmm6
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	mov	rsp, r11
	pop	rdi
	ret	0
?wood@Noise@@SAMVPoint3@@AEAV2@AEAVWoodParam@@@Z ENDP	; Noise::wood
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\noise.cpp
;	COMDAT ?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z
_TEXT	SEGMENT
p3$ = 32
f$ = 56
p$ = 112
np$ = 120
?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z PROC ; Noise::worleyWrapper, COMDAT

; 64   : float Noise::worleyWrapper(Point3 p, NoiseParams& np) {	

$LN19:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 96					; 00000060H
	vmovss	xmm0, DWORD PTR [rcx]
	vmovss	xmm1, DWORD PTR [rcx+4]

; 65   : 	float val;
; 66   : 	double p3[3] = {double(p.x), double(p.y), double(p.z)};
; 67   : 	double f[4];
; 68   : 	int order = 1;
; 69   : 	// Calc order
; 70   : 	if (np.F4 > 0.0001f || np.F4 < -0.0001f)

	vmovss	xmm2, DWORD PTR [rdx+32]
	vcvtss2sd xmm0, xmm0, xmm0
	vcvtss2sd xmm1, xmm1, xmm1
	vmovsd	QWORD PTR p3$[rsp], xmm0
	vmovss	xmm0, DWORD PTR [rcx+8]
	vmovsd	QWORD PTR p3$[rsp+8], xmm1
	vmovss	xmm1, DWORD PTR __real@38d1b717
	vcomiss	xmm2, xmm1
	vcvtss2sd xmm0, xmm0, xmm0
	vmovsd	QWORD PTR p3$[rsp+16], xmm0
	mov	rdi, rdx
	mov	ebx, 1
	ja	SHORT $LN6@worleyWrap
	vmovss	xmm0, DWORD PTR __real@b8d1b717
	vcomiss	xmm0, xmm2
	ja	SHORT $LN6@worleyWrap

; 72   : 	else if (np.F3 > 0.0001f || np.F3 < -0.0001f)

	vmovss	xmm2, DWORD PTR [rdx+28]
	vcomiss	xmm2, xmm1
	ja	SHORT $LN9@worleyWrap
	vcomiss	xmm0, xmm2
	ja	SHORT $LN9@worleyWrap

; 74   : 	else if (np.F2 > 0.0001f || np.F2 < -0.0001f)

	vmovss	xmm2, DWORD PTR [rdx+24]
	vcomiss	xmm2, xmm1
	ja	SHORT $LN11@worleyWrap
	vcomiss	xmm0, xmm2
	jbe	SHORT $LN10@worleyWrap
$LN11@worleyWrap:

; 75   : 		order = 2;

	mov	ebx, 2
	jmp	SHORT $LN10@worleyWrap
$LN9@worleyWrap:

; 73   : 		order = 3;

	mov	ebx, 3
	jmp	SHORT $LN10@worleyWrap
$LN6@worleyWrap:

; 71   : 		order = 4;

	mov	ebx, 4
$LN10@worleyWrap:

; 76   : 	// Worley
; 77   : 	Worley::noise(p3, order, f, np.worleyFunction);	

	mov	r9d, DWORD PTR [rdx+8]
	lea	r8, QWORD PTR f$[rsp]
	mov	edx, ebx
	lea	rcx, QWORD PTR p3$[rsp]
	call	?noise@Worley@@SAXQEBNHPEANH@Z		; Worley::noise

; 78   : 	// Return value
; 79   : 	switch (order) {

	sub	ebx, 1
	je	$LN12@worleyWrap
	sub	ebx, 1
	je	$LN13@worleyWrap
	sub	ebx, 1
	je	SHORT $LN14@worleyWrap
	cmp	ebx, 1
	je	SHORT $LN15@worleyWrap

; 84   : 		default: val = 0.0f;

	vxorps	xmm0, xmm0, xmm0
	jmp	$LN2@worleyWrap
$LN15@worleyWrap:
	vmovsd	xmm0, QWORD PTR f$[rsp]
	vmovsd	xmm1, QWORD PTR f$[rsp+8]

; 83   : 		case 4: val = float(f[0])*np.F1 + float(f[1])*np.F2 + float(f[2])*np.F3 + float(f[3])*np.F4; break;

	vcvtpd2ps xmm0, xmm0
	vmulss	xmm2, xmm0, DWORD PTR [rdi+20]
	vcvtpd2ps xmm1, xmm1
	vmulss	xmm0, xmm1, DWORD PTR [rdi+24]
	vmovsd	xmm1, QWORD PTR f$[rsp+24]
	vaddss	xmm3, xmm2, xmm0
	vmovsd	xmm2, QWORD PTR f$[rsp+16]
	vcvtpd2ps xmm2, xmm2
	vmulss	xmm0, xmm2, DWORD PTR [rdi+28]
	vcvtpd2ps xmm1, xmm1
	vmulss	xmm2, xmm1, DWORD PTR [rdi+32]
	vaddss	xmm3, xmm3, xmm0
	vaddss	xmm0, xmm3, xmm2
	jmp	SHORT $LN2@worleyWrap
$LN14@worleyWrap:
	vmovsd	xmm0, QWORD PTR f$[rsp]
	vmovsd	xmm1, QWORD PTR f$[rsp+8]

; 82   : 		case 3: val = float(f[0])*np.F1 + float(f[1])*np.F2 + float(f[2])*np.F3; break;

	vcvtpd2ps xmm0, xmm0
	vmulss	xmm2, xmm0, DWORD PTR [rdi+20]
	vcvtpd2ps xmm1, xmm1
	vmulss	xmm0, xmm1, DWORD PTR [rdi+24]
	vaddss	xmm3, xmm2, xmm0
	vmovsd	xmm2, QWORD PTR f$[rsp+16]
	vcvtpd2ps xmm2, xmm2
	vmulss	xmm0, xmm2, DWORD PTR [rdi+28]
	vaddss	xmm0, xmm3, xmm0
	jmp	SHORT $LN2@worleyWrap
$LN13@worleyWrap:
	vmovsd	xmm0, QWORD PTR f$[rsp]
	vmovsd	xmm1, QWORD PTR f$[rsp+8]

; 81   : 		case 2: val = float(f[0])*np.F1 + (float)f[1]*np.F2; break;

	vcvtpd2ps xmm0, xmm0
	vmulss	xmm2, xmm0, DWORD PTR [rdi+20]
	vcvtpd2ps xmm1, xmm1
	vmulss	xmm0, xmm1, DWORD PTR [rdi+24]
	vaddss	xmm0, xmm2, xmm0
	jmp	SHORT $LN2@worleyWrap
$LN12@worleyWrap:
	vmovsd	xmm0, QWORD PTR f$[rsp]

; 80   : 		case 1: val = float(f[0])*np.F1; break;

	vcvtpd2ps xmm0, xmm0
	vmulss	xmm0, xmm0, DWORD PTR [rdi+20]
$LN2@worleyWrap:

; 85   : 	}
; 86   : 	val = val/np.spread*2.f-1.f;

	vdivss	xmm0, xmm0, DWORD PTR [rdi+16]

; 87   : 	return val;
; 88   : }

	mov	rbx, QWORD PTR [rsp+112]
	vaddss	xmm1, xmm0, xmm0
	vsubss	xmm0, xmm1, DWORD PTR __real@3f800000
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ENDP ; Noise::worleyWrapper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\noise.cpp
;	COMDAT ?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z
_TEXT	SEGMENT
$T1 = 48
p$ = 80
d$ = 88
np$ = 96
?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z PROC	; Noise::noise, COMDAT

; 51   : float Noise::noise(Point3 p, float d, NoiseParams& np) {

$LN15:
	push	rbx
	sub	rsp, 64					; 00000040H

; 52   : 	switch (np.noiseFunction) {

	movsxd	rax, DWORD PTR [r8]
	mov	rbx, r8
	cmp	eax, 6
	ja	$LN11@noise
	lea	r8, OFFSET FLAT:__ImageBase
	mov	edx, DWORD PTR $LN13@noise[r8+rax*4]
	add	rdx, r8
	jmp	rdx
$LN4@noise:

; 53   : 		case 0: return Perlin::fnoise2D(p.x, p.y, d);

	vmovss	xmm0, DWORD PTR [rcx]
	vmovaps	xmm2, xmm1
	vmovss	xmm1, DWORD PTR [rcx+4]

; 60   : 		default: return 0.0f;
; 61   : 	}
; 62   : }

	add	rsp, 64					; 00000040H
	pop	rbx

; 53   : 		case 0: return Perlin::fnoise2D(p.x, p.y, d);

	jmp	?fnoise2D@Perlin@@SAMMMM@Z		; Perlin::fnoise2D
$LN5@noise:

; 54   : 		case 1: return Perlin::fnoise3D(p.x, p.y, p.z, d);

	vmovss	xmm2, DWORD PTR [rcx+8]
	vmovss	xmm0, DWORD PTR [rcx]
	vmovaps	xmm3, xmm1
	vmovss	xmm1, DWORD PTR [rcx+4]

; 60   : 		default: return 0.0f;
; 61   : 	}
; 62   : }

	add	rsp, 64					; 00000040H
	pop	rbx

; 54   : 		case 1: return Perlin::fnoise3D(p.x, p.y, p.z, d);

	jmp	?fnoise3D@Perlin@@SAMMMMM@Z		; Perlin::fnoise3D
$LN6@noise:

; 55   : 		case 2: return Perlin::fnoise4D(p.x, p.y, p.z, np.phase, d);		

	vmovss	xmm3, DWORD PTR [rbx+12]
	vmovss	xmm2, DWORD PTR [rcx+8]
	vmovss	xmm0, DWORD PTR [rcx]
	vmovss	DWORD PTR [rsp+32], xmm1
	vmovss	xmm1, DWORD PTR [rcx+4]
	call	?fnoise4D@Perlin@@SAMMMMMM@Z		; Perlin::fnoise4D

; 60   : 		default: return 0.0f;
; 61   : 	}
; 62   : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN7@noise:

; 56   : 		case 3: return Perlin::fsnoise2D(p.x, p.y, d);

	vmovss	xmm0, DWORD PTR [rcx]
	vmovaps	xmm2, xmm1
	vmovss	xmm1, DWORD PTR [rcx+4]

; 60   : 		default: return 0.0f;
; 61   : 	}
; 62   : }

	add	rsp, 64					; 00000040H
	pop	rbx

; 56   : 		case 3: return Perlin::fsnoise2D(p.x, p.y, d);

	jmp	?fsnoise2D@Perlin@@SAMMMM@Z		; Perlin::fsnoise2D
$LN8@noise:

; 57   : 		case 4: return Perlin::fsnoise3D(p.x, p.y, p.z, d);

	vmovss	xmm2, DWORD PTR [rcx+8]
	vmovss	xmm0, DWORD PTR [rcx]
	vmovaps	xmm3, xmm1
	vmovss	xmm1, DWORD PTR [rcx+4]

; 60   : 		default: return 0.0f;
; 61   : 	}
; 62   : }

	add	rsp, 64					; 00000040H
	pop	rbx

; 57   : 		case 4: return Perlin::fsnoise3D(p.x, p.y, p.z, d);

	jmp	?fsnoise3D@Perlin@@SAMMMMM@Z		; Perlin::fsnoise3D
$LN9@noise:

; 58   : 		case 5: return Perlin::fsnoise4D(p.x, p.y, p.z, np.phase, d);		

	vmovss	xmm3, DWORD PTR [rbx+12]
	vmovss	xmm2, DWORD PTR [rcx+8]
	vmovss	xmm0, DWORD PTR [rcx]
	vmovss	DWORD PTR [rsp+32], xmm1
	vmovss	xmm1, DWORD PTR [rcx+4]
	call	?fsnoise4D@Perlin@@SAMMMMMM@Z		; Perlin::fsnoise4D

; 60   : 		default: return 0.0f;
; 61   : 	}
; 62   : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN10@noise:

; 59   : 		case 6: return worleyWrapper(p, np);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Noise::worleyWrapper

; 60   : 		default: return 0.0f;
; 61   : 	}
; 62   : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN11@noise:
	vxorps	xmm0, xmm0, xmm0
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN13@noise:
	DD	$LN4@noise
	DD	$LN5@noise
	DD	$LN6@noise
	DD	$LN7@noise
	DD	$LN8@noise
	DD	$LN9@noise
	DD	$LN10@noise
?noise@Noise@@SAMVPoint3@@MAEAVNoiseParams@@@Z ENDP	; Noise::noise
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\noise.cpp
;	COMDAT ?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z
_TEXT	SEGMENT
$T1 = 32
p$ = 64
np$ = 72
?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z PROC	; Noise::noise, COMDAT

; 38   : float Noise::noise(Point3 p, NoiseParams& np) {

$LN15:
	push	rbx
	sub	rsp, 48					; 00000030H

; 39   : 	switch (np.noiseFunction) {

	movsxd	rax, DWORD PTR [rdx]
	mov	rbx, rdx
	cmp	eax, 6
	ja	$LN11@noise
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	r8d, DWORD PTR $LN13@noise[rdx+rax*4]
	add	r8, rdx
	jmp	r8
$LN4@noise:

; 40   : 		case 0: return Perlin::noise(p.x, p.y);						//Perlin 2d

	vmovss	xmm1, DWORD PTR [rcx+4]
	vmovss	xmm0, DWORD PTR [rcx]

; 47   : 		default: return 0.0f;
; 48   : 	}
; 49   : }

	add	rsp, 48					; 00000030H
	pop	rbx

; 40   : 		case 0: return Perlin::noise(p.x, p.y);						//Perlin 2d

	jmp	?noise@Perlin@@SAMMM@Z			; Perlin::noise
$LN5@noise:

; 41   : 		case 1: return Perlin::noise(p.x, p.y, p.z);				//Perlin 3d

	vmovss	xmm2, DWORD PTR [rcx+8]
	vmovss	xmm1, DWORD PTR [rcx+4]
	vmovss	xmm0, DWORD PTR [rcx]

; 47   : 		default: return 0.0f;
; 48   : 	}
; 49   : }

	add	rsp, 48					; 00000030H
	pop	rbx

; 41   : 		case 1: return Perlin::noise(p.x, p.y, p.z);				//Perlin 3d

	jmp	?noise@Perlin@@SAMMMM@Z			; Perlin::noise
$LN6@noise:

; 42   : 		case 2: return Perlin::noise(p.x, p.y, p.z, np.phase);		//Perlin 4D

	vmovss	xmm3, DWORD PTR [rbx+12]
	vmovss	xmm2, DWORD PTR [rcx+8]
	vmovss	xmm1, DWORD PTR [rcx+4]
	vmovss	xmm0, DWORD PTR [rcx]

; 47   : 		default: return 0.0f;
; 48   : 	}
; 49   : }

	add	rsp, 48					; 00000030H
	pop	rbx

; 42   : 		case 2: return Perlin::noise(p.x, p.y, p.z, np.phase);		//Perlin 4D

	jmp	?noise@Perlin@@SAMMMMM@Z		; Perlin::noise
$LN7@noise:

; 43   : 		case 3: return Perlin::snoise(p.x, p.y);					//Simplex 2D

	vmovss	xmm1, DWORD PTR [rcx+4]
	vmovss	xmm0, DWORD PTR [rcx]

; 47   : 		default: return 0.0f;
; 48   : 	}
; 49   : }

	add	rsp, 48					; 00000030H
	pop	rbx

; 43   : 		case 3: return Perlin::snoise(p.x, p.y);					//Simplex 2D

	jmp	?snoise@Perlin@@SAMMM@Z			; Perlin::snoise
$LN8@noise:

; 44   : 		case 4: return Perlin::snoise(p.x, p.y, p.z);				//Simplex 3D

	vmovss	xmm2, DWORD PTR [rcx+8]
	vmovss	xmm1, DWORD PTR [rcx+4]
	vmovss	xmm0, DWORD PTR [rcx]

; 47   : 		default: return 0.0f;
; 48   : 	}
; 49   : }

	add	rsp, 48					; 00000030H
	pop	rbx

; 44   : 		case 4: return Perlin::snoise(p.x, p.y, p.z);				//Simplex 3D

	jmp	?snoise@Perlin@@SAMMMM@Z		; Perlin::snoise
$LN9@noise:

; 45   : 		case 5: return Perlin::snoise(p.x, p.y, p.z, np.phase);		//Simplex 4D

	vmovss	xmm3, DWORD PTR [rbx+12]
	vmovss	xmm2, DWORD PTR [rcx+8]
	vmovss	xmm1, DWORD PTR [rcx+4]
	vmovss	xmm0, DWORD PTR [rcx]

; 47   : 		default: return 0.0f;
; 48   : 	}
; 49   : }

	add	rsp, 48					; 00000030H
	pop	rbx

; 45   : 		case 5: return Perlin::snoise(p.x, p.y, p.z, np.phase);		//Simplex 4D

	jmp	?snoise@Perlin@@SAMMMMM@Z		; Perlin::snoise
$LN10@noise:

; 46   : 		case 6: return worleyWrapper(p, np);						//Worley(Voronoi)

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	rcx, rax
	mov	rdx, rbx
	call	?worleyWrapper@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ; Noise::worleyWrapper

; 47   : 		default: return 0.0f;
; 48   : 	}
; 49   : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN11@noise:
	vxorps	xmm0, xmm0, xmm0
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
	npad	1
$LN13@noise:
	DD	$LN4@noise
	DD	$LN5@noise
	DD	$LN6@noise
	DD	$LN7@noise
	DD	$LN8@noise
	DD	$LN9@noise
	DD	$LN10@noise
?noise@Noise@@SAMVPoint3@@AEAVNoiseParams@@@Z ENDP	; Noise::noise
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ
text$di	SEGMENT
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ PROC	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId'', COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR ?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A, xmm0

; 32   : 		static AssetId kInvalidId;

	ret	0
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ENDP	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ PROC		; MaxSDK::AssetManagement::AssetId::AssetId, COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR [rcx], xmm0
	mov	rax, rcx
	ret	0
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ ENDP		; MaxSDK::AssetManagement::AssetId::AssetId
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
;	COMDAT ??D@YA?AVPoint3@@AEBV0@M@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
a$ = 56
f$ = 64
??D@YA?AVPoint3@@AEBV0@M@Z PROC				; operator*, COMDAT

; 326  : __forceinline Point3 operator*(const Point3& a, float f) {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm3, xmm2, DWORD PTR [rdx+8]
	vmovaps	xmm0, xmm2
	vmulss	xmm1, xmm0, DWORD PTR [rdx]
	vmulss	xmm2, xmm2, DWORD PTR [rdx+4]
	mov	rbx, rcx
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	mov	rax, rbx

; 328  :    }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??D@YA?AVPoint3@@AEBV0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
;	COMDAT ??D@YA?AVPoint3@@MAEBV0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
f$ = 56
a$ = 64
??D@YA?AVPoint3@@MAEBV0@@Z PROC				; operator*, COMDAT

; 320  : __forceinline Point3 operator*(float f, const Point3& a) {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm3, xmm1, DWORD PTR [r8+8]
	vmulss	xmm2, xmm1, DWORD PTR [r8+4]
	vmulss	xmm1, xmm1, DWORD PTR [r8]
	mov	rbx, rcx
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	mov	rax, rbx

; 322  :    }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??D@YA?AVPoint3@@MAEBV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 8
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 295  : 	return (_CSTD sqrtf(_Xx));

	jmp	sqrtf
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 8
?sin@@YAMM@Z PROC					; sin, COMDAT

; 285  : 	return (_CSTD sinf(_Xx));

	jmp	sinf
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?fmax@@YAMMM@Z
_TEXT	SEGMENT
$T1 = 32
_Xx$ = 64
_Yx$ = 72
?fmax@@YAMMM@Z PROC					; fmax, COMDAT

; 133  : 	{

$LN5:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2

; 134  : 	return (_CSTD fmaxf(_Xx, _Yx));

	call	QWORD PTR __imp_fmaxf
	npad	1

; 135  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?fmax@@YAMMM@Z ENDP					; fmax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\cmath
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 8
?cos@@YAMM@Z PROC					; cos, COMDAT

; 78   : 	return (_CSTD cosf(_Xx));

	jmp	cosf
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\maxtypes.h
;	COMDAT ??0Class_ID@@QEAA@KK@Z
_TEXT	SEGMENT
this$ = 8
aa$ = 16
bb$ = 24
??0Class_ID@@QEAA@KK@Z PROC				; Class_ID::Class_ID, COMDAT

; 160  : 	Class_ID(ulong aa, ulong bb) { a = aa; b = bb; }

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	DWORD PTR [rcx+4], r8d
	ret	0
??0Class_ID@@QEAA@KK@Z ENDP				; Class_ID::Class_ID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\noise.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\noise.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 8
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
__t$ = 48
__s$ = 56
__n$ = 64
__f$ = 72
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN12:
	test	r8, r8
	je	SHORT $LN10@vector
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r9
	mov	rbx, r8
	mov	rbp, rdx
	mov	rdi, rcx
$LL2@vector:
	mov	rcx, rdi
	call	rsi
	add	rdi, rbp
	sub	rbx, 1
	jne	SHORT $LL2@vector
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN10@vector:
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
