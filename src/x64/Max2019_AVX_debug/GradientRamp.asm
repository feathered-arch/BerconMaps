; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27031.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	WinbaseIsolationAwarePrivateT_UnPgpgk
PUBLIC	IsolationAwarePrivateT_SqbjaYRiRY
PUBLIC	IsolationAwarePrivateT_SAbnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
PUBLIC	?__LINE__Var@?0???0Class_ID@@QEAA@KK@Z@4JA	; `Class_ID::Class_ID'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0???0AssetId@AssetManagement@MaxSDK@@QEAA@XZ@4JA ; `MaxSDK::AssetManagement::AssetId::AssetId'::`1'::__LINE__Var
EXTRN	GUID_NULL:BYTE
;	COMDAT IsolationAwarePrivateT_SqbjaYRiRY
_BSS	SEGMENT
IsolationAwarePrivateT_SqbjaYRiRY DD 01H DUP (?)
_BSS	ENDS
;	COMDAT IsolationAwarePrivateT_SAbnPgpgk
_BSS	SEGMENT
IsolationAwarePrivateT_SAbnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?__LINE__Var@?0???0AssetId@AssetManagement@MaxSDK@@QEAA@XZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0???0AssetId@AssetManagement@MaxSDK@@QEAA@XZ@4JA DD 01dH ; `MaxSDK::AssetManagement::AssetId::AssetId'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0???0Class_ID@@QEAA@KK@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0???0Class_ID@@QEAA@KK@Z@4JA DD 0a0H	; `Class_ID::Class_ID'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_UnPgpgk
_DATA	SEGMENT
WinbaseIsolationAwarePrivateT_UnPgpgk DQ ffffffffffffffffH
_DATA	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	??0AColor@@QEAA@XZ				; AColor::AColor
PUBLIC	??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ	; Tab<VertexNormalsCallback *>::~Tab<VertexNormalsCallback *>
PUBLIC	??0VertexNormalsControl@@QEAA@XZ		; VertexNormalsControl::VertexNormalsControl
PUBLIC	?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z	; GradientRamp::setHWND
PUBLIC	?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z		; GradientRamp::paint
PUBLIC	?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z ; GradientRamp::paintArrow
PUBLIC	?invalidate@GradientRamp@@QEAAXXZ		; GradientRamp::invalidate
PUBLIC	?hit@GradientRamp@@QEAAHHH_N@Z			; GradientRamp::hit
PUBLIC	?toPos@GradientRamp@@QEAAMH@Z			; GradientRamp::toPos
PUBLIC	?leftDown@GradientRamp@@QEAAXHH_N00@Z		; GradientRamp::leftDown
PUBLIC	?leftUp@GradientRamp@@QEAAXHH_N00@Z		; GradientRamp::leftUp
PUBLIC	?dragging@GradientRamp@@QEAAXHH_N00@Z		; GradientRamp::dragging
PUBLIC	?popup@GradientRamp@@QEAAXHHH@Z			; GradientRamp::popup
PUBLIC	?toIndex@GradientRamp@@QEAAHH@Z			; GradientRamp::toIndex
PUBLIC	?selectKey@GradientRamp@@QEAAXH@Z		; GradientRamp::selectKey
PUBLIC	?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z ; GradientRamp::addKey
PUBLIC	?reset@GradientRamp@@QEAAXXZ			; GradientRamp::reset
PUBLIC	?swap@GradientRamp@@QEAAXHH@Z			; GradientRamp::swap
PUBLIC	?sort@GradientRamp@@QEAAXXZ			; GradientRamp::sort
PUBLIC	?getSubtex@GradientRamp@@QEAAPEAVTexmap@@H@Z	; GradientRamp::getSubtex
PUBLIC	?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z	; GradientRamp::setSubtex
PUBLIC	?setSubtex@GradientRamp@@QEAAXPEAVTexmap@@@Z	; GradientRamp::setSubtex
PUBLIC	?findHighKey@GradientRamp@@QEAAHM@Z		; GradientRamp::findHighKey
PUBLIC	?interpolate@GradientRamp@@QEAAMMMM@Z		; GradientRamp::interpolate
PUBLIC	?getColor@GradientRamp@@QEAA?AVAColor@@M@Z	; GradientRamp::getColor
PUBLIC	?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z ; GradientRamp::getColor
PUBLIC	?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z ; GradientRamp::getBump
PUBLIC	__real@3f800000
PUBLIC	__real@40400000
PUBLIC	__real@437f0000
PUBLIC	__xmm@3f800000000000000000000000000000
PUBLIC	__xmm@3f8000003f8000003f8000003f800000
EXTRN	??_U@YAPEAX_K@Z:PROC				; operator new[]
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	__imp_BitBlt:PROC
EXTRN	__imp_CreateCompatibleBitmap:PROC
EXTRN	__imp_CreateCompatibleDC:PROC
EXTRN	__imp_CreateSolidBrush:PROC
EXTRN	__imp_DeleteDC:PROC
EXTRN	__imp_DeleteObject:PROC
EXTRN	__imp_SelectObject:PROC
EXTRN	__imp_SetPixel:PROC
EXTRN	__imp_InvalidateRect:PROC
EXTRN	__imp_GetWindowRect:PROC
EXTRN	__imp_FillRect:PROC
EXTRN	__imp_??_UMaxHeapOperators@@SAPEAX_K@Z:PROC
EXTRN	__imp_??_VMaxHeapOperators@@SAXPEAX@Z:PROC
EXTRN	__imp_?zfree@@YAXPEAPEAX@Z:PROC
EXTRN	__imp_??0Point3@@QEAA@XZ:PROC
EXTRN	__imp_??0Point3@@QEAA@MMM@Z:PROC
EXTRN	__imp_??0Point3@@QEAA@AEBV0@@Z:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	_fltused:DWORD
_BSS	SEGMENT
?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A DB 010H DUP (?) ; MaxSDK::AssetManagement::kInvalidId
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D@YA?AVPoint3@@MAEBV0@@Z DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??D@YA?AVPoint3@@MAEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+25
	DD	imagerel $unwind$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0VertexNormalsControl@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+36
	DD	imagerel $unwind$??0VertexNormalsControl@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102
	DD	imagerel $LN102+36
	DD	imagerel $unwind$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102+36
	DD	imagerel $LN102+295
	DD	imagerel $chain$5$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102+295
	DD	imagerel $LN102+497
	DD	imagerel $chain$7$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102+497
	DD	imagerel $LN102+534
	DD	imagerel $chain$8$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102+534
	DD	imagerel $LN102+1006
	DD	imagerel $chain$9$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102+1006
	DD	imagerel $LN102+1148
	DD	imagerel $chain$10$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102+1148
	DD	imagerel $LN102+1158
	DD	imagerel $chain$11$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z DD imagerel $LN26
	DD	imagerel $LN26+188
	DD	imagerel $unwind$?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hit@GradientRamp@@QEAAHHH_N@Z DD imagerel $LN21
	DD	imagerel $LN21+192
	DD	imagerel $unwind$?hit@GradientRamp@@QEAAHHH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?leftUp@GradientRamp@@QEAAXHH_N00@Z DD imagerel $LN33
	DD	imagerel $LN33+303
	DD	imagerel $unwind$?leftUp@GradientRamp@@QEAAXHH_N00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?popup@GradientRamp@@QEAAXHHH@Z DD imagerel $LN38
	DD	imagerel $LN38+305
	DD	imagerel $unwind$?popup@GradientRamp@@QEAAXHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z DD imagerel $LN39
	DD	imagerel $LN39+555
	DD	imagerel $unwind$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reset@GradientRamp@@QEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+185
	DD	imagerel $unwind$?reset@GradientRamp@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?swap@GradientRamp@@QEAAXHH@Z DD imagerel $LN6
	DD	imagerel $LN6+219
	DD	imagerel $unwind$?swap@GradientRamp@@QEAAXHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sort@GradientRamp@@QEAAXXZ DD imagerel $LN16
	DD	imagerel $LN16+27
	DD	imagerel $unwind$?sort@GradientRamp@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?sort@GradientRamp@@QEAAXXZ DD imagerel $LN16+27
	DD	imagerel $LN16+263
	DD	imagerel $chain$1$?sort@GradientRamp@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?sort@GradientRamp@@QEAAXXZ DD imagerel $LN16+263
	DD	imagerel $LN16+274
	DD	imagerel $chain$2$?sort@GradientRamp@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z DD imagerel $LN15
	DD	imagerel $LN15+74
	DD	imagerel $unwind$?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD imagerel $LN60
	DD	imagerel $LN60+74
	DD	imagerel $unwind$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD imagerel $LN60+74
	DD	imagerel $LN60+148
	DD	imagerel $chain$0$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD imagerel $LN60+148
	DD	imagerel $LN60+287
	DD	imagerel $chain$2$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD imagerel $LN60+287
	DD	imagerel $LN60+344
	DD	imagerel $chain$5$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD imagerel $LN60+344
	DD	imagerel $LN60+538
	DD	imagerel $chain$6$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD imagerel $LN60+538
	DD	imagerel $LN60+563
	DD	imagerel $chain$7$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN90
	DD	imagerel $LN90+157
	DD	imagerel $unwind$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN90+157
	DD	imagerel $LN90+480
	DD	imagerel $chain$0$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN90+480
	DD	imagerel $LN90+619
	DD	imagerel $chain$1$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN90+619
	DD	imagerel $LN90+800
	DD	imagerel $chain$2$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN90+800
	DD	imagerel $LN90+1047
	DD	imagerel $chain$3$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN90+1047
	DD	imagerel $LN90+1055
	DD	imagerel $chain$4$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN90+1055
	DD	imagerel $LN90+1063
	DD	imagerel $chain$5$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN90+1063
	DD	imagerel $LN90+1069
	DD	imagerel $chain$6$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN90+1069
	DD	imagerel $LN90+1092
	DD	imagerel $chain$7$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN53
	DD	imagerel $LN53+144
	DD	imagerel $unwind$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN53+144
	DD	imagerel $LN53+256
	DD	imagerel $chain$0$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN53+256
	DD	imagerel $LN53+579
	DD	imagerel $chain$2$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN53+579
	DD	imagerel $LN53+996
	DD	imagerel $chain$3$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN53+996
	DD	imagerel $LN53+1012
	DD	imagerel $chain$4$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN53+1012
	DD	imagerel $LN53+1018
	DD	imagerel $chain$5$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN53+1018
	DD	imagerel $LN53+1053
	DD	imagerel $chain$6$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?kInvalidId$initializer$@AssetManagement@MaxSDK@@3P6AXXZEA DQ FLAT:??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ; MaxSDK::AssetManagement::kInvalidId$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@3f8000003f8000003f8000003f800000
CONST	SEGMENT
__xmm@3f8000003f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f800000000000000000000000000000
CONST	SEGMENT
__xmm@3f800000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
_DATA	SEGMENT
?BlinnClassID@@3VClass_ID@@A DD 038H			; BlinnClassID
	DD	00H
?AnisoShaderClassID@@3VClass_ID@@A DD 02857f460H	; AnisoShaderClassID
	DD	00H
?AnisoShaderDlgClassID@@3VClass_ID@@A DD 02857f460H	; AnisoShaderDlgClassID
	DD	00H
?OrenNayarBlinnShaderClassID@@3VClass_ID@@A DD 02857f421H ; OrenNayarBlinnShaderClassID
	DD	00H
?OrenNayarShaderDlgClassID@@3VClass_ID@@A DD 02857f422H	; OrenNayarShaderDlgClassID
	DD	00H
?StraussShaderClassID@@3VClass_ID@@A DD 02857f450H	; StraussShaderClassID
	DD	00H
?kTriObjNormalXTCID@@3VClass_ID@@B DD 0730a33d7H	; kTriObjNormalXTCID
	DD	027246c55H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+144
	DD	imagerel $unwind$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN53+144
	DD	imagerel $LN53+256
	DD	imagerel $chain$0$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN53+256
	DD	imagerel $LN53+579
	DD	imagerel $chain$2$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 020821H
	DD	01af408H
	DD	imagerel $LN53+256
	DD	imagerel $LN53+579
	DD	imagerel $chain$2$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 041421H
	DD	019e414H
	DD	0183408H
	DD	imagerel $LN53+144
	DD	imagerel $LN53+256
	DD	imagerel $chain$0$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 020621H
	DD	078806H
	DD	imagerel $LN53
	DD	imagerel $LN53+144
	DD	imagerel $unwind$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 0b2b01H
	DD	08782bH
	DD	09681bH
	DD	01b6416H
	DD	0140116H
	DD	07009d00bH
	DD	05008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN90
	DD	imagerel $LN90+157
	DD	imagerel $unwind$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN90+157
	DD	imagerel $LN90+480
	DD	imagerel $chain$0$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN90+480
	DD	imagerel $LN90+619
	DD	imagerel $chain$1$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN90+619
	DD	imagerel $LN90+800
	DD	imagerel $chain$2$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 020621H
	DD	076806H
	DD	imagerel $LN90+619
	DD	imagerel $LN90+800
	DD	imagerel $chain$2$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 020821H
	DD	015e408H
	DD	imagerel $LN90+480
	DD	imagerel $LN90+619
	DD	imagerel $chain$1$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 020821H
	DD	0147408H
	DD	imagerel $LN90+157
	DD	imagerel $LN90+480
	DD	imagerel $chain$0$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 020621H
	DD	067806H
	DD	imagerel $LN90
	DD	imagerel $LN90+157
	DD	imagerel $unwind$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 061301H
	DD	0163413H
	DD	0f009f213H
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD 021H
	DD	imagerel $LN60+287
	DD	imagerel $LN60+344
	DD	imagerel $chain$5$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD 020521H
	DD	085405H
	DD	imagerel $LN60+287
	DD	imagerel $LN60+344
	DD	imagerel $chain$5$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD 040721H
	DD	097407H
	DD	026800H
	DD	imagerel $LN60
	DD	imagerel $LN60+74
	DD	imagerel $unwind$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD 020021H
	DD	026800H
	DD	imagerel $LN60
	DD	imagerel $LN60+74
	DD	imagerel $unwind$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD 020621H
	DD	026806H
	DD	imagerel $LN60
	DD	imagerel $LN60+74
	DD	imagerel $unwind$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD 040a01H
	DD	0a340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?sort@GradientRamp@@QEAAXXZ DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+27
	DD	imagerel $unwind$?sort@GradientRamp@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?sort@GradientRamp@@QEAAXXZ DD 040d21H
	DD	05e40dH
	DD	046405H
	DD	imagerel $LN16
	DD	imagerel $LN16+27
	DD	imagerel $unwind$?sort@GradientRamp@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sort@GradientRamp@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?swap@GradientRamp@@QEAAXHH@Z DD 0a1a01H
	DD	07741aH
	DD	06641aH
	DD	05541aH
	DD	04341aH
	DD	0e016121aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reset@GradientRamp@@QEAAXXZ DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z DD imagerel ?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z DD 0e2911H
	DD	036829H
	DD	0116424H
	DD	0105420H
	DD	0f341cH
	DD	0f00c7210H
	DD	0d008e00aH
	DD	07004c006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?popup@GradientRamp@@QEAAXHHH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?leftUp@GradientRamp@@QEAAXHH_N00@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hit@GradientRamp@@QEAAHHH_N@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z DD 0c2101H
	DD	0e6421H
	DD	0d5421H
	DD	0c3421H
	DD	0f01d5221H
	DD	0d019e01bH
	DD	07015c017H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 021H
	DD	imagerel $LN102
	DD	imagerel $LN102+36
	DD	imagerel $unwind$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 021H
	DD	imagerel $LN102+497
	DD	imagerel $LN102+534
	DD	imagerel $chain$8$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 020821H
	DD	019d408H
	DD	imagerel $LN102+497
	DD	imagerel $LN102+534
	DD	imagerel $chain$8$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 021H
	DD	imagerel $LN102+36
	DD	imagerel $LN102+295
	DD	imagerel $chain$5$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 041f21H
	DD	09781fH
	DD	0a6809H
	DD	imagerel $LN102+36
	DD	imagerel $LN102+295
	DD	imagerel $chain$5$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 0c1c21H
	DD	08881cH
	DD	017f417H
	DD	018e413H
	DD	01ac40fH
	DD	01b740bH
	DD	01c6404H
	DD	imagerel $LN102
	DD	imagerel $LN102+36
	DD	imagerel $unwind$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 041401H
	DD	01d0114H
	DD	0300c500dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0VertexNormalsControl@@QEAA@XZ DD imagerel ??0VertexNormalsControl@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0VertexNormalsControl@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0VertexNormalsControl@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0VertexNormalsControl@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0VertexNormalsControl@@QEAA@XZ
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??0VertexNormalsControl@@QEAA@XZ
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0VertexNormalsControl@@QEAA@XZ DD 011111H
	DD	02209H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0VertexNormalsControl@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ DD imagerel ??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ
	DD	020H
	DD	00H
	DD	04H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D@YA?AVPoint3@@MAEBV0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 081901H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	070153219H
xdata	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
_TEXT	SEGMENT
v1$ = 32
v2$ = 48
$T1 = 64
$T2 = 76
$T3 = 88
$T4 = 88
$T5 = 88
$T6 = 88
$T7 = 100
$T8 = 100
$T9 = 100
$T10 = 100
$T11 = 100
$T12 = 100
$T13 = 100
$T14 = 100
$T15 = 100
$T16 = 100
this$ = 192
__$ReturnUdt$ = 200
x$ = 208
normal$ = 216
sc$ = 224
?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z PROC ; GradientRamp::getBump, COMDAT

; 495  : Point3 GradientRamp::getBump(float x, Point3 normal, ShadeContext& sc) {

$LN53:
	mov	rax, rsp
	mov	QWORD PTR [rax+32], rsi
	push	rbp
	push	rdi
	push	r13
	lea	rbp, QWORD PTR [rax-87]
	sub	rsp, 160				; 000000a0H
	vmovaps	XMMWORD PTR [rax-40], xmm6
	mov	r13, r9
	vxorps	xmm6, xmm6, xmm6

; 496  : 	if (x<=0) return subtex[0]?subtex[0]->EvalNormalPerturb(sc):NOBUMP;

	vcomiss	xmm6, xmm2
	vmovaps	XMMWORD PTR [rax-56], xmm7
	mov	rdi, rdx
	vmovaps	xmm7, xmm2
	mov	rsi, rcx
	jb	SHORT $LN2@getBump
	mov	rax, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN14@getBump
	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR $T16[rbp-97]
	mov	r8, QWORD PTR sc$[rbp-97]
	call	QWORD PTR [rax+1520]
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	jmp	$LN51@getBump
$LN14@getBump:
	vxorps	xmm3, xmm3, xmm3
	vxorps	xmm2, xmm2, xmm2
	vxorps	xmm1, xmm1, xmm1
	lea	rcx, QWORD PTR $T6[rbp-97]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	jmp	$LN51@getBump
$LN2@getBump:

; 497  : 	if (x>=1) return subtex[keys-1]?subtex[keys-1]->EvalNormalPerturb(sc):NOBUMP;

	movsxd	rdx, DWORD PTR [rcx+56]
	vmovaps	XMMWORD PTR [rsp+112], xmm8
	vmovss	xmm8, DWORD PTR __real@3f800000
	vcomiss	xmm7, xmm8
	jb	SHORT $LN3@getBump
	mov	rax, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR [rax+rdx*8-8]
	test	rcx, rcx
	je	SHORT $LN16@getBump
	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR $T15[rbp-97]
	mov	r8, QWORD PTR sc$[rbp-97]
	call	QWORD PTR [rax+1520]
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	jmp	$LN50@getBump
$LN16@getBump:
	vxorps	xmm3, xmm3, xmm3
	vxorps	xmm2, xmm2, xmm2
	vxorps	xmm1, xmm1, xmm1
	lea	rcx, QWORD PTR $T5[rbp-97]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	jmp	$LN50@getBump
$LN3@getBump:

; 440  : 	if (x < position[low])

	mov	r8, QWORD PTR [rcx+32]
	mov	QWORD PTR [rsp+192], rbx

; 437  : 	int low = 0;

	xor	ebx, ebx

; 438  : 	int high = keys-1;

	dec	edx
	mov	QWORD PTR [rsp+200], r14

; 439  : 	int mid;	
; 440  : 	if (x < position[low])

	vmovss	xmm0, DWORD PTR [r8]
	vcomiss	xmm0, xmm7
	ja	SHORT $LN24@getBump

; 441  : 		return low;
; 442  : 	while (low < (high-1)) {

	lea	eax, DWORD PTR [rdx-1]
	test	eax, eax
	jle	SHORT $LN26@getBump
$LL25@getBump:

; 443  : 		mid = (low + high) / 2;

	lea	ecx, DWORD PTR [rdx+rbx]
	test	ecx, ecx
	jns	SHORT $LN43@getBump
	inc	ecx
$LN43@getBump:
	sar	ecx, 1

; 444  : 		if (x < position[mid])

	movsxd	rax, ecx
	vmovss	xmm0, DWORD PTR [r8+rax*4]
	vcomiss	xmm0, xmm7
	mov	eax, ecx
	cmovbe	eax, edx
	cmovbe	ebx, ecx
	mov	edx, eax
	dec	eax
	cmp	ebx, eax
	jl	SHORT $LL25@getBump
$LN26@getBump:

; 445  : 			high  = mid;
; 446  : 		else
; 447  : 			low = mid;		
; 448  : 	}
; 449  : 	return high;

	mov	ebx, edx
$LN24@getBump:

; 498  : 	int high = findHighKey(x);
; 499  : 	if (interpolation == 4) return subtex[high]?subtex[high]->EvalNormalPerturb(sc):NOBUMP;

	mov	eax, DWORD PTR [rsi+64]
	movsxd	r14, ebx
	cmp	eax, 4
	jne	SHORT $LN4@getBump
	mov	rax, QWORD PTR [rsi+24]
	mov	rcx, QWORD PTR [rax+r14*8]
	test	rcx, rcx
	je	SHORT $LN18@getBump
	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR $T14[rbp-97]
	mov	r8, QWORD PTR sc$[rbp-97]
	call	QWORD PTR [rax+1520]

; 533  : 	}
; 534  : 
; 535  : 	return v1;

	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	jmp	$LN47@getBump
$LN18@getBump:
	vmovaps	xmm3, xmm6
	vmovaps	xmm2, xmm6
	vmovaps	xmm1, xmm6
	lea	rcx, QWORD PTR $T4[rbp-97]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	jmp	$LN47@getBump
$LN4@getBump:

; 500  : 	int low = high - 1;	

	lea	ecx, DWORD PTR [rbx-1]

; 501  : 	if (interpolation == 3) return subtex[low]?subtex[low]->EvalNormalPerturb(sc):NOBUMP;	

	cmp	eax, 3
	jne	SHORT $LN5@getBump
	mov	rax, QWORD PTR [rsi+24]
	mov	rcx, QWORD PTR [rax+r14*8-8]
	test	rcx, rcx
	je	SHORT $LN18@getBump
	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR $T13[rbp-97]
	mov	r8, QWORD PTR sc$[rbp-97]
	call	QWORD PTR [rax+1520]

; 533  : 	}
; 534  : 
; 535  : 	return v1;

	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	jmp	$LN47@getBump
$LN5@getBump:

; 502  : 	if (interpolation == 2) {		

	cmp	eax, 2
	jne	SHORT $LN6@getBump

; 503  : 		int key = x-position[low]<position[high]-x?low:high;

	vsubss	xmm2, xmm7, DWORD PTR [r8+r14*4-4]
	movsxd	rax, ebx
	vmovss	xmm0, DWORD PTR [r8+rax*4]

; 504  : 		return subtex[key]?subtex[key]->EvalNormalPerturb(sc):NOBUMP;

	mov	rax, QWORD PTR [rsi+24]
	vsubss	xmm1, xmm0, xmm7
	vcomiss	xmm1, xmm2
	cmova	ebx, ecx
	movsxd	rcx, ebx
	mov	rcx, QWORD PTR [rax+rcx*8]
	test	rcx, rcx
	je	$LN18@getBump
	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR $T12[rbp-97]
	mov	r8, QWORD PTR sc$[rbp-97]
	call	QWORD PTR [rax+1520]

; 533  : 	}
; 534  : 
; 535  : 	return v1;

	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	jmp	$LN47@getBump
$LN6@getBump:

; 505  : 	}
; 506  : 
; 507  : 	//float f1, f2;
; 508  : 	Point3 v1, v2;

	lea	rcx, QWORD PTR v1$[rbp-97]
	mov	QWORD PTR [rsp+208], r15
	call	QWORD PTR __imp_??0Point3@@QEAA@XZ
	lea	rcx, QWORD PTR v2$[rbp-97]
	call	QWORD PTR __imp_??0Point3@@QEAA@XZ

; 509  : 	bool maps = false;
; 510  : 	if (subtex[0]) {

	mov	rcx, QWORD PTR [rsi+24]
	xor	r15b, r15b
	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN7@getBump

; 511  : 		//f1 = subtex[low]->EvalMono(sc);
; 512  : 		v1 = subtex[low]->EvalNormalPerturb(sc);

	mov	rcx, QWORD PTR [rcx+r14*8-8]
	lea	rdx, QWORD PTR $T11[rbp-97]
	mov	r8, QWORD PTR sc$[rbp-97]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+1520]

; 513  : 		maps = true;

	mov	r15b, 1

; 514  : 	} else {

	jmp	SHORT $LN48@getBump
$LN7@getBump:

; 515  : 		//f1 = Intens(color[low]);
; 516  : 		v1 = Point3(0.f, 0.f, 0.f);

	vmovaps	xmm3, xmm6
	vmovaps	xmm2, xmm6
	vmovaps	xmm1, xmm6
	lea	rcx, QWORD PTR $T10[rbp-97]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
$LN48@getBump:

; 517  : 	}
; 518  : 	if (subtex[1]) {

	vmovsd	xmm0, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rsi+24]
	vmovsd	QWORD PTR v1$[rbp-97], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR v1$[rbp-89], eax
	cmp	QWORD PTR [rcx+8], 0
	movsxd	rbx, ebx
	je	SHORT $LN9@getBump

; 519  : 		//f2 = subtex[high]->EvalMono(sc);
; 520  : 		v2 = subtex[high]->EvalNormalPerturb(sc);

	mov	rcx, QWORD PTR [rcx+rbx*8]
	lea	rdx, QWORD PTR $T9[rbp-97]
	mov	r8, QWORD PTR sc$[rbp-97]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+1520]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR v2$[rbp-97], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR v2$[rbp-89], eax

; 521  : 		maps = true;
; 522  : 	} else {

	jmp	SHORT $LN42@getBump
$LN9@getBump:

; 523  : 		//f2 = Intens(color[high]);
; 524  : 		v2 = Point3(0.f, 0.f, 0.f);

	vmovaps	xmm3, xmm6
	vmovaps	xmm2, xmm6
	vmovaps	xmm1, xmm6
	lea	rcx, QWORD PTR $T8[rbp-97]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR v2$[rbp-97], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR v2$[rbp-89], eax

; 525  : 	}
; 526  : 	
; 527  : 	// Calculate vector	
; 528  : 	if (maps) {

	test	r15b, r15b
	je	$LN11@getBump
$LN42@getBump:

; 529  : 		float mult = interpolate(x, position[low], position[high]);

	mov	rax, QWORD PTR [rsi+32]
	mov	rcx, rsi
	vmovaps	xmm1, xmm7
	vmovss	xmm3, DWORD PTR [rax+rbx*4]
	vmovss	xmm2, DWORD PTR [rax+r14*4-4]
	call	?interpolate@GradientRamp@@QEAAMMMM@Z	; GradientRamp::interpolate

; 530  : 		v1 = /*(f2-f1)**/ normal + mult*v2 + (1.f-mult)*v1;

	vsubss	xmm4, xmm8, xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm3, xmm4, DWORD PTR v1$[rbp-89]
	vmulss	xmm2, xmm4, DWORD PTR v1$[rbp-93]
	vmulss	xmm1, xmm4, DWORD PTR v1$[rbp-97]
	lea	rcx, QWORD PTR $T2[rbp-97]
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 529  : 		float mult = interpolate(x, position[low], position[high]);

	vmovaps	xmm6, xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	vmulss	xmm3, xmm6, DWORD PTR v2$[rbp-89]
	vmulss	xmm2, xmm6, DWORD PTR v2$[rbp-93]
	vmulss	xmm1, xmm6, DWORD PTR v2$[rbp-97]
	lea	rcx, QWORD PTR $T1[rbp-97]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vmovss	xmm0, DWORD PTR $T1[rbp-89]
	vmovss	xmm1, DWORD PTR $T1[rbp-93]
	vaddss	xmm3, xmm0, DWORD PTR [r13+8]
	vmovss	xmm0, DWORD PTR $T1[rbp-97]
	vaddss	xmm2, xmm1, DWORD PTR [r13+4]
	vaddss	xmm1, xmm0, DWORD PTR [r13]
	lea	rcx, QWORD PTR $T3[rbp-97]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	vmovss	xmm0, DWORD PTR $T2[rbp-89]
	vmovss	xmm1, DWORD PTR $T2[rbp-93]
	vaddss	xmm3, xmm0, DWORD PTR $T3[rbp-89]
	vmovss	xmm0, DWORD PTR $T2[rbp-97]
	vaddss	xmm2, xmm1, DWORD PTR $T3[rbp-93]
	vaddss	xmm1, xmm0, DWORD PTR $T3[rbp-97]
	lea	rcx, QWORD PTR $T7[rbp-97]
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 530  : 		v1 = /*(f2-f1)**/ normal + mult*v2 + (1.f-mult)*v1;

	vmovsd	xmm0, QWORD PTR $T7[rbp-97]
	mov	eax, DWORD PTR $T7[rbp-89]

; 531  : 	} else {

	jmp	SHORT $LN49@getBump
$LN11@getBump:

; 532  : 		v1 = normal; // * (f2 - f1);

	vmovsd	xmm0, QWORD PTR [r13]
	mov	eax, DWORD PTR [r13+8]
$LN49@getBump:

; 533  : 	}
; 534  : 
; 535  : 	return v1;

	lea	rdx, QWORD PTR v1$[rbp-97]
	mov	DWORD PTR v1$[rbp-89], eax
	mov	rcx, rdi
	vmovsd	QWORD PTR v1$[rbp-97], xmm0
	call	QWORD PTR __imp_??0Point3@@QEAA@AEBV0@@Z
	mov	r15, QWORD PTR [rsp+208]
$LN47@getBump:
	mov	r14, QWORD PTR [rsp+200]
	mov	rbx, QWORD PTR [rsp+192]
$LN50@getBump:
	vmovaps	xmm8, XMMWORD PTR [rsp+112]
$LN51@getBump:

; 536  : }

	lea	r11, QWORD PTR [rsp+160]
	mov	rax, rdi
	mov	rsi, QWORD PTR [r11+56]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	mov	rsp, r11
	pop	r13
	pop	rdi
	pop	rbp
	ret	0
?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z ENDP ; GradientRamp::getBump
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 48
$T8 = 48
$T9 = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 64
$T14 = 80
this$ = 160
__$ReturnUdt$ = 168
x$ = 176
sc$ = 184
?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z PROC ; GradientRamp::getColor, COMDAT

; 478  : AColor GradientRamp::getColor(float x, ShadeContext& sc) {

$LN90:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	r15
	mov	rbp, rsp
	sub	rsp, 128				; 00000080H
	vxorps	xmm0, xmm0, xmm0

; 479  : 	if (x<=0) return subtex[0]?subtex[0]->EvalColor(sc):color[0];

	vcomiss	xmm0, xmm2
	mov	r15, r9
	mov	rbx, rdx
	vmovaps	xmm1, xmm2
	mov	rsi, rcx
	jb	SHORT $LN2@getColor
	mov	rax, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN8@getColor
	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR $T12[rbp-128]
	mov	r8, r9
	call	QWORD PTR [rax+1504]
	mov	rcx, rax
	vmovss	xmm2, DWORD PTR [rax]
	jmp	SHORT $LN9@getColor
$LN8@getColor:
	mov	rax, QWORD PTR [rsi+40]
	lea	rcx, QWORD PTR $T6[rbp-128]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovss	xmm0, DWORD PTR [rax+4]
	vmovss	xmm2, DWORD PTR [rax]
	vmovss	xmm1, DWORD PTR [rax+8]
	vmovss	DWORD PTR $T6[rbp-124], xmm0
	vmovss	xmm0, DWORD PTR [rax+12]
	vmovss	DWORD PTR $T6[rbp-116], xmm0
	vmovss	DWORD PTR $T6[rbp-128], xmm2
	vmovss	DWORD PTR $T6[rbp-120], xmm1
$LN9@getColor:
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rbx+12], eax
	vmovss	DWORD PTR [rbx], xmm2
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 479  : 	if (x<=0) return subtex[0]?subtex[0]->EvalColor(sc):color[0];

	jmp	$LN88@getColor
$LN2@getColor:

; 480  : 	if (x>=1) return subtex[keys-1]?subtex[keys-1]->EvalColor(sc):color[keys-1];

	movsxd	rdx, DWORD PTR [rcx+56]
	vmovaps	XMMWORD PTR [rsp+96], xmm7
	vmovss	xmm7, DWORD PTR __real@3f800000
	vcomiss	xmm1, xmm7
	jb	SHORT $LN3@getColor
	lea	rax, QWORD PTR [rdx-1]
	mov	r8, rdx
	mov	rdx, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR [rdx+rax*8]
	test	rcx, rcx
	je	SHORT $LN10@getColor
	mov	rax, QWORD PTR [rdx+r8*8-8]
	mov	r8, r15
	lea	rdx, QWORD PTR $T11[rbp-128]
	mov	r9, QWORD PTR [rax]
	call	QWORD PTR [r9+1504]
	mov	rcx, rax
	vmovss	xmm2, DWORD PTR [rax]
	jmp	$LN13@getColor
$LN10@getColor:
	shl	rax, 4
	add	rax, QWORD PTR [rsi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovss	xmm0, DWORD PTR [rax+4]
	vmovss	xmm2, DWORD PTR [rax]
	vmovss	xmm1, DWORD PTR [rax+8]
	vmovss	DWORD PTR $T5[rbp-124], xmm0
	vmovss	xmm0, DWORD PTR [rax+12]
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 480  : 	if (x>=1) return subtex[keys-1]?subtex[keys-1]->EvalColor(sc):color[keys-1];

	jmp	$LN85@getColor
$LN3@getColor:

; 440  : 	if (x < position[low])

	mov	r9, QWORD PTR [rcx+32]
	xor	r10d, r10d
	dec	edx
	mov	r8d, r10d
	vmovss	xmm0, DWORD PTR [r9]
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN67@getColor

; 441  : 		return low;

	mov	edx, r10d
	jmp	SHORT $LN34@getColor
$LN67@getColor:

; 442  : 	while (low < (high-1)) {

	lea	eax, DWORD PTR [rdx-1]
	test	eax, eax
	jle	SHORT $LN34@getColor
	npad	1
$LL33@getColor:

; 443  : 		mid = (low + high) / 2;

	lea	ecx, DWORD PTR [rdx+r8]
	test	ecx, ecx
	jns	SHORT $LN79@getColor
	inc	ecx
$LN79@getColor:
	sar	ecx, 1

; 444  : 		if (x < position[mid])

	movsxd	rax, ecx
	vmovss	xmm0, DWORD PTR [r9+rax*4]
	vcomiss	xmm0, xmm1
	mov	eax, ecx
	cmovbe	eax, edx
	cmovbe	r8d, ecx
	mov	edx, eax
	dec	eax
	cmp	r8d, eax
	jl	SHORT $LL33@getColor
$LN34@getColor:

; 482  : 	if (interpolation == 4) return subtex[high]?subtex[high]->EvalColor(sc):color[high];

	mov	eax, DWORD PTR [rsi+64]
	cmp	eax, 4
	jne	SHORT $LN4@getColor
	mov	rax, QWORD PTR [rsi+24]
	movsxd	r8, edx
	mov	rcx, QWORD PTR [rax+r8*8]
	test	rcx, rcx
	je	SHORT $LN12@getColor
	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR $T10[rbp-128]
	mov	r8, r15
	call	QWORD PTR [rax+1504]
	mov	rcx, rax
	vmovss	xmm2, DWORD PTR [rax]
	jmp	SHORT $LN13@getColor
$LN12@getColor:
	shl	r8, 4
	add	r8, QWORD PTR [rsi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovss	xmm0, DWORD PTR [r8+4]
	vmovss	xmm2, DWORD PTR [r8]
	vmovss	xmm1, DWORD PTR [r8+8]
	vmovss	DWORD PTR $T4[rbp-124], xmm0
	vmovss	xmm0, DWORD PTR [r8+12]
$LN85@getColor:
	vmovss	DWORD PTR $T4[rbp-120], xmm1
	vmovss	DWORD PTR $T4[rbp-128], xmm2
	vmovss	DWORD PTR $T4[rbp-116], xmm0
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 482  : 	if (interpolation == 4) return subtex[high]?subtex[high]->EvalColor(sc):color[high];

	lea	rcx, QWORD PTR $T4[rbp-128]
$LN13@getColor:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rbx+12], eax
	vmovss	DWORD PTR [rbx], xmm2
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 482  : 	if (interpolation == 4) return subtex[high]?subtex[high]->EvalColor(sc):color[high];

	jmp	$LN87@getColor
$LN4@getColor:

; 484  : 	if (interpolation == 3) return subtex[low]?subtex[low]->EvalColor(sc):color[low];	

	test	edx, edx
	mov	QWORD PTR [rsp+160], rdi
	lea	ecx, DWORD PTR [rdx-1]
	cmovle	ecx, r10d
	movsxd	rdi, ecx
	cmp	eax, 3
	jne	SHORT $LN5@getColor
	mov	rax, QWORD PTR [rsi+24]
	mov	rcx, QWORD PTR [rax+rdi*8]
	test	rcx, rcx
	je	SHORT $LN16@getColor
	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR $T9[rbp-128]
	mov	r8, r15
	call	QWORD PTR [rax+1504]
	mov	rcx, rax
	vmovss	xmm2, DWORD PTR [rax]
	jmp	SHORT $LN17@getColor
$LN16@getColor:
	shl	rdi, 4
	lea	rcx, QWORD PTR $T3[rbp-128]
	add	rdi, QWORD PTR [rsi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovss	xmm0, DWORD PTR [rdi+4]
	vmovss	xmm2, DWORD PTR [rdi]
	vmovss	xmm1, DWORD PTR [rdi+8]
	vmovss	DWORD PTR $T3[rbp-124], xmm0
	vmovss	xmm0, DWORD PTR [rdi+12]
	vmovss	DWORD PTR $T3[rbp-116], xmm0
	vmovss	DWORD PTR $T3[rbp-128], xmm2
	vmovss	DWORD PTR $T3[rbp-120], xmm1
$LN17@getColor:
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rbx+12], eax
	vmovss	DWORD PTR [rbx], xmm2
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 484  : 	if (interpolation == 3) return subtex[low]?subtex[low]->EvalColor(sc):color[low];	

	jmp	$LN86@getColor
$LN5@getColor:
	mov	QWORD PTR [rsp+168], r14

; 485  : 	if (interpolation == 2) {		

	movsxd	r14, edx
	cmp	eax, 2
	jne	$LN6@getColor

; 486  : 		int key = x-position[low]<position[high]-x?low:high;

	vsubss	xmm2, xmm1, DWORD PTR [r9+rdi*4]
	vmovss	xmm0, DWORD PTR [r9+r14*4]

; 487  : 		return subtex[key]?subtex[key]->EvalColor(sc):color[key];

	mov	rax, QWORD PTR [rsi+24]
	vsubss	xmm1, xmm0, xmm1
	vcomiss	xmm1, xmm2
	cmova	edx, ecx
	movsxd	r8, edx
	mov	rcx, QWORD PTR [rax+r8*8]
	test	rcx, rcx
	je	SHORT $LN18@getColor
	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR $T8[rbp-128]
	mov	r8, r15
	call	QWORD PTR [rax+1504]
	mov	rcx, rax
	vmovss	xmm2, DWORD PTR [rax]
	jmp	SHORT $LN19@getColor
$LN18@getColor:
	shl	r8, 4
	lea	rcx, QWORD PTR $T2[rbp-128]
	add	r8, QWORD PTR [rsi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovss	xmm0, DWORD PTR [r8+4]
	vmovss	xmm2, DWORD PTR [r8]
	vmovss	xmm1, DWORD PTR [r8+8]
	vmovss	DWORD PTR $T2[rbp-124], xmm0
	vmovss	xmm0, DWORD PTR [r8+12]
	vmovss	DWORD PTR $T2[rbp-116], xmm0
	vmovss	DWORD PTR $T2[rbp-128], xmm2
	vmovss	DWORD PTR $T2[rbp-120], xmm1
$LN19@getColor:
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rbx+12], eax
	vmovss	DWORD PTR [rbx], xmm2
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 487  : 		return subtex[key]?subtex[key]->EvalColor(sc):color[key];

	jmp	$LN83@getColor
$LN6@getColor:

; 488  : 	}
; 489  : 	float mult = interpolate(x, position[low], position[high]);

	vmovss	xmm3, DWORD PTR [r9+r14*4]
	vmovss	xmm2, DWORD PTR [r9+rdi*4]
	mov	rcx, rsi
	vmovaps	XMMWORD PTR [rsp+112], xmm6
	call	?interpolate@GradientRamp@@QEAAMMMM@Z	; GradientRamp::interpolate

; 490  : 	return (subtex[low]?subtex[low]->EvalColor(sc):color[low])

	mov	rcx, QWORD PTR [rsi+24]
	vmovaps	xmm6, xmm0
	mov	r9, QWORD PTR [rcx+r14*8]
	test	r9, r9
	je	SHORT $LN22@getColor
	mov	rax, QWORD PTR [r9]
	lea	rdx, QWORD PTR $T13[rbp-128]
	mov	r8, r15
	mov	rcx, r9
	call	QWORD PTR [rax+1504]
	mov	rcx, QWORD PTR [rsi+24]
	mov	r14, rax
	jmp	SHORT $LN23@getColor
$LN22@getColor:
	shl	r14, 4
	add	r14, QWORD PTR [rsi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	xmm0, XMMWORD PTR [r14]
	vmovups	XMMWORD PTR $T1[rbp-128], xmm0
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 490  : 	return (subtex[low]?subtex[low]->EvalColor(sc):color[low])

	lea	r14, QWORD PTR $T1[rbp-128]
$LN23@getColor:
	mov	rcx, QWORD PTR [rcx+rdi*8]
	test	rcx, rcx
	je	SHORT $LN20@getColor
	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR $T14[rbp-128]
	mov	r8, r15
	call	QWORD PTR [rax+1504]
	vmovss	xmm2, DWORD PTR [rax]
	jmp	SHORT $LN21@getColor
$LN20@getColor:
	shl	rdi, 4
	lea	rax, QWORD PTR $T7[rbp-128]
	add	rdi, QWORD PTR [rsi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovss	xmm0, DWORD PTR [rdi+4]
	vmovss	xmm2, DWORD PTR [rdi]
	vmovss	xmm1, DWORD PTR [rdi+8]
	vmovss	DWORD PTR $T7[rbp-124], xmm0
	vmovss	xmm0, DWORD PTR [rdi+12]
	vmovss	DWORD PTR $T7[rbp-116], xmm0
	vmovss	DWORD PTR $T7[rbp-128], xmm2
	vmovss	DWORD PTR $T7[rbp-120], xmm1
$LN21@getColor:

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmulss	xmm0, xmm6, DWORD PTR [r14]
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 490  : 	return (subtex[low]?subtex[low]->EvalColor(sc):color[low])

	vsubss	xmm3, xmm7, xmm6
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmulss	xmm1, xmm2, xmm3
	vmulss	xmm2, xmm3, DWORD PTR [rax+4]

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vaddss	xmm1, xmm0, xmm1

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmulss	xmm0, xmm6, DWORD PTR [r14+4]

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	DWORD PTR [rbx], xmm1
	vaddss	xmm1, xmm2, xmm0

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmulss	xmm0, xmm6, DWORD PTR [r14+8]
	vmulss	xmm2, xmm3, DWORD PTR [rax+8]

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	DWORD PTR [rbx+4], xmm1
	vaddss	xmm1, xmm2, xmm0

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmulss	xmm0, xmm6, DWORD PTR [r14+12]
	vmulss	xmm2, xmm3, DWORD PTR [rax+12]
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 490  : 	return (subtex[low]?subtex[low]->EvalColor(sc):color[low])

	vmovaps	xmm6, XMMWORD PTR [rsp+112]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	DWORD PTR [rbx+8], xmm1
	vaddss	xmm1, xmm2, xmm0
	vmovss	DWORD PTR [rbx+12], xmm1
$LN83@getColor:
	mov	r14, QWORD PTR [rsp+168]
$LN86@getColor:
	mov	rdi, QWORD PTR [rsp+160]
$LN87@getColor:
	vmovaps	xmm7, XMMWORD PTR [rsp+96]
$LN88@getColor:
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 492  : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+176]
	add	rsp, 128				; 00000080H
	pop	r15
	pop	rsi
	pop	rbp
	ret	0
?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z ENDP ; GradientRamp::getColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
x$ = 80
?getColor@GradientRamp@@QEAA?AVAColor@@M@Z PROC		; GradientRamp::getColor, COMDAT

; 466  : AColor GradientRamp::getColor(float x) {

$LN60:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 48					; 00000030H
	vxorps	xmm0, xmm0, xmm0

; 467  : 	if (x<=0) return color[0];

	vcomiss	xmm0, xmm2
	vmovaps	xmm1, xmm2
	mov	rbx, rdx
	mov	rsi, rcx
	jb	SHORT $LN2@getColor
	mov	rcx, QWORD PTR [rcx+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rdx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rdx+8], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdx+12], eax
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 476  : }

	mov	rax, rdx
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
$LN2@getColor:

; 468  : 	if (x>=1) return color[keys-1];

	movsxd	rdx, DWORD PTR [rcx+56]
	vmovaps	XMMWORD PTR [rsp+32], xmm6
	vmovss	xmm6, DWORD PTR __real@3f800000
	vcomiss	xmm1, xmm6
	jb	SHORT $LN3@getColor
	mov	rcx, QWORD PTR [rcx+40]
	add	rdx, rdx
	vmovaps	xmm6, XMMWORD PTR [rsp+32]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	mov	eax, DWORD PTR [rcx+rdx*8-16]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [rcx+rdx*8-12]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rcx+rdx*8-8]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rcx+rdx*8-4]
	mov	DWORD PTR [rbx+12], eax
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 476  : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
$LN3@getColor:

; 440  : 	if (x < position[low])

	mov	r9, QWORD PTR [rcx+32]
	xor	r10d, r10d
	dec	edx
	mov	r8d, r10d
	vmovss	xmm0, DWORD PTR [r9]
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN39@getColor

; 441  : 		return low;

	mov	edx, r10d
	jmp	SHORT $LN16@getColor
$LN39@getColor:

; 442  : 	while (low < (high-1)) {

	lea	eax, DWORD PTR [rdx-1]
	test	eax, eax
	jle	SHORT $LN16@getColor
$LL15@getColor:

; 443  : 		mid = (low + high) / 2;

	lea	ecx, DWORD PTR [rdx+r8]
	test	ecx, ecx
	jns	SHORT $LN51@getColor
	inc	ecx
$LN51@getColor:
	sar	ecx, 1

; 444  : 		if (x < position[mid])

	movsxd	rax, ecx
	vmovss	xmm0, DWORD PTR [r9+rax*4]
	vcomiss	xmm0, xmm1
	mov	eax, ecx
	cmovbe	eax, edx
	cmovbe	r8d, ecx
	mov	edx, eax
	dec	eax
	cmp	r8d, eax
	jl	SHORT $LL15@getColor
$LN16@getColor:

; 469  : 	int high = findHighKey(x);
; 470  : 	if (interpolation == 4) return color[high];

	mov	ecx, DWORD PTR [rsi+64]
	cmp	ecx, 4
	jne	SHORT $LN4@getColor
	vmovaps	xmm6, XMMWORD PTR [rsp+32]
	movsxd	rcx, edx
	shl	rcx, 4
	add	rcx, QWORD PTR [rsi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rbx+12], eax
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 476  : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
$LN4@getColor:

; 472  : 	if (interpolation == 3) return color[low];

	test	edx, edx
	mov	QWORD PTR [rsp+72], rdi
	lea	eax, DWORD PTR [rdx-1]
	cmovle	eax, r10d
	movsxd	rdi, eax
	cmp	ecx, 3
	jne	SHORT $LN5@getColor
	shl	rdi, 4
	add	rdi, QWORD PTR [rsi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [rdi+4]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rdi+8]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rdi+12]
	mov	DWORD PTR [rbx+12], eax
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 472  : 	if (interpolation == 3) return color[low];

	jmp	$LN56@getColor
$LN5@getColor:
	mov	QWORD PTR [rsp+64], rbp

; 473  : 	if (interpolation == 2) return color[x-position[low]<position[high]-x?low:high];

	movsxd	rbp, edx
	cmp	ecx, 2
	jne	SHORT $LN6@getColor
	vsubss	xmm2, xmm1, DWORD PTR [r9+rdi*4]
	vmovss	xmm0, DWORD PTR [r9+rbp*4]
	vsubss	xmm1, xmm0, xmm1
	vcomiss	xmm1, xmm2
	cmova	edx, eax
	movsxd	rcx, edx
	shl	rcx, 4
	add	rcx, QWORD PTR [rsi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rbx+12], eax
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 473  : 	if (interpolation == 2) return color[x-position[low]<position[high]-x?low:high];

	jmp	SHORT $LN55@getColor
$LN6@getColor:

; 474  : 	float mult = interpolate(x, position[low], position[high]);

	vmovss	xmm3, DWORD PTR [r9+rbp*4]
	vmovss	xmm2, DWORD PTR [r9+rdi*4]
	mov	rcx, rsi
	call	?interpolate@GradientRamp@@QEAAMMMM@Z	; GradientRamp::interpolate

; 475  : 	return color[low] * (1.f - mult) + color[high] * mult;

	vsubss	xmm3, xmm6, xmm0
	vmovaps	xmm4, xmm0
	shl	rbp, 4
	add	rbp, QWORD PTR [rsi+40]
	shl	rdi, 4
	add	rdi, QWORD PTR [rsi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmulss	xmm0, xmm0, DWORD PTR [rbp]
	vmulss	xmm1, xmm3, DWORD PTR [rdi]
	vmulss	xmm2, xmm3, DWORD PTR [rdi+4]

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vaddss	xmm1, xmm1, xmm0

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmulss	xmm0, xmm4, DWORD PTR [rbp+4]

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	DWORD PTR [rbx], xmm1
	vaddss	xmm1, xmm2, xmm0

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmulss	xmm2, xmm3, DWORD PTR [rdi+8]
	vmulss	xmm0, xmm4, DWORD PTR [rbp+8]

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	DWORD PTR [rbx+4], xmm1
	vaddss	xmm1, xmm2, xmm0

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmulss	xmm2, xmm3, DWORD PTR [rdi+12]
	vmulss	xmm0, xmm4, DWORD PTR [rbp+12]

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	DWORD PTR [rbx+8], xmm1
	vaddss	xmm1, xmm2, xmm0
	vmovss	DWORD PTR [rbx+12], xmm1
$LN55@getColor:
	mov	rbp, QWORD PTR [rsp+64]
$LN56@getColor:
	mov	rdi, QWORD PTR [rsp+72]
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 476  : }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+80]
	vmovaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
?getColor@GradientRamp@@QEAA?AVAColor@@M@Z ENDP		; GradientRamp::getColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?interpolate@GradientRamp@@QEAAMMMM@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
low$ = 24
high$ = 32
?interpolate@GradientRamp@@QEAAMMMM@Z PROC		; GradientRamp::interpolate, COMDAT

; 453  : 	//int interpolation; // 0 linear 1 smooth 2 solid near 3 solid left 4 solid right	
; 454  : 	switch (interpolation) {

	mov	edx, DWORD PTR [rcx+64]
	test	edx, edx
	je	SHORT $LN4@interpolat
	cmp	edx, 1
	je	SHORT $LN5@interpolat
	vxorps	xmm0, xmm0, xmm0

; 462  : 	}
; 463  : 	return 0.f;
; 464  : }

	ret	0
$LN5@interpolat:

; 457  : 		case 1:	
; 458  : 			x = (x-low)/(high-low);

	vsubss	xmm0, xmm3, xmm2
	vsubss	xmm1, xmm1, xmm2
	vdivss	xmm4, xmm1, xmm0
	vxorps	xmm3, xmm3, xmm3

; 459  : 			if (x < 0.f) x = 0.f;

	vcomiss	xmm3, xmm4
	ja	SHORT $LN8@interpolat

; 460  : 			else if (x > 1.f) x = 1.f;

	vmovss	xmm0, DWORD PTR __real@3f800000
	vminss	xmm3, xmm0, xmm4
$LN8@interpolat:

; 461  : 			return (x*x*(3.f-2.f*x));

	vmovss	xmm0, DWORD PTR __real@40400000
	vaddss	xmm1, xmm3, xmm3
	vsubss	xmm2, xmm0, xmm1
	vmulss	xmm1, xmm3, xmm3
	vmulss	xmm0, xmm2, xmm1

; 462  : 	}
; 463  : 	return 0.f;
; 464  : }

	ret	0
$LN4@interpolat:

; 455  : 		case 0:	
; 456  : 			return (x - low) / (high - low);

	vsubss	xmm1, xmm1, xmm2
	vsubss	xmm0, xmm3, xmm2
	vdivss	xmm0, xmm1, xmm0

; 462  : 	}
; 463  : 	return 0.f;
; 464  : }

	ret	0
?interpolate@GradientRamp@@QEAAMMMM@Z ENDP		; GradientRamp::interpolate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?findHighKey@GradientRamp@@QEAAHM@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
?findHighKey@GradientRamp@@QEAAHM@Z PROC		; GradientRamp::findHighKey, COMDAT

; 437  : 	int low = 0;
; 438  : 	int high = keys-1;
; 439  : 	int mid;	
; 440  : 	if (x < position[low])

	mov	r9, QWORD PTR [rcx+32]
	xor	r8d, r8d
	mov	edx, DWORD PTR [rcx+56]
	dec	edx
	vmovss	xmm0, DWORD PTR [r9]
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN8@findHighKe

; 441  : 		return low;

	xor	eax, eax

; 450  : }

	ret	0
$LN8@findHighKe:

; 442  : 	while (low < (high-1)) {

	lea	eax, DWORD PTR [rdx-1]
	test	eax, eax
	jle	SHORT $LN3@findHighKe
$LL2@findHighKe:

; 443  : 		mid = (low + high) / 2;

	lea	ecx, DWORD PTR [rdx+r8]
	test	ecx, ecx
	jns	SHORT $LN11@findHighKe
	inc	ecx
$LN11@findHighKe:
	sar	ecx, 1

; 444  : 		if (x < position[mid])

	movsxd	rax, ecx
	vmovss	xmm0, DWORD PTR [r9+rax*4]
	vcomiss	xmm0, xmm1
	mov	eax, ecx
	cmovbe	eax, edx
	cmovbe	r8d, ecx
	mov	edx, eax
	lea	ecx, DWORD PTR [rax-1]
	cmp	r8d, ecx
	jl	SHORT $LL2@findHighKe
$LN3@findHighKe:

; 445  : 			high  = mid;
; 446  : 		else
; 447  : 			low = mid;		
; 448  : 	}
; 449  : 	return high;

	mov	eax, edx

; 450  : }

	ret	0
?findHighKey@GradientRamp@@QEAAHM@Z ENDP		; GradientRamp::findHighKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?setSubtex@GradientRamp@@QEAAXPEAVTexmap@@@Z
_TEXT	SEGMENT
this$ = 8
sub$ = 16
?setSubtex@GradientRamp@@QEAAXPEAVTexmap@@@Z PROC	; GradientRamp::setSubtex, COMDAT

; 412  : 	if (selected >= 0 && selected < keys)

	mov	r9d, DWORD PTR [rcx+60]
	mov	r11, rdx
	mov	r10, rcx
	test	r9d, r9d
	js	SHORT $LN2@setSubtex
	movsxd	rax, DWORD PTR [rcx+56]
	cmp	r9d, eax
	jge	SHORT $LN2@setSubtex

; 159  : 	for (int i=0;i<keys;i++)

	xor	r8d, r8d
	test	eax, eax
	jle	SHORT $LN8@setSubtex
	mov	rdx, rax
	mov	ecx, r8d

; 160  : 		if (number[i] == n)

	mov	rax, QWORD PTR [r10+48]
	npad	7
$LL9@setSubtex:
	cmp	DWORD PTR [rax], r9d
	je	SHORT $LN6@setSubtex

; 159  : 	for (int i=0;i<keys;i++)

	inc	r8d
	inc	rcx
	add	rax, 4
	cmp	rcx, rdx
	jl	SHORT $LL9@setSubtex
$LN8@setSubtex:

; 161  : 			return i;
; 162  : 	return -1;

	mov	r8d, -1
$LN6@setSubtex:

; 408  : 	subtex[toIndex(n)] = sub;

	mov	rax, QWORD PTR [r10+24]
	movsxd	rcx, r8d
	mov	QWORD PTR [rax+rcx*8], r11
$LN2@setSubtex:

; 413  : 		setSubtex(selected, sub);
; 414  : }	

	ret	0
?setSubtex@GradientRamp@@QEAAXPEAVTexmap@@@Z ENDP	; GradientRamp::setSubtex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z
_TEXT	SEGMENT
this$ = 8
n$ = 16
sub$ = 24
?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z PROC	; GradientRamp::setSubtex, COMDAT

; 407  : void GradientRamp::setSubtex(int n, Texmap* sub) {

$LN15:
	mov	QWORD PTR [rsp+8], rbx

; 159  : 	for (int i=0;i<keys;i++)

	movsxd	rax, DWORD PTR [rcx+56]
	xor	r10d, r10d

; 407  : void GradientRamp::setSubtex(int n, Texmap* sub) {

	mov	rbx, rcx

; 159  : 	for (int i=0;i<keys;i++)

	test	eax, eax
	jle	SHORT $LN5@setSubtex
	mov	r11, rax
	mov	r9d, r10d

; 160  : 		if (number[i] == n)

	mov	rax, QWORD PTR [rcx+48]
	npad	3
$LL6@setSubtex:
	cmp	DWORD PTR [rax], edx
	je	SHORT $LN3@setSubtex

; 159  : 	for (int i=0;i<keys;i++)

	inc	r10d
	inc	r9
	add	rax, 4
	cmp	r9, r11
	jl	SHORT $LL6@setSubtex
$LN5@setSubtex:

; 161  : 			return i;
; 162  : 	return -1;

	mov	r10d, -1
$LN3@setSubtex:

; 408  : 	subtex[toIndex(n)] = sub;

	mov	rax, QWORD PTR [rbx+24]

; 409  : }

	mov	rbx, QWORD PTR [rsp+8]
	movsxd	rcx, r10d
	mov	QWORD PTR [rax+rcx*8], r8
	ret	0
?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z ENDP	; GradientRamp::setSubtex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?getSubtex@GradientRamp@@QEAAPEAVTexmap@@H@Z
_TEXT	SEGMENT
this$ = 8
n$ = 16
?getSubtex@GradientRamp@@QEAAPEAVTexmap@@H@Z PROC	; GradientRamp::getSubtex, COMDAT

; 396  : Texmap* GradientRamp::getSubtex(int n) {

	mov	r8d, edx
	mov	r9, rcx

; 397  : 	if (n == -1)

	cmp	edx, -1
	jne	SHORT $LN2@getSubtex

; 398  : 		if (selected >= 0 && selected < keys)

	mov	r8d, DWORD PTR [rcx+60]
	test	r8d, r8d
	js	SHORT $LN4@getSubtex
	movsxd	rcx, DWORD PTR [rcx+56]
	cmp	r8d, ecx
	jge	SHORT $LN4@getSubtex

; 159  : 	for (int i=0;i<keys;i++)

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN15@getSubtex
	mov	r10, rcx
	mov	edx, eax

; 160  : 		if (number[i] == n)

	mov	rcx, QWORD PTR [r9+48]
	npad	4
$LL10@getSubtex:
	cmp	DWORD PTR [rcx], r8d
	je	SHORT $LN13@getSubtex

; 159  : 	for (int i=0;i<keys;i++)

	inc	eax
	inc	rdx
	add	rcx, 4
	cmp	rdx, r10
	jl	SHORT $LL10@getSubtex

; 402  : 	else
; 403  : 		return subtex[toIndex(n)]; 
; 404  : }

	mov	eax, -1
	movsxd	rcx, eax
	mov	rax, QWORD PTR [r9+24]
	mov	rax, QWORD PTR [rax+rcx*8]
	ret	0
$LN4@getSubtex:

; 399  : 			return subtex[toIndex(selected)];
; 400  : 		else
; 401  : 			return NULL;

	xor	eax, eax

; 402  : 	else
; 403  : 		return subtex[toIndex(n)]; 
; 404  : }

	ret	0
$LN2@getSubtex:

; 159  : 	for (int i=0;i<keys;i++)

	movsxd	rcx, DWORD PTR [rcx+56]
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN15@getSubtex
	mov	r10, rcx
	mov	edx, eax

; 160  : 		if (number[i] == n)

	mov	rcx, QWORD PTR [r9+48]
	npad	6
$LL16@getSubtex:
	cmp	DWORD PTR [rcx], r8d
	je	SHORT $LN13@getSubtex

; 159  : 	for (int i=0;i<keys;i++)

	inc	eax
	inc	rdx
	add	rcx, 4
	cmp	rdx, r10
	jl	SHORT $LL16@getSubtex
$LN15@getSubtex:

; 402  : 	else
; 403  : 		return subtex[toIndex(n)]; 
; 404  : }

	mov	eax, -1
$LN13@getSubtex:
	movsxd	rcx, eax
	mov	rax, QWORD PTR [r9+24]
	mov	rax, QWORD PTR [rax+rcx*8]
	ret	0
?getSubtex@GradientRamp@@QEAAPEAVTexmap@@H@Z ENDP	; GradientRamp::getSubtex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?sort@GradientRamp@@QEAAXXZ
_TEXT	SEGMENT
col$1 = 0
this$ = 32
?sort@GradientRamp@@QEAAXXZ PROC			; GradientRamp::sort, COMDAT

; 378  : void GradientRamp::sort() {

$LN16:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 16

; 379  : 	int i = 1;	

	mov	ebx, 1
	mov	rdi, rcx

; 380  : 	while (i < keys) {

	cmp	DWORD PTR [rcx+56], ebx
	jle	$LN3@sort
	mov	QWORD PTR [rsp+32], rsi
	mov	r11d, ebx
	mov	QWORD PTR [rsp+40], r14
	npad	8
$LL2@sort:

; 381  : 		if (position[i-1] <= position[i]) {

	mov	rax, QWORD PTR [rdi+32]
	lea	rsi, QWORD PTR [r11-1]
	lea	r14, QWORD PTR [r11*4]
	vmovss	xmm2, DWORD PTR [rax+rsi*4]
	vmovss	xmm0, DWORD PTR [r14+rax]
	vcomiss	xmm0, xmm2
	jb	SHORT $LN4@sort

; 382  : 	        i++;			

	inc	ebx
	inc	r11

; 383  : 		} else {

	jmp	$LN6@sort
$LN4@sort:

; 362  : 	Texmap* sub	= subtex[a];

	mov	rcx, QWORD PTR [rdi+24]

; 366  : 	
; 367  : 	subtex[a]	= subtex[b];

	lea	rdx, QWORD PTR [r11*8]
	mov	rax, QWORD PTR [rdi+40]

; 369  : 	color[a]	= color[b];

	add	r11, r11
	mov	r9, rsi

; 384  : 			swap(i-1, i);
; 385  : 			i--;

	dec	ebx

; 364  : 	AColor col	= color[a];

	add	r9, r9
	mov	r10, QWORD PTR [rcx+rsi*8]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	xmm0, XMMWORD PTR [rax+r9*8]
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 365  : 	int num		= number[a];

	mov	rax, QWORD PTR [rdi+48]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	XMMWORD PTR col$1[rsp], xmm0
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 365  : 	int num		= number[a];

	mov	r8d, DWORD PTR [rax+rsi*4]

; 366  : 	
; 367  : 	subtex[a]	= subtex[b];

	mov	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR [rcx+rsi*8], rax

; 368  : 	position[a] = position[b];

	mov	rcx, QWORD PTR [rdi+32]
	mov	eax, DWORD PTR [rcx+r14]
	mov	DWORD PTR [rcx+rsi*4], eax

; 369  : 	color[a]	= color[b];

	mov	rax, QWORD PTR [rdi+40]
	vmovups	xmm0, XMMWORD PTR [rax+r11*8]
	vmovups	XMMWORD PTR [rax+r9*8], xmm0

; 370  : 	number[a]	= number[b];

	mov	rcx, QWORD PTR [rdi+48]

; 371  : 
; 372  : 	subtex[b]	= sub;
; 373  : 	position[b] = pos;
; 374  : 	color[b]	= col;

	vmovups	xmm0, XMMWORD PTR col$1[rsp]
	mov	eax, DWORD PTR [rcx+r14]
	mov	DWORD PTR [rcx+rsi*4], eax
	mov	rax, QWORD PTR [rdi+24]
	mov	QWORD PTR [rdx+rax], r10
	mov	rax, QWORD PTR [rdi+32]
	vmovss	DWORD PTR [r14+rax], xmm2
	mov	rax, QWORD PTR [rdi+40]
	vmovups	XMMWORD PTR [rax+r11*8], xmm0

; 375  : 	number[b]	= num;

	mov	rax, QWORD PTR [rdi+48]

; 384  : 			swap(i-1, i);
; 385  : 			i--;

	mov	r11, rsi

; 375  : 	number[b]	= num;

	mov	DWORD PTR [r14+rax], r8d

; 386  : 			if (i <= 0)

	test	rsi, rsi
	jg	SHORT $LN6@sort

; 387  : 				i = 1;

	mov	ebx, 1
	mov	r11d, ebx
$LN6@sort:

; 380  : 	while (i < keys) {

	cmp	ebx, DWORD PTR [rdi+56]
	jl	$LL2@sort
	mov	r14, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+32]
$LN3@sort:

; 388  : 		}
; 389  : 	} 
; 390  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 16
	pop	rdi
	ret	0
?sort@GradientRamp@@QEAAXXZ ENDP			; GradientRamp::sort
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?swap@GradientRamp@@QEAAXHH@Z
_TEXT	SEGMENT
col$ = 0
this$ = 32
a$ = 40
b$ = 48
?swap@GradientRamp@@QEAAXHH@Z PROC			; GradientRamp::swap, COMDAT

; 361  : void GradientRamp::swap(int a, int b) {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 16

; 362  : 	Texmap* sub	= subtex[a];

	mov	r9, QWORD PTR [rcx+24]
	mov	r14, rcx

; 363  : 	float pos	= position[a];

	mov	rax, QWORD PTR [rcx+32]
	movsxd	rsi, edx
	mov	rbp, QWORD PTR [r9+rsi*8]
	lea	r10, QWORD PTR [r9+rsi*8]

; 366  : 	
; 367  : 	subtex[a]	= subtex[b];

	movsxd	r11, r8d
	lea	rdi, QWORD PTR [rsi*4]
	add	rsi, rsi
	vmovss	xmm2, DWORD PTR [rdi+rax]
	mov	rax, QWORD PTR [rcx+40]

; 368  : 	position[a] = position[b];

	lea	r8, QWORD PTR [r11*4]
	lea	rdx, QWORD PTR [r11*8]

; 369  : 	color[a]	= color[b];

	add	r11, r11
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	xmm0, XMMWORD PTR [rax+rsi*8]
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 365  : 	int num		= number[a];

	mov	rax, QWORD PTR [rcx+48]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	XMMWORD PTR col$[rsp], xmm0
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 365  : 	int num		= number[a];

	mov	ebx, DWORD PTR [rdi+rax]

; 366  : 	
; 367  : 	subtex[a]	= subtex[b];

	mov	rax, QWORD PTR [rdx+r9]
	mov	QWORD PTR [r10], rax

; 368  : 	position[a] = position[b];

	mov	rcx, QWORD PTR [rcx+32]
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rdi+rcx], eax

; 369  : 	color[a]	= color[b];

	mov	rax, QWORD PTR [r14+40]
	vmovups	xmm0, XMMWORD PTR [rax+r11*8]
	vmovups	XMMWORD PTR [rax+rsi*8], xmm0

; 370  : 	number[a]	= number[b];

	mov	rcx, QWORD PTR [r14+48]

; 371  : 
; 372  : 	subtex[b]	= sub;
; 373  : 	position[b] = pos;
; 374  : 	color[b]	= col;

	vmovups	xmm0, XMMWORD PTR col$[rsp]

; 375  : 	number[b]	= num;
; 376  : }

	mov	rsi, QWORD PTR [rsp+48]
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rdi+rcx], eax
	mov	rax, QWORD PTR [r14+24]
	mov	rdi, QWORD PTR [rsp+56]
	mov	QWORD PTR [rdx+rax], rbp
	mov	rax, QWORD PTR [r14+32]
	mov	rbp, QWORD PTR [rsp+40]
	vmovss	DWORD PTR [r8+rax], xmm2
	mov	rax, QWORD PTR [r14+40]
	vmovups	XMMWORD PTR [rax+r11*8], xmm0
	mov	rax, QWORD PTR [r14+48]
	mov	DWORD PTR [r8+rax], ebx
	mov	rbx, QWORD PTR [rsp+32]
	add	rsp, 16
	pop	r14
	ret	0
?swap@GradientRamp@@QEAAXHH@Z ENDP			; GradientRamp::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?reset@GradientRamp@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
this$ = 80
?reset@GradientRamp@@QEAAXXZ PROC			; GradientRamp::reset, COMDAT

; 344  : void GradientRamp::reset() {		

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 345  : 	keys = 0;

	xor	edi, edi
	mov	rbx, rcx
	mov	DWORD PTR [rcx+56], edi

; 346  : 	
; 347  : 	if (subtex) delete[] subtex;

	mov	rcx, QWORD PTR [rcx+24]
	test	rcx, rcx
	je	SHORT $LN2@reset
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN2@reset:

; 348  : 	if (position) delete[] position;

	mov	rcx, QWORD PTR [rbx+32]
	test	rcx, rcx
	je	SHORT $LN3@reset
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN3@reset:

; 349  : 	if (color) delete[] color;

	mov	rcx, QWORD PTR [rbx+40]
	test	rcx, rcx
	je	SHORT $LN4@reset
	call	QWORD PTR __imp_??_VMaxHeapOperators@@SAXPEAX@Z
$LN4@reset:

; 350  : 	if (number) delete[] number;

	mov	rcx, QWORD PTR [rbx+48]
	test	rcx, rcx
	je	SHORT $LN5@reset
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN5@reset:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovups	xmm0, XMMWORD PTR __xmm@3f800000000000000000000000000000
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 357  : 	addKey(0, 0.f, AColor(0.f,0.f,0.f,1.f), NULL);

	lea	r9, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rbx+24], rdi
	vxorps	xmm2, xmm2, xmm2
	xor	edx, edx
	mov	QWORD PTR [rbx+32], rdi
	mov	rcx, rbx
	mov	QWORD PTR [rbx+40], rdi
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovups	XMMWORD PTR $T2[rsp], xmm0
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 355  : 	number = NULL;

	mov	QWORD PTR [rbx+48], rdi

; 357  : 	addKey(0, 0.f, AColor(0.f,0.f,0.f,1.f), NULL);

	mov	QWORD PTR [rsp+32], rdi
	call	?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z ; GradientRamp::addKey
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovups	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 358  : 	addKey(1, 1.f, AColor(1.f,1.f,1.f,1.f), NULL);	

	vmovss	xmm2, DWORD PTR __real@3f800000
	lea	r9, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rsp+32], rdi
	mov	edx, 1
	mov	rcx, rbx
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovups	XMMWORD PTR $T1[rsp], xmm0
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 358  : 	addKey(1, 1.f, AColor(1.f,1.f,1.f,1.f), NULL);	

	call	?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z ; GradientRamp::addKey

; 359  : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?reset@GradientRamp@@QEAAXXZ ENDP			; GradientRamp::reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z
_TEXT	SEGMENT
$T1 = 112
this$ = 112
n$ = 120
pos$ = 128
col$ = 136
sub$ = 144
?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z PROC ; GradientRamp::addKey, COMDAT

; 296  : void GradientRamp::addKey(int n, float pos, AColor col, Texmap* sub) {

$LN39:
	mov	rax, rsp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR [rax-72], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rbp
	mov	QWORD PTR [rax+32], rsi
	vmovaps	XMMWORD PTR [rax-56], xmm6
	mov	r13, r9
	mov	esi, edx
	mov	rbx, rcx
	vxorps	xmm6, xmm6, xmm6

; 297  : 	if (pos < 0.f) pos = 0.f;

	vcomiss	xmm6, xmm2
	ja	SHORT $LN10@addKey

; 298  : 	else if (pos > 1.f) pos = 1.f;

	vmovss	xmm0, DWORD PTR __real@3f800000
	vminss	xmm6, xmm0, xmm2
$LN10@addKey:

; 299  : 
; 300  : 	int key = -1;

	mov	r14, -1
	mov	r8d, r14d

; 301  : 	for (int i=0;i<keys;i++)

	xor	edi, edi
	mov	ecx, edi
	movsxd	r9, DWORD PTR [rbx+56]
	test	r9d, r9d
	jle	SHORT $LN36@addKey

; 302  : 		if (number[i] == n)

	mov	rdx, QWORD PTR [rbx+48]
$LL4@addKey:

; 301  : 	for (int i=0;i<keys;i++)

	mov	eax, ecx
	cmp	DWORD PTR [rdx], esi
	cmovne	eax, r8d
	movsxd	r8, eax
	inc	ecx
	lea	rdx, QWORD PTR [rdx+4]
	cmp	ecx, r9d
	jl	SHORT $LL4@addKey

; 303  : 			key = i;
; 304  : 
; 305  : 	if (key >= 0) { // update only, no keys added

	test	eax, eax
	js	SHORT $LN36@addKey

; 306  : 		subtex[key] = sub;

	mov	rdx, r8
	mov	rcx, QWORD PTR [rbx+24]
	mov	rax, QWORD PTR sub$[rsp]
	mov	QWORD PTR [rcx+r8*8], rax

; 307  : 		position[key] = pos;

	mov	rax, QWORD PTR [rbx+32]
	vmovss	DWORD PTR [rax+r8*4], xmm6

; 308  : 		color[key] = col;

	add	rdx, rdx
	mov	rax, QWORD PTR [rbx+40]
	vmovups	xmm0, XMMWORD PTR [r13]
	vmovups	XMMWORD PTR [rax+rdx*8], xmm0

; 309  : 		return;

	jmp	$LN1@addKey
$LN36@addKey:

; 310  : 	}
; 311  : 
; 312  : 	keys++;	

	lea	eax, DWORD PTR [r9+1]
	mov	DWORD PTR [rbx+56], eax

; 313  : 	Texmap** t_subtex = new Texmap*[keys];

	lea	rcx, QWORD PTR [r9+1]
	mov	eax, 8
	mul	rcx
	cmovo	rax, r14
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r15, rax

; 314  : 	auto t_position = new float[keys];

	movsxd	rcx, DWORD PTR [rbx+56]
	mov	eax, 4
	mul	rcx
	cmovo	rax, r14
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r12, rax

; 315  : 	auto t_color = new AColor[keys];

	movsxd	rcx, DWORD PTR [rbx+56]
	mov	eax, 16
	mul	rcx
	cmovo	rax, r14
	mov	rcx, rax
	call	QWORD PTR __imp_??_UMaxHeapOperators@@SAPEAX_K@Z
	mov	rbp, rax
	mov	QWORD PTR $T1[rsp], rax

; 316  : 	int* t_number = new int[keys];

	movsxd	rcx, DWORD PTR [rbx+56]
	mov	eax, 4
	mul	rcx
	cmovo	rax, r14
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r14, rax

; 317  : 	keys--;

	mov	ecx, DWORD PTR [rbx+56]
	dec	ecx
	mov	DWORD PTR [rbx+56], ecx

; 318  : 
; 319  : 	for (int i=0;i<keys;i++) {

	test	ecx, ecx
	jle	SHORT $LN6@addKey
	mov	r8, rdi
	mov	r9, rdi
	mov	r10, rdi
	mov	r11, r12
	sub	r11, rax
	npad	12
$LL7@addKey:

; 320  : 		t_subtex[i] = subtex[i];

	mov	rax, QWORD PTR [rbx+24]
	mov	rcx, QWORD PTR [r10+rax]
	mov	QWORD PTR [r10+r15], rcx

; 321  : 		t_position[i] = position[i];

	lea	rdx, QWORD PTR [r8+r14]
	mov	rax, QWORD PTR [rbx+32]
	mov	ecx, DWORD PTR [r8+rax]
	mov	DWORD PTR [r11+rdx], ecx

; 322  : 		t_color[i] = color[i];

	mov	rax, QWORD PTR [rbx+40]
	vmovups	xmm0, XMMWORD PTR [rax+r9]
	vmovups	XMMWORD PTR [r9+rbp], xmm0

; 323  : 		t_number[i] = number[i];

	mov	rax, QWORD PTR [rbx+48]
	mov	ecx, DWORD PTR [r8+rax]
	mov	DWORD PTR [rdx], ecx

; 318  : 
; 319  : 	for (int i=0;i<keys;i++) {

	inc	edi
	lea	r10, QWORD PTR [r10+8]
	lea	r9, QWORD PTR [r9+16]
	lea	r8, QWORD PTR [r8+4]
	mov	ecx, DWORD PTR [rbx+56]
	cmp	edi, ecx
	jl	SHORT $LL7@addKey
$LN6@addKey:

; 324  : 	}
; 325  : 
; 326  : 	t_subtex[keys] = sub;

	movsxd	rcx, ecx
	mov	rax, QWORD PTR sub$[rsp]
	mov	QWORD PTR [r15+rcx*8], rax

; 327  : 	t_position[keys] = pos;

	movsxd	rax, DWORD PTR [rbx+56]
	vmovss	DWORD PTR [r12+rax*4], xmm6

; 328  : 	t_color[keys] = col;

	movsxd	rax, DWORD PTR [rbx+56]
	add	rax, rax
	vmovups	xmm0, XMMWORD PTR [r13]
	vmovups	XMMWORD PTR [rbp+rax*8], xmm0

; 329  : 	t_number[keys] = n;

	movsxd	rax, DWORD PTR [rbx+56]
	mov	DWORD PTR [r14+rax*4], esi

; 330  : 
; 331  : 	delete[] subtex;

	mov	rcx, QWORD PTR [rbx+24]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 332  : 	delete[] position;

	mov	rcx, QWORD PTR [rbx+32]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 333  : 	delete[] color;

	mov	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR __imp_??_VMaxHeapOperators@@SAXPEAX@Z

; 334  : 	delete[] number;

	mov	rcx, QWORD PTR [rbx+48]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 335  : 
; 336  : 	subtex = t_subtex;

	mov	QWORD PTR [rbx+24], r15

; 337  : 	position = t_position;

	mov	QWORD PTR [rbx+32], r12

; 338  : 	color = t_color;

	mov	QWORD PTR [rbx+40], rbp

; 339  : 	number = t_number;

	mov	QWORD PTR [rbx+48], r14

; 340  : 
; 341  : 	keys++;		

	inc	DWORD PTR [rbx+56]
$LN1@addKey:

; 342  : }

	lea	r11, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	vmovaps	xmm6, XMMWORD PTR [rsp+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z ENDP ; GradientRamp::addKey
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 112
this$ = 112
n$ = 120
pos$ = 128
col$ = 136
sub$ = 144
?dtor$0@?0??addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z@4HA PROC ; `GradientRamp::addKey'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	rex_jmp	QWORD PTR __imp_??_VMaxHeapOperators@@SAXPEAX@Z
?dtor$0@?0??addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z@4HA ENDP ; `GradientRamp::addKey'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 112
this$ = 112
n$ = 120
pos$ = 128
col$ = 136
sub$ = 144
?dtor$0@?0??addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z@4HA PROC ; `GradientRamp::addKey'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	rex_jmp	QWORD PTR __imp_??_VMaxHeapOperators@@SAXPEAX@Z
?dtor$0@?0??addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z@4HA ENDP ; `GradientRamp::addKey'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?selectKey@GradientRamp@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
n$ = 16
?selectKey@GradientRamp@@QEAAXH@Z PROC			; GradientRamp::selectKey, COMDAT

; 270  : 	selected = n;	

	mov	DWORD PTR [rcx+60], edx

; 271  : 	//CharStream *out = thread_local(current_stdout);
; 272  : 	//out->printf("Selection sent (%d)\n", selected);
; 273  : 	parent->gradSelKey();

	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+24]
?selectKey@GradientRamp@@QEAAXH@Z ENDP			; GradientRamp::selectKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?toIndex@GradientRamp@@QEAAHH@Z
_TEXT	SEGMENT
this$ = 8
n$ = 16
?toIndex@GradientRamp@@QEAAHH@Z PROC			; GradientRamp::toIndex, COMDAT

; 159  : 	for (int i=0;i<keys;i++)

	movsxd	rax, DWORD PTR [rcx+56]
	xor	r9d, r9d
	test	eax, eax
	jle	SHORT $LN3@toIndex
	mov	r10, rax
	mov	r8d, r9d

; 160  : 		if (number[i] == n)

	mov	rax, QWORD PTR [rcx+48]
$LL4@toIndex:
	cmp	DWORD PTR [rax], edx
	je	SHORT $LN8@toIndex

; 159  : 	for (int i=0;i<keys;i++)

	inc	r9d
	inc	r8
	add	rax, 4
	cmp	r8, r10
	jl	SHORT $LL4@toIndex
$LN3@toIndex:

; 162  : 	return -1;

	mov	eax, -1

; 163  : }

	ret	0
$LN8@toIndex:

; 161  : 			return i;

	mov	eax, r9d

; 163  : }

	ret	0
?toIndex@GradientRamp@@QEAAHH@Z ENDP			; GradientRamp::toIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?popup@GradientRamp@@QEAAXHHH@Z
_TEXT	SEGMENT
this$ = 48
x$ = 56
y$ = 64
sel$ = 72
?popup@GradientRamp@@QEAAXHHH@Z PROC			; GradientRamp::popup, COMDAT

; 237  : void GradientRamp::popup(int x, int y, int sel) {

$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H

; 183  : 	float f_Width = (float)(width - PADDING * 2);	

	mov	r11d, DWORD PTR [rcx+16]

; 184  : 	for (int i=0;i<keys;i++) {

	xor	r8d, r8d
	mov	r10d, DWORD PTR [rcx+56]

; 237  : void GradientRamp::popup(int x, int y, int sel) {

	mov	rbx, rcx
	vxorps	xmm2, xmm2, xmm2

; 183  : 	float f_Width = (float)(width - PADDING * 2);	

	lea	eax, DWORD PTR [r11-12]
	vcvtsi2ss xmm2, xmm2, eax

; 184  : 	for (int i=0;i<keys;i++) {

	test	r10d, r10d
	jle	SHORT $LN35@popup

; 185  : 		int kx = (int)(f_Width * position[i]) + PADDING;

	mov	rcx, QWORD PTR [rcx+32]
	npad	7
$LL16@popup:
	vmulss	xmm0, xmm2, DWORD PTR [rcx]
	vcvttss2si eax, xmm0

; 186  : 		//out->printf("Hit key: %d %d %d\n", x-dist, x+dist, x);
; 187  : 		if (kx-dist <= x && kx+dist >= x)

	cmp	eax, edx
	jg	SHORT $LN14@popup
	add	eax, 12
	cmp	eax, edx
	jge	SHORT $LN13@popup
$LN14@popup:

; 184  : 	for (int i=0;i<keys;i++) {

	inc	r8d
	add	rcx, 4
	cmp	r8d, r10d
	jl	SHORT $LL16@popup
$LN35@popup:

; 188  : 			return i;
; 189  : 	}
; 190  : 
; 191  : 	// No keys found
; 192  : 	return -1;	

	mov	r8d, -1
$LN13@popup:

; 238  : 	int key = hit(x,y,true);
; 239  : 	switch (sel) {

	sub	r9d, 40005				; 00009c45H
	je	SHORT $LN6@popup
	sub	r9d, 1
	je	SHORT $LN4@popup
	cmp	r9d, 1
	jne	$LN10@popup

; 252  : 				int k = selected;				
; 253  : 				selected = -1;
; 254  : 				parent->gradDelKey(k);
; 255  : 			}
; 256  : 			break;
; 257  : 		case ID_RESET_RESET:
; 258  : 			selected = -1;
; 259  : 			parent->gradReset();

	mov	rcx, QWORD PTR [rbx+8]
	mov	DWORD PTR [rbx+60], -1
	mov	rax, QWORD PTR [rcx]

; 260  : 			break;
; 261  : 	}
; 262  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 252  : 				int k = selected;				
; 253  : 				selected = -1;
; 254  : 				parent->gradDelKey(k);
; 255  : 			}
; 256  : 			break;
; 257  : 		case ID_RESET_RESET:
; 258  : 			selected = -1;
; 259  : 			parent->gradReset();

	rex_jmp	QWORD PTR [rax+32]
$LN4@popup:

; 240  : 		case ID_MENU_ADDKEY:
; 241  : 			if (key == -1) {

	cmp	r8d, -1
	jne	$LN10@popup

; 151  : 	if (x > width - PADDING)

	lea	eax, DWORD PTR [r11-6]
	vxorps	xmm1, xmm1, xmm1
	cmp	edx, eax
	jle	SHORT $LN25@popup

; 152  : 		pos = 1.f;

	vmovss	xmm1, DWORD PTR __real@3f800000
	jmp	SHORT $LN27@popup
$LN25@popup:

; 153  : 	else if (x > PADDING)

	cmp	edx, 6
	jle	SHORT $LN27@popup

; 154  : 		pos = (float)(x - PADDING) / (float)(width - PADDING * 2);

	lea	eax, DWORD PTR [rdx-6]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm2
$LN27@popup:

; 242  : 				parent->gradAddKey(toPos(x));

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax]

; 243  : 				selected = keys - 1; // New key gets the last id

	mov	eax, DWORD PTR [rbx+56]

; 244  : 				parent->gradSelKey();

	mov	rcx, QWORD PTR [rbx+8]
	dec	eax
	mov	DWORD PTR [rbx+60], eax
	mov	rax, QWORD PTR [rcx]

; 260  : 			break;
; 261  : 	}
; 262  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 244  : 				parent->gradSelKey();

	rex_jmp	QWORD PTR [rax+24]
$LN6@popup:

; 245  : 			}
; 246  : 			break;
; 247  : 		case ID_MENU_REMOVEKEY:
; 248  : 			if (key >= 0) {

	mov	edx, DWORD PTR [rbx+60]
	test	r8d, r8d
	js	SHORT $LN7@popup

; 249  : 				if (selected == number[key]) selected = -1;

	mov	rcx, QWORD PTR [rbx+48]
	movsxd	rax, r8d
	mov	r8d, DWORD PTR [rcx+rax*4]
	cmp	edx, r8d
	jne	SHORT $LN9@popup
	mov	DWORD PTR [rbx+60], -1
	mov	r8d, DWORD PTR [rcx+rax*4]
$LN9@popup:

; 260  : 			break;
; 261  : 	}
; 262  : }

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, r8d
	mov	rax, QWORD PTR [rcx]
	add	rsp, 32					; 00000020H
	pop	rbx
	rex_jmp	QWORD PTR [rax+16]
$LN7@popup:

; 250  : 				parent->gradDelKey(number[key]);
; 251  : 			} else if (selected >= 0) {

	test	edx, edx
	js	SHORT $LN10@popup

; 260  : 			break;
; 261  : 	}
; 262  : }

	mov	rcx, QWORD PTR [rbx+8]
	mov	DWORD PTR [rbx+60], -1
	mov	rax, QWORD PTR [rcx]
	add	rsp, 32					; 00000020H
	pop	rbx
	rex_jmp	QWORD PTR [rax+16]
$LN10@popup:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?popup@GradientRamp@@QEAAXHHH@Z ENDP			; GradientRamp::popup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?dragging@GradientRamp@@QEAAXHH_N00@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
ctrl$ = 32
shift$ = 40
alt$ = 48
?dragging@GradientRamp@@QEAAXHH_N00@Z PROC		; GradientRamp::dragging, COMDAT

; 229  : 	if (selected <= 1) // Refuse to move ends and empty

	mov	r8d, DWORD PTR [rcx+60]
	cmp	r8d, 1
	jle	SHORT $LN3@dragging

; 230  : 		return; 	
; 231  : 	if (selected < keys)

	cmp	r8d, DWORD PTR [rcx+56]
	jge	SHORT $LN3@dragging

; 151  : 	if (x > width - PADDING)

	mov	r9d, DWORD PTR [rcx+16]
	vxorps	xmm2, xmm2, xmm2
	lea	eax, DWORD PTR [r9-6]
	cmp	edx, eax
	jle	SHORT $LN6@dragging

; 232  : 		parent->gradMoveKey(selected, toPos(x));		

	mov	rcx, QWORD PTR [rcx+8]
	mov	edx, r8d

; 152  : 		pos = 1.f;

	vmovss	xmm2, DWORD PTR __real@3f800000

; 232  : 		parent->gradMoveKey(selected, toPos(x));		

	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+8]
$LN6@dragging:

; 153  : 	else if (x > PADDING)

	cmp	edx, 6
	jle	SHORT $LN8@dragging

; 154  : 		pos = (float)(x - PADDING) / (float)(width - PADDING * 2);

	lea	eax, DWORD PTR [rdx-6]
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	lea	eax, DWORD PTR [r9-12]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm2, xmm1, xmm0
$LN8@dragging:

; 232  : 		parent->gradMoveKey(selected, toPos(x));		

	mov	rcx, QWORD PTR [rcx+8]
	mov	edx, r8d
	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+8]
$LN3@dragging:

; 233  : 	//CharStream *out = thread_local(current_stdout);
; 234  : 	//out->printf("Move key: %d %f\n", number[selected], pos);
; 235  : }

	ret	0
?dragging@GradientRamp@@QEAAXHH_N00@Z ENDP		; GradientRamp::dragging
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?leftUp@GradientRamp@@QEAAXHH_N00@Z
_TEXT	SEGMENT
this$ = 48
x$ = 56
y$ = 64
ctrl$ = 72
shift$ = 80
alt$ = 88
?leftUp@GradientRamp@@QEAAXHH_N00@Z PROC		; GradientRamp::leftUp, COMDAT

; 212  : void GradientRamp::leftUp(int x, int y, bool ctrl, bool shift, bool alt) {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r10d, edx
	mov	rbx, rcx

; 169  : 	if (y > PADDING && y < (height - PADDING) && !broad)

	cmp	r8d, 6
	jle	SHORT $LN31@leftUp
	mov	eax, DWORD PTR [rcx+20]
	sub	eax, 6
	cmp	r8d, eax
	jl	SHORT $LN30@leftUp

; 170  : 		return -1;
; 171  : 
; 172  : 	// Distance from gradient
; 173  : 	int dist;
; 174  : 	if (broad)
; 175  : 		dist  = ARROWS;
; 176  : 	else if (y < PADDING)

	cmp	r8d, 6
$LN31@leftUp:
	jge	SHORT $LN14@leftUp

; 177  : 		dist = PADDING - y;

	mov	ecx, 6
	sub	ecx, r8d

; 178  : 	else

	jmp	SHORT $LN15@leftUp
$LN14@leftUp:

; 179  : 		dist = y - height + PADDING;	

	mov	ecx, r8d
	sub	ecx, DWORD PTR [rbx+20]
	add	ecx, 6
$LN15@leftUp:

; 180  : 
; 181  : 	//CharStream *out = thread_local(current_stdout);
; 182  : 	// Intersect all keys
; 183  : 	float f_Width = (float)(width - PADDING * 2);	

	mov	eax, DWORD PTR [rbx+16]

; 184  : 	for (int i=0;i<keys;i++) {

	xor	r8d, r8d
	mov	r11d, DWORD PTR [rbx+56]
	sub	eax, 12
	vxorps	xmm1, xmm1, xmm1

; 180  : 
; 181  : 	//CharStream *out = thread_local(current_stdout);
; 182  : 	// Intersect all keys
; 183  : 	float f_Width = (float)(width - PADDING * 2);	

	vcvtsi2ss xmm1, xmm1, eax

; 184  : 	for (int i=0;i<keys;i++) {

	test	r11d, r11d
	jle	SHORT $LN30@leftUp

; 185  : 		int kx = (int)(f_Width * position[i]) + PADDING;

	mov	r9, QWORD PTR [rbx+32]
	npad	12
$LL10@leftUp:
	vmulss	xmm0, xmm1, DWORD PTR [r9]
	vcvttss2si edx, xmm0
	add	edx, 6

; 186  : 		//out->printf("Hit key: %d %d %d\n", x-dist, x+dist, x);
; 187  : 		if (kx-dist <= x && kx+dist >= x)

	mov	eax, edx
	sub	eax, ecx
	cmp	eax, r10d
	jg	SHORT $LN8@leftUp
	lea	eax, DWORD PTR [rdx+rcx]
	cmp	eax, r10d
	jge	SHORT $LN7@leftUp
$LN8@leftUp:

; 184  : 	for (int i=0;i<keys;i++) {

	inc	r8d
	add	r9, 4
	cmp	r8d, r11d
	jl	SHORT $LL10@leftUp
$LN30@leftUp:

; 213  : 	int key = hit(x,y);	 
; 214  : 	if (alt && key == -1) {

	mov	r8d, -1
$LN7@leftUp:
	cmp	BYTE PTR alt$[rsp], 0
	je	$LN4@leftUp
	cmp	r8d, -1
	jne	SHORT $LN2@leftUp

; 151  : 	if (x > width - PADDING)

	mov	ecx, DWORD PTR [rbx+16]
	vxorps	xmm1, xmm1, xmm1
	lea	eax, DWORD PTR [rcx-6]
	cmp	r10d, eax
	jle	SHORT $LN19@leftUp

; 152  : 		pos = 1.f;

	vmovss	xmm1, DWORD PTR __real@3f800000
	jmp	SHORT $LN21@leftUp
$LN19@leftUp:

; 153  : 	else if (x > PADDING)

	cmp	r10d, 6
	jle	SHORT $LN21@leftUp

; 154  : 		pos = (float)(x - PADDING) / (float)(width - PADDING * 2);

	lea	eax, DWORD PTR [r10-6]
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	lea	eax, DWORD PTR [rcx-12]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm1, xmm0
$LN21@leftUp:

; 215  : 		parent->gradAddKey(toPos(x));

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax]

; 216  : 		selected = keys - 1; // New key gets the last id

	mov	eax, DWORD PTR [rbx+56]

; 217  : 		parent->gradSelKey();

	mov	rcx, QWORD PTR [rbx+8]
	dec	eax
	mov	DWORD PTR [rbx+60], eax
	mov	rax, QWORD PTR [rcx]

; 225  : 	}	
; 226  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 217  : 		parent->gradSelKey();

	rex_jmp	QWORD PTR [rax+24]
$LN2@leftUp:

; 218  : 		
; 219  : 		//CharStream *out = thread_local(current_stdout);
; 220  : 		//out->printf("Key added!\n");	
; 221  : 
; 222  : 	} else if (alt && key >= 0) {

	test	r8d, r8d
	js	SHORT $LN4@leftUp

; 223  : 		if (selected == number[key]) selected = -1;

	mov	rcx, QWORD PTR [rbx+48]
	movsxd	rax, r8d
	mov	edx, DWORD PTR [rcx+rax*4]
	cmp	DWORD PTR [rbx+60], edx
	jne	SHORT $LN5@leftUp
	mov	DWORD PTR [rbx+60], -1
	mov	edx, DWORD PTR [rcx+rax*4]
$LN5@leftUp:

; 224  : 		parent->gradDelKey(number[key]);

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rcx]

; 225  : 	}	
; 226  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 224  : 		parent->gradDelKey(number[key]);

	rex_jmp	QWORD PTR [rax+16]
$LN4@leftUp:

; 225  : 	}	
; 226  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?leftUp@GradientRamp@@QEAAXHH_N00@Z ENDP		; GradientRamp::leftUp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?leftDown@GradientRamp@@QEAAXHH_N00@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
ctrl$ = 32
shift$ = 40
alt$ = 48
?leftDown@GradientRamp@@QEAAXHH_N00@Z PROC		; GradientRamp::leftDown, COMDAT

; 183  : 	float f_Width = (float)(width - PADDING * 2);	

	mov	eax, DWORD PTR [rcx+16]

; 195  : void GradientRamp::leftDown(int x, int y, bool ctrl, bool shift, bool alt) {

	mov	r10, rcx

; 184  : 	for (int i=0;i<keys;i++) {

	mov	ecx, DWORD PTR [rcx+56]
	sub	eax, 12
	xor	r8d, r8d
	vxorps	xmm1, xmm1, xmm1

; 183  : 	float f_Width = (float)(width - PADDING * 2);	

	vcvtsi2ss xmm1, xmm1, eax

; 184  : 	for (int i=0;i<keys;i++) {

	test	ecx, ecx
	jle	SHORT $LN27@leftDown

; 185  : 		int kx = (int)(f_Width * position[i]) + PADDING;

	mov	r9, QWORD PTR [r10+32]
	npad	1
$LL9@leftDown:
	vmulss	xmm0, xmm1, DWORD PTR [r9]
	vcvttss2si eax, xmm0

; 186  : 		//out->printf("Hit key: %d %d %d\n", x-dist, x+dist, x);
; 187  : 		if (kx-dist <= x && kx+dist >= x)

	cmp	eax, edx
	jg	SHORT $LN7@leftDown
	add	eax, 12
	cmp	eax, edx
	jge	SHORT $LN6@leftDown
$LN7@leftDown:

; 184  : 	for (int i=0;i<keys;i++) {

	inc	r8d
	add	r9, 4
	cmp	r8d, ecx
	jl	SHORT $LL9@leftDown
$LN27@leftDown:

; 188  : 			return i;
; 189  : 	}
; 190  : 
; 191  : 	// No keys found
; 192  : 	return -1;	

	mov	r8d, -1
$LN6@leftDown:

; 196  : 	int key = hit(x,y,true);
; 197  : 
; 198  : 	//CharStream *out = thread_local(current_stdout);
; 199  : 	//out->printf("Hit key: %d %d\n", key, selected);
; 200  : 	//out->printf("Left down\n");
; 201  : 
; 202  : 	if (!alt && key >= 0) {

	cmp	BYTE PTR alt$[rsp], 0
	jne	SHORT $LN2@leftDown
	test	r8d, r8d
	js	SHORT $LN2@leftDown

; 270  : 	selected = n;	

	mov	rax, QWORD PTR [r10+48]

; 203  : 		selectKey(number[key]);

	movsxd	rcx, r8d

; 270  : 	selected = n;	

	mov	ecx, DWORD PTR [rax+rcx*4]
	mov	DWORD PTR [r10+60], ecx

; 205  : 		selectKey(-1);
; 206  : 	}
; 207  : 
; 208  : 	//out->printf("Selected key: %d\n", selected);
; 209  : 	//out->printf("## Seletion DONE! ##\n", selected);
; 210  : }

	mov	rcx, QWORD PTR [r10+8]
	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+24]
$LN2@leftDown:

; 204  : 	} else if (key == -1) {

	cmp	r8d, -1
	jne	SHORT $LN4@leftDown

; 205  : 		selectKey(-1);
; 206  : 	}
; 207  : 
; 208  : 	//out->printf("Selected key: %d\n", selected);
; 209  : 	//out->printf("## Seletion DONE! ##\n", selected);
; 210  : }

	mov	rcx, QWORD PTR [r10+8]

; 270  : 	selected = n;	

	mov	DWORD PTR [r10+60], r8d

; 205  : 		selectKey(-1);
; 206  : 	}
; 207  : 
; 208  : 	//out->printf("Selected key: %d\n", selected);
; 209  : 	//out->printf("## Seletion DONE! ##\n", selected);
; 210  : }

	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+24]
$LN4@leftDown:
	ret	0
?leftDown@GradientRamp@@QEAAXHH_N00@Z ENDP		; GradientRamp::leftDown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?toPos@GradientRamp@@QEAAMH@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
?toPos@GradientRamp@@QEAAMH@Z PROC			; GradientRamp::toPos, COMDAT

; 150  : 	float pos = 0.f;
; 151  : 	if (x > width - PADDING)

	mov	r8d, DWORD PTR [rcx+16]
	lea	eax, DWORD PTR [r8-6]
	cmp	edx, eax
	jle	SHORT $LN2@toPos

; 155  : 	return pos;

	vmovss	xmm0, DWORD PTR __real@3f800000

; 156  : }

	ret	0
$LN2@toPos:

; 152  : 		pos = 1.f;
; 153  : 	else if (x > PADDING)

	vxorps	xmm0, xmm0, xmm0
	cmp	edx, 6
	jle	SHORT $LN4@toPos

; 154  : 		pos = (float)(x - PADDING) / (float)(width - PADDING * 2);

	lea	eax, DWORD PTR [rdx-6]
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	lea	eax, DWORD PTR [r8-12]
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm0, xmm1, xmm0
$LN4@toPos:

; 156  : }

	ret	0
?toPos@GradientRamp@@QEAAMH@Z ENDP			; GradientRamp::toPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?hit@GradientRamp@@QEAAHHH_N@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
broad$ = 32
?hit@GradientRamp@@QEAAHHH_N@Z PROC			; GradientRamp::hit, COMDAT

; 167  : int GradientRamp::hit(int x, int y, bool broad) {

$LN21:
	mov	QWORD PTR [rsp+8], rbx
	movzx	r10d, r9b
	mov	r9, rcx
	mov	r11d, edx

; 168  : 	// On gradient, no keys there
; 169  : 	if (y > PADDING && y < (height - PADDING) && !broad)

	cmp	r8d, 6
	jle	SHORT $LN18@hit
	mov	eax, DWORD PTR [rcx+20]
	sub	eax, 6
	cmp	r8d, eax
	jge	SHORT $LN18@hit
	test	r10b, r10b
	jne	SHORT $LN17@hit
$LN19@hit:

; 188  : 			return i;
; 189  : 	}
; 190  : 
; 191  : 	// No keys found
; 192  : 	return -1;	

	mov	eax, -1

; 193  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN18@hit:

; 170  : 		return -1;
; 171  : 
; 172  : 	// Distance from gradient
; 173  : 	int dist;
; 174  : 	if (broad)

	test	r10b, r10b
	je	SHORT $LN6@hit
$LN17@hit:

; 175  : 		dist  = ARROWS;

	mov	ecx, 6
	jmp	SHORT $LN9@hit
$LN6@hit:

; 176  : 	else if (y < PADDING)

	cmp	r8d, 6
	jge	SHORT $LN8@hit

; 177  : 		dist = PADDING - y;

	mov	ecx, 6
	sub	ecx, r8d

; 178  : 	else

	jmp	SHORT $LN9@hit
$LN8@hit:

; 179  : 		dist = y - height + PADDING;	

	mov	ecx, r8d
	sub	ecx, DWORD PTR [r9+20]
	add	ecx, 6
$LN9@hit:

; 180  : 
; 181  : 	//CharStream *out = thread_local(current_stdout);
; 182  : 	// Intersect all keys
; 183  : 	float f_Width = (float)(width - PADDING * 2);	

	mov	eax, DWORD PTR [r9+16]

; 184  : 	for (int i=0;i<keys;i++) {

	xor	r10d, r10d
	sub	eax, 12
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	movsxd	rax, DWORD PTR [r9+56]
	test	eax, eax
	jle	SHORT $LN19@hit

; 185  : 		int kx = (int)(f_Width * position[i]) + PADDING;

	mov	r9, QWORD PTR [r9+32]
	mov	rbx, rax
	mov	r8d, r10d
	npad	6
$LL4@hit:
	vmulss	xmm0, xmm1, DWORD PTR [r9]
	vcvttss2si edx, xmm0
	add	edx, 6

; 186  : 		//out->printf("Hit key: %d %d %d\n", x-dist, x+dist, x);
; 187  : 		if (kx-dist <= x && kx+dist >= x)

	mov	eax, edx
	sub	eax, ecx
	cmp	eax, r11d
	jg	SHORT $LN2@hit
	lea	eax, DWORD PTR [rdx+rcx]
	cmp	eax, r11d
	jge	SHORT $LN13@hit
$LN2@hit:

; 184  : 	for (int i=0;i<keys;i++) {

	inc	r10d
	inc	r8
	add	r9, 4
	cmp	r8, rbx
	jl	SHORT $LL4@hit

; 188  : 			return i;
; 189  : 	}
; 190  : 
; 191  : 	// No keys found
; 192  : 	return -1;	

	mov	eax, -1

; 193  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN13@hit:
	mov	rbx, QWORD PTR [rsp+8]
	mov	eax, r10d
	ret	0
?hit@GradientRamp@@QEAAHHH_N@Z ENDP			; GradientRamp::hit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?invalidate@GradientRamp@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?invalidate@GradientRamp@@QEAAXXZ PROC			; GradientRamp::invalidate, COMDAT

; 137  :    if (m_hWnd == NULL) return;

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN1@invalidate

; 138  :    //RECT rect;
; 139  :    //GetClientRect(m_hWnd, &rect);
; 140  :    //MapWindowPoints(m_hWnd, p_hWnd, (POINT*)&rect, 2);
; 141  :    //InvalidateRect(p_hWnd, &rect, TRUE);
; 142  :    InvalidateRect(m_hWnd, NULL, TRUE);

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+1]
	rex_jmp	QWORD PTR __imp_InvalidateRect
$LN1@invalidate:

; 143  : }

	ret	0
?invalidate@GradientRamp@@QEAAXXZ ENDP			; GradientRamp::invalidate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z
_TEXT	SEGMENT
tv358 = 32
this$ = 96
px$ = 104
py$ = 112
up$ = 120
hDC$ = 128
colR$ = 136
?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z PROC	; GradientRamp::paintArrow, COMDAT

; 123  : void GradientRamp::paintArrow(int px, int py, bool up, HDC hDC, COLORREF colR) {

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	BYTE PTR [rsp+32], r9b
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 124  : 	int offset = 0;

	mov	ebp, DWORD PTR colR$[rsp]
	xor	r15d, r15d
	mov	r14, QWORD PTR hDC$[rsp]
	mov	eax, r8d
	sub	eax, edx
	mov	r13d, r8d
	mov	esi, edx
	mov	DWORD PTR tv358[rsp], eax
	lea	edi, QWORD PTR [r15+1]
$LL4@paintArrow:

; 126  : 		for (int x=0;x<(y*2+1);x++) {

	xor	ebx, ebx
	test	edi, edi
	jle	SHORT $LN5@paintArrow

; 127  : 			if (up)

	test	r9b, r9b
	je	SHORT $LN8@paintArrow
$LL7@paintArrow:

; 128  : 				SetPixel(hDC, px+x-offset, py+y, colR);

	lea	r8d, DWORD PTR [r15+r13]
	mov	r9d, ebp
	lea	edx, DWORD PTR [rsi+rbx]
	mov	rcx, r14
	call	QWORD PTR __imp_SetPixel
	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LL7@paintArrow

; 129  : 			else

	jmp	SHORT $LN24@paintArrow
$LN8@paintArrow:
	lea	r12d, DWORD PTR [rax+rsi]
	npad	1
$LL15@paintArrow:

; 130  : 				SetPixel(hDC, px+x-offset, py-y, colR);

	lea	edx, DWORD PTR [rsi+rbx]
	mov	r9d, ebp
	mov	r8d, r12d
	mov	rcx, r14
	call	QWORD PTR __imp_SetPixel
	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LL15@paintArrow
$LN24@paintArrow:

; 125  : 	for (int y=0;y<ARROWS;y++) {

	movzx	r9d, BYTE PTR up$[rsp]
	mov	eax, DWORD PTR tv358[rsp]
$LN5@paintArrow:
	inc	r15d
	add	edi, 2
	dec	esi
	cmp	edi, 13
	jl	SHORT $LL4@paintArrow

; 131  : 		}
; 132  : 		offset++;
; 133  : 	}
; 134  : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z ENDP	; GradientRamp::paintArrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
_TEXT	SEGMENT
tv1314 = 80
col$1 = 80
hbm_oldBuffer$1$ = 96
hbm_Buffer$1$ = 104
rect$ = 112
this$ = 256
hDC$ = 264
sel$1$ = 272
i$1$ = 280
?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z PROC		; GradientRamp::paint, COMDAT

; 42   : void GradientRamp::paint(HDC hDC) {	

$LN102:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rdx
	mov	QWORD PTR [rax+8], rcx
	push	rbx
	push	rbp
	sub	rsp, 232				; 000000e8H

; 43   : 	if (m_hWnd == NULL) return;

	cmp	QWORD PTR [rcx], 0
	mov	rbx, rdx
	mov	rbp, rcx
	je	$LN1@paint

; 44   : 	//SetBkMode(hDC, TRANSPARENT);	
; 45   : 
; 46   : 	//RECT rect;
; 47   : 	//GetClientRect(m_hWnd, &rect);
; 48   : 	
; 49   : 	/*SelectObject(hdc,red_pen);
; 50   : 	MoveToEx(hdc,10,20,NULL);
; 51   : 	LineTo(hdc,10,40,NULL);
; 52   : 	LineTo(hdc,50,150,NULL);*/
; 53   : 	/*	
; 54   : 	int width = rect.right - rect.left;
; 55   : 	int height = rect.top - rect.bottom;
; 56   : 
; 57   : 	RECT rect2;
; 58   : 	GetWindowRect(m_hWnd, &rect2);
; 59   : 									
; 60   : 	CharStream *out = thread_local(current_stdout);
; 61   : 	out->printf("Rectangle: %d %d %d %d\n", rect.left, rect.right, rect.top, rect.bottom);
; 62   : 	out->printf("Rectangle2: %d %d %d %d\n", (int)(rect2.left, (int)(rect2.right), (int)(rect2.top), (int)(rect2.bottom));
; 63   : 	*/
; 64   : 
; 65   : 	HDC tempHDC = CreateCompatibleDC(hDC);

	mov	QWORD PTR [rax-24], rsi
	mov	rcx, rdx
	mov	QWORD PTR [rax-32], rdi
	mov	QWORD PTR [rax-40], r12
	mov	QWORD PTR [rax-56], r14
	mov	QWORD PTR [rax-64], r15
	vmovaps	XMMWORD PTR [rax-120], xmm8
	call	QWORD PTR __imp_CreateCompatibleDC

; 66   : 	HBITMAP hbm_Buffer = CreateCompatibleBitmap(hDC, width, height);

	mov	r8d, DWORD PTR [rbp+20]
	mov	rcx, rbx
	mov	edx, DWORD PTR [rbp+16]
	mov	rdi, rax
	call	QWORD PTR __imp_CreateCompatibleBitmap

; 67   : 	HBITMAP hbm_oldBuffer = (HBITMAP)SelectObject(tempHDC, hbm_Buffer);

	mov	rdx, rax
	mov	QWORD PTR hbm_Buffer$1$[rsp], rax
	mov	rcx, rdi
	call	QWORD PTR __imp_SelectObject

; 68   : 
; 69   : 	// Borders
; 70   : 	RECT rect;	
; 71   : 	HBRUSH gray = CreateSolidBrush(RGB(175,175,175)); 	

	mov	ecx, 11513775				; 00afafafH
	mov	QWORD PTR hbm_oldBuffer$1$[rsp], rax
	call	QWORD PTR __imp_CreateSolidBrush

; 72   : 	rect.left = 0; rect.top = 0; rect.right = width; rect.bottom = PADDING;

	mov	ecx, DWORD PTR [rbp+16]

; 73   : 	FillRect(tempHDC,&rect,gray);

	lea	rdx, QWORD PTR rect$[rsp]
	mov	DWORD PTR rect$[rsp+8], ecx
	xor	esi, esi
	mov	rcx, rdi
	mov	QWORD PTR rect$[rsp], rsi
	mov	r8, rax
	mov	DWORD PTR rect$[rsp+12], 6
	mov	rbx, rax
	call	QWORD PTR __imp_FillRect

; 74   : 	rect.right = PADDING; rect.bottom = height;

	mov	ecx, DWORD PTR [rbp+20]

; 75   : 	FillRect(tempHDC,&rect,gray);

	lea	rdx, QWORD PTR rect$[rsp]
	mov	DWORD PTR rect$[rsp+12], ecx
	mov	r8, rbx
	mov	rcx, rdi
	mov	DWORD PTR rect$[rsp+8], 6
	call	QWORD PTR __imp_FillRect

; 76   : 	rect.left = width-PADDING; rect.right = width;

	mov	ecx, DWORD PTR [rbp+16]

; 77   : 	FillRect(tempHDC,&rect,gray);

	lea	rdx, QWORD PTR rect$[rsp]
	mov	DWORD PTR rect$[rsp+8], ecx
	mov	r8, rbx
	lea	eax, DWORD PTR [rcx-6]
	mov	rcx, rdi
	mov	DWORD PTR rect$[rsp], eax
	call	QWORD PTR __imp_FillRect

; 78   : 	rect.left = 0; rect.top = height-PADDING;

	mov	eax, DWORD PTR [rbp+20]

; 79   : 	FillRect(tempHDC,&rect,gray);

	lea	rdx, QWORD PTR rect$[rsp]
	add	eax, -6
	mov	DWORD PTR rect$[rsp], esi
	mov	r8, rbx
	mov	DWORD PTR rect$[rsp+4], eax
	mov	rcx, rdi
	call	QWORD PTR __imp_FillRect

; 80   : 
; 81   : 	int g_Width = width - PADDING * 2;

	mov	eax, DWORD PTR [rbp+16]
	mov	esi, 6

; 82   : 	int g_Height = height - PADDING *2;

	mov	r12d, DWORD PTR [rbp+20]
	sub	eax, 12
	vxorps	xmm8, xmm8, xmm8

; 83   : 	float f_Width = (float)g_Width;	

	vcvtsi2ss xmm8, xmm8, eax

; 84   : 
; 85   : 	// Gradient
; 86   : 	for (int x=PADDING; x<g_Width+PADDING; x++) {

	lea	r15d, DWORD PTR [rax+6]
	cmp	r15d, esi
	jle	$LN3@paint
	vmovaps	XMMWORD PTR [rsp+160], xmm6
	lea	r14d, DWORD PTR [r12-6]
	vmovss	xmm6, DWORD PTR __real@437f0000
	vmovaps	XMMWORD PTR [rsp+144], xmm7
	vsubss	xmm7, xmm8, DWORD PTR __real@3f800000
	npad	2
$LL4@paint:

; 87   : 		AColor col = getColor((float)(x-PADDING) / (f_Width-1.f));

	lea	eax, DWORD PTR [rsi-6]
	mov	rcx, rbp
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm2, xmm0, xmm7
	lea	rdx, QWORD PTR col$1[rsp]
	call	?getColor@GradientRamp@@QEAA?AVAColor@@M@Z ; GradientRamp::getColor

; 88   : 
; 89   : 		COLORREF colR = RGB((int)(col.r*255.f), (int)(col.g*255.f), (int)(col.b*255.f));		

	vmulss	xmm1, xmm6, DWORD PTR col$1[rsp+4]
	vcvttss2si eax, xmm1
	vmulss	xmm1, xmm6, DWORD PTR col$1[rsp+8]
	movzx	ebp, al
	mov	ebx, 6
	vcvttss2si eax, xmm1
	vmulss	xmm1, xmm6, DWORD PTR col$1[rsp]
	shl	ebp, 8
	movzx	ecx, al
	shl	ecx, 16
	or	ebp, ecx
	vcvttss2si eax, xmm1
	movzx	ecx, al
	or	ebp, ecx

; 90   : 		for (int y=PADDING; y<g_Height+PADDING; y++)		

	cmp	r14d, ebx
	jle	SHORT $LN2@paint
	npad	9
$LL7@paint:

; 91   : 			SetPixel(tempHDC, x, y, colR);

	mov	r9d, ebp
	mov	r8d, ebx
	mov	edx, esi
	mov	rcx, rdi
	call	QWORD PTR __imp_SetPixel
	inc	ebx
	cmp	ebx, r14d
	jl	SHORT $LL7@paint
$LN2@paint:

; 84   : 
; 85   : 	// Gradient
; 86   : 	for (int x=PADDING; x<g_Width+PADDING; x++) {

	mov	rbp, QWORD PTR this$[rsp]
	inc	esi
	cmp	esi, r15d
	jl	$LL4@paint
	mov	r12d, DWORD PTR [rbp+20]
	vmovaps	xmm7, XMMWORD PTR [rsp+144]
	vmovaps	xmm6, XMMWORD PTR [rsp+160]
$LN3@paint:

; 92   : 	}
; 93   : 
; 94   : 	// Keys
; 95   : 	int yTop = PADDING - 1;
; 96   : 	int yBottom = height - PADDING;
; 97   : 	int sel = -1;
; 98   : 	for (int i=0;i<keys;i++) {

	xor	edx, edx
	mov	DWORD PTR sel$1$[rsp], -1
	lea	r12d, DWORD PTR [r12-6]
	mov	DWORD PTR i$1$[rsp], edx
	cmp	DWORD PTR [rbp+56], edx
	jle	$LN48@paint
	xor	r8d, r8d
	mov	QWORD PTR [rsp+200], r13
	mov	QWORD PTR tv1314[rsp], r8
	lea	r13d, QWORD PTR [rdx+1]
	npad	9
$LL10@paint:

; 99   : 		//CharStream *out = thread_local(current_stdout);
; 100  : 		//out->printf("Key pos: %f\n", position[i]);	
; 101  : 		if (number[i] != selected) {

	mov	rcx, QWORD PTR [rbp+48]
	mov	eax, DWORD PTR [rbp+60]
	cmp	DWORD PTR [r8+rcx], eax
	je	$LN12@paint

; 102  : 			int x = (int)(f_Width * position[i]) + PADDING;

	mov	rax, QWORD PTR [rbp+32]
	mov	esi, r13d
	vmulss	xmm0, xmm8, DWORD PTR [rax+r8]
	vcvttss2si r15d, xmm0
	add	r15d, 6
	xor	r14d, r14d
	npad	7
$LL19@paint:

; 126  : 		for (int x=0;x<(y*2+1);x++) {

	xor	ebx, ebx
	test	esi, esi
	jle	SHORT $LN21@paint
	npad	10
$LL22@paint:

; 127  : 			if (up)

	lea	edx, DWORD PTR [r14+r15]

; 129  : 			else
; 130  : 				SetPixel(hDC, px+x-offset, py-y, colR);

	xor	r9d, r9d
	add	edx, ebx
	lea	r8d, DWORD PTR [r14+5]
	mov	rcx, rdi
	call	QWORD PTR __imp_SetPixel
	inc	ebx
	cmp	ebx, esi
	jl	SHORT $LL22@paint
$LN21@paint:

; 125  : 	for (int y=0;y<ARROWS;y++) {

	add	esi, 2
	dec	r14d
	cmp	esi, 13
	jl	SHORT $LL19@paint

; 124  : 	int offset = 0;

	xor	r14d, r14d
	mov	esi, r13d
	xor	ebp, ebp
	npad	1
$LL29@paint:

; 126  : 		for (int x=0;x<(y*2+1);x++) {

	xor	ebx, ebx
	test	esi, esi
	jle	SHORT $LN31@paint
	npad	10
$LL32@paint:

; 127  : 			if (up)

	lea	edx, DWORD PTR [r15+rbx]

; 128  : 				SetPixel(hDC, px+x-offset, py+y, colR);

	xor	r9d, r9d
	add	edx, ebp
	lea	r8d, DWORD PTR [r14+r12]
	mov	rcx, rdi
	call	QWORD PTR __imp_SetPixel
	inc	ebx
	cmp	ebx, esi
	jl	SHORT $LL32@paint
$LN31@paint:

; 125  : 	for (int y=0;y<ARROWS;y++) {

	inc	r14d
	add	esi, 2
	dec	ebp
	cmp	esi, 13
	jl	SHORT $LL29@paint

; 103  : 			paintArrow(x, yTop, false, tempHDC, ARROWDESEL);
; 104  : 			paintArrow(x, yBottom, true, tempHDC, ARROWDESEL);
; 105  : 		} else {

	mov	rbp, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR i$1$[rsp]
	mov	r8, QWORD PTR tv1314[rsp]
	mov	r9d, DWORD PTR sel$1$[rsp]
	jmp	SHORT $LN8@paint
$LN12@paint:

; 106  : 			sel = i;

	mov	r9d, edx
	mov	DWORD PTR sel$1$[rsp], edx
$LN8@paint:

; 92   : 	}
; 93   : 
; 94   : 	// Keys
; 95   : 	int yTop = PADDING - 1;
; 96   : 	int yBottom = height - PADDING;
; 97   : 	int sel = -1;
; 98   : 	for (int i=0;i<keys;i++) {

	inc	edx
	add	r8, 4
	mov	DWORD PTR i$1$[rsp], edx
	mov	QWORD PTR tv1314[rsp], r8
	cmp	edx, DWORD PTR [rbp+56]
	jl	$LL10@paint

; 107  : 		}
; 108  : 	}	
; 109  : 	if (sel != -1) {

	cmp	r9d, -1
	je	$LN100@paint

; 110  : 		paintArrow((int)(f_Width * position[sel]) + PADDING, yTop, false, tempHDC, ARROWSEL);

	mov	rax, QWORD PTR [rbp+32]
	mov	esi, r13d
	movsxd	rcx, r9d
	vmulss	xmm0, xmm8, DWORD PTR [rax+rcx*4]
	vcvttss2si r15d, xmm0
	add	r15d, 6
	xor	ebp, ebp
	npad	1
$LL39@paint:

; 126  : 		for (int x=0;x<(y*2+1);x++) {

	xor	ebx, ebx
	test	esi, esi
	jle	SHORT $LN41@paint
	npad	10
$LL42@paint:

; 127  : 			if (up)

	lea	edx, DWORD PTR [r15+rbp]

; 129  : 			else
; 130  : 				SetPixel(hDC, px+x-offset, py-y, colR);

	mov	r9d, 16777215				; 00ffffffH
	add	edx, ebx
	lea	r8d, DWORD PTR [rbp+5]
	mov	rcx, rdi
	call	QWORD PTR __imp_SetPixel
	inc	ebx
	cmp	ebx, esi
	jl	SHORT $LL42@paint
$LN41@paint:

; 125  : 	for (int y=0;y<ARROWS;y++) {

	add	esi, 2
	dec	ebp
	cmp	esi, 13
	jl	SHORT $LL39@paint

; 111  : 		paintArrow((int)(f_Width * position[sel]) + PADDING, yBottom, true, tempHDC, ARROWSEL);	

	mov	rax, QWORD PTR this$[rsp]
	xor	esi, esi
	movsxd	rdx, DWORD PTR sel$1$[rsp]
	mov	rax, QWORD PTR [rax+32]
	vmulss	xmm0, xmm8, DWORD PTR [rax+rdx*4]
	vcvttss2si r14d, xmm0
	add	r14d, 6
	xor	ebp, ebp
	npad	2
$LL49@paint:

; 126  : 		for (int x=0;x<(y*2+1);x++) {

	xor	ebx, ebx
	test	r13d, r13d
	jle	SHORT $LN51@paint
	npad	9
$LL52@paint:

; 127  : 			if (up)

	lea	edx, DWORD PTR [r14+rbp]

; 128  : 				SetPixel(hDC, px+x-offset, py+y, colR);

	mov	r9d, 16777215				; 00ffffffH
	add	edx, ebx
	lea	r8d, DWORD PTR [rsi+r12]
	mov	rcx, rdi
	call	QWORD PTR __imp_SetPixel
	inc	ebx
	cmp	ebx, r13d
	jl	SHORT $LL52@paint
$LN51@paint:

; 125  : 	for (int y=0;y<ARROWS;y++) {

	inc	esi
	add	r13d, 2
	dec	ebp
	cmp	r13d, 13
	jl	SHORT $LL49@paint
	mov	rbp, QWORD PTR this$[rsp]
$LN100@paint:
	mov	r13, QWORD PTR [rsp+200]
$LN48@paint:

; 112  : 	}
; 113  : 
; 114  : 	//GetClientRect(m_hWnd, &rect);
; 115  : 	BitBlt(hDC, 0, 0, width, height, tempHDC, 0, 0, SRCCOPY);

	mov	eax, DWORD PTR [rbp+20]
	xor	r8d, r8d
	mov	r9d, DWORD PTR [rbp+16]
	xor	edx, edx
	mov	rcx, QWORD PTR hDC$[rsp]
	mov	DWORD PTR [rsp+64], 13369376		; 00cc0020H
	mov	DWORD PTR [rsp+56], 0
	mov	DWORD PTR [rsp+48], 0
	mov	QWORD PTR [rsp+40], rdi
	mov	DWORD PTR [rsp+32], eax
	call	QWORD PTR __imp_BitBlt

; 116  : 	//BitBlt(hDC, rect.left, rect.top, rect.right, rect.bottom, tempHDC, 0, 0, SRCCOPY);
; 117  : 
; 118  :     SelectObject(tempHDC, hbm_oldBuffer);

	mov	rdx, QWORD PTR hbm_oldBuffer$1$[rsp]
	mov	rcx, rdi
	call	QWORD PTR __imp_SelectObject

; 119  :  	DeleteDC(tempHDC);

	mov	rcx, rdi
	call	QWORD PTR __imp_DeleteDC

; 120  :     DeleteObject(hbm_Buffer); 

	mov	rcx, QWORD PTR hbm_Buffer$1$[rsp]
	call	QWORD PTR __imp_DeleteObject
	vmovaps	xmm8, XMMWORD PTR [rsp+128]
	mov	r15, QWORD PTR [rsp+184]
	mov	r14, QWORD PTR [rsp+192]
	mov	r12, QWORD PTR [rsp+208]
	mov	rdi, QWORD PTR [rsp+216]
	mov	rsi, QWORD PTR [rsp+224]
$LN1@paint:

; 121  : }

	add	rsp, 232				; 000000e8H
	pop	rbp
	pop	rbx
	ret	0
?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z ENDP		; GradientRamp::paint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z
_TEXT	SEGMENT
rect$ = 32
this$ = 64
hWnd$ = 72
?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z PROC		; GradientRamp::setHWND, COMDAT

; 30   : void GradientRamp::setHWND(HWND hWnd) {

$LN4:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, rdx

; 31   : 	m_hWnd = hWnd; 

	mov	QWORD PTR [rcx], rdx
	mov	rbx, rcx

; 32   : 	RECT rect;
; 33   : 	GetWindowRect(m_hWnd, &rect);													

	lea	rdx, QWORD PTR rect$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_GetWindowRect

; 34   : 	width = rect.right - rect.left;

	mov	eax, DWORD PTR rect$[rsp+8]
	sub	eax, DWORD PTR rect$[rsp]
	mov	DWORD PTR [rbx+16], eax

; 35   : 	height = rect.bottom - rect.top;	

	mov	eax, DWORD PTR rect$[rsp+12]
	sub	eax, DWORD PTR rect$[rsp+4]
	mov	DWORD PTR [rbx+20], eax

; 36   : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z ENDP		; GradientRamp::setHWND
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\mesh.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\tab.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\mesh.h
;	COMDAT ??0VertexNormalsControl@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 0
this$ = 32
??0VertexNormalsControl@@QEAA@XZ PROC			; VertexNormalsControl::VertexNormalsControl, COMDAT

; 2949 : 	DllExport VertexNormalsControl () : mUseFaceAngles(true) { }

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	mov	QWORD PTR $T1[rsp], -2
	mov	BYTE PTR [rcx], 1
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\tab.h

; 186  : 		Tab() : th(NULL)

	mov	QWORD PTR [rcx+8], 0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\mesh.h

; 2949 : 	DllExport VertexNormalsControl () : mUseFaceAngles(true) { }

	mov	rax, rcx
	add	rsp, 24
	ret	0
??0VertexNormalsControl@@QEAA@XZ ENDP			; VertexNormalsControl::VertexNormalsControl
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
?dtor$0@?0???0VertexNormalsControl@@QEAA@XZ@4HA PROC	; `VertexNormalsControl::VertexNormalsControl'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ ; Tab<VertexNormalsCallback *>::~Tab<VertexNormalsCallback *>
?dtor$0@?0???0VertexNormalsControl@@QEAA@XZ@4HA ENDP	; `VertexNormalsControl::VertexNormalsControl'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 0
this$ = 32
?dtor$0@?0???0VertexNormalsControl@@QEAA@XZ@4HA PROC	; `VertexNormalsControl::VertexNormalsControl'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 8
	jmp	??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ ; Tab<VertexNormalsCallback *>::~Tab<VertexNormalsCallback *>
?dtor$0@?0???0VertexNormalsControl@@QEAA@XZ@4HA ENDP	; `VertexNormalsControl::VertexNormalsControl'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\tab.h
;	COMDAT ??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ PROC	; Tab<VertexNormalsCallback *>::~Tab<VertexNormalsCallback *>, COMDAT

; 204  : 		~Tab() {

$LN5:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2

; 205  : 			zfree((void**)&th); 

	call	QWORD PTR __imp_?zfree@@YAXPEAPEAX@Z
	npad	1

; 206  : 		}

	add	rsp, 56					; 00000038H
	ret	0
??1?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ ENDP	; Tab<VertexNormalsCallback *>::~Tab<VertexNormalsCallback *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\tab.h
;	COMDAT ??0?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ PROC	; Tab<VertexNormalsCallback *>::Tab<VertexNormalsCallback *>, COMDAT

; 186  : 		Tab() : th(NULL)

	mov	QWORD PTR [rcx], 0

; 188  : 			ADSK_MAXSDK_IS_PLAIN_OLD_DATA_TYPE(T);
; 189  : 		}

	mov	rax, rcx
	ret	0
??0?$Tab@PEAVVertexNormalsCallback@@@@QEAA@XZ ENDP	; Tab<VertexNormalsCallback *>::Tab<VertexNormalsCallback *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
;	COMDAT ??D@YA?AVAColor@@AEBV0@M@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
a$ = 16
f$ = 24
??D@YA?AVAColor@@AEBV0@M@Z PROC				; operator*, COMDAT

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmovaps	xmm1, xmm2
	vbroadcastss xmm1, xmm1
	vmulps	xmm1, xmm1, XMMWORD PTR [rdx]

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovups	XMMWORD PTR [rcx], xmm1

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	mov	rax, rcx

; 316  : 	}

	ret	0
??D@YA?AVAColor@@AEBV0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
;	COMDAT ??HAColor@@QEBA?AV0@AEBV0@@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
c$ = 24
??HAColor@@QEBA?AV0@AEBV0@@Z PROC			; AColor::operator+, COMDAT

; 291  : 	return(AColor(r+c.r,g+c.g,b+c.b,a+c.a));

	vmovups	xmm1, XMMWORD PTR [r8]
	vaddps	xmm1, xmm1, XMMWORD PTR [rcx]

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovups	XMMWORD PTR [rdx], xmm1

; 291  : 	return(AColor(r+c.r,g+c.g,b+c.b,a+c.a));

	mov	rax, rdx

; 292  : 	}

	ret	0
??HAColor@@QEBA?AV0@AEBV0@@Z ENDP			; AColor::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
;	COMDAT ??0AColor@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
this$ = 8
c$ = 16
??0AColor@@QEAA@AEBV0@@Z PROC				; AColor::AColor, COMDAT

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rcx+12], eax
	mov	rax, rcx
	ret	0
??0AColor@@QEAA@AEBV0@@Z ENDP				; AColor::AColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
;	COMDAT ??0AColor@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 8
R$ = 16
G$ = 24
B$ = 32
A$ = 40
??0AColor@@QEAA@MMMM@Z PROC				; AColor::AColor, COMDAT

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	xmm0, DWORD PTR A$[rsp]
	vmovss	DWORD PTR [rcx+12], xmm0
	vmovss	DWORD PTR [rcx], xmm1
	vmovss	DWORD PTR [rcx+4], xmm2
	vmovss	DWORD PTR [rcx+8], xmm3
	mov	rax, rcx
	ret	0
??0AColor@@QEAA@MMMM@Z ENDP				; AColor::AColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
;	COMDAT ??0AColor@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0AColor@@QEAA@XZ PROC					; AColor::AColor, COMDAT

; 41   : 	AColor()  {}

	mov	rax, rcx
	ret	0
??0AColor@@QEAA@XZ ENDP					; AColor::AColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
;	COMDAT ??D@YA?AVPoint3@@MAEBV0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
f$ = 56
a$ = 64
??D@YA?AVPoint3@@MAEBV0@@Z PROC				; operator*, COMDAT

; 320  : __forceinline Point3 operator*(float f, const Point3& a) {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm3, xmm1, DWORD PTR [r8+8]
	vmulss	xmm2, xmm1, DWORD PTR [r8+4]
	vmulss	xmm1, xmm1, DWORD PTR [r8]
	mov	rbx, rcx
	call	QWORD PTR __imp_??0Point3@@QEAA@MMM@Z
	mov	rax, rbx

; 322  :    }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??D@YA?AVPoint3@@MAEBV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ
text$di	SEGMENT
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ PROC	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId'', COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR ?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A, xmm0

; 32   : 		static AssetId kInvalidId;

	ret	0
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ENDP	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ PROC		; MaxSDK::AssetManagement::AssetId::AssetId, COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR [rcx], xmm0
	mov	rax, rcx
	ret	0
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ ENDP		; MaxSDK::AssetManagement::AssetId::AssetId
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\maxtypes.h
;	COMDAT ??0Class_ID@@QEAA@KK@Z
_TEXT	SEGMENT
this$ = 8
aa$ = 16
bb$ = 24
??0Class_ID@@QEAA@KK@Z PROC				; Class_ID::Class_ID, COMDAT

; 160  : 	Class_ID(ulong aa, ulong bb) { a = aa; b = bb; }

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	DWORD PTR [rcx+4], r8d
	ret	0
??0Class_ID@@QEAA@KK@Z ENDP				; Class_ID::Class_ID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 8
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
__t$ = 48
__s$ = 56
__n$ = 64
__f$ = 72
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN12:
	test	r8, r8
	je	SHORT $LN10@vector
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r9
	mov	rbx, r8
	mov	rbp, rdx
	mov	rdi, rcx
$LL2@vector:
	mov	rcx, rdi
	call	rsi
	add	rdi, rbp
	sub	rbx, 1
	jne	SHORT $LL2@vector
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN10@vector:
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
