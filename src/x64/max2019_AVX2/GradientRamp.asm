; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24234.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	WinbaseIsolationAwarePrivateT_UnPgpgk
PUBLIC	IsolationAwarePrivateT_SqbjaYRiRY
PUBLIC	IsolationAwarePrivateT_SAbnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
EXTRN	GUID_NULL:BYTE
;	COMDAT IsolationAwarePrivateT_SqbjaYRiRY
_BSS	SEGMENT
IsolationAwarePrivateT_SqbjaYRiRY DD 01H DUP (?)
_BSS	ENDS
;	COMDAT IsolationAwarePrivateT_SAbnPgpgk
_BSS	SEGMENT
IsolationAwarePrivateT_SAbnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_UnPgpgk
_DATA	SEGMENT
WinbaseIsolationAwarePrivateT_UnPgpgk DQ ffffffffffffffffH
_DATA	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	??0AColor@@QEAA@XZ				; AColor::AColor
PUBLIC	?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z	; GradientRamp::setHWND
PUBLIC	?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z		; GradientRamp::paint
PUBLIC	?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z ; GradientRamp::paintArrow
PUBLIC	?invalidate@GradientRamp@@QEAAXXZ		; GradientRamp::invalidate
PUBLIC	?hit@GradientRamp@@QEAAHHH_N@Z			; GradientRamp::hit
PUBLIC	?toPos@GradientRamp@@QEAAMH@Z			; GradientRamp::toPos
PUBLIC	?leftDown@GradientRamp@@QEAAXHH_N00@Z		; GradientRamp::leftDown
PUBLIC	?leftUp@GradientRamp@@QEAAXHH_N00@Z		; GradientRamp::leftUp
PUBLIC	?dragging@GradientRamp@@QEAAXHH_N00@Z		; GradientRamp::dragging
PUBLIC	?popup@GradientRamp@@QEAAXHHH@Z			; GradientRamp::popup
PUBLIC	?toIndex@GradientRamp@@QEAAHH@Z			; GradientRamp::toIndex
PUBLIC	?selectKey@GradientRamp@@QEAAXH@Z		; GradientRamp::selectKey
PUBLIC	?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z ; GradientRamp::addKey
PUBLIC	?reset@GradientRamp@@QEAAXXZ			; GradientRamp::reset
PUBLIC	?swap@GradientRamp@@QEAAXHH@Z			; GradientRamp::swap
PUBLIC	?sort@GradientRamp@@QEAAXXZ			; GradientRamp::sort
PUBLIC	?getSubtex@GradientRamp@@QEAAPEAVTexmap@@H@Z	; GradientRamp::getSubtex
PUBLIC	?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z	; GradientRamp::setSubtex
PUBLIC	?setSubtex@GradientRamp@@QEAAXPEAVTexmap@@@Z	; GradientRamp::setSubtex
PUBLIC	?findHighKey@GradientRamp@@QEAAHM@Z		; GradientRamp::findHighKey
PUBLIC	?interpolate@GradientRamp@@QEAAMMMM@Z		; GradientRamp::interpolate
PUBLIC	?getColor@GradientRamp@@QEAA?AVAColor@@M@Z	; GradientRamp::getColor
PUBLIC	?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z ; GradientRamp::getColor
PUBLIC	?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z ; GradientRamp::getBump
PUBLIC	__real@3f800000
PUBLIC	__real@40400000
PUBLIC	__real@437f0000
PUBLIC	__xmm@3f800000000000000000000000000000
PUBLIC	__xmm@3f8000003f8000003f8000003f800000
EXTRN	??_U@YAPEAX_K@Z:PROC				; operator new[]
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	__imp_BitBlt:PROC
EXTRN	__imp_CreateCompatibleBitmap:PROC
EXTRN	__imp_CreateCompatibleDC:PROC
EXTRN	__imp_CreateSolidBrush:PROC
EXTRN	__imp_DeleteDC:PROC
EXTRN	__imp_DeleteObject:PROC
EXTRN	__imp_SelectObject:PROC
EXTRN	__imp_SetPixel:PROC
EXTRN	__imp_InvalidateRect:PROC
EXTRN	__imp_GetWindowRect:PROC
EXTRN	__imp_FillRect:PROC
EXTRN	__imp_??_UMaxHeapOperators@@SAPEAX_K@Z:PROC
EXTRN	__imp_??_VMaxHeapOperators@@SAXPEAX@Z:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A DB 010H DUP (?) ; MaxSDK::AssetManagement::kInvalidId
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??HAColor@@QEBA?AV0@AEBV0@@Z DD imagerel $LN19
	DD	imagerel $LN19+37
	DD	imagerel $unwind$??HAColor@@QEBA?AV0@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D@YA?AVAColor@@AEBV0@M@Z DD imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$??D@YA?AVAColor@@AEBV0@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102
	DD	imagerel $LN102+56
	DD	imagerel $unwind$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102+56
	DD	imagerel $LN102+361
	DD	imagerel $chain$5$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102+361
	DD	imagerel $LN102+554
	DD	imagerel $chain$7$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102+554
	DD	imagerel $LN102+588
	DD	imagerel $chain$8$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102+588
	DD	imagerel $LN102+1028
	DD	imagerel $chain$9$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102+1028
	DD	imagerel $LN102+1173
	DD	imagerel $chain$10$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD imagerel $LN102+1173
	DD	imagerel $LN102+1199
	DD	imagerel $chain$11$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z DD imagerel $LN21
	DD	imagerel $LN21+156
	DD	imagerel $unwind$?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hit@GradientRamp@@QEAAHHH_N@Z DD imagerel $LN21
	DD	imagerel $LN21+92
	DD	imagerel $unwind$?hit@GradientRamp@@QEAAHHH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?hit@GradientRamp@@QEAAHHH_N@Z DD imagerel $LN21+92
	DD	imagerel $LN21+184
	DD	imagerel $chain$0$?hit@GradientRamp@@QEAAHHH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?hit@GradientRamp@@QEAAHHH_N@Z DD imagerel $LN21+184
	DD	imagerel $LN21+196
	DD	imagerel $chain$2$?hit@GradientRamp@@QEAAHHH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?leftUp@GradientRamp@@QEAAXHH_N00@Z DD imagerel $LN32
	DD	imagerel $LN32+303
	DD	imagerel $unwind$?leftUp@GradientRamp@@QEAAXHH_N00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?popup@GradientRamp@@QEAAXHHH@Z DD imagerel $LN38
	DD	imagerel $LN38+300
	DD	imagerel $unwind$?popup@GradientRamp@@QEAAXHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z DD imagerel $LN36
	DD	imagerel $LN36+538
	DD	imagerel $unwind$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reset@GradientRamp@@QEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+185
	DD	imagerel $unwind$?reset@GradientRamp@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?swap@GradientRamp@@QEAAXHH@Z DD imagerel $LN6
	DD	imagerel $LN6+219
	DD	imagerel $unwind$?swap@GradientRamp@@QEAAXHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sort@GradientRamp@@QEAAXXZ DD imagerel $LN16
	DD	imagerel $LN16+27
	DD	imagerel $unwind$?sort@GradientRamp@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?sort@GradientRamp@@QEAAXXZ DD imagerel $LN16+27
	DD	imagerel $LN16+263
	DD	imagerel $chain$1$?sort@GradientRamp@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?sort@GradientRamp@@QEAAXXZ DD imagerel $LN16+263
	DD	imagerel $LN16+274
	DD	imagerel $chain$2$?sort@GradientRamp@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z DD imagerel $LN15
	DD	imagerel $LN15+72
	DD	imagerel $unwind$?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD imagerel $LN58
	DD	imagerel $LN58+319
	DD	imagerel $unwind$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD imagerel $LN58+319
	DD	imagerel $LN58+482
	DD	imagerel $chain$4$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD imagerel $LN58+482
	DD	imagerel $LN58+502
	DD	imagerel $chain$5$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN88
	DD	imagerel $LN88+122
	DD	imagerel $unwind$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN88+122
	DD	imagerel $LN88+422
	DD	imagerel $chain$0$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN88+422
	DD	imagerel $LN88+745
	DD	imagerel $chain$6$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN88+745
	DD	imagerel $LN88+751
	DD	imagerel $chain$7$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD imagerel $LN88+751
	DD	imagerel $LN88+774
	DD	imagerel $chain$8$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN92
	DD	imagerel $LN92+147
	DD	imagerel $unwind$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN92+147
	DD	imagerel $LN92+260
	DD	imagerel $chain$0$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN92+260
	DD	imagerel $LN92+421
	DD	imagerel $chain$1$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN92+421
	DD	imagerel $LN92+866
	DD	imagerel $chain$2$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN92+866
	DD	imagerel $LN92+874
	DD	imagerel $chain$3$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN92+874
	DD	imagerel $LN92+880
	DD	imagerel $chain$4$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD imagerel $LN92+880
	DD	imagerel $LN92+925
	DD	imagerel $chain$5$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?kInvalidId$initializer$@AssetManagement@MaxSDK@@3P6AXXZEA DQ FLAT:??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ; MaxSDK::AssetManagement::kInvalidId$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@3f8000003f8000003f8000003f800000
CONST	SEGMENT
__xmm@3f8000003f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f800000000000000000000000000000
CONST	SEGMENT
__xmm@3f800000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
_DATA	SEGMENT
?kTriObjNormalXTCID@@3VClass_ID@@B DD 0730a33d7H	; kTriObjNormalXTCID
	DD	027246c55H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN92
	DD	imagerel $LN92+147
	DD	imagerel $unwind$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN92+147
	DD	imagerel $LN92+260
	DD	imagerel $chain$0$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN92+260
	DD	imagerel $LN92+421
	DD	imagerel $chain$1$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 020821H
	DD	012f408H
	DD	imagerel $LN92+260
	DD	imagerel $LN92+421
	DD	imagerel $chain$1$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 020821H
	DD	0137408H
	DD	imagerel $LN92+147
	DD	imagerel $LN92+260
	DD	imagerel $chain$0$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 020621H
	DD	068806H
	DD	imagerel $LN92
	DD	imagerel $LN92+147
	DD	imagerel $unwind$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z DD 0b3119H
	DD	077823H
	DD	08681dH
	DD	0140114H
	DD	0d006e008H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN88
	DD	imagerel $LN88+122
	DD	imagerel $unwind$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN88+122
	DD	imagerel $LN88+422
	DD	imagerel $chain$0$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 0c4621H
	DD	079846H
	DD	08883aH
	DD	09782bH
	DD	0a681fH
	DD	01be410H
	DD	01a6408H
	DD	imagerel $LN88+122
	DD	imagerel $LN88+422
	DD	imagerel $chain$0$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 020621H
	DD	06a806H
	DD	imagerel $LN88
	DD	imagerel $LN88+122
	DD	imagerel $unwind$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z DD 071501H
	DD	01c3415H
	DD	0160115H
	DD	07007f009H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD 021H
	DD	imagerel $LN58
	DD	imagerel $LN58+319
	DD	imagerel $unwind$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD 081f21H
	DD	03781fH
	DD	046819H
	DD	0d740aH
	DD	0c3405H
	DD	imagerel $LN58
	DD	imagerel $LN58+319
	DD	imagerel $unwind$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getColor@GradientRamp@@QEAA?AVAColor@@M@Z DD 064c01H
	DD	02884cH
	DD	0e540aH
	DD	06006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?sort@GradientRamp@@QEAAXXZ DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+27
	DD	imagerel $unwind$?sort@GradientRamp@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?sort@GradientRamp@@QEAAXXZ DD 040d21H
	DD	05e40dH
	DD	046405H
	DD	imagerel $LN16
	DD	imagerel $LN16+27
	DD	imagerel $unwind$?sort@GradientRamp@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sort@GradientRamp@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?swap@GradientRamp@@QEAAXHH@Z DD 0a1a01H
	DD	07741aH
	DD	06641aH
	DD	05541aH
	DD	04341aH
	DD	0e016121aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reset@GradientRamp@@QEAAXXZ DD 040a01H
	DD	0c340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z DD imagerel ?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z DD 0e2911H
	DD	036829H
	DD	0116424H
	DD	0105420H
	DD	0f341cH
	DD	0f00c7210H
	DD	0d008e00aH
	DD	07004c006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?popup@GradientRamp@@QEAAXHHH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?leftUp@GradientRamp@@QEAAXHH_N00@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?hit@GradientRamp@@QEAAHHH_N@Z DD 020021H
	DD	03400H
	DD	imagerel $LN21
	DD	imagerel $LN21+92
	DD	imagerel $unwind$?hit@GradientRamp@@QEAAHHH_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?hit@GradientRamp@@QEAAHHH_N@Z DD 020421H
	DD	03404H
	DD	imagerel $LN21
	DD	imagerel $LN21+92
	DD	imagerel $unwind$?hit@GradientRamp@@QEAAHHH_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hit@GradientRamp@@QEAAHHH_N@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z DD 0c1c01H
	DD	0d641cH
	DD	0c541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 021H
	DD	imagerel $LN102
	DD	imagerel $LN102+56
	DD	imagerel $unwind$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 021H
	DD	imagerel $LN102+554
	DD	imagerel $LN102+588
	DD	imagerel $chain$8$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 020821H
	DD	01ed408H
	DD	imagerel $LN102+554
	DD	imagerel $LN102+588
	DD	imagerel $chain$8$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 021H
	DD	imagerel $LN102+56
	DD	imagerel $LN102+361
	DD	imagerel $chain$5$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 041e21H
	DD	0c781eH
	DD	0d6809H
	DD	imagerel $LN102+56
	DD	imagerel $LN102+361
	DD	imagerel $chain$5$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 0c1d21H
	DD	0b881dH
	DD	01cf417H
	DD	01de413H
	DD	01fc40fH
	DD	020740bH
	DD	0266404H
	DD	imagerel $LN102
	DD	imagerel $LN102+56
	DD	imagerel $unwind$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z DD 041e19H
	DD	021010cH
	DD	030045005H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z DD 021519H
	DD	030027206H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D@YA?AVAColor@@AEBV0@M@Z DD 020f01H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??HAColor@@QEBA?AV0@AEBV0@@Z DD 020f01H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 081901H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	070153219H
xdata	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 48
v2$ = 48
$T10 = 48
$T11 = 48
$T12 = 48
$T13 = 48
v1$ = 64
__$ArrayPad$ = 80
this$ = 208
__$ReturnUdt$ = 216
x$ = 224
normal$ = 232
sc$ = 240
?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z PROC ; GradientRamp::getBump, COMDAT

; 495  : Point3 GradientRamp::getBump(float x, Point3 normal, ShadeContext& sc) {

$LN92:
	push	rbp
	push	rbx
	push	rsi
	push	r13
	push	r14
	lea	rbp, QWORD PTR [rsp-47]
	sub	rsp, 160				; 000000a0H
	vmovaps	XMMWORD PTR [rsp+128], xmm6
	vmovaps	XMMWORD PTR [rsp+112], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-113], rax
	mov	r14, QWORD PTR sc$[rbp-113]
	mov	r13, r9
	vxorps	xmm6, xmm6, xmm6

; 496  : 	if (x<=0) return subtex[0]?subtex[0]->EvalNormalPerturb(sc):NOBUMP;

	vcomiss	xmm6, xmm2
	vmovaps	xmm7, xmm2
	mov	rbx, rdx
	mov	rsi, rcx
	jb	SHORT $LN2@getBump
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN14@getBump
	mov	rcx, QWORD PTR [rcx]
	lea	rdx, QWORD PTR $T8[rbp-113]
	mov	r8, r14
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+1520]
	jmp	SHORT $LN15@getBump
$LN14@getBump:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T13[rbp-113], xmm6
	vmovss	DWORD PTR $T13[rbp-109], xmm6
	vmovss	DWORD PTR $T13[rbp-105], xmm6
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 496  : 	if (x<=0) return subtex[0]?subtex[0]->EvalNormalPerturb(sc):NOBUMP;

	lea	rax, QWORD PTR $T13[rbp-113]
$LN15@getBump:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	mov	ecx, DWORD PTR [rax]
	mov	DWORD PTR [rbx], ecx
	mov	ecx, DWORD PTR [rax+4]
	mov	DWORD PTR [rbx+4], ecx
	mov	ecx, DWORD PTR [rax+8]
	mov	DWORD PTR [rbx+8], ecx
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 496  : 	if (x<=0) return subtex[0]?subtex[0]->EvalNormalPerturb(sc):NOBUMP;

	jmp	$LN90@getBump
$LN2@getBump:
	vmovaps	XMMWORD PTR [rsp+96], xmm8

; 497  : 	if (x>=1) return subtex[keys-1]?subtex[keys-1]->EvalNormalPerturb(sc):NOBUMP;

	vmovss	xmm8, DWORD PTR __real@3f800000
	vcomiss	xmm7, xmm8
	jb	SHORT $LN3@getBump
	mov	eax, DWORD PTR [rcx+56]
	dec	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rsi+24]
	cmp	QWORD PTR [rax+rcx*8], 0
	je	SHORT $LN16@getBump
	mov	rcx, QWORD PTR [rax+rcx*8]
	lea	rdx, QWORD PTR $T7[rbp-113]
	mov	r8, r14
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+1520]
	mov	rcx, rax
	jmp	SHORT $LN17@getBump
$LN16@getBump:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T12[rbp-113], xmm6
	vmovss	DWORD PTR $T12[rbp-109], xmm6
	vmovss	DWORD PTR $T12[rbp-105], xmm6
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 497  : 	if (x>=1) return subtex[keys-1]?subtex[keys-1]->EvalNormalPerturb(sc):NOBUMP;

	lea	rcx, QWORD PTR $T12[rbp-113]
$LN17@getBump:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+8], eax
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 497  : 	if (x>=1) return subtex[keys-1]?subtex[keys-1]->EvalNormalPerturb(sc):NOBUMP;

	jmp	$LN89@getBump
$LN3@getBump:

; 440  : 	if (x < position[low])

	mov	r9, QWORD PTR [rcx+32]
	mov	r8d, DWORD PTR [rcx+56]
	mov	QWORD PTR [rsp+152], rdi

; 438  : 	int high = keys-1;

	dec	r8d
	xor	edi, edi

; 439  : 	int mid;	
; 440  : 	if (x < position[low])

	vmovss	xmm0, DWORD PTR [r9]
	vcomiss	xmm0, xmm7
	ja	SHORT $LN32@getBump

; 441  : 		return low;
; 442  : 	while (low < (high-1)) {

	lea	eax, DWORD PTR [r8-1]
	test	eax, eax
	jle	SHORT $LN34@getBump
$LL33@getBump:

; 443  : 		mid = (low + high) / 2;

	lea	eax, DWORD PTR [r8+rdi]
	cdq
	sub	eax, edx
	sar	eax, 1

; 444  : 		if (x < position[mid])

	movsxd	rcx, eax
	vmovss	xmm0, DWORD PTR [r9+rcx*4]
	vcomiss	xmm0, xmm7
	jbe	SHORT $LN36@getBump

; 445  : 			high  = mid;

	mov	r8d, eax

; 446  : 		else

	jmp	SHORT $LN37@getBump
$LN36@getBump:

; 447  : 			low = mid;		

	mov	edi, eax
$LN37@getBump:

; 441  : 		return low;
; 442  : 	while (low < (high-1)) {

	lea	eax, DWORD PTR [r8-1]
	cmp	edi, eax
	jl	SHORT $LL33@getBump
$LN34@getBump:

; 448  : 	}
; 449  : 	return high;

	mov	edi, r8d
$LN32@getBump:

; 499  : 	if (interpolation == 4) return subtex[high]?subtex[high]->EvalNormalPerturb(sc):NOBUMP;

	mov	eax, DWORD PTR [rsi+68]
	cmp	eax, 4
	jne	SHORT $LN4@getBump
	mov	rax, QWORD PTR [rsi+24]
	movsxd	rcx, edi
	cmp	QWORD PTR [rax+rcx*8], 0
	je	SHORT $LN18@getBump
	mov	rcx, QWORD PTR [rax+rcx*8]
	lea	rdx, QWORD PTR $T6[rbp-113]
	mov	r8, r14
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+1520]
	mov	rcx, rax
	jmp	SHORT $LN19@getBump
$LN18@getBump:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T11[rbp-113], xmm6
	vmovss	DWORD PTR $T11[rbp-109], xmm6
	vmovss	DWORD PTR $T11[rbp-105], xmm6
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 499  : 	if (interpolation == 4) return subtex[high]?subtex[high]->EvalNormalPerturb(sc):NOBUMP;

	lea	rcx, QWORD PTR $T11[rbp-113]
$LN19@getBump:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+8], eax
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 499  : 	if (interpolation == 4) return subtex[high]?subtex[high]->EvalNormalPerturb(sc):NOBUMP;

	jmp	$LN87@getBump
$LN4@getBump:
	mov	QWORD PTR [rsp+144], r15

; 500  : 	int low = high - 1;	

	lea	r15d, DWORD PTR [rdi-1]

; 501  : 	if (interpolation == 3) return subtex[low]?subtex[low]->EvalNormalPerturb(sc):NOBUMP;	

	cmp	eax, 3
	jne	SHORT $LN5@getBump
	movsxd	rcx, r15d
$LN88@getBump:
	mov	rax, QWORD PTR [rsi+24]
	cmp	QWORD PTR [rax+rcx*8], 0
	je	SHORT $LN20@getBump
	mov	rcx, QWORD PTR [rax+rcx*8]
	lea	rdx, QWORD PTR $T5[rbp-113]
	mov	r8, r14
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+1520]
	mov	rcx, rax
	jmp	SHORT $LN21@getBump
$LN20@getBump:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T10[rbp-113], xmm6
	vmovss	DWORD PTR $T10[rbp-109], xmm6
	vmovss	DWORD PTR $T10[rbp-105], xmm6
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 501  : 	if (interpolation == 3) return subtex[low]?subtex[low]->EvalNormalPerturb(sc):NOBUMP;	

	lea	rcx, QWORD PTR $T10[rbp-113]
$LN21@getBump:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+8], eax
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 501  : 	if (interpolation == 3) return subtex[low]?subtex[low]->EvalNormalPerturb(sc):NOBUMP;	

	jmp	$LN84@getBump
$LN5@getBump:

; 502  : 	if (interpolation == 2) {		

	cmp	eax, 2
	jne	SHORT $LN6@getBump

; 503  : 		int key = x-position[low]<position[high]-x?low:high;

	movsxd	rax, r15d
	vsubss	xmm2, xmm7, DWORD PTR [r9+rax*4]
	movsxd	rax, edi
	vmovss	xmm0, DWORD PTR [r9+rax*4]
	vsubss	xmm1, xmm0, xmm7
	vcomiss	xmm1, xmm2
	cmova	edi, r15d

; 504  : 		return subtex[key]?subtex[key]->EvalNormalPerturb(sc):NOBUMP;

	movsxd	rcx, edi
	jmp	SHORT $LN88@getBump
$LN6@getBump:

; 505  : 	}
; 506  : 
; 507  : 	//float f1, f2;
; 508  : 	Point3 v1, v2;
; 509  : 	bool maps = false;
; 510  : 	if (subtex[0]) {

	mov	rcx, QWORD PTR [rsi+24]
	xor	dl, dl
	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN7@getBump

; 511  : 		//f1 = subtex[low]->EvalMono(sc);
; 512  : 		v1 = subtex[low]->EvalNormalPerturb(sc);

	movsxd	rax, r15d
	lea	rdx, QWORD PTR $T4[rbp-113]
	mov	r8, r14
	mov	rcx, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+1520]

; 513  : 		maps = true;

	mov	dl, 1
	vmovsd	xmm0, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+8]

; 514  : 	} else {

	jmp	SHORT $LN85@getBump
$LN7@getBump:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T9[rbp-105], xmm6
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 516  : 		v1 = Point3(0.f, 0.f, 0.f);

	mov	eax, DWORD PTR $T9[rbp-105]
	vunpcklps xmm0, xmm6, xmm6
$LN85@getBump:

; 517  : 	}
; 518  : 	if (subtex[1]) {

	mov	rcx, QWORD PTR [rsi+24]
	mov	DWORD PTR v1$[rbp-105], eax
	vmovsd	QWORD PTR v1$[rbp-113], xmm0
	cmp	QWORD PTR [rcx+8], 0
	je	SHORT $LN9@getBump

; 519  : 		//f2 = subtex[high]->EvalMono(sc);
; 520  : 		v2 = subtex[high]->EvalNormalPerturb(sc);

	movsxd	rax, edi
	lea	rdx, QWORD PTR $T3[rbp-113]
	mov	r8, r14
	mov	rcx, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+1520]
	vmovsd	xmm0, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+8]
	vmovsd	QWORD PTR v2$[rbp-113], xmm0
	mov	DWORD PTR v2$[rbp-105], eax

; 521  : 		maps = true;
; 522  : 	} else {

	jmp	SHORT $LN80@getBump
$LN9@getBump:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T2[rbp-105], xmm6
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 524  : 		v2 = Point3(0.f, 0.f, 0.f);

	mov	eax, DWORD PTR $T2[rbp-105]
	mov	DWORD PTR v2$[rbp-105], eax
	vunpcklps xmm0, xmm6, xmm6
	vmovsd	QWORD PTR v2$[rbp-113], xmm0

; 525  : 	}
; 526  : 	
; 527  : 	// Calculate vector	
; 528  : 	if (maps) {

	test	dl, dl
	je	SHORT $LN11@getBump
$LN80@getBump:

; 529  : 		float mult = interpolate(x, position[low], position[high]);

	mov	r8, QWORD PTR [rsi+32]
	mov	rcx, rsi
	movsxd	rax, edi
	movsxd	rdx, r15d
	vmovaps	xmm1, xmm7
	vmovss	xmm3, DWORD PTR [r8+rax*4]
	vmovss	xmm2, DWORD PTR [r8+rdx*4]
	call	?interpolate@GradientRamp@@QEAAMMMM@Z	; GradientRamp::interpolate
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm4, xmm0, DWORD PTR v2$[rbp-113]
	vmulss	xmm5, xmm0, DWORD PTR v2$[rbp-109]

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vaddss	xmm1, xmm5, DWORD PTR [r13+4]
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 530  : 		v1 = /*(f2-f1)**/ normal + mult*v2 + (1.f-mult)*v1;

	vsubss	xmm3, xmm8, xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm0, xmm0, DWORD PTR v2$[rbp-105]

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vaddss	xmm0, xmm0, DWORD PTR [r13+8]

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm8, xmm3, DWORD PTR v1$[rbp-113]
	vmulss	xmm7, xmm3, DWORD PTR v1$[rbp-109]
	vmulss	xmm6, xmm3, DWORD PTR v1$[rbp-105]

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vaddss	xmm3, xmm4, DWORD PTR [r13]
	vaddss	xmm0, xmm0, xmm6
	vmovss	DWORD PTR $T1[rbp-105], xmm0
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 530  : 		v1 = /*(f2-f1)**/ normal + mult*v2 + (1.f-mult)*v1;

	mov	eax, DWORD PTR $T1[rbp-105]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vaddss	xmm4, xmm3, xmm8
	vaddss	xmm2, xmm1, xmm7
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 530  : 		v1 = /*(f2-f1)**/ normal + mult*v2 + (1.f-mult)*v1;

	vunpcklps xmm0, xmm4, xmm2

; 531  : 	} else {

	jmp	SHORT $LN86@getBump
$LN11@getBump:

; 532  : 		v1 = normal; // * (f2 - f1);

	vmovsd	xmm0, QWORD PTR [r13]
	mov	eax, DWORD PTR [r13+8]
$LN86@getBump:
	vmovsd	QWORD PTR v1$[rbp-113], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR v1$[rbp-113]
	vmovss	xmm1, DWORD PTR v1$[rbp-109]
	vmovss	DWORD PTR [rbx], xmm0
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 532  : 		v1 = normal; // * (f2 - f1);

	mov	DWORD PTR v1$[rbp-105], eax
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR v1$[rbp-105]
	vmovss	DWORD PTR [rbx+8], xmm0
	vmovss	DWORD PTR [rbx+4], xmm1
$LN84@getBump:
	mov	r15, QWORD PTR [rsp+144]
$LN87@getBump:
	mov	rdi, QWORD PTR [rsp+152]
$LN89@getBump:
	vmovaps	xmm8, XMMWORD PTR [rsp+96]
$LN90@getBump:
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 535  : 	return v1;

	mov	rax, rbx

; 536  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-113]
	xor	rcx, rsp
	call	__security_check_cookie
	vmovaps	xmm6, XMMWORD PTR [rsp+128]
	vmovaps	xmm7, XMMWORD PTR [rsp+112]
	add	rsp, 160				; 000000a0H
	pop	r14
	pop	r13
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?getBump@GradientRamp@@QEAA?AVPoint3@@MV2@AEAVShadeContext@@@Z ENDP ; GradientRamp::getBump
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 64
$T8 = 80
this$ = 208
__$ReturnUdt$ = 216
x$ = 224
sc$ = 232
?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z PROC ; GradientRamp::getColor, COMDAT

; 478  : AColor GradientRamp::getColor(float x, ShadeContext& sc) {

$LN88:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rdi
	push	r15
	lea	rbp, QWORD PTR [rsp-71]
	sub	rsp, 176				; 000000b0H
	vxorps	xmm0, xmm0, xmm0

; 479  : 	if (x<=0) return subtex[0]?subtex[0]->EvalColor(sc):color[0];

	vcomiss	xmm0, xmm2
	mov	r15, r9
	mov	rbx, rdx
	vmovaps	xmm1, xmm2
	mov	rdi, rcx
	jb	SHORT $LN2@getColor
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN8@getColor
	mov	rcx, QWORD PTR [rcx]
	lea	rdx, QWORD PTR $T6[rbp-105]
	mov	r8, r9
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+1504]
	mov	rcx, rax
	jmp	SHORT $LN9@getColor
$LN8@getColor:
	mov	rax, QWORD PTR [rdi+40]
	lea	rcx, QWORD PTR $T3[rbp-105]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T3[rbp-105], xmm0
$LN9@getColor:
	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rbx+12], eax
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 479  : 	if (x<=0) return subtex[0]?subtex[0]->EvalColor(sc):color[0];

	jmp	$LN83@getColor
$LN2@getColor:
	vmovaps	XMMWORD PTR [rsp+96], xmm10

; 480  : 	if (x>=1) return subtex[keys-1]?subtex[keys-1]->EvalColor(sc):color[keys-1];

	vmovss	xmm10, DWORD PTR __real@3f800000
	vcomiss	xmm1, xmm10
	jb	SHORT $LN3@getColor
	mov	eax, DWORD PTR [rcx+56]
	dec	eax
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdi+24]
	cmp	QWORD PTR [rax+rcx*8], 0
	je	SHORT $LN10@getColor
	mov	rcx, QWORD PTR [rax+rcx*8]
$LN84@getColor:
	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR $T5[rbp-105]
	mov	r8, r15
	call	QWORD PTR [rax+1504]
	mov	rcx, rax
	jmp	SHORT $LN11@getColor
$LN10@getColor:
	shl	rcx, 4
	add	rcx, QWORD PTR [rdi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	xmm0, XMMWORD PTR [rcx]
$LN82@getColor:
	vmovups	XMMWORD PTR $T2[rbp-105], xmm0
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 480  : 	if (x>=1) return subtex[keys-1]?subtex[keys-1]->EvalColor(sc):color[keys-1];

	lea	rcx, QWORD PTR $T2[rbp-105]
$LN11@getColor:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rbx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rbx+8], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rbx+12], eax
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 480  : 	if (x>=1) return subtex[keys-1]?subtex[keys-1]->EvalColor(sc):color[keys-1];

	jmp	$LN81@getColor
$LN3@getColor:

; 440  : 	if (x < position[low])

	mov	r10, QWORD PTR [rcx+32]
	xor	r11d, r11d
	mov	r8d, DWORD PTR [rcx+56]
	mov	r9d, r11d
	dec	r8d
	vmovss	xmm0, DWORD PTR [r10]
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN67@getColor

; 441  : 		return low;

	mov	r8d, r11d
	jmp	SHORT $LN34@getColor
$LN67@getColor:

; 442  : 	while (low < (high-1)) {

	lea	eax, DWORD PTR [r8-1]
	test	eax, eax
	jle	SHORT $LN34@getColor
$LL33@getColor:

; 443  : 		mid = (low + high) / 2;

	lea	eax, DWORD PTR [r8+r9]
	cdq
	sub	eax, edx
	sar	eax, 1

; 444  : 		if (x < position[mid])

	movsxd	rcx, eax
	vmovss	xmm0, DWORD PTR [r10+rcx*4]
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN36@getColor

; 445  : 			high  = mid;

	mov	r8d, eax

; 446  : 		else

	jmp	SHORT $LN37@getColor
$LN36@getColor:

; 447  : 			low = mid;		

	mov	r9d, eax
$LN37@getColor:

; 442  : 	while (low < (high-1)) {

	lea	eax, DWORD PTR [r8-1]
	cmp	r9d, eax
	jl	SHORT $LL33@getColor
$LN34@getColor:

; 482  : 	if (interpolation == 4) return subtex[high]?subtex[high]->EvalColor(sc):color[high];

	mov	eax, DWORD PTR [rdi+68]
	cmp	eax, 4
	jne	SHORT $LN4@getColor
$LN86@getColor:
	movsxd	rax, r8d
$LN85@getColor:
	mov	rcx, QWORD PTR [rdi+24]
	cmp	QWORD PTR [rcx+rax*8], r11
	je	SHORT $LN12@getColor
	mov	rcx, QWORD PTR [rcx+rax*8]
	jmp	$LN84@getColor
$LN12@getColor:
	shl	rax, 4
	add	rax, QWORD PTR [rdi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	xmm0, XMMWORD PTR [rax]
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 482  : 	if (interpolation == 4) return subtex[high]?subtex[high]->EvalColor(sc):color[high];

	jmp	$LN82@getColor
$LN4@getColor:
	test	r8d, r8d
	lea	ecx, DWORD PTR [r8-1]
	cmovle	ecx, r11d

; 483  : 	int low = (high > 0 ? high - 1 : 0); // should never happen but just in case
; 484  : 	if (interpolation == 3) return subtex[low]?subtex[low]->EvalColor(sc):color[low];	

	cmp	eax, 3
	jne	SHORT $LN5@getColor
	movsxd	rax, ecx
	jmp	SHORT $LN85@getColor
$LN5@getColor:

; 485  : 	if (interpolation == 2) {		

	cmp	eax, 2
	jne	SHORT $LN6@getColor

; 486  : 		int key = x-position[low]<position[high]-x?low:high;

	movsxd	rax, ecx
	vsubss	xmm2, xmm1, DWORD PTR [r10+rax*4]
	movsxd	rax, r8d
	vmovss	xmm0, DWORD PTR [r10+rax*4]
	vsubss	xmm1, xmm0, xmm1
	vcomiss	xmm1, xmm2
	cmova	r8d, ecx

; 487  : 		return subtex[key]?subtex[key]->EvalColor(sc):color[key];

	jmp	SHORT $LN86@getColor
$LN6@getColor:
	mov	QWORD PTR [rsp+208], rsi
	mov	QWORD PTR [rsp+216], r14

; 488  : 	}
; 489  : 	float mult = interpolate(x, position[low], position[high]);

	movsxd	rsi, ecx
	mov	rcx, rdi
	vmovaps	XMMWORD PTR [rsp+160], xmm6
	movsxd	r14, r8d
	vmovaps	XMMWORD PTR [rsp+144], xmm7
	vmovss	xmm2, DWORD PTR [r10+rsi*4]
	vmovaps	XMMWORD PTR [rsp+128], xmm8
	vmovss	xmm3, DWORD PTR [r10+r14*4]
	vmovaps	XMMWORD PTR [rsp+112], xmm9
	call	?interpolate@GradientRamp@@QEAAMMMM@Z	; GradientRamp::interpolate

; 490  : 	return (subtex[low]?subtex[low]->EvalColor(sc):color[low])

	mov	rcx, QWORD PTR [rdi+24]
	vmovaps	xmm9, xmm0
	cmp	QWORD PTR [rcx+r14*8], 0
	je	SHORT $LN22@getColor
	mov	rcx, QWORD PTR [rcx+r14*8]
	lea	rdx, QWORD PTR $T7[rbp-105]
	mov	r8, r15
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+1504]
	mov	r14, rax
	jmp	SHORT $LN23@getColor
$LN22@getColor:
	shl	r14, 4
	add	r14, QWORD PTR [rdi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	xmm0, XMMWORD PTR [r14]
	vmovups	XMMWORD PTR $T1[rbp-105], xmm0
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 490  : 	return (subtex[low]?subtex[low]->EvalColor(sc):color[low])

	lea	r14, QWORD PTR $T1[rbp-105]
$LN23@getColor:
	mov	rcx, QWORD PTR [rdi+24]
	cmp	QWORD PTR [rcx+rsi*8], 0
	je	SHORT $LN20@getColor
	mov	rcx, QWORD PTR [rcx+rsi*8]
	lea	rdx, QWORD PTR $T8[rbp-105]
	mov	r8, r15
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+1504]
	jmp	SHORT $LN21@getColor
$LN20@getColor:
	shl	rsi, 4
	lea	rax, QWORD PTR $T4[rbp-105]
	add	rsi, QWORD PTR [rdi+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	xmm0, XMMWORD PTR [rsi]
	vmovups	XMMWORD PTR $T4[rbp-105], xmm0
$LN21@getColor:

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmulss	xmm6, xmm9, DWORD PTR [r14+4]
	vmulss	xmm7, xmm9, DWORD PTR [r14+8]
	vmulss	xmm8, xmm9, DWORD PTR [r14+12]
	vmulss	xmm5, xmm9, DWORD PTR [r14]
	mov	r14, QWORD PTR [rsp+216]
	mov	rsi, QWORD PTR [rsp+208]
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 490  : 	return (subtex[low]?subtex[low]->EvalColor(sc):color[low])

	vsubss	xmm0, xmm10, xmm9
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmulss	xmm1, xmm0, DWORD PTR [rax]
	vmulss	xmm2, xmm0, DWORD PTR [rax+4]
	vmulss	xmm4, xmm0, DWORD PTR [rax+12]
	vmulss	xmm3, xmm0, DWORD PTR [rax+8]
	vmovaps	xmm9, XMMWORD PTR [rsp+112]

; 291  : 	return(AColor(r+c.r,g+c.g,b+c.b,a+c.a));

	vaddss	xmm0, xmm1, xmm5

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	DWORD PTR [rbx], xmm0

; 291  : 	return(AColor(r+c.r,g+c.g,b+c.b,a+c.a));

	vaddss	xmm1, xmm2, xmm6
	vmovaps	xmm6, XMMWORD PTR [rsp+160]

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	DWORD PTR [rbx+4], xmm1

; 291  : 	return(AColor(r+c.r,g+c.g,b+c.b,a+c.a));

	vaddss	xmm0, xmm3, xmm7
	vmovaps	xmm7, XMMWORD PTR [rsp+144]
	vaddss	xmm1, xmm4, xmm8
	vmovaps	xmm8, XMMWORD PTR [rsp+128]

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	DWORD PTR [rbx+8], xmm0
	vmovss	DWORD PTR [rbx+12], xmm1
$LN81@getColor:
	vmovaps	xmm10, XMMWORD PTR [rsp+96]
$LN83@getColor:
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 490  : 	return (subtex[low]?subtex[low]->EvalColor(sc):color[low])

	mov	rax, rbx

; 491  : 		* (1.f - mult) + (subtex[high]?subtex[high]->EvalColor(sc):color[high]) * mult;
; 492  : }

	mov	rbx, QWORD PTR [rsp+224]
	add	rsp, 176				; 000000b0H
	pop	r15
	pop	rdi
	pop	rbp
	ret	0
?getColor@GradientRamp@@QEAA?AVAColor@@MAEAVShadeContext@@@Z ENDP ; GradientRamp::getColor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?getColor@GradientRamp@@QEAA?AVAColor@@M@Z
_TEXT	SEGMENT
this$ = 96
__$ReturnUdt$ = 104
x$ = 112
?getColor@GradientRamp@@QEAA?AVAColor@@M@Z PROC		; GradientRamp::getColor, COMDAT

; 466  : AColor GradientRamp::getColor(float x) {

$LN58:
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	sub	rsp, 80					; 00000050H
	vxorps	xmm0, xmm0, xmm0

; 467  : 	if (x<=0) return color[0];

	vcomiss	xmm0, xmm2
	vmovaps	xmm1, xmm2
	mov	rsi, rdx
	mov	rbp, rcx
	jb	SHORT $LN2@getColor
	mov	rcx, QWORD PTR [rcx+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rdx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rdx+8], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdx+12], eax
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 475  : 	return color[low] * (1.f - mult) + color[high] * mult;

	mov	rax, rdx

; 476  : }

	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rsi
	ret	0
$LN2@getColor:
	vmovaps	XMMWORD PTR [rsp+32], xmm8

; 468  : 	if (x>=1) return color[keys-1];

	vmovss	xmm8, DWORD PTR __real@3f800000
	vcomiss	xmm1, xmm8
	jb	SHORT $LN3@getColor
	mov	eax, DWORD PTR [rcx+56]
	dec	eax
	movsxd	rcx, eax
	shl	rcx, 4
	add	rcx, QWORD PTR [rbp+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rdx+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rdx+8], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rdx+12], eax
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 468  : 	if (x>=1) return color[keys-1];

	jmp	$LN53@getColor
$LN3@getColor:

; 440  : 	if (x < position[low])

	mov	r10, QWORD PTR [rcx+32]
	xor	r11d, r11d
	mov	r8d, DWORD PTR [rcx+56]
	mov	r9d, r11d
	dec	r8d
	vmovss	xmm0, DWORD PTR [r10]
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN39@getColor

; 441  : 		return low;

	mov	r8d, r11d
	jmp	SHORT $LN16@getColor
$LN39@getColor:

; 442  : 	while (low < (high-1)) {

	lea	eax, DWORD PTR [r8-1]
	test	eax, eax
	jle	SHORT $LN16@getColor
	npad	1
$LL15@getColor:

; 443  : 		mid = (low + high) / 2;

	lea	eax, DWORD PTR [r8+r9]
	cdq
	sub	eax, edx
	sar	eax, 1

; 444  : 		if (x < position[mid])

	movsxd	rcx, eax
	vmovss	xmm0, DWORD PTR [r10+rcx*4]
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN18@getColor

; 445  : 			high  = mid;

	mov	r8d, eax

; 446  : 		else

	jmp	SHORT $LN19@getColor
$LN18@getColor:

; 447  : 			low = mid;		

	mov	r9d, eax
$LN19@getColor:

; 442  : 	while (low < (high-1)) {

	lea	eax, DWORD PTR [r8-1]
	cmp	r9d, eax
	jl	SHORT $LL15@getColor
$LN16@getColor:

; 469  : 	int high = findHighKey(x);
; 470  : 	if (interpolation == 4) return color[high];

	mov	eax, DWORD PTR [rbp+68]
	cmp	eax, 4
	je	SHORT $LN55@getColor

; 471  : 	int low = (high > 0 ? high - 1 : 0); // should never happen but just in case
; 472  : 	if (interpolation == 3) return color[low];

	test	r8d, r8d
	lea	ecx, DWORD PTR [r8-1]
	cmovle	ecx, r11d
	cmp	eax, 3
	jne	SHORT $LN5@getColor
	movsxd	rcx, ecx
	jmp	SHORT $LN54@getColor
$LN5@getColor:

; 473  : 	if (interpolation == 2) return color[x-position[low]<position[high]-x?low:high];

	cmp	eax, 2
	jne	SHORT $LN6@getColor
	movsxd	rax, ecx
	vsubss	xmm2, xmm1, DWORD PTR [r10+rax*4]
	movsxd	rax, r8d
	vmovss	xmm0, DWORD PTR [r10+rax*4]
	vsubss	xmm1, xmm0, xmm1
	vcomiss	xmm1, xmm2
	cmova	r8d, ecx
$LN55@getColor:
	movsxd	rcx, r8d
$LN54@getColor:
	shl	rcx, 4
	add	rcx, QWORD PTR [rbp+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [rsi], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [rsi+4], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [rsi+8], eax
	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rsi+12], eax
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 473  : 	if (interpolation == 2) return color[x-position[low]<position[high]-x?low:high];

	jmp	$LN53@getColor
$LN6@getColor:
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+104], rdi

; 474  : 	float mult = interpolate(x, position[low], position[high]);

	movsxd	rdi, ecx
	mov	rcx, rbp
	movsxd	rbx, r8d
	vmovaps	XMMWORD PTR [rsp+64], xmm6
	vmovaps	XMMWORD PTR [rsp+48], xmm7
	vmovss	xmm2, DWORD PTR [r10+rdi*4]
	vmovss	xmm3, DWORD PTR [r10+rbx*4]
	call	?interpolate@GradientRamp@@QEAAMMMM@Z	; GradientRamp::interpolate

; 475  : 	return color[low] * (1.f - mult) + color[high] * mult;

	vsubss	xmm3, xmm8, xmm0
	shl	rbx, 4
	add	rbx, QWORD PTR [rbp+40]
	shl	rdi, 4
	add	rdi, QWORD PTR [rbp+40]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmulss	xmm7, xmm0, DWORD PTR [rbx+12]
	vmulss	xmm5, xmm0, DWORD PTR [rbx+4]
	vmulss	xmm6, xmm0, DWORD PTR [rbx+8]
	vmulss	xmm4, xmm0, DWORD PTR [rbx]
	vmulss	xmm0, xmm3, DWORD PTR [rdi]
	vmulss	xmm1, xmm3, DWORD PTR [rdi+4]
	vmulss	xmm2, xmm3, DWORD PTR [rdi+8]
	vmulss	xmm3, xmm3, DWORD PTR [rdi+12]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]

; 291  : 	return(AColor(r+c.r,g+c.g,b+c.b,a+c.a));

	vaddss	xmm0, xmm0, xmm4

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	DWORD PTR [rsi], xmm0

; 291  : 	return(AColor(r+c.r,g+c.g,b+c.b,a+c.a));

	vaddss	xmm1, xmm1, xmm5

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	DWORD PTR [rsi+4], xmm1

; 291  : 	return(AColor(r+c.r,g+c.g,b+c.b,a+c.a));

	vaddss	xmm0, xmm2, xmm6
	vmovaps	xmm6, XMMWORD PTR [rsp+64]
	vaddss	xmm1, xmm3, xmm7
	vmovaps	xmm7, XMMWORD PTR [rsp+48]

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	DWORD PTR [rsi+8], xmm0
	vmovss	DWORD PTR [rsi+12], xmm1
$LN53@getColor:
	vmovaps	xmm8, XMMWORD PTR [rsp+32]
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 475  : 	return color[low] * (1.f - mult) + color[high] * mult;

	mov	rax, rsi

; 476  : }

	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rsi
	ret	0
?getColor@GradientRamp@@QEAA?AVAColor@@M@Z ENDP		; GradientRamp::getColor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?interpolate@GradientRamp@@QEAAMMMM@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
low$ = 24
high$ = 32
?interpolate@GradientRamp@@QEAAMMMM@Z PROC		; GradientRamp::interpolate, COMDAT

; 453  : 	//int interpolation; // 0 linear 1 smooth 2 solid near 3 solid left 4 solid right	
; 454  : 	switch (interpolation) {

	mov	edx, DWORD PTR [rcx+68]
	test	edx, edx
	je	SHORT $LN4@interpolat
	cmp	edx, 1
	je	SHORT $LN5@interpolat
	vxorps	xmm0, xmm0, xmm0

; 462  : 	}
; 463  : 	return 0.f;
; 464  : }

	ret	0
$LN5@interpolat:

; 457  : 		case 1:	
; 458  : 			x = (x-low)/(high-low);

	vsubss	xmm0, xmm3, xmm2
	vsubss	xmm1, xmm1, xmm2
	vdivss	xmm4, xmm1, xmm0
	vxorps	xmm3, xmm3, xmm3

; 459  : 			if (x < 0.f) x = 0.f;

	vcomiss	xmm3, xmm4
	ja	SHORT $LN8@interpolat
	vmovss	xmm0, DWORD PTR __real@3f800000
	vminss	xmm3, xmm0, xmm4
$LN8@interpolat:

; 460  : 			else if (x > 1.f) x = 1.f;
; 461  : 			return (x*x*(3.f-2.f*x));

	vmovss	xmm0, DWORD PTR __real@40400000
	vaddss	xmm1, xmm3, xmm3
	vsubss	xmm2, xmm0, xmm1
	vmulss	xmm1, xmm3, xmm3
	vmulss	xmm0, xmm2, xmm1

; 462  : 	}
; 463  : 	return 0.f;
; 464  : }

	ret	0
$LN4@interpolat:

; 455  : 		case 0:	
; 456  : 			return (x - low) / (high - low);

	vsubss	xmm1, xmm1, xmm2
	vsubss	xmm0, xmm3, xmm2
	vdivss	xmm0, xmm1, xmm0

; 462  : 	}
; 463  : 	return 0.f;
; 464  : }

	ret	0
?interpolate@GradientRamp@@QEAAMMMM@Z ENDP		; GradientRamp::interpolate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?findHighKey@GradientRamp@@QEAAHM@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
?findHighKey@GradientRamp@@QEAAHM@Z PROC		; GradientRamp::findHighKey, COMDAT

; 437  : 	int low = 0;
; 438  : 	int high = keys-1;
; 439  : 	int mid;	
; 440  : 	if (x < position[low])

	mov	r10, QWORD PTR [rcx+32]
	xor	r9d, r9d
	mov	r8d, DWORD PTR [rcx+56]
	dec	r8d
	vmovss	xmm0, DWORD PTR [r10]
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN8@findHighKe

; 441  : 		return low;

	xor	eax, eax

; 450  : }

	ret	0
$LN8@findHighKe:

; 442  : 	while (low < (high-1)) {

	lea	eax, DWORD PTR [r8-1]
	test	eax, eax
	jle	SHORT $LN3@findHighKe
$LL2@findHighKe:

; 443  : 		mid = (low + high) / 2;

	lea	eax, DWORD PTR [r8+r9]
	cdq
	sub	eax, edx
	sar	eax, 1
	movsxd	rcx, eax

; 444  : 		if (x < position[mid])

	vmovss	xmm0, DWORD PTR [r10+rcx*4]
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN5@findHighKe

; 445  : 			high  = mid;

	mov	r8d, ecx

; 446  : 		else

	jmp	SHORT $LN6@findHighKe
$LN5@findHighKe:

; 447  : 			low = mid;		

	mov	r9d, ecx
$LN6@findHighKe:

; 442  : 	while (low < (high-1)) {

	lea	ecx, DWORD PTR [r8-1]
	cmp	r9d, ecx
	jl	SHORT $LL2@findHighKe
$LN3@findHighKe:

; 448  : 	}
; 449  : 	return high;

	mov	eax, r8d

; 450  : }

	ret	0
?findHighKey@GradientRamp@@QEAAHM@Z ENDP		; GradientRamp::findHighKey
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?setSubtex@GradientRamp@@QEAAXPEAVTexmap@@@Z
_TEXT	SEGMENT
this$ = 8
sub$ = 16
?setSubtex@GradientRamp@@QEAAXPEAVTexmap@@@Z PROC	; GradientRamp::setSubtex, COMDAT

; 412  : 	if (selected >= 0 && selected < keys)

	mov	r9d, DWORD PTR [rcx+64]
	mov	r11, rdx
	mov	r10, rcx
	test	r9d, r9d
	js	SHORT $LN2@setSubtex
	movsxd	rcx, DWORD PTR [rcx+56]
	cmp	r9d, ecx
	jge	SHORT $LN2@setSubtex

; 159  : 	for (int i=0;i<keys;i++)

	xor	r8d, r8d
	test	ecx, ecx
	jle	SHORT $LN8@setSubtex

; 160  : 		if (number[i] == n)

	mov	rax, QWORD PTR [r10+48]
	mov	rdx, rcx
	mov	ecx, r8d
	npad	7
$LL9@setSubtex:
	cmp	DWORD PTR [rax], r9d
	je	SHORT $LN6@setSubtex

; 159  : 	for (int i=0;i<keys;i++)

	inc	r8d
	inc	rcx
	add	rax, 4
	cmp	rcx, rdx
	jl	SHORT $LL9@setSubtex
$LN8@setSubtex:

; 161  : 			return i;
; 162  : 	return -1;

	or	r8d, -1
$LN6@setSubtex:

; 408  : 	subtex[toIndex(n)] = sub;

	mov	rax, QWORD PTR [r10+24]
	movsxd	rcx, r8d
	mov	QWORD PTR [rax+rcx*8], r11
$LN2@setSubtex:

; 413  : 		setSubtex(selected, sub);
; 414  : }	

	ret	0
?setSubtex@GradientRamp@@QEAAXPEAVTexmap@@@Z ENDP	; GradientRamp::setSubtex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z
_TEXT	SEGMENT
this$ = 8
n$ = 16
sub$ = 24
?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z PROC	; GradientRamp::setSubtex, COMDAT

; 407  : void GradientRamp::setSubtex(int n, Texmap* sub) {

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	mov	rbx, rcx

; 159  : 	for (int i=0;i<keys;i++)

	xor	r10d, r10d
	movsxd	rcx, DWORD PTR [rcx+56]
	test	ecx, ecx
	jle	SHORT $LN5@setSubtex

; 160  : 		if (number[i] == n)

	mov	rax, QWORD PTR [rbx+48]
	mov	r9d, r10d
	npad	6
$LL6@setSubtex:
	cmp	DWORD PTR [rax], edx
	je	SHORT $LN3@setSubtex

; 159  : 	for (int i=0;i<keys;i++)

	inc	r10d
	inc	r9
	add	rax, 4
	cmp	r9, rcx
	jl	SHORT $LL6@setSubtex
$LN5@setSubtex:

; 161  : 			return i;
; 162  : 	return -1;

	or	r10d, -1
$LN3@setSubtex:

; 408  : 	subtex[toIndex(n)] = sub;

	mov	rax, QWORD PTR [rbx+24]

; 409  : }

	mov	rbx, QWORD PTR [rsp+8]
	movsxd	rcx, r10d
	mov	QWORD PTR [rax+rcx*8], r8
	ret	0
?setSubtex@GradientRamp@@QEAAXHPEAVTexmap@@@Z ENDP	; GradientRamp::setSubtex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?getSubtex@GradientRamp@@QEAAPEAVTexmap@@H@Z
_TEXT	SEGMENT
this$ = 8
n$ = 16
?getSubtex@GradientRamp@@QEAAPEAVTexmap@@H@Z PROC	; GradientRamp::getSubtex, COMDAT

; 396  : Texmap* GradientRamp::getSubtex(int n) {

	mov	r8d, edx
	mov	r9, rcx

; 397  : 	if (n == -1)

	cmp	edx, -1
	jne	SHORT $LN2@getSubtex

; 398  : 		if (selected >= 0 && selected < keys)

	mov	r8d, DWORD PTR [rcx+64]
	test	r8d, r8d
	js	SHORT $LN4@getSubtex
	movsxd	rdx, DWORD PTR [rcx+56]
	cmp	r8d, edx
	jge	SHORT $LN4@getSubtex

; 159  : 	for (int i=0;i<keys;i++)

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN15@getSubtex

; 160  : 		if (number[i] == n)

	mov	rcx, QWORD PTR [rcx+48]
	mov	r10, rdx
	mov	edx, eax
	npad	4
$LL10@getSubtex:
	cmp	DWORD PTR [rcx], r8d
	je	SHORT $LN13@getSubtex

; 159  : 	for (int i=0;i<keys;i++)

	inc	eax
	inc	rdx
	add	rcx, 4
	cmp	rdx, r10
	jl	SHORT $LL10@getSubtex

; 162  : 	return -1;

	or	eax, -1

; 402  : 	else
; 403  : 		return subtex[toIndex(n)]; 

	movsxd	rcx, eax
	mov	rax, QWORD PTR [r9+24]
	mov	rax, QWORD PTR [rax+rcx*8]

; 404  : }

	ret	0
$LN4@getSubtex:

; 399  : 			return subtex[toIndex(selected)];
; 400  : 		else
; 401  : 			return NULL;

	xor	eax, eax

; 404  : }

	ret	0
$LN2@getSubtex:
	movsxd	rdx, DWORD PTR [rcx+56]

; 159  : 	for (int i=0;i<keys;i++)

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN15@getSubtex

; 160  : 		if (number[i] == n)

	mov	rcx, QWORD PTR [rcx+48]
	mov	r10, rdx
	mov	edx, eax
$LL16@getSubtex:
	cmp	DWORD PTR [rcx], r8d
	je	SHORT $LN13@getSubtex

; 159  : 	for (int i=0;i<keys;i++)

	inc	eax
	inc	rdx
	add	rcx, 4
	cmp	rdx, r10
	jl	SHORT $LL16@getSubtex
$LN15@getSubtex:

; 161  : 			return i;
; 162  : 	return -1;

	or	eax, -1
$LN13@getSubtex:

; 402  : 	else
; 403  : 		return subtex[toIndex(n)]; 

	movsxd	rcx, eax
	mov	rax, QWORD PTR [r9+24]
	mov	rax, QWORD PTR [rax+rcx*8]

; 404  : }

	ret	0
?getSubtex@GradientRamp@@QEAAPEAVTexmap@@H@Z ENDP	; GradientRamp::getSubtex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?sort@GradientRamp@@QEAAXXZ
_TEXT	SEGMENT
col$1 = 0
this$ = 32
?sort@GradientRamp@@QEAAXXZ PROC			; GradientRamp::sort, COMDAT

; 378  : void GradientRamp::sort() {

$LN16:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 16

; 379  : 	int i = 1;	

	mov	ebx, 1
	mov	rdi, rcx

; 380  : 	while (i < keys) {

	cmp	DWORD PTR [rcx+56], ebx
	jle	$LN3@sort

; 379  : 	int i = 1;	

	mov	QWORD PTR [rsp+32], rsi
	mov	r11d, ebx
	mov	QWORD PTR [rsp+40], r14
	npad	8
$LL2@sort:

; 381  : 		if (position[i-1] <= position[i]) {

	mov	rax, QWORD PTR [rdi+32]
	lea	rsi, QWORD PTR [r11-1]
	lea	r14, QWORD PTR [r11*4]
	vmovss	xmm2, DWORD PTR [rax+rsi*4]
	vmovss	xmm0, DWORD PTR [r14+rax]
	vcomiss	xmm0, xmm2
	jb	SHORT $LN4@sort

; 382  : 	        i++;			

	inc	ebx
	inc	r11

; 383  : 		} else {

	jmp	$LN6@sort
$LN4@sort:

; 362  : 	Texmap* sub	= subtex[a];

	mov	rcx, QWORD PTR [rdi+24]

; 366  : 	
; 367  : 	subtex[a]	= subtex[b];

	lea	rdx, QWORD PTR [r11*8]
	mov	rax, QWORD PTR [rdi+40]

; 369  : 	color[a]	= color[b];

	add	r11, r11
	mov	r9, rsi

; 384  : 			swap(i-1, i);
; 385  : 			i--;

	dec	ebx

; 364  : 	AColor col	= color[a];

	add	r9, r9
	mov	r10, QWORD PTR [rcx+rsi*8]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	xmm0, XMMWORD PTR [rax+r9*8]
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 365  : 	int num		= number[a];

	mov	rax, QWORD PTR [rdi+48]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	XMMWORD PTR col$1[rsp], xmm0
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 365  : 	int num		= number[a];

	mov	r8d, DWORD PTR [rax+rsi*4]

; 366  : 	
; 367  : 	subtex[a]	= subtex[b];

	mov	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR [rcx+rsi*8], rax

; 368  : 	position[a] = position[b];

	mov	rcx, QWORD PTR [rdi+32]
	mov	eax, DWORD PTR [rcx+r14]
	mov	DWORD PTR [rcx+rsi*4], eax

; 369  : 	color[a]	= color[b];

	mov	rax, QWORD PTR [rdi+40]
	vmovups	xmm0, XMMWORD PTR [rax+r11*8]
	vmovups	XMMWORD PTR [rax+r9*8], xmm0

; 370  : 	number[a]	= number[b];

	mov	rcx, QWORD PTR [rdi+48]

; 371  : 
; 372  : 	subtex[b]	= sub;
; 373  : 	position[b] = pos;
; 374  : 	color[b]	= col;

	vmovups	xmm0, XMMWORD PTR col$1[rsp]
	mov	eax, DWORD PTR [rcx+r14]
	mov	DWORD PTR [rcx+rsi*4], eax
	mov	rax, QWORD PTR [rdi+24]
	mov	QWORD PTR [rdx+rax], r10
	mov	rax, QWORD PTR [rdi+32]
	vmovss	DWORD PTR [r14+rax], xmm2
	mov	rax, QWORD PTR [rdi+40]
	vmovups	XMMWORD PTR [rax+r11*8], xmm0

; 375  : 	number[b]	= num;

	mov	rax, QWORD PTR [rdi+48]

; 384  : 			swap(i-1, i);
; 385  : 			i--;

	mov	r11, rsi

; 375  : 	number[b]	= num;

	mov	DWORD PTR [r14+rax], r8d

; 386  : 			if (i <= 0)

	test	rsi, rsi
	jg	SHORT $LN6@sort

; 387  : 				i = 1;

	mov	ebx, 1
	mov	r11d, ebx
$LN6@sort:

; 380  : 	while (i < keys) {

	cmp	ebx, DWORD PTR [rdi+56]
	jl	$LL2@sort
	mov	r14, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+32]
$LN3@sort:

; 388  : 		}
; 389  : 	} 
; 390  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 16
	pop	rdi
	ret	0
?sort@GradientRamp@@QEAAXXZ ENDP			; GradientRamp::sort
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?swap@GradientRamp@@QEAAXHH@Z
_TEXT	SEGMENT
col$ = 0
this$ = 32
a$ = 40
b$ = 48
?swap@GradientRamp@@QEAAXHH@Z PROC			; GradientRamp::swap, COMDAT

; 361  : void GradientRamp::swap(int a, int b) {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 16

; 362  : 	Texmap* sub	= subtex[a];

	mov	r9, QWORD PTR [rcx+24]
	mov	r14, rcx

; 363  : 	float pos	= position[a];

	mov	rax, QWORD PTR [rcx+32]
	movsxd	rsi, edx
	mov	rbp, QWORD PTR [r9+rsi*8]
	lea	r10, QWORD PTR [r9+rsi*8]

; 366  : 	
; 367  : 	subtex[a]	= subtex[b];

	movsxd	r11, r8d
	lea	rdi, QWORD PTR [rsi*4]
	add	rsi, rsi
	vmovss	xmm2, DWORD PTR [rdi+rax]
	mov	rax, QWORD PTR [rcx+40]

; 368  : 	position[a] = position[b];

	lea	r8, QWORD PTR [r11*4]
	lea	rdx, QWORD PTR [r11*8]

; 369  : 	color[a]	= color[b];

	add	r11, r11
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	xmm0, XMMWORD PTR [rax+rsi*8]
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 365  : 	int num		= number[a];

	mov	rax, QWORD PTR [rcx+48]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	vmovups	XMMWORD PTR col$[rsp], xmm0
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp

; 365  : 	int num		= number[a];

	mov	ebx, DWORD PTR [rdi+rax]

; 366  : 	
; 367  : 	subtex[a]	= subtex[b];

	mov	rax, QWORD PTR [rdx+r9]
	mov	QWORD PTR [r10], rax

; 368  : 	position[a] = position[b];

	mov	rcx, QWORD PTR [rcx+32]
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rdi+rcx], eax

; 369  : 	color[a]	= color[b];

	mov	rax, QWORD PTR [r14+40]
	vmovups	xmm0, XMMWORD PTR [rax+r11*8]
	vmovups	XMMWORD PTR [rax+rsi*8], xmm0

; 370  : 	number[a]	= number[b];

	mov	rcx, QWORD PTR [r14+48]

; 371  : 
; 372  : 	subtex[b]	= sub;
; 373  : 	position[b] = pos;
; 374  : 	color[b]	= col;

	vmovups	xmm0, XMMWORD PTR col$[rsp]

; 375  : 	number[b]	= num;
; 376  : }

	mov	rsi, QWORD PTR [rsp+48]
	mov	eax, DWORD PTR [r8+rcx]
	mov	DWORD PTR [rdi+rcx], eax
	mov	rax, QWORD PTR [r14+24]
	mov	rdi, QWORD PTR [rsp+56]
	mov	QWORD PTR [rdx+rax], rbp
	mov	rax, QWORD PTR [r14+32]
	mov	rbp, QWORD PTR [rsp+40]
	vmovss	DWORD PTR [r8+rax], xmm2
	mov	rax, QWORD PTR [r14+40]
	vmovups	XMMWORD PTR [rax+r11*8], xmm0
	mov	rax, QWORD PTR [r14+48]
	mov	DWORD PTR [r8+rax], ebx
	mov	rbx, QWORD PTR [rsp+32]
	add	rsp, 16
	pop	r14
	ret	0
?swap@GradientRamp@@QEAAXHH@Z ENDP			; GradientRamp::swap
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?reset@GradientRamp@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
this$ = 96
?reset@GradientRamp@@QEAAXXZ PROC			; GradientRamp::reset, COMDAT

; 344  : void GradientRamp::reset() {		

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 80					; 00000050H

; 345  : 	keys = 0;

	xor	edi, edi
	mov	rbx, rcx
	mov	DWORD PTR [rcx+56], edi

; 346  : 	
; 347  : 	if (subtex) delete[] subtex;

	mov	rcx, QWORD PTR [rcx+24]
	test	rcx, rcx
	je	SHORT $LN2@reset
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN2@reset:

; 348  : 	if (position) delete[] position;

	mov	rcx, QWORD PTR [rbx+32]
	test	rcx, rcx
	je	SHORT $LN3@reset
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN3@reset:

; 349  : 	if (color) delete[] color;

	mov	rcx, QWORD PTR [rbx+40]
	test	rcx, rcx
	je	SHORT $LN4@reset
	call	QWORD PTR __imp_??_VMaxHeapOperators@@SAXPEAX@Z
$LN4@reset:

; 350  : 	if (number) delete[] number;

	mov	rcx, QWORD PTR [rbx+48]
	test	rcx, rcx
	je	SHORT $LN5@reset
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN5@reset:
	vmovups	xmm0, XMMWORD PTR __xmm@3f800000000000000000000000000000

; 351  : 	
; 352  : 	subtex = NULL;
; 353  : 	position = NULL;
; 354  : 	color = NULL;
; 355  : 	number = NULL;
; 356  : 
; 357  : 	addKey(0, 0.f, AColor(0.f,0.f,0.f,1.f), NULL);

	lea	r9, QWORD PTR $T2[rsp]
	mov	QWORD PTR [rbx+24], rdi
	vxorps	xmm2, xmm2, xmm2
	xor	edx, edx
	mov	QWORD PTR [rbx+32], rdi
	mov	rcx, rbx
	mov	QWORD PTR [rbx+40], rdi
	vmovups	XMMWORD PTR $T2[rsp], xmm0
	mov	QWORD PTR [rbx+48], rdi
	mov	QWORD PTR [rsp+32], rdi
	call	?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z ; GradientRamp::addKey
	vmovups	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000

; 358  : 	addKey(1, 1.f, AColor(1.f,1.f,1.f,1.f), NULL);	

	vmovss	xmm2, DWORD PTR __real@3f800000
	lea	r9, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rsp+32], rdi
	mov	edx, 1
	mov	rcx, rbx
	vmovups	XMMWORD PTR $T1[rsp], xmm0
	call	?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z ; GradientRamp::addKey

; 359  : }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?reset@GradientRamp@@QEAAXXZ ENDP			; GradientRamp::reset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z
_TEXT	SEGMENT
$T1 = 112
this$ = 112
n$ = 120
pos$ = 128
col$ = 136
sub$ = 144
?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z PROC ; GradientRamp::addKey, COMDAT

; 296  : void GradientRamp::addKey(int n, float pos, AColor col, Texmap* sub) {

$LN36:
	mov	rax, rsp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR [rax-72], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rbp
	mov	QWORD PTR [rax+32], rsi
	vmovaps	XMMWORD PTR [rax-56], xmm6
	mov	r13, r9
	mov	esi, edx
	mov	rbx, rcx
	vxorps	xmm6, xmm6, xmm6

; 297  : 	if (pos < 0.f) pos = 0.f;

	vcomiss	xmm6, xmm2
	ja	SHORT $LN10@addKey
	vmovss	xmm0, DWORD PTR __real@3f800000
	vminss	xmm6, xmm0, xmm2
$LN10@addKey:

; 298  : 	else if (pos > 1.f) pos = 1.f;
; 299  : 
; 300  : 	int key = -1;

	or	r14, -1
	mov	eax, r14d

; 301  : 	for (int i=0;i<keys;i++)

	xor	edi, edi
	mov	ecx, edi
	mov	r8d, DWORD PTR [rbx+56]
	test	r8d, r8d
	jle	SHORT $LN12@addKey

; 302  : 		if (number[i] == n)

	mov	rdx, QWORD PTR [rbx+48]
	npad	1
$LL4@addKey:
	cmp	DWORD PTR [rdx], esi
	cmove	eax, ecx

; 301  : 	for (int i=0;i<keys;i++)

	inc	ecx
	lea	rdx, QWORD PTR [rdx+4]
	cmp	ecx, r8d
	jl	SHORT $LL4@addKey

; 303  : 			key = i;
; 304  : 
; 305  : 	if (key >= 0) { // update only, no keys added

	test	eax, eax
	js	SHORT $LN12@addKey

; 306  : 		subtex[key] = sub;

	movsxd	rdx, eax
	mov	rcx, QWORD PTR [rbx+24]
	mov	rax, QWORD PTR sub$[rsp]
	mov	QWORD PTR [rcx+rdx*8], rax

; 307  : 		position[key] = pos;

	mov	rax, QWORD PTR [rbx+32]
	vmovss	DWORD PTR [rax+rdx*4], xmm6

; 308  : 		color[key] = col;

	add	rdx, rdx
	mov	rax, QWORD PTR [rbx+40]
	vmovups	xmm0, XMMWORD PTR [r9]
	vmovups	XMMWORD PTR [rax+rdx*8], xmm0

; 309  : 		return;

	jmp	$LN1@addKey
$LN12@addKey:

; 310  : 	}
; 311  : 
; 312  : 	keys++;	

	lea	eax, DWORD PTR [r8+1]
	mov	DWORD PTR [rbx+56], eax

; 313  : 	Texmap** t_subtex = new Texmap*[keys];

	movsxd	rcx, eax
	mov	eax, 8
	mul	rcx
	cmovo	rax, r14
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r15, rax

; 314  : 	float* t_position = new float[keys];

	movsxd	rcx, DWORD PTR [rbx+56]
	mov	eax, 4
	mul	rcx
	cmovo	rax, r14
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r12, rax

; 315  : 	AColor* t_color = new AColor[keys];

	movsxd	rcx, DWORD PTR [rbx+56]
	mov	eax, 16
	mul	rcx
	cmovo	rax, r14
	mov	rcx, rax
	call	QWORD PTR __imp_??_UMaxHeapOperators@@SAPEAX_K@Z
	mov	rbp, rax
	mov	QWORD PTR $T1[rsp], rax

; 316  : 	int* t_number = new int[keys];

	movsxd	rcx, DWORD PTR [rbx+56]
	mov	eax, 4
	mul	rcx
	cmovo	rax, r14
	mov	rcx, rax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	r14, rax

; 317  : 	keys--;

	mov	ecx, DWORD PTR [rbx+56]
	dec	ecx
	mov	DWORD PTR [rbx+56], ecx

; 318  : 
; 319  : 	for (int i=0;i<keys;i++) {

	test	ecx, ecx
	jle	SHORT $LN6@addKey
	mov	r8, rdi
	mov	r9, rdi
	mov	r10, rdi
	mov	r11, r12
	sub	r11, rax
	npad	7
$LL7@addKey:

; 320  : 		t_subtex[i] = subtex[i];

	mov	rax, QWORD PTR [rbx+24]
	mov	rcx, QWORD PTR [r10+rax]
	mov	QWORD PTR [r10+r15], rcx

; 321  : 		t_position[i] = position[i];

	lea	rdx, QWORD PTR [r8+r14]
	mov	rax, QWORD PTR [rbx+32]
	mov	ecx, DWORD PTR [r8+rax]
	mov	DWORD PTR [r11+rdx], ecx

; 322  : 		t_color[i] = color[i];

	mov	rax, QWORD PTR [rbx+40]
	vmovups	xmm0, XMMWORD PTR [r9+rax]
	vmovups	XMMWORD PTR [r9+rbp], xmm0

; 323  : 		t_number[i] = number[i];

	mov	rax, QWORD PTR [rbx+48]
	mov	ecx, DWORD PTR [r8+rax]
	mov	DWORD PTR [rdx], ecx

; 318  : 
; 319  : 	for (int i=0;i<keys;i++) {

	inc	edi
	lea	r10, QWORD PTR [r10+8]
	lea	r9, QWORD PTR [r9+16]
	lea	r8, QWORD PTR [r8+4]
	cmp	edi, DWORD PTR [rbx+56]
	jl	SHORT $LL7@addKey
$LN6@addKey:

; 324  : 	}
; 325  : 
; 326  : 	t_subtex[keys] = sub;

	movsxd	rcx, DWORD PTR [rbx+56]
	mov	rax, QWORD PTR sub$[rsp]
	mov	QWORD PTR [r15+rcx*8], rax

; 327  : 	t_position[keys] = pos;

	movsxd	rax, DWORD PTR [rbx+56]
	vmovss	DWORD PTR [r12+rax*4], xmm6

; 328  : 	t_color[keys] = col;

	movsxd	rax, DWORD PTR [rbx+56]
	add	rax, rax
	vmovups	xmm0, XMMWORD PTR [r13]
	vmovups	XMMWORD PTR [rbp+rax*8], xmm0

; 329  : 	t_number[keys] = n;

	movsxd	rax, DWORD PTR [rbx+56]
	mov	DWORD PTR [r14+rax*4], esi

; 330  : 
; 331  : 	delete[] subtex;

	mov	rcx, QWORD PTR [rbx+24]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 332  : 	delete[] position;

	mov	rcx, QWORD PTR [rbx+32]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 333  : 	delete[] color;

	mov	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR __imp_??_VMaxHeapOperators@@SAXPEAX@Z

; 334  : 	delete[] number;

	mov	rcx, QWORD PTR [rbx+48]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 335  : 
; 336  : 	subtex = t_subtex;

	mov	QWORD PTR [rbx+24], r15

; 337  : 	position = t_position;

	mov	QWORD PTR [rbx+32], r12

; 338  : 	color = t_color;

	mov	QWORD PTR [rbx+40], rbp

; 339  : 	number = t_number;

	mov	QWORD PTR [rbx+48], r14

; 340  : 
; 341  : 	keys++;		

	inc	DWORD PTR [rbx+56]
$LN1@addKey:

; 342  : }

	lea	r11, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	vmovaps	xmm6, XMMWORD PTR [rsp+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z ENDP ; GradientRamp::addKey
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 112
this$ = 112
n$ = 120
pos$ = 128
col$ = 136
sub$ = 144
?dtor$0@?0??addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z@4HA PROC ; `GradientRamp::addKey'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	rex_jmp	QWORD PTR __imp_??_VMaxHeapOperators@@SAXPEAX@Z
?dtor$0@?0??addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z@4HA ENDP ; `GradientRamp::addKey'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 112
this$ = 112
n$ = 120
pos$ = 128
col$ = 136
sub$ = 144
?dtor$0@?0??addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z@4HA PROC ; `GradientRamp::addKey'::`1'::dtor$0
	mov	rcx, QWORD PTR $T1[rdx]
	rex_jmp	QWORD PTR __imp_??_VMaxHeapOperators@@SAXPEAX@Z
?dtor$0@?0??addKey@GradientRamp@@QEAAXHMVAColor@@PEAVTexmap@@@Z@4HA ENDP ; `GradientRamp::addKey'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?selectKey@GradientRamp@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
n$ = 16
?selectKey@GradientRamp@@QEAAXH@Z PROC			; GradientRamp::selectKey, COMDAT

; 270  : 	selected = n;	

	mov	DWORD PTR [rcx+64], edx

; 271  : 	//CharStream *out = thread_local(current_stdout);
; 272  : 	//out->printf("Selection sent (%d)\n", selected);
; 273  : 	parent->gradSelKey();

	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+24]
?selectKey@GradientRamp@@QEAAXH@Z ENDP			; GradientRamp::selectKey
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?toIndex@GradientRamp@@QEAAHH@Z
_TEXT	SEGMENT
this$ = 8
n$ = 16
?toIndex@GradientRamp@@QEAAHH@Z PROC			; GradientRamp::toIndex, COMDAT

; 158  : int GradientRamp::toIndex(int n) {	

	movsxd	r9, DWORD PTR [rcx+56]

; 159  : 	for (int i=0;i<keys;i++)

	xor	r8d, r8d
	test	r9d, r9d
	jle	SHORT $LN3@toIndex

; 160  : 		if (number[i] == n)

	mov	rax, QWORD PTR [rcx+48]
	mov	ecx, r8d
$LL4@toIndex:
	cmp	DWORD PTR [rax], edx
	je	SHORT $LN8@toIndex

; 159  : 	for (int i=0;i<keys;i++)

	inc	r8d
	inc	rcx
	add	rax, 4
	cmp	rcx, r9
	jl	SHORT $LL4@toIndex
$LN3@toIndex:

; 162  : 	return -1;

	or	eax, -1

; 163  : }

	ret	0
$LN8@toIndex:

; 161  : 			return i;

	mov	eax, r8d

; 163  : }

	ret	0
?toIndex@GradientRamp@@QEAAHH@Z ENDP			; GradientRamp::toIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?popup@GradientRamp@@QEAAXHHH@Z
_TEXT	SEGMENT
this$ = 48
x$ = 56
y$ = 64
sel$ = 72
?popup@GradientRamp@@QEAAXHHH@Z PROC			; GradientRamp::popup, COMDAT

; 237  : void GradientRamp::popup(int x, int y, int sel) {

$LN38:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 183  : 	float f_Width = (float)(width - PADDING * 2);	

	mov	edi, DWORD PTR [rcx+16]

; 237  : void GradientRamp::popup(int x, int y, int sel) {

	mov	rbx, rcx

; 184  : 	for (int i=0;i<keys;i++) {

	xor	ecx, ecx

; 237  : void GradientRamp::popup(int x, int y, int sel) {

	mov	r10d, edx
	vxorps	xmm2, xmm2, xmm2

; 184  : 	for (int i=0;i<keys;i++) {

	mov	r11d, DWORD PTR [rbx+56]
	lea	eax, DWORD PTR [rdi-12]
	vcvtsi2ss xmm2, xmm2, eax
	test	r11d, r11d
	jle	SHORT $LN35@popup

; 185  : 		int kx = (int)(f_Width * position[i]) + PADDING;

	mov	r8, QWORD PTR [rbx+32]
	npad	3
$LL16@popup:
	vmulss	xmm0, xmm2, DWORD PTR [r8]
	vcvttss2si edx, xmm0

; 186  : 		//out->printf("Hit key: %d %d %d\n", x-dist, x+dist, x);
; 187  : 		if (kx-dist <= x && kx+dist >= x)

	cmp	edx, r10d
	jg	SHORT $LN14@popup
	lea	eax, DWORD PTR [rdx+12]
	cmp	eax, r10d
	jge	SHORT $LN13@popup
$LN14@popup:

; 184  : 	for (int i=0;i<keys;i++) {

	inc	ecx
	add	r8, 4
	cmp	ecx, r11d
	jl	SHORT $LL16@popup
$LN35@popup:

; 188  : 			return i;
; 189  : 	}
; 190  : 
; 191  : 	// No keys found
; 192  : 	return -1;	

	or	ecx, -1
$LN13@popup:

; 238  : 	int key = hit(x,y,true);
; 239  : 	switch (sel) {

	sub	r9d, 40005				; 00009c45H
	je	$LN6@popup
	sub	r9d, 1
	je	SHORT $LN4@popup
	cmp	r9d, 1
	jne	$LN10@popup

; 255  : 			}
; 256  : 			break;
; 257  : 		case ID_RESET_RESET:
; 258  : 			selected = -1;
; 259  : 			parent->gradReset();

	mov	rcx, QWORD PTR [rbx+8]
	mov	DWORD PTR [rbx+64], -1
	mov	rax, QWORD PTR [rcx]

; 260  : 			break;
; 261  : 	}
; 262  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 255  : 			}
; 256  : 			break;
; 257  : 		case ID_RESET_RESET:
; 258  : 			selected = -1;
; 259  : 			parent->gradReset();

	rex_jmp	QWORD PTR [rax+32]
$LN4@popup:

; 240  : 		case ID_MENU_ADDKEY:
; 241  : 			if (key == -1) {

	cmp	ecx, -1
	jne	$LN10@popup

; 151  : 	if (x > width - PADDING)

	lea	eax, DWORD PTR [rdi-6]
	vxorps	xmm1, xmm1, xmm1
	cmp	r10d, eax
	jle	SHORT $LN25@popup

; 152  : 		pos = 1.f;

	vmovss	xmm1, DWORD PTR __real@3f800000
	jmp	SHORT $LN27@popup
$LN25@popup:

; 153  : 	else if (x > PADDING)

	cmp	r10d, 6
	jle	SHORT $LN27@popup

; 154  : 		pos = (float)(x - PADDING) / (float)(width - PADDING * 2);

	lea	eax, DWORD PTR [r10-6]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm2
$LN27@popup:

; 242  : 				parent->gradAddKey(toPos(x));

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax]

; 243  : 				selected = keys - 1; // New key gets the last id

	mov	eax, DWORD PTR [rbx+56]

; 244  : 				parent->gradSelKey();

	mov	rcx, QWORD PTR [rbx+8]
	dec	eax
	mov	DWORD PTR [rbx+64], eax
	mov	rax, QWORD PTR [rcx]

; 260  : 			break;
; 261  : 	}
; 262  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 244  : 				parent->gradSelKey();

	rex_jmp	QWORD PTR [rax+24]
$LN6@popup:

; 245  : 			}
; 246  : 			break;
; 247  : 		case ID_MENU_REMOVEKEY:
; 248  : 			if (key >= 0) {

	test	ecx, ecx
	js	SHORT $LN7@popup

; 249  : 				if (selected == number[key]) selected = -1;

	mov	r8, QWORD PTR [rbx+48]
	movsxd	rdx, ecx
	mov	eax, DWORD PTR [r8+rdx*4]
	cmp	DWORD PTR [rbx+64], eax
	jne	SHORT $LN9@popup
	mov	DWORD PTR [rbx+64], -1
$LN9@popup:

; 250  : 				parent->gradDelKey(number[key]);

	mov	edx, DWORD PTR [r8+rdx*4]
	jmp	SHORT $LN36@popup
$LN7@popup:

; 251  : 			} else if (selected >= 0) {

	mov	edx, DWORD PTR [rbx+64]
	test	edx, edx
	js	SHORT $LN10@popup

; 252  : 				int k = selected;				
; 253  : 				selected = -1;

	mov	DWORD PTR [rbx+64], -1
$LN36@popup:

; 254  : 				parent->gradDelKey(k);

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
$LN10@popup:

; 260  : 			break;
; 261  : 	}
; 262  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?popup@GradientRamp@@QEAAXHHH@Z ENDP			; GradientRamp::popup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?dragging@GradientRamp@@QEAAXHH_N00@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
ctrl$ = 32
shift$ = 40
alt$ = 48
?dragging@GradientRamp@@QEAAXHH_N00@Z PROC		; GradientRamp::dragging, COMDAT

; 229  : 	if (selected <= 1) // Refuse to move ends and empty

	mov	r8d, DWORD PTR [rcx+64]
	cmp	r8d, 1
	jle	SHORT $LN3@dragging

; 230  : 		return; 	
; 231  : 	if (selected < keys)

	cmp	r8d, DWORD PTR [rcx+56]
	jge	SHORT $LN3@dragging

; 151  : 	if (x > width - PADDING)

	mov	r9d, DWORD PTR [rcx+16]
	vxorps	xmm2, xmm2, xmm2
	lea	eax, DWORD PTR [r9-6]
	cmp	edx, eax
	jle	SHORT $LN6@dragging

; 232  : 		parent->gradMoveKey(selected, toPos(x));		

	mov	rcx, QWORD PTR [rcx+8]
	mov	edx, r8d

; 152  : 		pos = 1.f;

	vmovss	xmm2, DWORD PTR __real@3f800000

; 232  : 		parent->gradMoveKey(selected, toPos(x));		

	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+8]
$LN6@dragging:

; 153  : 	else if (x > PADDING)

	cmp	edx, 6
	jle	SHORT $LN8@dragging

; 154  : 		pos = (float)(x - PADDING) / (float)(width - PADDING * 2);

	lea	eax, DWORD PTR [rdx-6]
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	lea	eax, DWORD PTR [r9-12]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm2, xmm1, xmm0
$LN8@dragging:

; 232  : 		parent->gradMoveKey(selected, toPos(x));		

	mov	rcx, QWORD PTR [rcx+8]
	mov	edx, r8d
	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+8]
$LN3@dragging:

; 233  : 	//CharStream *out = thread_local(current_stdout);
; 234  : 	//out->printf("Move key: %d %f\n", number[selected], pos);
; 235  : }

	ret	0
?dragging@GradientRamp@@QEAAXHH_N00@Z ENDP		; GradientRamp::dragging
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?leftUp@GradientRamp@@QEAAXHH_N00@Z
_TEXT	SEGMENT
this$ = 48
x$ = 56
y$ = 64
ctrl$ = 72
shift$ = 80
alt$ = 88
?leftUp@GradientRamp@@QEAAXHH_N00@Z PROC		; GradientRamp::leftUp, COMDAT

; 212  : void GradientRamp::leftUp(int x, int y, bool ctrl, bool shift, bool alt) {

$LN32:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r10d, edx
	mov	rbx, rcx

; 169  : 	if (y > PADDING && y < (height - PADDING) && !broad)

	cmp	r8d, 6
	jle	SHORT $LN30@leftUp
	mov	eax, DWORD PTR [rcx+20]
	sub	eax, 6
	cmp	r8d, eax
	jl	SHORT $LN29@leftUp

; 170  : 		return -1;
; 171  : 
; 172  : 	// Distance from gradient
; 173  : 	int dist = 0;
; 174  : 	if (broad)
; 175  : 		dist  = ARROWS;
; 176  : 	else if (y < PADDING)

	cmp	r8d, 6
$LN30@leftUp:
	jge	SHORT $LN14@leftUp

; 177  : 		dist = PADDING - y;

	mov	ecx, 6
	sub	ecx, r8d

; 178  : 	else

	jmp	SHORT $LN15@leftUp
$LN14@leftUp:

; 179  : 		dist = y - height + PADDING;	

	mov	ecx, r8d
	sub	ecx, DWORD PTR [rbx+20]
	add	ecx, 6
$LN15@leftUp:

; 180  : 
; 181  : 	//CharStream *out = thread_local(current_stdout);
; 182  : 	// Intersect all keys
; 183  : 	float f_Width = (float)(width - PADDING * 2);	

	mov	eax, DWORD PTR [rbx+16]

; 184  : 	for (int i=0;i<keys;i++) {

	xor	r8d, r8d
	mov	r11d, DWORD PTR [rbx+56]
	sub	eax, 12
	vxorps	xmm1, xmm1, xmm1

; 180  : 
; 181  : 	//CharStream *out = thread_local(current_stdout);
; 182  : 	// Intersect all keys
; 183  : 	float f_Width = (float)(width - PADDING * 2);	

	vcvtsi2ss xmm1, xmm1, eax

; 184  : 	for (int i=0;i<keys;i++) {

	test	r11d, r11d
	jle	SHORT $LN29@leftUp

; 185  : 		int kx = (int)(f_Width * position[i]) + PADDING;

	mov	r9, QWORD PTR [rbx+32]
	npad	12
$LL10@leftUp:
	vmulss	xmm0, xmm1, DWORD PTR [r9]
	vcvttss2si edx, xmm0
	add	edx, 6

; 186  : 		//out->printf("Hit key: %d %d %d\n", x-dist, x+dist, x);
; 187  : 		if (kx-dist <= x && kx+dist >= x)

	mov	eax, edx
	sub	eax, ecx
	cmp	eax, r10d
	jg	SHORT $LN8@leftUp
	lea	eax, DWORD PTR [rdx+rcx]
	cmp	eax, r10d
	jge	SHORT $LN7@leftUp
$LN8@leftUp:

; 184  : 	for (int i=0;i<keys;i++) {

	inc	r8d
	add	r9, 4
	cmp	r8d, r11d
	jl	SHORT $LL10@leftUp
$LN29@leftUp:

; 188  : 			return i;
; 189  : 	}
; 190  : 
; 191  : 	// No keys found
; 192  : 	return -1;	

	or	r8d, -1
$LN7@leftUp:

; 213  : 	int key = hit(x,y);	 
; 214  : 	if (alt && key == -1) {

	cmp	BYTE PTR alt$[rsp], 0
	je	$LN4@leftUp
	cmp	r8d, -1
	jne	SHORT $LN2@leftUp

; 151  : 	if (x > width - PADDING)

	mov	ecx, DWORD PTR [rbx+16]
	vxorps	xmm1, xmm1, xmm1
	lea	eax, DWORD PTR [rcx-6]
	cmp	r10d, eax
	jle	SHORT $LN19@leftUp

; 152  : 		pos = 1.f;

	vmovss	xmm1, DWORD PTR __real@3f800000
	jmp	SHORT $LN21@leftUp
$LN19@leftUp:

; 153  : 	else if (x > PADDING)

	cmp	r10d, 6
	jle	SHORT $LN21@leftUp

; 154  : 		pos = (float)(x - PADDING) / (float)(width - PADDING * 2);

	lea	eax, DWORD PTR [r10-6]
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	lea	eax, DWORD PTR [rcx-12]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm1, xmm0
$LN21@leftUp:

; 215  : 		parent->gradAddKey(toPos(x));

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax]

; 216  : 		selected = keys - 1; // New key gets the last id

	mov	eax, DWORD PTR [rbx+56]

; 217  : 		parent->gradSelKey();

	mov	rcx, QWORD PTR [rbx+8]
	dec	eax
	mov	DWORD PTR [rbx+64], eax
	mov	rax, QWORD PTR [rcx]

; 225  : 	}	
; 226  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 217  : 		parent->gradSelKey();

	rex_jmp	QWORD PTR [rax+24]
$LN2@leftUp:

; 218  : 		
; 219  : 		//CharStream *out = thread_local(current_stdout);
; 220  : 		//out->printf("Key added!\n");	
; 221  : 
; 222  : 	} else if (alt && key >= 0) {

	test	r8d, r8d
	js	SHORT $LN4@leftUp

; 223  : 		if (selected == number[key]) selected = -1;

	movsxd	rdx, r8d
	mov	r8, QWORD PTR [rbx+48]
	mov	eax, DWORD PTR [r8+rdx*4]
	cmp	DWORD PTR [rbx+64], eax
	jne	SHORT $LN5@leftUp
	mov	DWORD PTR [rbx+64], -1
$LN5@leftUp:

; 224  : 		parent->gradDelKey(number[key]);

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [r8+rdx*4]
	mov	rax, QWORD PTR [rcx]

; 225  : 	}	
; 226  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 224  : 		parent->gradDelKey(number[key]);

	rex_jmp	QWORD PTR [rax+16]
$LN4@leftUp:

; 225  : 	}	
; 226  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?leftUp@GradientRamp@@QEAAXHH_N00@Z ENDP		; GradientRamp::leftUp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?leftDown@GradientRamp@@QEAAXHH_N00@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
ctrl$ = 32
shift$ = 40
alt$ = 48
?leftDown@GradientRamp@@QEAAXHH_N00@Z PROC		; GradientRamp::leftDown, COMDAT

; 183  : 	float f_Width = (float)(width - PADDING * 2);	

	mov	eax, DWORD PTR [rcx+16]

; 184  : 	for (int i=0;i<keys;i++) {

	xor	r8d, r8d
	mov	r11d, DWORD PTR [rcx+56]
	sub	eax, 12

; 195  : void GradientRamp::leftDown(int x, int y, bool ctrl, bool shift, bool alt) {

	mov	r10, rcx
	vxorps	xmm1, xmm1, xmm1

; 183  : 	float f_Width = (float)(width - PADDING * 2);	

	vcvtsi2ss xmm1, xmm1, eax

; 184  : 	for (int i=0;i<keys;i++) {

	test	r11d, r11d
	jle	SHORT $LN27@leftDown

; 185  : 		int kx = (int)(f_Width * position[i]) + PADDING;

	mov	r9, QWORD PTR [rcx+32]
$LL9@leftDown:
	vmulss	xmm0, xmm1, DWORD PTR [r9]
	vcvttss2si ecx, xmm0

; 186  : 		//out->printf("Hit key: %d %d %d\n", x-dist, x+dist, x);
; 187  : 		if (kx-dist <= x && kx+dist >= x)

	cmp	ecx, edx
	jg	SHORT $LN7@leftDown
	lea	eax, DWORD PTR [rcx+12]
	cmp	eax, edx
	jge	SHORT $LN6@leftDown
$LN7@leftDown:

; 184  : 	for (int i=0;i<keys;i++) {

	inc	r8d
	add	r9, 4
	cmp	r8d, r11d
	jl	SHORT $LL9@leftDown
$LN27@leftDown:

; 188  : 			return i;
; 189  : 	}
; 190  : 
; 191  : 	// No keys found
; 192  : 	return -1;	

	or	r8d, -1
$LN6@leftDown:

; 196  : 	int key = hit(x,y,true);
; 197  : 
; 198  : 	//CharStream *out = thread_local(current_stdout);
; 199  : 	//out->printf("Hit key: %d %d\n", key, selected);
; 200  : 	//out->printf("Left down\n");
; 201  : 
; 202  : 	if (!alt && key >= 0) {

	cmp	BYTE PTR alt$[rsp], 0
	jne	SHORT $LN2@leftDown
	test	r8d, r8d
	js	SHORT $LN2@leftDown

; 270  : 	selected = n;	

	mov	rax, QWORD PTR [r10+48]

; 203  : 		selectKey(number[key]);

	movsxd	rcx, r8d

; 270  : 	selected = n;	

	mov	ecx, DWORD PTR [rax+rcx*4]
	mov	DWORD PTR [r10+64], ecx

; 273  : 	parent->gradSelKey();

	mov	rcx, QWORD PTR [r10+8]
	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+24]
$LN2@leftDown:

; 204  : 	} else if (key == -1) {

	cmp	r8d, -1
	jne	SHORT $LN4@leftDown

; 273  : 	parent->gradSelKey();

	mov	rcx, QWORD PTR [r10+8]
	mov	DWORD PTR [r10+64], r8d
	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+24]
$LN4@leftDown:

; 205  : 		selectKey(-1);
; 206  : 	}
; 207  : 
; 208  : 	//out->printf("Selected key: %d\n", selected);
; 209  : 	//out->printf("## Seletion DONE! ##\n", selected);
; 210  : }

	ret	0
?leftDown@GradientRamp@@QEAAXHH_N00@Z ENDP		; GradientRamp::leftDown
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?toPos@GradientRamp@@QEAAMH@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
?toPos@GradientRamp@@QEAAMH@Z PROC			; GradientRamp::toPos, COMDAT

; 150  : 	float pos = 0.f;
; 151  : 	if (x > width - PADDING)

	mov	r8d, DWORD PTR [rcx+16]
	lea	eax, DWORD PTR [r8-6]
	cmp	edx, eax
	jle	SHORT $LN2@toPos

; 155  : 	return pos;

	vmovss	xmm0, DWORD PTR __real@3f800000

; 156  : }

	ret	0
$LN2@toPos:
	vxorps	xmm0, xmm0, xmm0

; 152  : 		pos = 1.f;
; 153  : 	else if (x > PADDING)

	cmp	edx, 6
	jle	SHORT $LN4@toPos

; 154  : 		pos = (float)(x - PADDING) / (float)(width - PADDING * 2);

	lea	eax, DWORD PTR [rdx-6]
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	lea	eax, DWORD PTR [r8-12]
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm0, xmm1, xmm0
$LN4@toPos:

; 156  : }

	ret	0
?toPos@GradientRamp@@QEAAMH@Z ENDP			; GradientRamp::toPos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?hit@GradientRamp@@QEAAHHH_N@Z
_TEXT	SEGMENT
this$ = 16
x$ = 24
y$ = 32
broad$ = 40
?hit@GradientRamp@@QEAAHHH_N@Z PROC			; GradientRamp::hit, COMDAT

; 167  : int GradientRamp::hit(int x, int y, bool broad) {

$LN21:
	sub	rsp, 8
	movzx	r10d, r9b
	mov	r9, rcx
	mov	r11d, edx

; 168  : 	// On gradient, no keys there
; 169  : 	if (y > PADDING && y < (height - PADDING) && !broad)

	cmp	r8d, 6
	jle	SHORT $LN5@hit
	mov	eax, DWORD PTR [rcx+20]
	sub	eax, 6
	cmp	r8d, eax
	jge	SHORT $LN5@hit
	test	r10b, r10b
	jne	SHORT $LN17@hit

; 170  : 		return -1;

	or	eax, -1

; 193  : }

	add	rsp, 8
	ret	0
$LN5@hit:

; 171  : 
; 172  : 	// Distance from gradient
; 173  : 	int dist = 0;
; 174  : 	if (broad)

	test	r10b, r10b
	je	SHORT $LN6@hit
$LN17@hit:

; 175  : 		dist  = ARROWS;

	mov	ecx, 6
	jmp	SHORT $LN9@hit
$LN6@hit:

; 176  : 	else if (y < PADDING)

	cmp	r8d, 6
	jge	SHORT $LN8@hit

; 177  : 		dist = PADDING - y;

	mov	ecx, 6
	sub	ecx, r8d

; 178  : 	else

	jmp	SHORT $LN9@hit
$LN8@hit:

; 179  : 		dist = y - height + PADDING;	

	mov	ecx, r8d
	sub	ecx, DWORD PTR [r9+20]
	add	ecx, 6
$LN9@hit:

; 180  : 
; 181  : 	//CharStream *out = thread_local(current_stdout);
; 182  : 	// Intersect all keys
; 183  : 	float f_Width = (float)(width - PADDING * 2);	

	mov	eax, DWORD PTR [r9+16]

; 184  : 	for (int i=0;i<keys;i++) {

	xor	r10d, r10d
	sub	eax, 12
	mov	QWORD PTR [rsp], rbx
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	movsxd	rax, DWORD PTR [r9+56]
	test	eax, eax
	jle	SHORT $LN18@hit

; 185  : 		int kx = (int)(f_Width * position[i]) + PADDING;

	mov	r9, QWORD PTR [r9+32]
	mov	rbx, rax
	mov	r8d, r10d
	npad	6
$LL4@hit:
	vmulss	xmm0, xmm1, DWORD PTR [r9]
	vcvttss2si edx, xmm0
	add	edx, 6

; 186  : 		//out->printf("Hit key: %d %d %d\n", x-dist, x+dist, x);
; 187  : 		if (kx-dist <= x && kx+dist >= x)

	mov	eax, edx
	sub	eax, ecx
	cmp	eax, r11d
	jg	SHORT $LN2@hit
	lea	eax, DWORD PTR [rdx+rcx]
	cmp	eax, r11d
	jge	SHORT $LN13@hit
$LN2@hit:

; 184  : 	for (int i=0;i<keys;i++) {

	inc	r10d
	inc	r8
	add	r9, 4
	cmp	r8, rbx
	jl	SHORT $LL4@hit
$LN18@hit:

; 189  : 	}
; 190  : 
; 191  : 	// No keys found
; 192  : 	return -1;	

	or	eax, -1
	mov	rbx, QWORD PTR [rsp]

; 193  : }

	add	rsp, 8
	ret	0
$LN13@hit:

; 188  : 			return i;

	mov	eax, r10d
	mov	rbx, QWORD PTR [rsp]

; 193  : }

	add	rsp, 8
	ret	0
?hit@GradientRamp@@QEAAHHH_N@Z ENDP			; GradientRamp::hit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?invalidate@GradientRamp@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?invalidate@GradientRamp@@QEAAXXZ PROC			; GradientRamp::invalidate, COMDAT

; 137  :    if (m_hWnd == NULL) return;

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN1@invalidate

; 138  :    //RECT rect;
; 139  :    //GetClientRect(m_hWnd, &rect);
; 140  :    //MapWindowPoints(m_hWnd, p_hWnd, (POINT*)&rect, 2);
; 141  :    //InvalidateRect(p_hWnd, &rect, TRUE);
; 142  :    InvalidateRect(m_hWnd, NULL, TRUE);

	xor	edx, edx
	lea	r8d, QWORD PTR [rdx+1]
	rex_jmp	QWORD PTR __imp_InvalidateRect
$LN1@invalidate:

; 143  : }

	ret	0
?invalidate@GradientRamp@@QEAAXXZ ENDP			; GradientRamp::invalidate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z
_TEXT	SEGMENT
this$ = 80
px$ = 88
py$ = 96
up$ = 104
hDC$ = 112
colR$ = 120
?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z PROC	; GradientRamp::paintArrow, COMDAT

; 123  : void GradientRamp::paintArrow(int px, int py, bool up, HDC hDC, COLORREF colR) {

$LN21:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 124  : 	int offset = 0;
; 125  : 	for (int y=0;y<ARROWS;y++) {

	mov	r14d, DWORD PTR colR$[rsp]
	xor	esi, esi
	mov	r15, QWORD PTR hDC$[rsp]
	sub	edx, r8d
	mov	DWORD PTR px$[rsp], edx
	movzx	r12d, r9b
	mov	r13d, r8d
	mov	ebp, r8d
	npad	7
$LL4@paintArrow:

; 126  : 		for (int x=0;x<(y*2+1);x++) {

	lea	eax, DWORD PTR [rsi*2+1]
	test	eax, eax
	jle	SHORT $LN6@paintArrow
	lea	ebx, DWORD PTR [rdx+rbp]
	mov	edi, eax
$LL7@paintArrow:

; 127  : 			if (up)
; 128  : 				SetPixel(hDC, px+x-offset, py+y, colR);

	lea	r8d, DWORD PTR [rsi+r13]
	mov	r9d, r14d
	mov	edx, ebx
	mov	rcx, r15
	test	r12b, r12b
	jne	SHORT $LN19@paintArrow

; 129  : 			else
; 130  : 				SetPixel(hDC, px+x-offset, py-y, colR);

	mov	r8d, ebp
$LN19@paintArrow:
	call	QWORD PTR __imp_SetPixel
	inc	ebx
	sub	rdi, 1
	jne	SHORT $LL7@paintArrow
	mov	edx, DWORD PTR px$[rsp]
$LN6@paintArrow:

; 124  : 	int offset = 0;
; 125  : 	for (int y=0;y<ARROWS;y++) {

	inc	esi
	dec	ebp
	cmp	esi, 6
	jl	SHORT $LL4@paintArrow

; 131  : 		}
; 132  : 		offset++;
; 133  : 	}
; 134  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?paintArrow@GradientRamp@@QEAAXHH_NPEAUHDC__@@K@Z ENDP	; GradientRamp::paintArrow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z
_TEXT	SEGMENT
tv1140 = 80
tv1135 = 80
sel$1$ = 84
i$1$ = 88
this$GSCopy$1$ = 96
tv1139 = 104
col$1 = 104
hDC$GSCopy$1$ = 120
hbm_oldBuffer$1$ = 128
hbm_Buffer$1$ = 136
rect$ = 144
__$ArrayPad$ = 160
this$ = 288
hDC$ = 296
?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z PROC		; GradientRamp::paint, COMDAT

; 42   : void GradientRamp::paint(HDC hDC) {	

$LN102:
	mov	r11, rsp
	push	rbx
	push	rbp
	sub	rsp, 264				; 00000108H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 43   : 	if (m_hWnd == NULL) return;

	cmp	QWORD PTR [rcx], 0
	mov	rbx, rdx
	mov	QWORD PTR hDC$GSCopy$1$[rsp], rdx
	mov	rbp, rcx
	mov	QWORD PTR this$GSCopy$1$[rsp], rcx
	je	$LN1@paint

; 44   : 	//SetBkMode(hDC, TRANSPARENT);	
; 45   : 
; 46   : 	//RECT rect;
; 47   : 	//GetClientRect(m_hWnd, &rect);
; 48   : 	
; 49   : 	/*SelectObject(hdc,red_pen);
; 50   : 	MoveToEx(hdc,10,20,NULL);
; 51   : 	LineTo(hdc,10,40,NULL);
; 52   : 	LineTo(hdc,50,150,NULL);*/
; 53   : 	/*	
; 54   : 	int width = rect.right - rect.left;
; 55   : 	int height = rect.top - rect.bottom;
; 56   : 
; 57   : 	RECT rect2;
; 58   : 	GetWindowRect(m_hWnd, &rect2);
; 59   : 									
; 60   : 	CharStream *out = thread_local(current_stdout);
; 61   : 	out->printf("Rectangle: %d %d %d %d\n", rect.left, rect.right, rect.top, rect.bottom);
; 62   : 	out->printf("Rectangle2: %d %d %d %d\n", (int)(rect2.left, (int)(rect2.right), (int)(rect2.top), (int)(rect2.bottom));
; 63   : 	*/
; 64   : 
; 65   : 	HDC tempHDC = CreateCompatibleDC(hDC);

	mov	QWORD PTR [r11+24], rsi
	mov	rcx, rdx
	mov	QWORD PTR [r11-24], rdi
	mov	QWORD PTR [r11-32], r12
	mov	QWORD PTR [r11-48], r14
	mov	QWORD PTR [r11-56], r15
	vmovaps	XMMWORD PTR [r11-104], xmm8
	call	QWORD PTR __imp_CreateCompatibleDC

; 66   : 	HBITMAP hbm_Buffer = CreateCompatibleBitmap(hDC, width, height);

	mov	r8d, DWORD PTR [rbp+20]
	mov	rcx, rbx
	mov	edx, DWORD PTR [rbp+16]
	mov	rdi, rax
	call	QWORD PTR __imp_CreateCompatibleBitmap

; 67   : 	HBITMAP hbm_oldBuffer = (HBITMAP)SelectObject(tempHDC, hbm_Buffer);

	mov	rdx, rax
	mov	QWORD PTR hbm_Buffer$1$[rsp], rax
	mov	rcx, rdi
	call	QWORD PTR __imp_SelectObject

; 68   : 
; 69   : 	// Borders
; 70   : 	RECT rect;	
; 71   : 	HBRUSH gray = CreateSolidBrush(RGB(175,175,175)); 	

	mov	ecx, 11513775				; 00afafafH
	mov	QWORD PTR hbm_oldBuffer$1$[rsp], rax
	call	QWORD PTR __imp_CreateSolidBrush

; 72   : 	rect.left = 0; rect.top = 0; rect.right = width; rect.bottom = PADDING;

	mov	ecx, DWORD PTR [rbp+16]

; 73   : 	FillRect(tempHDC,&rect,gray);

	lea	rdx, QWORD PTR rect$[rsp]
	mov	DWORD PTR rect$[rsp+8], ecx
	xor	esi, esi
	mov	rcx, rdi
	mov	QWORD PTR rect$[rsp], rsi
	mov	r8, rax
	mov	DWORD PTR rect$[rsp+12], 6
	mov	rbx, rax
	call	QWORD PTR __imp_FillRect

; 74   : 	rect.right = PADDING; rect.bottom = height;

	mov	ecx, DWORD PTR [rbp+20]

; 75   : 	FillRect(tempHDC,&rect,gray);

	lea	rdx, QWORD PTR rect$[rsp]
	mov	DWORD PTR rect$[rsp+12], ecx
	mov	r8, rbx
	mov	rcx, rdi
	mov	DWORD PTR rect$[rsp+8], 6
	call	QWORD PTR __imp_FillRect

; 76   : 	rect.left = width-PADDING; rect.right = width;

	mov	ecx, DWORD PTR [rbp+16]

; 77   : 	FillRect(tempHDC,&rect,gray);

	lea	rdx, QWORD PTR rect$[rsp]
	mov	DWORD PTR rect$[rsp+8], ecx
	mov	r8, rbx
	lea	eax, DWORD PTR [rcx-6]
	mov	rcx, rdi
	mov	DWORD PTR rect$[rsp], eax
	call	QWORD PTR __imp_FillRect

; 78   : 	rect.left = 0; rect.top = height-PADDING;

	mov	eax, DWORD PTR [rbp+20]

; 79   : 	FillRect(tempHDC,&rect,gray);

	lea	rdx, QWORD PTR rect$[rsp]
	add	eax, -6
	mov	DWORD PTR rect$[rsp], esi
	mov	r8, rbx
	mov	DWORD PTR rect$[rsp+4], eax
	mov	rcx, rdi
	call	QWORD PTR __imp_FillRect

; 80   : 
; 81   : 	int g_Width = width - PADDING * 2;

	mov	eax, DWORD PTR [rbp+16]

; 82   : 	int g_Height = height - PADDING *2;
; 83   : 	float f_Width = (float)g_Width;	
; 84   : 
; 85   : 	// Gradient
; 86   : 	for (int x=PADDING; x<g_Width+PADDING; x++) {

	mov	esi, 6
	mov	r14d, DWORD PTR [rbp+20]
	sub	eax, 12
	vxorps	xmm8, xmm8, xmm8
	vcvtsi2ss xmm8, xmm8, eax
	lea	r15d, DWORD PTR [rax+6]
	cmp	r15d, esi
	jle	$LN3@paint
	vmovaps	XMMWORD PTR [rsp+208], xmm6
	add	r14d, -6
	vmovss	xmm6, DWORD PTR __real@437f0000
	vmovaps	XMMWORD PTR [rsp+192], xmm7
	vsubss	xmm7, xmm8, DWORD PTR __real@3f800000
	npad	1
$LL4@paint:

; 87   : 		AColor col = getColor((float)(x-PADDING) / (f_Width-1.f));

	lea	eax, DWORD PTR [rsi-6]
	mov	rcx, rbp
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm2, xmm0, xmm7
	lea	rdx, QWORD PTR col$1[rsp]
	call	?getColor@GradientRamp@@QEAA?AVAColor@@M@Z ; GradientRamp::getColor

; 88   : 
; 89   : 		COLORREF colR = RGB((int)(col.r*255.f), (int)(col.g*255.f), (int)(col.b*255.f));		

	vmulss	xmm1, xmm6, DWORD PTR col$1[rsp+4]
	vcvttss2si eax, xmm1
	vmulss	xmm1, xmm6, DWORD PTR col$1[rsp+8]
	movzx	ebp, al

; 90   : 		for (int y=PADDING; y<g_Height+PADDING; y++)		

	mov	ebx, 6
	vcvttss2si eax, xmm1
	vmulss	xmm1, xmm6, DWORD PTR col$1[rsp]
	shl	ebp, 8
	movzx	ecx, al
	shl	ecx, 16
	or	ebp, ecx
	vcvttss2si eax, xmm1
	movzx	ecx, al
	or	ebp, ecx
	cmp	r14d, ebx
	jle	SHORT $LN2@paint
	npad	9
$LL7@paint:

; 91   : 			SetPixel(tempHDC, x, y, colR);

	mov	r9d, ebp
	mov	r8d, ebx
	mov	edx, esi
	mov	rcx, rdi
	call	QWORD PTR __imp_SetPixel
	inc	ebx
	cmp	ebx, r14d
	jl	SHORT $LL7@paint
$LN2@paint:

; 82   : 	int g_Height = height - PADDING *2;
; 83   : 	float f_Width = (float)g_Width;	
; 84   : 
; 85   : 	// Gradient
; 86   : 	for (int x=PADDING; x<g_Width+PADDING; x++) {

	mov	rbp, QWORD PTR this$GSCopy$1$[rsp]
	inc	esi
	cmp	esi, r15d
	jl	$LL4@paint
	vmovaps	xmm7, XMMWORD PTR [rsp+192]
	vmovaps	xmm6, XMMWORD PTR [rsp+208]
$LN3@paint:

; 92   : 	}
; 93   : 
; 94   : 	// Keys
; 95   : 	int yTop = PADDING - 1;
; 96   : 	int yBottom = height - PADDING;

	mov	r12d, DWORD PTR [rbp+20]

; 97   : 	int sel = -1;
; 98   : 	for (int i=0;i<keys;i++) {

	xor	edx, edx
	add	r12d, -6
	mov	DWORD PTR sel$1$[rsp], -1
	mov	DWORD PTR i$1$[rsp], edx
	cmp	DWORD PTR [rbp+56], edx
	jle	$LN48@paint
	xor	r8d, r8d
	mov	QWORD PTR [rsp+240], r13
	mov	QWORD PTR tv1139[rsp], r8
	lea	r13d, QWORD PTR [rdx+1]
	lea	r10d, QWORD PTR [rdx+5]
$LL10@paint:

; 99   : 		//CharStream *out = thread_local(current_stdout);
; 100  : 		//out->printf("Key pos: %f\n", position[i]);	
; 101  : 		if (number[i] != selected) {

	mov	rcx, QWORD PTR [rbp+48]
	mov	eax, DWORD PTR [rbp+64]
	cmp	DWORD PTR [r8+rcx], eax
	je	$LN12@paint

; 102  : 			int x = (int)(f_Width * position[i]) + PADDING;

	mov	rax, QWORD PTR [rbp+32]
	mov	esi, r13d
	vmulss	xmm0, xmm8, DWORD PTR [rax+r8]
	vcvttss2si r15d, xmm0
	add	r15d, 6

; 125  : 	for (int y=0;y<ARROWS;y++) {

	mov	eax, r10d
	sub	eax, r15d

; 102  : 			int x = (int)(f_Width * position[i]) + PADDING;

	mov	r14d, r15d

; 125  : 	for (int y=0;y<ARROWS;y++) {

	mov	DWORD PTR tv1140[rsp], eax
$LL19@paint:

; 126  : 		for (int x=0;x<(y*2+1);x++) {

	xor	ebx, ebx
	test	esi, esi
	jle	SHORT $LN21@paint
	lea	ebp, DWORD PTR [rax+r14]
	npad	2
$LL22@paint:

; 129  : 			else
; 130  : 				SetPixel(hDC, px+x-offset, py-y, colR);

	lea	edx, DWORD PTR [r14+rbx]
	xor	r9d, r9d
	mov	r8d, ebp
	mov	rcx, rdi
	call	QWORD PTR __imp_SetPixel
	inc	ebx
	cmp	ebx, esi
	jl	SHORT $LL22@paint
	mov	eax, DWORD PTR tv1140[rsp]
$LN21@paint:

; 122  : 
; 123  : void GradientRamp::paintArrow(int px, int py, bool up, HDC hDC, COLORREF colR) {
; 124  : 	int offset = 0;
; 125  : 	for (int y=0;y<ARROWS;y++) {

	add	esi, 2
	dec	r14d
	cmp	esi, 13
	jl	SHORT $LL19@paint
	xor	r14d, r14d
	mov	esi, r13d
	npad	2
$LL29@paint:

; 126  : 		for (int x=0;x<(y*2+1);x++) {

	xor	ebx, ebx
	test	esi, esi
	jle	SHORT $LN31@paint
	npad	10
$LL32@paint:

; 127  : 			if (up)
; 128  : 				SetPixel(hDC, px+x-offset, py+y, colR);

	lea	r8d, DWORD PTR [r14+r12]
	xor	r9d, r9d
	lea	edx, DWORD PTR [r15+rbx]
	mov	rcx, rdi
	call	QWORD PTR __imp_SetPixel
	inc	ebx
	cmp	ebx, esi
	jl	SHORT $LL32@paint
$LN31@paint:

; 122  : 
; 123  : void GradientRamp::paintArrow(int px, int py, bool up, HDC hDC, COLORREF colR) {
; 124  : 	int offset = 0;
; 125  : 	for (int y=0;y<ARROWS;y++) {

	inc	r14d
	add	esi, 2
	dec	r15d
	cmp	esi, 13
	jl	SHORT $LL29@paint

; 103  : 			paintArrow(x, yTop, false, tempHDC, ARROWDESEL);
; 104  : 			paintArrow(x, yBottom, true, tempHDC, ARROWDESEL);
; 105  : 		} else {

	mov	rbp, QWORD PTR this$GSCopy$1$[rsp]
	mov	r10d, 5
	mov	edx, DWORD PTR i$1$[rsp]
	mov	r8, QWORD PTR tv1139[rsp]
	mov	r9d, DWORD PTR sel$1$[rsp]
	jmp	SHORT $LN8@paint
$LN12@paint:

; 106  : 			sel = i;

	mov	r9d, edx
	mov	DWORD PTR sel$1$[rsp], edx
$LN8@paint:

; 97   : 	int sel = -1;
; 98   : 	for (int i=0;i<keys;i++) {

	inc	edx
	add	r8, 4
	mov	DWORD PTR i$1$[rsp], edx
	mov	QWORD PTR tv1139[rsp], r8
	cmp	edx, DWORD PTR [rbp+56]
	jl	$LL10@paint

; 107  : 		}
; 108  : 	}	
; 109  : 	if (sel != -1) {

	cmp	r9d, -1
	je	$LN100@paint

; 110  : 		paintArrow((int)(f_Width * position[sel]) + PADDING, yTop, false, tempHDC, ARROWSEL);

	mov	rax, QWORD PTR [rbp+32]
	mov	esi, r13d
	movsxd	r15, r9d
	vmulss	xmm0, xmm8, DWORD PTR [rax+r15*4]
	vcvttss2si r14d, xmm0
	add	r14d, 6

; 125  : 	for (int y=0;y<ARROWS;y++) {

	sub	r10d, r14d
	mov	DWORD PTR tv1135[rsp], r10d
	npad	4
$LL39@paint:

; 126  : 		for (int x=0;x<(y*2+1);x++) {

	xor	ebx, ebx
	test	esi, esi
	jle	SHORT $LN41@paint
	lea	ebp, DWORD PTR [r14+r10]
	npad	6
$LL42@paint:

; 129  : 			else
; 130  : 				SetPixel(hDC, px+x-offset, py-y, colR);

	lea	edx, DWORD PTR [r14+rbx]
	mov	r9d, 16777215				; 00ffffffH
	mov	r8d, ebp
	mov	rcx, rdi
	call	QWORD PTR __imp_SetPixel
	inc	ebx
	cmp	ebx, esi
	jl	SHORT $LL42@paint
	mov	r10d, DWORD PTR tv1135[rsp]
$LN41@paint:

; 122  : 
; 123  : void GradientRamp::paintArrow(int px, int py, bool up, HDC hDC, COLORREF colR) {
; 124  : 	int offset = 0;
; 125  : 	for (int y=0;y<ARROWS;y++) {

	add	esi, 2
	dec	r14d
	cmp	esi, 13
	jl	SHORT $LL39@paint

; 111  : 		paintArrow((int)(f_Width * position[sel]) + PADDING, yBottom, true, tempHDC, ARROWSEL);	

	mov	rbp, QWORD PTR this$GSCopy$1$[rsp]
	mov	rax, QWORD PTR [rbp+32]
	vmulss	xmm0, xmm8, DWORD PTR [rax+r15*4]
	vcvttss2si esi, xmm0
	add	esi, 6

; 125  : 	for (int y=0;y<ARROWS;y++) {

	xor	r14d, r14d
$LL49@paint:

; 126  : 		for (int x=0;x<(y*2+1);x++) {

	xor	ebx, ebx
	test	r13d, r13d
	jle	SHORT $LN51@paint
	npad	4
$LL52@paint:

; 127  : 			if (up)
; 128  : 				SetPixel(hDC, px+x-offset, py+y, colR);

	lea	r8d, DWORD PTR [r14+r12]
	mov	r9d, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [rsi+rbx]
	mov	rcx, rdi
	call	QWORD PTR __imp_SetPixel
	inc	ebx
	cmp	ebx, r13d
	jl	SHORT $LL52@paint
$LN51@paint:

; 122  : 
; 123  : void GradientRamp::paintArrow(int px, int py, bool up, HDC hDC, COLORREF colR) {
; 124  : 	int offset = 0;
; 125  : 	for (int y=0;y<ARROWS;y++) {

	inc	r14d
	add	r13d, 2
	dec	esi
	cmp	r13d, 13
	jl	SHORT $LL49@paint
$LN100@paint:
	mov	r13, QWORD PTR [rsp+240]
$LN48@paint:

; 112  : 	}
; 113  : 
; 114  : 	//GetClientRect(m_hWnd, &rect);
; 115  : 	BitBlt(hDC, 0, 0, width, height, tempHDC, 0, 0, SRCCOPY);

	mov	eax, DWORD PTR [rbp+20]
	xor	r8d, r8d
	mov	r9d, DWORD PTR [rbp+16]
	xor	edx, edx
	mov	rcx, QWORD PTR hDC$GSCopy$1$[rsp]
	mov	DWORD PTR [rsp+64], 13369376		; 00cc0020H
	mov	DWORD PTR [rsp+56], 0
	mov	DWORD PTR [rsp+48], 0
	mov	QWORD PTR [rsp+40], rdi
	mov	DWORD PTR [rsp+32], eax
	call	QWORD PTR __imp_BitBlt

; 116  : 	//BitBlt(hDC, rect.left, rect.top, rect.right, rect.bottom, tempHDC, 0, 0, SRCCOPY);
; 117  : 
; 118  :     SelectObject(tempHDC, hbm_oldBuffer);

	mov	rdx, QWORD PTR hbm_oldBuffer$1$[rsp]
	mov	rcx, rdi
	call	QWORD PTR __imp_SelectObject

; 119  :  	DeleteDC(tempHDC);

	mov	rcx, rdi
	call	QWORD PTR __imp_DeleteDC

; 120  :     DeleteObject(hbm_Buffer); 

	mov	rcx, QWORD PTR hbm_Buffer$1$[rsp]
	call	QWORD PTR __imp_DeleteObject
	vmovaps	xmm8, XMMWORD PTR [rsp+176]
	mov	r15, QWORD PTR [rsp+224]
	mov	r14, QWORD PTR [rsp+232]
	mov	r12, QWORD PTR [rsp+248]
	mov	rdi, QWORD PTR [rsp+256]
	mov	rsi, QWORD PTR [rsp+304]
$LN1@paint:

; 121  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 264				; 00000108H
	pop	rbp
	pop	rbx
	ret	0
?paint@GradientRamp@@QEAAXPEAUHDC__@@@Z ENDP		; GradientRamp::paint
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z
_TEXT	SEGMENT
rect$ = 32
__$ArrayPad$ = 48
this$ = 80
hWnd$ = 88
?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z PROC		; GradientRamp::setHWND, COMDAT

; 30   : void GradientRamp::setHWND(HWND hWnd) {

$LN4:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rax, rdx

; 31   : 	m_hWnd = hWnd; 

	mov	QWORD PTR [rcx], rdx
	mov	rbx, rcx

; 32   : 	RECT rect;
; 33   : 	GetWindowRect(m_hWnd, &rect);													

	lea	rdx, QWORD PTR rect$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_GetWindowRect

; 34   : 	width = rect.right - rect.left;

	mov	eax, DWORD PTR rect$[rsp+8]
	sub	eax, DWORD PTR rect$[rsp]
	mov	DWORD PTR [rbx+16], eax

; 35   : 	height = rect.bottom - rect.top;	

	mov	eax, DWORD PTR rect$[rsp+12]
	sub	eax, DWORD PTR rect$[rsp+4]
	mov	DWORD PTR [rbx+20], eax

; 36   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
?setHWND@GradientRamp@@QEAAXPEAUHWND__@@@Z ENDP		; GradientRamp::setHWND
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
;	COMDAT ??D@YA?AVAColor@@AEBV0@M@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
a$ = 56
f$ = 64
??D@YA?AVAColor@@AEBV0@M@Z PROC				; operator*, COMDAT

; 314  : inline AColor operator*(const AColor& a, float f) {

$LN19:
	push	rbp
	sub	rsp, 32					; 00000020H
	lea	rbp, QWORD PTR [rsp+32]
	and	rbp, -32				; ffffffffffffffe0H
	vmovaps	xmm1, xmm2
	vbroadcastss xmm1, xmm1

; 315  : 	return(AColor(a.r*f, a.g*f, a.b*f, a.a*f));

	vmulps	xmm1, xmm1, XMMWORD PTR [rdx]
	vmovups	XMMWORD PTR [rcx], xmm1
	mov	rax, rcx

; 316  : 	}

	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
??D@YA?AVAColor@@AEBV0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
;	COMDAT ??HAColor@@QEBA?AV0@AEBV0@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
c$ = 64
??HAColor@@QEBA?AV0@AEBV0@@Z PROC			; AColor::operator+, COMDAT

; 290  : inline AColor AColor::operator+(const AColor& c) const {

$LN19:
	push	rbp
	sub	rsp, 32					; 00000020H
	lea	rbp, QWORD PTR [rsp+32]
	and	rbp, -32				; ffffffffffffffe0H
	vmovups	xmm1, XMMWORD PTR [r8]

; 291  : 	return(AColor(r+c.r,g+c.g,b+c.b,a+c.a));

	vaddps	xmm1, xmm1, XMMWORD PTR [rcx]
	vmovups	XMMWORD PTR [rdx], xmm1
	mov	rax, rdx

; 292  : 	}

	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
??HAColor@@QEBA?AV0@AEBV0@@Z ENDP			; AColor::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
;	COMDAT ??0AColor@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
this$ = 8
c$ = 16
??0AColor@@QEAA@AEBV0@@Z PROC				; AColor::AColor, COMDAT

; 54   : 	AColor(const AColor& c) { r = c.r; g = c.g; b = c.b; a = c.a; } 

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rcx+12], eax
	mov	rax, rcx
	ret	0
??0AColor@@QEAA@AEBV0@@Z ENDP				; AColor::AColor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
;	COMDAT ??0AColor@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 8
R$ = 16
G$ = 24
B$ = 32
A$ = 40
??0AColor@@QEAA@MMMM@Z PROC				; AColor::AColor, COMDAT

; 44   : 	AColor(float R, float G, float B, float A=1.0f)  { r = R; g = G; b = B; a = A; }

	vmovss	xmm0, DWORD PTR A$[rsp]
	vmovss	DWORD PTR [rcx+12], xmm0
	vmovss	DWORD PTR [rcx], xmm1
	vmovss	DWORD PTR [rcx+4], xmm2
	vmovss	DWORD PTR [rcx+8], xmm3
	mov	rax, rcx
	ret	0
??0AColor@@QEAA@MMMM@Z ENDP				; AColor::AColor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\acolor.h
;	COMDAT ??0AColor@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0AColor@@QEAA@XZ PROC					; AColor::AColor, COMDAT

; 41   : 	AColor()  {}

	mov	rax, rcx
	ret	0
??0AColor@@QEAA@XZ ENDP					; AColor::AColor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ
text$di	SEGMENT
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ PROC	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId'', COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR ?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A, xmm0

; 32   : 		static AssetId kInvalidId;

	ret	0
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ENDP	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ PROC		; MaxSDK::AssetManagement::AssetId::AssetId, COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR [rcx], xmm0
	mov	rax, rcx
	ret	0
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ ENDP		; MaxSDK::AssetManagement::AssetId::AssetId
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
;	COMDAT ??D@YA?AVPoint3@@MAEBV0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
f$ = 16
a$ = 24
??D@YA?AVPoint3@@MAEBV0@@Z PROC				; operator*, COMDAT

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm0, xmm1, DWORD PTR [r8]
	vmulss	xmm2, xmm1, DWORD PTR [r8+4]

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR [rcx], xmm0

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm0, xmm1, DWORD PTR [r8+8]

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR [rcx+8], xmm0
	vmovss	DWORD PTR [rcx+4], xmm2

; 321  :    return(Point3(a.x*f, a.y*f, a.z*f));

	mov	rax, rcx

; 322  :    }

	ret	0
??D@YA?AVPoint3@@MAEBV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\maxtypes.h
;	COMDAT ??0Class_ID@@QEAA@KK@Z
_TEXT	SEGMENT
this$ = 8
aa$ = 16
bb$ = 24
??0Class_ID@@QEAA@KK@Z PROC				; Class_ID::Class_ID, COMDAT

; 160  : 	Class_ID(ulong aa, ulong bb) { a = aa; b = bb; }

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	DWORD PTR [rcx+4], r8d
	ret	0
??0Class_ID@@QEAA@KK@Z ENDP				; Class_ID::Class_ID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\gradientramp.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 8
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
__t$ = 48
__s$ = 56
__n$ = 64
__f$ = 72
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN12:
	test	r8, r8
	je	SHORT $LN10@vector
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r9
	mov	rbx, r8
	mov	rbp, rdx
	mov	rdi, rcx
$LL2@vector:
	mov	rcx, rdi
	call	rsi
	add	rdi, rbp
	sub	rbx, 1
	jne	SHORT $LL2@vector
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN10@vector:
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
