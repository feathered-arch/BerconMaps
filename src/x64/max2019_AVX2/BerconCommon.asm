; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24234.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	WinbaseIsolationAwarePrivateT_UnPgpgk
PUBLIC	IsolationAwarePrivateT_SqbjaYRiRY
PUBLIC	IsolationAwarePrivateT_SAbnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
PUBLIC	WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
EXTRN	GUID_NULL:BYTE
;	COMDAT IsolationAwarePrivateT_SqbjaYRiRY
_BSS	SEGMENT
IsolationAwarePrivateT_SqbjaYRiRY DD 01H DUP (?)
_BSS	ENDS
;	COMDAT IsolationAwarePrivateT_SAbnPgpgk
_BSS	SEGMENT
IsolationAwarePrivateT_SAbnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
_BSS	SEGMENT
WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ DD 01H DUP (?)
_BSS	ENDS
;	COMDAT WinbaseIsolationAwarePrivateT_UnPgpgk
_DATA	SEGMENT
WinbaseIsolationAwarePrivateT_UnPgpgk DQ ffffffffffffffffH
_DATA	ENDS
PUBLIC	??_H@YAXPEAX_K1P6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	?GetString@@YAPEA_WH@Z				; GetString
PUBLIC	?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z ; BerconXYZ::update
PUBLIC	?update@BerconXYZ@@QEAAXXZ			; BerconXYZ::update
PUBLIC	?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z ; BerconXYZ::reset
PUBLIC	?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z ; BerconXYZ::get
PUBLIC	?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z ; BerconXYZ::get
PUBLIC	?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z ; BerconXYZ::get
PUBLIC	?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z ; BerconXYZ::get
PUBLIC	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z ; BerconXYZ::get
PUBLIC	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z ; BerconXYZ::get
PUBLIC	?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z ; BerconXYZ::seedRandomGen
PUBLIC	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
PUBLIC	?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z ; BerconXYZ::EnableStuff
PUBLIC	?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z ; BerconXYZ::getBasis
PUBLIC	__real@38d1b717
PUBLIC	__real@3c8efa35
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@46fffe00
PUBLIC	__real@49742400
PUBLIC	__real@c9742400
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__imp_LoadStringW:PROC
EXTRN	__imp_srand:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp_??0Point3@@QEAA@XZ:PROC
EXTRN	__imp_??TPoint3@@QEBA?AV0@AEBV0@@Z:PROC
EXTRN	__imp_?Normalize@@YA?AVPoint3@@AEBV1@@Z:PROC
EXTRN	__imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z:PROC
EXTRN	__imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z:PROC
EXTRN	__imp_?IdentityMatrix@Matrix3@@QEAAXXZ:PROC
EXTRN	__imp_?Translate@Matrix3@@QEAAXAEBVPoint3@@@Z:PROC
EXTRN	__imp_?RotateX@Matrix3@@QEAAXM@Z:PROC
EXTRN	__imp_?RotateY@Matrix3@@QEAAXM@Z:PROC
EXTRN	__imp_?RotateZ@Matrix3@@QEAAXM@Z:PROC
EXTRN	__imp_?Scale@Matrix3@@QEAAXAEBVPoint3@@H@Z:PROC
EXTRN	__imp_?Invert@Matrix3@@QEAAXXZ:PROC
EXTRN	__imp_?ReleaseISpinner@@YAXPEAVISpinnerControl@@@Z:PROC
EXTRN	__imp_?SetupFloatSpinner@@YAPEAVISpinnerControl@@PEAUHWND__@@HHMMMM@Z:PROC
EXTRN	__imp_?SetupUniverseSpinner@@YAPEAVISpinnerControl@@PEAUHWND__@@HHMMMM@Z:PROC
EXTRN	__imp_??0Interval@@QEAA@HH@Z:PROC
EXTRN	__imp_?GetCOREInterface@@YAPEAVInterface@@XZ:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	?hInstance@@3PEAUHINSTANCE__@@EA:QWORD		; hInstance
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A DB 010H DUP (?) ; MaxSDK::AssetManagement::kInvalidId
_BSS	ENDS
;	COMDAT ?buf@?1??GetString@@YAPEA_WH@Z@4PA_WA
_BSS	SEGMENT
?buf@?1??GetString@@YAPEA_WH@Z@4PA_WA DW 0100H DUP (?)	; `GetString'::`2'::buf
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetString@@YAPEA_WH@Z DD imagerel $LN5
	DD	imagerel $LN5+18
	DD	imagerel $unwind$?GetString@@YAPEA_WH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?GetString@@YAPEA_WH@Z DD imagerel $LN5+18
	DD	imagerel $LN5+66
	DD	imagerel $chain$0$?GetString@@YAPEA_WH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?GetString@@YAPEA_WH@Z DD imagerel $LN5+66
	DD	imagerel $LN5+73
	DD	imagerel $chain$1$?GetString@@YAPEA_WH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z DD imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+73
	DD	imagerel $unwind$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z DD imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+73
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+162
	DD	imagerel $chain$0$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z DD imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+162
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+302
	DD	imagerel $chain$1$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z DD imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z DD imagerel $LN6+36
	DD	imagerel $LN6+1284
	DD	imagerel $chain$3$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z DD imagerel $LN6+1284
	DD	imagerel $LN6+1285
	DD	imagerel $chain$4$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?update@BerconXYZ@@QEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+407
	DD	imagerel $unwind$?update@BerconXYZ@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z DD imagerel $LN8
	DD	imagerel $LN8+24
	DD	imagerel $unwind$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z DD imagerel $LN8+24
	DD	imagerel $LN8+943
	DD	imagerel $chain$2$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z DD imagerel $LN8+943
	DD	imagerel $LN8+944
	DD	imagerel $chain$3$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z DD imagerel $LN6
	DD	imagerel $LN6+219
	DD	imagerel $unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z DD imagerel $LN43
	DD	imagerel $LN43+898
	DD	imagerel $unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z DD imagerel $LN6
	DD	imagerel $LN6+180
	DD	imagerel $unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z DD imagerel $LN43
	DD	imagerel $LN43+847
	DD	imagerel $unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z DD imagerel $LN64
	DD	imagerel $LN64+783
	DD	imagerel $unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z DD imagerel $LN64+783
	DD	imagerel $LN64+1045
	DD	imagerel $chain$0$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z DD imagerel $LN64+1045
	DD	imagerel $LN64+1158
	DD	imagerel $chain$1$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z DD imagerel $LN45
	DD	imagerel $LN45+364
	DD	imagerel $unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z DD imagerel $LN45+364
	DD	imagerel $LN45+496
	DD	imagerel $chain$0$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z DD imagerel $LN45+496
	DD	imagerel $LN45+609
	DD	imagerel $chain$1$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD imagerel $LN12
	DD	imagerel $LN12+107
	DD	imagerel $unwind$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD imagerel $LN12+107
	DD	imagerel $LN12+150
	DD	imagerel $chain$0$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD imagerel $LN12+150
	DD	imagerel $LN12+226
	DD	imagerel $chain$1$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD imagerel $LN12+226
	DD	imagerel $LN12+231
	DD	imagerel $chain$2$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD imagerel $LN12+231
	DD	imagerel $LN12+277
	DD	imagerel $chain$3$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD imagerel $LN20
	DD	imagerel $LN20+798
	DD	imagerel $unwind$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD imagerel $LN13
	DD	imagerel $LN13+29
	DD	imagerel $unwind$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD imagerel $LN13+29
	DD	imagerel $LN13+66
	DD	imagerel $chain$0$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD imagerel $LN13+66
	DD	imagerel $LN13+691
	DD	imagerel $chain$2$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD imagerel $LN13+691
	DD	imagerel $LN13+707
	DD	imagerel $chain$3$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD imagerel $LN13+707
	DD	imagerel $LN13+708
	DD	imagerel $chain$4$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z DD imagerel $LN43
	DD	imagerel $LN43+451
	DD	imagerel $unwind$?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z
pdata	ENDS
CRT$XCU	SEGMENT
?kInvalidId$initializer$@AssetManagement@MaxSDK@@3P6AXXZEA DQ FLAT:??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ; MaxSDK::AssetManagement::kInvalidId$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c9742400
CONST	SEGMENT
__real@c9742400 DD 0c9742400r			; -1e+06
CONST	ENDS
;	COMDAT __real@49742400
CONST	SEGMENT
__real@49742400 DD 049742400r			; 1e+06
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
_DATA	SEGMENT
?kTriObjNormalXTCID@@3VClass_ID@@B DD 0730a33d7H	; kTriObjNormalXTCID
	DD	027246c55H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z DD 062319H
	DD	0157415H
	DD	0123415H
	DD	0500bf215H
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+29
	DD	imagerel $unwind$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD 021H
	DD	imagerel $LN13+29
	DD	imagerel $LN13+66
	DD	imagerel $chain$0$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD 040a21H
	DD	0c740aH
	DD	0a3405H
	DD	imagerel $LN13+29
	DD	imagerel $LN13+66
	DD	imagerel $chain$0$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD 020521H
	DD	0b6405H
	DD	imagerel $LN13
	DD	imagerel $LN13+29
	DD	imagerel $unwind$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z DD 041401H
	DD	0d5414H
	DD	0e0107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z DD 0d3019H
	DD	059821H
	DD	06881cH
	DD	077817H
	DD	086812H
	DD	012010dH
	DD	060057006H
	DD	03004H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+107
	DD	imagerel $unwind$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD 021H
	DD	imagerel $LN12+107
	DD	imagerel $LN12+150
	DD	imagerel $chain$0$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD 020521H
	DD	07e405H
	DD	imagerel $LN12+107
	DD	imagerel $LN12+150
	DD	imagerel $chain$0$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN12
	DD	imagerel $LN12+107
	DD	imagerel $unwind$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z DD 060f01H
	DD	09640fH
	DD	08540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+364
	DD	imagerel $unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z DD 020621H
	DD	067806H
	DD	imagerel $LN45
	DD	imagerel $LN45+364
	DD	imagerel $unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z DD 0a2919H
	DD	07681bH
	DD	0110115H
	DD	0e007f009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+783
	DD	imagerel $unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z DD 020621H
	DD	067806H
	DD	imagerel $LN64
	DD	imagerel $LN64+783
	DD	imagerel $unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z DD 0c2d19H
	DD	07681fH
	DD	0110119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z DD 092519H
	DD	02a0117H
	DD	0e009f00bH
	DD	07005c007H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0140H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z DD 071201H
	DD	0196412H
	DD	0183412H
	DD	0160112H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z DD 0a2719H
	DD	02f0119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0160H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z DD 091701H
	DD	01c6417H
	DD	01b5417H
	DD	01a3417H
	DD	0180117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z DD 021H
	DD	imagerel $LN8
	DD	imagerel $LN8+24
	DD	imagerel $unwind$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z DD 061621H
	DD	036816H
	DD	0be40dH
	DD	0a3405H
	DD	imagerel $LN8
	DD	imagerel $LN8+24
	DD	imagerel $unwind$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z DD 061801H
	DD	0d6418H
	DD	0c5418H
	DD	070147218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?update@BerconXYZ@@QEAAXXZ DD 040a01H
	DD	010340aH
	DD	07006d20aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z DD 021H
	DD	imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z DD 081c21H
	DD	06f41cH
	DD	07e416H
	DD	08640cH
	DD	0e5404H
	DD	imagerel $LN6
	DD	imagerel $LN6+36
	DD	imagerel $unwind$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z DD 051e01H
	DD	0d01a821eH
	DD	07016c018H
	DD	03015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z DD 021H
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+73
	DD	imagerel $unwind$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z DD 020521H
	DD	0c7405H
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
	DD	imagerel ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z+73
	DD	imagerel $unwind$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z DD 071d19H
	DD	0f00ac20eH
	DD	0c006e008H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?GetString@@YAPEA_WH@Z DD 021H
	DD	imagerel $LN5
	DD	imagerel $LN5+18
	DD	imagerel $unwind$?GetString@@YAPEA_WH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?GetString@@YAPEA_WH@Z DD 020521H
	DD	043405H
	DD	imagerel $LN5
	DD	imagerel $LN5+18
	DD	imagerel $unwind$?GetString@@YAPEA_WH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetString@@YAPEA_WH@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_K1P6APEAX0@Z@Z DD 081901H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	070153219H
xdata	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?tiling@@YAHHAEAMAEAH@Z
_TEXT	SEGMENT
type$ = 8
x$ = 16
flip$ = 24
?tiling@@YAHHAEAMAEAH@Z PROC				; tiling, COMDAT

; 255  : 	switch (type) {

	sub	ecx, 1
	je	$LN4@tiling
	sub	ecx, 1
	je	$LN8@tiling
	sub	ecx, 1
	je	SHORT $LN10@tiling
	cmp	ecx, 1
	jne	$LN7@tiling

; 263  : 			return TRUE;				
; 264  : 		}
; 265  : 		case 4: {if (x<0||x>1) return FALSE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm1
	ja	SHORT $LN16@tiling
	vcomiss	xmm1, DWORD PTR __real@3f800000
	jbe	$LN7@tiling
$LN16@tiling:
	xor	eax, eax

; 266  : 	}
; 267  : 	return TRUE;
; 268  : }

	ret	0
$LN10@tiling:

; 258  : 		case 3: {
; 259  : 			if (x<0) x = -x;

	vmovss	xmm1, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN11@tiling
	vxorps	xmm0, xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	vmovss	DWORD PTR [rdx], xmm0
$LN11@tiling:

; 260  : 			int ix = (int)x;

	vmovss	xmm1, DWORD PTR [rdx]
	vcvttss2si eax, xmm1

; 261  : 			if (ix%2==0) x = x - ix;

	test	al, 1
	jne	SHORT $LN12@tiling
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vsubss	xmm1, xmm1, xmm0
	vmovss	DWORD PTR [rdx], xmm1
	mov	eax, 1

; 266  : 	}
; 267  : 	return TRUE;
; 268  : }

	ret	0
$LN12@tiling:

; 262  : 			else { x = 1.f - x + ix; flip = 1; }

	vmovss	xmm0, DWORD PTR __real@3f800000
	vsubss	xmm2, xmm0, xmm1
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	vaddss	xmm2, xmm2, xmm1
	vmovss	DWORD PTR [rdx], xmm2
	mov	DWORD PTR [r8], 1
	mov	eax, 1

; 266  : 	}
; 267  : 	return TRUE;
; 268  : }

	ret	0
$LN8@tiling:

; 257  : 		case 2: {D_LOOP(x) return TRUE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vcvttss2si eax, xmm1
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vsubss	xmm2, xmm1, xmm0
	vxorps	xmm1, xmm1, xmm1
	vcomiss	xmm1, xmm2
	vmovss	DWORD PTR [rdx], xmm2
	jbe	SHORT $LN7@tiling
	vaddss	xmm0, xmm2, DWORD PTR __real@3f800000
	vmovss	DWORD PTR [rdx], xmm0
	mov	eax, 1

; 266  : 	}
; 267  : 	return TRUE;
; 268  : }

	ret	0
$LN4@tiling:

; 256  : 		case 1: {D_STRE(x) return TRUE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN5@tiling
	mov	DWORD PTR [rdx], 0
	mov	eax, 1

; 266  : 	}
; 267  : 	return TRUE;
; 268  : }

	ret	0
$LN5@tiling:

; 256  : 		case 1: {D_STRE(x) return TRUE;}

	vcomiss	xmm1, DWORD PTR __real@3f800000
	jbe	SHORT $LN7@tiling
	mov	DWORD PTR [rdx], 1065353216		; 3f800000H
$LN7@tiling:
	mov	eax, 1

; 266  : 	}
; 267  : 	return TRUE;
; 268  : }

	ret	0
?tiling@@YAHHAEAMAEAH@Z ENDP				; tiling
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?tiling@@YAHHAEAM@Z
_TEXT	SEGMENT
type$ = 8
x$ = 16
?tiling@@YAHHAEAM@Z PROC				; tiling, COMDAT

; 245  : 	switch (type) {

	sub	ecx, 1
	je	$LN4@tiling
	sub	ecx, 1
	je	$LN8@tiling
	sub	ecx, 1
	je	SHORT $LN10@tiling
	cmp	ecx, 1
	jne	$LN7@tiling

; 249  : 		case 4: {if (x<0||x>1) return FALSE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm1
	ja	SHORT $LN16@tiling
	vcomiss	xmm1, DWORD PTR __real@3f800000
	jbe	$LN7@tiling
$LN16@tiling:
	xor	eax, eax

; 250  : 	}
; 251  : 	return TRUE;
; 252  : }

	ret	0
$LN10@tiling:

; 248  : 		case 3: {D_MIRR(x) return TRUE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN11@tiling
	vxorps	xmm0, xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	vmovss	DWORD PTR [rdx], xmm0
$LN11@tiling:
	vmovss	xmm1, DWORD PTR [rdx]
	vcvttss2si eax, xmm1
	test	al, 1
	jne	SHORT $LN12@tiling
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vsubss	xmm1, xmm1, xmm0
	vmovss	DWORD PTR [rdx], xmm1
	mov	eax, 1

; 250  : 	}
; 251  : 	return TRUE;
; 252  : }

	ret	0
$LN12@tiling:

; 248  : 		case 3: {D_MIRR(x) return TRUE;}

	vmovss	xmm0, DWORD PTR __real@3f800000
	vsubss	xmm2, xmm0, xmm1
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	vaddss	xmm2, xmm2, xmm1
	vmovss	DWORD PTR [rdx], xmm2
	mov	eax, 1

; 250  : 	}
; 251  : 	return TRUE;
; 252  : }

	ret	0
$LN8@tiling:

; 247  : 		case 2: {D_LOOP(x) return TRUE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vcvttss2si eax, xmm1
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vsubss	xmm2, xmm1, xmm0
	vxorps	xmm1, xmm1, xmm1
	vcomiss	xmm1, xmm2
	vmovss	DWORD PTR [rdx], xmm2
	jbe	SHORT $LN7@tiling
	vaddss	xmm0, xmm2, DWORD PTR __real@3f800000
	vmovss	DWORD PTR [rdx], xmm0
	mov	eax, 1

; 250  : 	}
; 251  : 	return TRUE;
; 252  : }

	ret	0
$LN4@tiling:

; 246  : 		case 1: {D_STRE(x) return TRUE;}

	vmovss	xmm1, DWORD PTR [rdx]
	vxorps	xmm0, xmm0, xmm0
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN5@tiling
	mov	DWORD PTR [rdx], 0
	mov	eax, 1

; 250  : 	}
; 251  : 	return TRUE;
; 252  : }

	ret	0
$LN5@tiling:

; 246  : 		case 1: {D_STRE(x) return TRUE;}

	vcomiss	xmm1, DWORD PTR __real@3f800000
	jbe	SHORT $LN7@tiling
	mov	DWORD PTR [rdx], 1065353216		; 3f800000H
$LN7@tiling:
	mov	eax, 1

; 250  : 	}
; 251  : 	return TRUE;
; 252  : }

	ret	0
?tiling@@YAHHAEAM@Z ENDP				; tiling
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 44
$T8 = 44
$T9 = 44
$T10 = 44
$T11 = 44
temp$12 = 56
__$ArrayPad$ = 112
this$ = 144
transform$ = 152
b$ = 160
?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z PROC	; BerconXYZ::getBasis, COMDAT

; 152  : void BerconXYZ::getBasis(Matrix3 transform, Point3* b) {

$LN43:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	mov	rbp, rsp
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-128], rax

; 153  : 	if (mappingType==4&&mode2D) {

	cmp	DWORD PTR [rcx], 4
	mov	rdi, r8
	mov	rbx, rdx
	jne	$LN2@getBasis
	cmp	DWORD PTR [rcx+260], 0
	je	$LN2@getBasis

; 154  : 		Matrix3 temp = transform;

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	xmm1, XMMWORD PTR [rdx+32]
	mov	eax, DWORD PTR [rdx+48]

; 155  : 		temp.Invert();

	lea	rcx, QWORD PTR temp$12[rbp-128]
	vmovups	YMMWORD PTR temp$12[rbp-128], ymm0
	vmovups	XMMWORD PTR temp$12[rbp-96], xmm1
	mov	DWORD PTR temp$12[rbp-80], eax
	vzeroupper
	call	QWORD PTR __imp_?Invert@Matrix3@@QEAAXXZ
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR temp$12[rbp-128]
	vmovss	xmm1, DWORD PTR temp$12[rbp-124]
	vmovss	DWORD PTR $T6[rbp-128], xmm0
	vmovss	xmm0, DWORD PTR temp$12[rbp-120]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 156  : 		b[0] = Normalize(temp.GetRow(0));

	lea	rdx, QWORD PTR $T6[rbp-128]
	lea	rcx, QWORD PTR $T11[rbp-128]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T6[rbp-120], xmm0
	vmovss	DWORD PTR $T6[rbp-124], xmm1
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 156  : 		b[0] = Normalize(temp.GetRow(0));

	call	QWORD PTR __imp_?Normalize@@YA?AVPoint3@@AEBV1@@Z
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm1, DWORD PTR temp$12[rbp-112]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 157  : 		b[1] = Normalize(temp.GetRow(1));

	lea	rdx, QWORD PTR $T5[rbp-128]
	lea	rcx, QWORD PTR $T10[rbp-128]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR temp$12[rbp-116]
	vmovss	DWORD PTR $T5[rbp-128], xmm0
	vmovss	xmm0, DWORD PTR temp$12[rbp-108]
	vmovss	DWORD PTR $T5[rbp-120], xmm0
	vmovss	DWORD PTR $T5[rbp-124], xmm1
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 156  : 		b[0] = Normalize(temp.GetRow(0));

	mov	DWORD PTR [rdi+8], eax

; 157  : 		b[1] = Normalize(temp.GetRow(1));

	call	QWORD PTR __imp_?Normalize@@YA?AVPoint3@@AEBV1@@Z
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm1, DWORD PTR temp$12[rbp-100]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 157  : 		b[1] = Normalize(temp.GetRow(1));

	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi+12], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR temp$12[rbp-104]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 157  : 		b[1] = Normalize(temp.GetRow(1));

	mov	eax, DWORD PTR [rax+8]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T4[rbp-128], xmm0
	vmovss	xmm0, DWORD PTR temp$12[rbp-96]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 157  : 		b[1] = Normalize(temp.GetRow(1));

	mov	DWORD PTR [rdi+20], eax

; 158  : 		b[2] = Normalize(temp.GetRow(2));
; 159  : 	} else {

	jmp	$LN41@getBasis
$LN2@getBasis:
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR [rdx]
	vmovss	xmm1, DWORD PTR [rdx+4]
	vmovss	DWORD PTR $T3[rbp-128], xmm0
	vmovss	xmm0, DWORD PTR [rdx+8]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 160  : 		b[0] = Normalize(transform.GetRow(0));

	lea	rdx, QWORD PTR $T3[rbp-128]
	lea	rcx, QWORD PTR $T9[rbp-128]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T3[rbp-120], xmm0
	vmovss	DWORD PTR $T3[rbp-124], xmm1
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 160  : 		b[0] = Normalize(transform.GetRow(0));

	call	QWORD PTR __imp_?Normalize@@YA?AVPoint3@@AEBV1@@Z

; 161  : 		b[1] = Normalize(transform.GetRow(1));

	lea	rdx, QWORD PTR $T2[rbp-128]
	lea	rcx, QWORD PTR $T8[rbp-128]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+8], eax
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR [rbx+12]
	vmovss	xmm1, DWORD PTR [rbx+16]
	vmovss	DWORD PTR $T2[rbp-128], xmm0
	vmovss	xmm0, DWORD PTR [rbx+20]
	vmovss	DWORD PTR $T2[rbp-120], xmm0
	vmovss	DWORD PTR $T2[rbp-124], xmm1
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 161  : 		b[1] = Normalize(transform.GetRow(1));

	call	QWORD PTR __imp_?Normalize@@YA?AVPoint3@@AEBV1@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi+12], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+20], eax
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	xmm0, DWORD PTR [rbx+24]
	vmovss	xmm1, DWORD PTR [rbx+28]
	vmovss	DWORD PTR $T1[rbp-128], xmm0
	vmovss	xmm0, DWORD PTR [rbx+32]
$LN41@getBasis:
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 162  : 		b[2] = Normalize(transform.GetRow(2));

	lea	rdx, QWORD PTR $T1[rbp-128]
	lea	rcx, QWORD PTR $T7[rbp-128]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	vmovss	DWORD PTR $T1[rbp-124], xmm1
	vmovss	DWORD PTR $T1[rbp-120], xmm0
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 162  : 		b[2] = Normalize(transform.GetRow(2));

	call	QWORD PTR __imp_?Normalize@@YA?AVPoint3@@AEBV1@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi+24], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+32], eax

; 163  : 	}
; 164  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-128]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+16]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z ENDP	; BerconXYZ::getBasis
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z
_TEXT	SEGMENT
this$ = 80
pblock$ = 88
t$ = 96
?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z PROC	; BerconXYZ::EnableStuff, COMDAT

; 122  : void BerconXYZ::EnableStuff(IParamBlock2* pblock, TimeValue t) {	

$LN13:

; 123  : 	if (pblock) {

	test	rdx, rdx
	je	$LN11@EnableStuf
	mov	QWORD PTR [rsp+32], rbp
	push	r14
	sub	rsp, 64					; 00000040H

; 124  : 		IParamMap2 *map = pblock->GetMap();

	mov	rax, QWORD PTR [rdx]
	mov	r9, rdx
	mov	r14, rcx
	mov	QWORD PTR [rsp+88], rsi
	xor	edx, edx
	mov	rcx, r9
	mov	ebp, r8d
	call	QWORD PTR [rax+2328]
	mov	rsi, rax

; 125  : 		if (map) {

	test	rax, rax
	je	$LN10@EnableStuf

; 126  : 			map->Enable(xyz_size_y2, !lock);			

	mov	r10, QWORD PTR [rax]
	mov	rcx, rax
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+96], rdi
	xor	edi, edi
	cmp	DWORD PTR [r14+112], edi
	mov	r8d, edi
	sete	r8b
	xor	r9d, r9d
	lea	edx, QWORD PTR [rdi+18]
	call	QWORD PTR [r10+184]

; 127  : 			map->Enable(xyz_size_z2, !lock);

	cmp	DWORD PTR [r14+112], edi
	lea	edx, QWORD PTR [rdi+19]
	mov	rax, QWORD PTR [rsi]
	mov	r8d, edi
	sete	r8b
	mov	rcx, rsi
	xor	r9d, r9d
	call	QWORD PTR [rax+184]

; 128  : 
; 129  : 			bool s = mappingType==0; // || mappingType==1;
; 130  : 			map->Enable(xyz_tile_x, s);

	mov	rax, QWORD PTR [rsi]
	lea	edx, QWORD PTR [rdi+11]
	mov	ebx, edi
	mov	rcx, rsi
	cmp	DWORD PTR [r14], ebx
	sete	bl
	xor	r9d, r9d
	mov	r8d, ebx
	call	QWORD PTR [rax+184]

; 131  : 			map->Enable(xyz_tile_y, s);

	mov	rax, QWORD PTR [rsi]
	lea	edx, QWORD PTR [rdi+12]
	xor	r9d, r9d
	mov	r8d, ebx
	mov	rcx, rsi
	call	QWORD PTR [rax+184]

; 132  : 			map->Enable(xyz_tile_z, s);

	mov	rax, QWORD PTR [rsi]
	lea	edx, QWORD PTR [rdi+13]
	xor	r9d, r9d
	mov	r8d, ebx
	mov	rcx, rsi
	call	QWORD PTR [rax+184]
	test	DWORD PTR [r14], -5			; fffffffbH

; 133  : 
; 134  : 			int type = isRealworld();
; 135  : 			
; 136  : 			setSpinnerType(map, t, xyz_offset_x, IDC_OFF_X, IDC_OFF_X_SPIN, type, true);	

	mov	r9d, 1072				; 00000430H
	mov	BYTE PTR [rsp+48], 1
	mov	r8d, 2
	setne	dil
	mov	edx, ebp
	mov	DWORD PTR [rsp+40], edi
	mov	rcx, rsi
	mov	DWORD PTR [rsp+32], 1073		; 00000431H
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 137  : 			setSpinnerType(map, t, xyz_offset_y, IDC_OFF_Y, IDC_OFF_Y_SPIN, type, true);	

	mov	BYTE PTR [rsp+48], 1
	mov	r9d, 1053				; 0000041dH
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 3
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1054		; 0000041eH
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 138  : 			setSpinnerType(map, t, xyz_offset_z, IDC_OFF_Z, IDC_OFF_Z_SPIN, type, true);	

	mov	BYTE PTR [rsp+48], 1
	mov	r9d, 1063				; 00000427H
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 4
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1064		; 00000428H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 139  : 			setSpinnerType(map, t, xyz_size_x, IDC_SIZ_X, IDC_SIZ_X_SPIN, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1055				; 0000041fH
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 5
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1056		; 00000420H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 140  : 			setSpinnerType(map, t, xyz_size_y, IDC_SIZ_Y, IDC_SIZ_Y_SPIN, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1059				; 00000423H
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 6
	mov	DWORD PTR [rsp+32], 1060		; 00000424H
	mov	edx, ebp
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 141  : 			setSpinnerType(map, t, xyz_size_z, IDC_SIZ_Z, IDC_SIZ_Z_SPIN, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1067				; 0000042bH
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 7
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1068		; 0000042cH
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 142  : 			setSpinnerType(map, t, xyz_offset_x2, IDC_OFF_X2, IDC_OFF_X_SPIN2, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1094				; 00000446H
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 14
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1095		; 00000447H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 143  : 			setSpinnerType(map, t, xyz_offset_y2, IDC_OFF_Y2, IDC_OFF_Y_SPIN2, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1101				; 0000044dH
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 15
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1102		; 0000044eH
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 144  : 			setSpinnerType(map, t, xyz_offset_z2, IDC_OFF_Z2, IDC_OFF_Z_SPIN2, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1108				; 00000454H
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 16
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1109		; 00000455H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 145  : 			setSpinnerType(map, t, xyz_size_x2, IDC_SIZ_X2, IDC_SIZ_X_SPIN2, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1096				; 00000448H
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 17
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1097		; 00000449H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 146  : 			setSpinnerType(map, t, xyz_size_y2, IDC_SIZ_Y2, IDC_SIZ_Y_SPIN2, type);	

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1103				; 0000044fH
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 18
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1104		; 00000450H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType

; 147  : 			setSpinnerType(map, t, xyz_size_z2, IDC_SIZ_Z2, IDC_SIZ_Z_SPIN2, type);

	mov	BYTE PTR [rsp+48], 0
	mov	r9d, 1110				; 00000456H
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, 19
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], 1111		; 00000457H
	mov	rcx, rsi
	call	?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ; setSpinnerType
	mov	rdi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+80]
$LN10@EnableStuf:
	mov	rsi, QWORD PTR [rsp+88]

; 148  : 		}
; 149  : 	}
; 150  : }

	mov	rbp, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
$LN11@EnableStuf:
	ret	0
?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z ENDP	; BerconXYZ::EnableStuff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
scale$ = 48
__$ArrayPad$ = 64
this$ = 176
__$ReturnUdt$ = 184
sc$ = 192
inv$ = 200
?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z PROC ; BerconXYZ::random, COMDAT

; 184  : Matrix3 BerconXYZ::random(ShadeContext& sc, Matrix3* inv) {

$LN20:
	mov	rax, rsp
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 144				; 00000090H
	vmovaps	XMMWORD PTR [rax-40], xmm6
	vmovaps	XMMWORD PTR [rax-56], xmm7
	vmovaps	XMMWORD PTR [rax-72], xmm8
	vmovaps	XMMWORD PTR [rax-88], xmm9
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rsi, r9

; 185  : 	seedRandomGen(sc);

	mov	rdx, r8
	mov	rbx, rcx
	call	?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z ; BerconXYZ::seedRandomGen

; 188  : 	transform.IdentityMatrix();

	mov	rcx, rdi
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h

; 172  :    Matrix3(){ flags = 0; }

	mov	DWORD PTR [rdi+48], 0
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 188  : 	transform.IdentityMatrix();

	call	QWORD PTR __imp_?IdentityMatrix@Matrix3@@QEAAXXZ

; 189  : 	transform.Translate(Point3(offX+offX2*URANDF(), offY+offY2*URANDF(), offZ+offZ2*URANDF()));

	call	QWORD PTR __imp_rand
	vmovss	xmm9, DWORD PTR __real@46fffe00
	vmovss	xmm8, DWORD PTR __real@3f800000
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm0, xmm0, xmm9
	vaddss	xmm1, xmm0, xmm0
	vsubss	xmm1, xmm1, xmm8
	vmulss	xmm0, xmm1, DWORD PTR [rbx+64]
	vaddss	xmm7, xmm0, DWORD PTR [rbx+16]
	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rbx+60]
	vaddss	xmm6, xmm0, DWORD PTR [rbx+12]
	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rbx+56]
	vaddss	xmm1, xmm0, DWORD PTR [rbx+8]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rdi
	vmovss	DWORD PTR $T2[rsp], xmm1
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T2[rsp+4], xmm6
	vmovss	DWORD PTR $T2[rsp+8], xmm7
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 189  : 	transform.Translate(Point3(offX+offX2*URANDF(), offY+offY2*URANDF(), offZ+offZ2*URANDF()));

	call	QWORD PTR __imp_?Translate@Matrix3@@QEAAXAEBVPoint3@@@Z

; 190  :  	transform.RotateX(angX+angX2*URANDF());

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rbx+80]
	vaddss	xmm1, xmm0, DWORD PTR [rbx+32]
	mov	rcx, rdi
	call	QWORD PTR __imp_?RotateX@Matrix3@@QEAAXM@Z

; 191  : 	transform.RotateY(angY+angY2*URANDF());

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rbx+84]
	vaddss	xmm1, xmm0, DWORD PTR [rbx+36]
	mov	rcx, rdi
	call	QWORD PTR __imp_?RotateY@Matrix3@@QEAAXM@Z

; 192  : 	transform.RotateZ(angZ+angZ2*URANDF());	

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rbx+88]
	vaddss	xmm1, xmm0, DWORD PTR [rbx+40]
	mov	rcx, rdi
	call	QWORD PTR __imp_?RotateZ@Matrix3@@QEAAXM@Z

; 193  : 
; 194  : 	if (inv) {

	test	rsi, rsi
	je	SHORT $LN2@random

; 195  : 		*inv = transform;

	vmovups	ymm0, YMMWORD PTR [rdi]
	vmovups	YMMWORD PTR [rsi], ymm0
	vmovups	xmm1, XMMWORD PTR [rdi+32]
	vmovups	XMMWORD PTR [rsi+32], xmm1
	mov	eax, DWORD PTR [rdi+48]

; 196  : 		inv->Invert();

	mov	rcx, rsi
	mov	DWORD PTR [rsi+48], eax
	vzeroupper
	call	QWORD PTR __imp_?Invert@Matrix3@@QEAAXXZ
$LN2@random:

; 200  : 	if (lock) {

	cmp	DWORD PTR [rbx+112], 0
	vxorps	xmm0, xmm0, xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 58   :    Point3() : x(0.0f), y(0.0f), z(0.0f) {  }

	vmovss	DWORD PTR scale$[rsp], xmm0
	vmovss	DWORD PTR scale$[rsp+4], xmm0
	vmovss	DWORD PTR scale$[rsp+8], xmm0
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 200  : 	if (lock) {

	je	SHORT $LN3@random

; 201  : 		float add = sizeX2*URANDF();

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rbx+68]

; 202  : 		scale = Point3(sizeX+add, sizeY+add, sizeZ+add);	

	vaddss	xmm1, xmm0, DWORD PTR [rbx+24]
	vaddss	xmm2, xmm0, DWORD PTR [rbx+20]
	vaddss	xmm0, xmm0, DWORD PTR [rbx+28]
	vmovss	DWORD PTR $T1[rsp+8], xmm0
	mov	eax, DWORD PTR $T1[rsp+8]
	vunpcklps xmm0, xmm2, xmm1
	vmovsd	QWORD PTR scale$[rsp], xmm0

; 203  : 	} else {

	vmovss	xmm7, DWORD PTR scale$[rsp+4]
	vmovss	xmm1, DWORD PTR scale$[rsp]
	mov	DWORD PTR scale$[rsp+8], eax
	vmovss	xmm6, DWORD PTR scale$[rsp+8]
	jmp	SHORT $LN4@random
$LN3@random:

; 204  : 		scale = Point3(sizeX+sizeX2*URANDF(), sizeY+sizeY2*URANDF(), sizeZ+sizeZ2*URANDF());

	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rbx+76]
	vaddss	xmm6, xmm0, DWORD PTR [rbx+28]
	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rbx+72]
	vaddss	xmm7, xmm0, DWORD PTR [rbx+24]
	call	QWORD PTR __imp_rand
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vdivss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, xmm1
	vsubss	xmm3, xmm2, xmm8
	vmulss	xmm0, xmm3, DWORD PTR [rbx+68]
	vaddss	xmm1, xmm0, DWORD PTR [rbx+20]
$LN4@random:

; 205  : 	}
; 206  : 	if (scale.x < 0.0001f) scale.x = 0.0001f;

	vmovss	xmm0, DWORD PTR __real@38d1b717
	vcomiss	xmm0, xmm1
	jbe	SHORT $LN5@random
	vmovaps	xmm1, xmm0
$LN5@random:

; 207  : 	if (scale.y < 0.0001f) scale.y = 0.0001f;

	vcomiss	xmm0, xmm7
	jbe	SHORT $LN6@random
	vmovaps	xmm7, xmm0
$LN6@random:

; 208  : 	if (scale.z < 0.0001f) scale.z = 0.0001f;

	vcomiss	xmm0, xmm6
	jbe	SHORT $LN7@random
	vmovaps	xmm6, xmm0
$LN7@random:

; 209  : 	scale.x = 1.f/scale.x; scale.y = 1.f/scale.y; scale.z = 1.f/scale.z;

	vdivss	xmm0, xmm8, xmm1
	vmovss	DWORD PTR scale$[rsp], xmm0
	vdivss	xmm0, xmm8, xmm6
	vdivss	xmm1, xmm8, xmm7

; 210  : 	transform.Scale(scale);

	xor	r8d, r8d
	lea	rdx, QWORD PTR scale$[rsp]
	mov	rcx, rdi
	vmovss	DWORD PTR scale$[rsp+8], xmm0
	vmovss	DWORD PTR scale$[rsp+4], xmm1
	call	QWORD PTR __imp_?Scale@Matrix3@@QEAAXAEBVPoint3@@H@Z

; 211  : 
; 212  : 	return transform;

	mov	rax, rdi

; 213  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	vmovaps	xmm6, XMMWORD PTR [rsp+128]
	vmovaps	xmm7, XMMWORD PTR [rsp+112]
	vmovaps	xmm8, XMMWORD PTR [rsp+96]
	vmovaps	xmm9, XMMWORD PTR [rsp+80]
	add	rsp, 144				; 00000090H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ENDP ; BerconXYZ::random
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z
_TEXT	SEGMENT
this$ = 48
sc$ = 56
?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z PROC ; BerconXYZ::seedRandomGen, COMDAT

; 215  : void BerconXYZ::seedRandomGen(ShadeContext& sc) {

$LN12:
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 216  : 	int seed = 1;
; 217  : 
; 218  : 	if (p_randMat) { 		

	cmp	DWORD PTR [rcx+100], 0
	mov	rsi, rdx
	mov	rbp, rcx
	mov	edi, 1
	je	SHORT $LN2@seedRandom

; 219  : 		seed += sc.mtlNum;

	mov	edi, DWORD PTR [rdx+28]
	inc	edi
$LN2@seedRandom:

; 220  : 	}
; 221  : 	if (p_randObj) {

	cmp	DWORD PTR [rcx+96], 0
	je	SHORT $LN4@seedRandom

; 222  : 		INode *node=sc.Node();

	mov	rax, QWORD PTR [rdx]
	mov	rcx, rsi
	call	QWORD PTR [rax+72]

; 223  : 		if (node) {

	test	rax, rax
	je	SHORT $LN4@seedRandom

; 224  : 			int hand = (int) node->GetHandle();

	mov	rdx, QWORD PTR [rax]
	mov	rcx, rax
	call	QWORD PTR [rdx+2600]

; 225  : 			seed += hand*(hand*hand*15731 + 789221);

	mov	ecx, eax
	imul	ecx, eax
	imul	edx, ecx, 15731				; 00003d73H
	add	edx, 789221				; 000c0ae5H
	imul	edx, eax
	add	edi, edx
$LN4@seedRandom:

; 226  : 		}
; 227  : 	}
; 228  : 	if (p_randPar) {

	cmp	DWORD PTR [rbp+104], 0
	je	$LN7@seedRandom

; 229  : 		Object *ob = sc.GetEvalObject();		

	mov	rax, QWORD PTR [rsi]
	mov	rcx, rsi
	mov	QWORD PTR [rsp+48], rbx
	call	QWORD PTR [rax+80]
	mov	rbx, rax

; 230  : 		if (ob && ob->IsParticleSystem()) {

	test	rax, rax
	je	SHORT $LN9@seedRandom
	mov	rdx, QWORD PTR [rax]
	mov	rcx, rax
	call	QWORD PTR [rdx+1896]
	test	eax, eax
	je	SHORT $LN9@seedRandom

; 231  : 			ParticleObject *obj = (ParticleObject*)ob;
; 232  : 			IChkMtlAPI* chkMtlAPI = static_cast<IChkMtlAPI*>(obj->GetInterface(I_NEWMTLINTERFACE));

	mov	r8, QWORD PTR [rbx]
	mov	edx, 4752				; 00001290H
	mov	rcx, rbx
	mov	QWORD PTR [rsp+56], r14
	call	QWORD PTR [r8+72]
	mov	r14, rax

; 233  : 			if ((chkMtlAPI && chkMtlAPI->SupportsParticleIDbyFace())) {

	test	rax, rax
	je	SHORT $LN10@seedRandom
	mov	rdx, QWORD PTR [rax]
	mov	rcx, rax
	call	QWORD PTR [rdx]
	test	eax, eax
	je	SHORT $LN10@seedRandom

; 234  : 				int id = chkMtlAPI->GetParticleFromFace(sc.FaceNumber());

	mov	rdx, QWORD PTR [rsi]
	mov	rcx, rsi
	mov	rbx, QWORD PTR [r14]
	call	QWORD PTR [rdx+96]
	mov	edx, eax
	mov	rcx, r14
	call	QWORD PTR [rbx+8]

; 235  : 				seed += id*(id*id*571 + 789221);

	mov	ecx, eax
	imul	ecx, eax
	imul	edx, ecx, 571				; 0000023bH
	add	edx, 789221				; 000c0ae5H
	imul	edx, eax
	add	edi, edx
$LN10@seedRandom:
	mov	r14, QWORD PTR [rsp+56]
$LN9@seedRandom:
	mov	rbx, QWORD PTR [rsp+48]
$LN7@seedRandom:

; 236  : 			}			
; 237  : 		}
; 238  : 	}
; 239  : 
; 240  : 	seed *= p_seed;

	imul	edi, DWORD PTR [rbp+92]

; 241  : 	srand(seed*(seed*seed*15731 + 789221));	

	mov	eax, edi
	imul	eax, edi
	imul	ecx, eax, 15731				; 00003d73H
	add	ecx, 789221				; 000c0ae5H
	imul	ecx, edi

; 242  : }

	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi

; 241  : 	srand(seed*(seed*seed*15731 + 789221));	

	rex_jmp	QWORD PTR __imp_srand
?seedRandomGen@BerconXYZ@@AEAAXAEAVShadeContext@@@Z ENDP ; BerconXYZ::seedRandomGen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point2.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 44
$T7 = 44
$T8 = 44
$T9 = 44
$T10 = 44
uv$11 = 56
duv$12 = 64
$T13 = 64
$T14 = 64
__$ArrayPad$ = 80
this$ = 192
sc$ = 200
p$ = 208
transform$ = 216
flips$ = 224
?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z PROC ; BerconXYZ::get, COMDAT

; 318  : int BerconXYZ::get(ShadeContext& sc, Point3& p, Matrix3 transform, int* flips) {

$LN45:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 136				; 00000088H
	vmovaps	XMMWORD PTR [rsp+112], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-97], rax
	mov	r14, QWORD PTR flips$[rbp-97]
	mov	rsi, rdx

; 319  : 	switch (mappingType) {

	mov	edx, DWORD PTR [rcx]
	mov	r15, r9
	mov	rdi, r8
	mov	rbx, rcx
	test	edx, edx
	je	$LN4@get
	sub	edx, 1
	je	$LN17@get
	sub	edx, 1
	je	$LN18@get
	sub	edx, 1
	je	$LN19@get
	cmp	edx, 1
	jne	SHORT $LN16@get

; 340  : 			sc.ScreenUV(uv, duv);

	mov	rax, QWORD PTR [rsi]
	lea	r8, QWORD PTR duv$12[rbp-97]
	vxorps	xmm6, xmm6, xmm6
	lea	rdx, QWORD PTR uv$11[rbp-97]
	mov	rcx, rsi
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point2.h

; 50   : 	Point2() : x(0.0f), y(0.0f) {}

	vmovss	DWORD PTR uv$11[rbp-97], xmm6
	vmovss	DWORD PTR uv$11[rbp-93], xmm6
	vmovss	DWORD PTR duv$12[rbp-97], xmm6
	vmovss	DWORD PTR duv$12[rbp-93], xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 340  : 			sc.ScreenUV(uv, duv);

	call	QWORD PTR [rax+272]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR uv$11[rbp-97]
	vmovss	xmm1, DWORD PTR uv$11[rbp-93]
	vmovss	DWORD PTR $T1[rbp-97], xmm0
	vmovss	DWORD PTR $T1[rbp-93], xmm1
	vmovss	DWORD PTR $T1[rbp-89], xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 341  : 			p = transform * Point3(uv.x, uv.y, 0.f);

	lea	r8, QWORD PTR $T1[rbp-97]
	mov	rdx, r15
	lea	rcx, QWORD PTR $T6[rbp-97]
$LN41@get:

; 328  : 			break;
; 329  : 		case 1:			
; 330  : 			p = transform * sc.UVW(mappingChannel);			

	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rdi], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rdi+8], eax
$LN16@get:

; 342  : 			break;}
; 343  : 		}
; 344  : 	return TRUE;

	mov	eax, 1
$LN1@get:

; 345  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-97]
	xor	rcx, rsp
	call	__security_check_cookie
	vmovaps	xmm6, XMMWORD PTR [rsp+112]
	add	rsp, 136				; 00000088H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN19@get:

; 335  : 		case 3: {
; 336  : 			p = transform * sc.PointTo(sc.P(),REF_WORLD);

	mov	rbx, QWORD PTR [rsi]
	lea	rdx, QWORD PTR $T7[rbp-97]
	mov	rcx, rsi
	call	QWORD PTR [rbx+208]
	mov	r9d, 1

; 337  : 			break;}

	jmp	SHORT $LN43@get
$LN18@get:

; 332  : 		case 2: {
; 333  : 			p = transform * sc.PointTo(sc.P(),REF_OBJECT);

	mov	rbx, QWORD PTR [rsi]
	lea	rdx, QWORD PTR $T8[rbp-97]
	mov	rcx, rsi
	call	QWORD PTR [rbx+208]
	mov	r9d, 2
$LN43@get:
	mov	r8, rax
	lea	rdx, QWORD PTR $T2[rbp-97]
	mov	rcx, rsi
	call	QWORD PTR [rbx+416]
	mov	rdx, r15
	lea	rcx, QWORD PTR $T13[rbp-97]
	mov	r8, rax

; 334  : 			break;}

	jmp	$LN41@get
$LN17@get:

; 328  : 			break;
; 329  : 		case 1:			
; 330  : 			p = transform * sc.UVW(mappingChannel);			

	mov	r8d, DWORD PTR [rcx+4]
	lea	rdx, QWORD PTR $T9[rbp-97]
	mov	rax, QWORD PTR [rsi]
	mov	rcx, rsi
	call	QWORD PTR [rax+296]
	mov	rdx, r15
	lea	rcx, QWORD PTR $T3[rbp-97]
	mov	r8, rax

; 331  : 			break;

	jmp	$LN41@get
$LN4@get:

; 321  : 			p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;	

	mov	r8d, DWORD PTR [rcx+4]
	lea	rdx, QWORD PTR $T10[rbp-97]
	mov	rax, QWORD PTR [rsi]
	mov	rcx, rsi
	vmovaps	XMMWORD PTR [rsp+96], xmm7
	call	QWORD PTR [rax+296]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 293  :    return(Point3(x-b.x,y-b.y,z-b.z));

	vmovss	xmm6, DWORD PTR __real@3f000000
	vxorps	xmm7, xmm7, xmm7
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 321  : 			p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;	

	lea	r8, QWORD PTR $T5[rbp-97]
	mov	rdx, r15
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 293  :    return(Point3(x-b.x,y-b.y,z-b.z));

	vmovss	xmm0, DWORD PTR [rax+8]
	vsubss	xmm3, xmm0, xmm7
	vmovss	xmm0, DWORD PTR [rax+4]
	vsubss	xmm2, xmm0, xmm6
	vmovss	xmm0, DWORD PTR [rax]
	vsubss	xmm1, xmm0, xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 321  : 			p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;	

	lea	rcx, QWORD PTR $T14[rbp-97]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 293  :    return(Point3(x-b.x,y-b.y,z-b.z));

	vmovss	DWORD PTR $T5[rbp-97], xmm1

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T5[rbp-93], xmm2
	vmovss	DWORD PTR $T5[rbp-89], xmm3
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 321  : 			p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;	

	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z

; 322  : 			if (flips) { if (!tiling(tileX, p.x, flips[0])) return FALSE; }

	mov	rdx, rdi
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vaddss	xmm0, xmm7, DWORD PTR [rax+8]
	vmovaps	xmm7, XMMWORD PTR [rsp+96]
	vaddss	xmm3, xmm6, DWORD PTR [rax]
	vaddss	xmm2, xmm6, DWORD PTR [rax+4]
	vmovss	DWORD PTR $T4[rbp-89], xmm0
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 321  : 			p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;	

	mov	eax, DWORD PTR $T4[rbp-89]
	vunpcklps xmm0, xmm3, xmm2
	vmovsd	QWORD PTR [rdi], xmm0
	mov	DWORD PTR [rdi+8], eax

; 322  : 			if (flips) { if (!tiling(tileX, p.x, flips[0])) return FALSE; }

	mov	ecx, DWORD PTR [rbx+44]
	test	r14, r14
	je	SHORT $LN5@get
	mov	r8, r14
	call	?tiling@@YAHHAEAMAEAH@Z			; tiling
	test	eax, eax
	je	SHORT $LN42@get

; 324  : 			if (flips) { if (!tiling(tileY, p.y, flips[1])) return FALSE; }

	mov	ecx, DWORD PTR [rbx+48]
	lea	r8, QWORD PTR [r14+4]
	lea	rdx, QWORD PTR [rdi+4]
	call	?tiling@@YAHHAEAMAEAH@Z			; tiling
	test	eax, eax
	je	SHORT $LN42@get

; 326  : 			if (flips) { if (!tiling(tileZ, p.z, flips[2])) return FALSE; }

	mov	ecx, DWORD PTR [rbx+52]
	lea	r8, QWORD PTR [r14+8]
	lea	rdx, QWORD PTR [rdi+8]
	call	?tiling@@YAHHAEAMAEAH@Z			; tiling
	test	eax, eax
	jne	$LN16@get
$LN42@get:
	xor	eax, eax
	jmp	$LN1@get
$LN5@get:

; 323  : 			else { if (!tiling(tileX, p.x)) return FALSE; }

	call	?tiling@@YAHHAEAM@Z			; tiling
	test	eax, eax
	je	SHORT $LN42@get

; 325  : 			else { if (!tiling(tileY, p.y)) return FALSE; }

	mov	ecx, DWORD PTR [rbx+48]
	lea	rdx, QWORD PTR [rdi+4]
	call	?tiling@@YAHHAEAM@Z			; tiling
	test	eax, eax
	je	SHORT $LN42@get

; 327  : 			else { if (!tiling(tileZ, p.z)) return FALSE; }

	mov	ecx, DWORD PTR [rbx+52]
	lea	rdx, QWORD PTR [rdi+8]
	call	?tiling@@YAHHAEAM@Z			; tiling
	test	eax, eax
	jne	$LN16@get
	jmp	$LN1@get
?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z ENDP ; BerconXYZ::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point2.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 32
$T9 = 32
$T10 = 32
$T11 = 48
$T12 = 48
$T13 = 48
$T14 = 48
$T15 = 48
$T16 = 48
$T17 = 48
$T18 = 48
$T19 = 48
$T20 = 48
$T21 = 48
duvw$22 = 48
$T23 = 48
$T24 = 48
$T25 = 48
duv$26 = 64
$T27 = 64
$T28 = 64
$T29 = 64
$T30 = 64
uv$31 = 80
__$ArrayPad$ = 88
this$ = 208
sc$ = 216
p$ = 224
dpdx$ = 232
dpdy$ = 240
transform$ = 248
flips$ = 256
?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z PROC ; BerconXYZ::get, COMDAT

; 272  : int BerconXYZ::get(ShadeContext& sc, Point3& p, Point3& dpdx, Point3& dpdy, Matrix3 transform, int* flips) {

$LN64:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-7]
	sub	rsp, 136				; 00000088H
	vmovaps	XMMWORD PTR [rsp+112], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-129], rax

; 273  : 	switch (mappingType) {

	mov	eax, DWORD PTR [rcx]
	mov	r15, r9
	mov	r13, QWORD PTR dpdy$[rbp-129]
	mov	rsi, r8
	mov	r12, QWORD PTR transform$[rbp-129]
	mov	r14, rdx
	mov	rbx, QWORD PTR flips$[rbp-129]
	mov	rdi, rcx
	test	eax, eax
	js	$LN18@get
	cmp	eax, 1
	jle	$LN4@get
	cmp	eax, 2
	je	$LN19@get
	cmp	eax, 3
	je	$LN20@get
	cmp	eax, 4
	jne	$LN18@get

; 306  : 			sc.ScreenUV(uv, duv);

	mov	rax, QWORD PTR [rdx]
	lea	r8, QWORD PTR duv$26[rbp-129]
	vxorps	xmm6, xmm6, xmm6
	lea	rdx, QWORD PTR uv$31[rbp-129]
	mov	rcx, r14
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point2.h

; 50   : 	Point2() : x(0.0f), y(0.0f) {}

	vmovss	DWORD PTR uv$31[rbp-129], xmm6
	vmovss	DWORD PTR uv$31[rbp-125], xmm6
	vmovss	DWORD PTR duv$26[rbp-129], xmm6
	vmovss	DWORD PTR duv$26[rbp-125], xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 306  : 			sc.ScreenUV(uv, duv);

	call	QWORD PTR [rax+272]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR uv$31[rbp-129]
	vmovss	xmm1, DWORD PTR uv$31[rbp-125]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 307  : 			p = transform * Point3(uv.x, uv.y, 0.f);

	lea	r8, QWORD PTR $T15[rbp-129]
	mov	rdx, r12
	lea	rcx, QWORD PTR $T3[rbp-129]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T15[rbp-129], xmm0
	vmovss	DWORD PTR $T15[rbp-125], xmm1
	vmovss	DWORD PTR $T15[rbp-121], xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 307  : 			p = transform * Point3(uv.x, uv.y, 0.f);

	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z

; 308  : 			dpdx = VectorTransform(transform, Point3(duv.x, 0.f, 0.f));

	lea	r8, QWORD PTR $T14[rbp-129]
	mov	rdx, r12
	lea	rcx, QWORD PTR $T2[rbp-129]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rsi], xmm0
	mov	eax, DWORD PTR [rax+8]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR duv$26[rbp-129]
	vmovss	DWORD PTR $T14[rbp-129], xmm0
	vmovss	DWORD PTR $T14[rbp-125], xmm6
	vmovss	DWORD PTR $T14[rbp-121], xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 307  : 			p = transform * Point3(uv.x, uv.y, 0.f);

	mov	DWORD PTR [rsi+8], eax

; 308  : 			dpdx = VectorTransform(transform, Point3(duv.x, 0.f, 0.f));

	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 309  : 			dpdy = VectorTransform(transform, Point3(0.f, duv.y, 0.f));

	lea	r8, QWORD PTR $T13[rbp-129]
	lea	rcx, QWORD PTR $T1[rbp-129]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r15], xmm0
	mov	eax, DWORD PTR [rax+8]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR duv$26[rbp-125]
	vmovss	DWORD PTR $T13[rbp-125], xmm0
	vmovss	DWORD PTR $T13[rbp-129], xmm6
	vmovss	DWORD PTR $T13[rbp-121], xmm6
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 308  : 			dpdx = VectorTransform(transform, Point3(duv.x, 0.f, 0.f));

	mov	DWORD PTR [r15+8], eax
$LN62@get:

; 309  : 			dpdy = VectorTransform(transform, Point3(0.f, duv.y, 0.f));

	mov	rdx, r12
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r13], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r13+8], eax
$LN18@get:

; 313  : 	dpdx = dpdx * filtering; dpdy = dpdy * filtering;

	vmovss	xmm0, DWORD PTR [rdi+108]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm2, xmm0, DWORD PTR [r15]
	vmulss	xmm1, xmm0, DWORD PTR [r15+4]
	vmulss	xmm0, xmm0, DWORD PTR [r15+8]
	vmovss	DWORD PTR $T12[rbp-121], xmm0
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 313  : 	dpdx = dpdx * filtering; dpdy = dpdy * filtering;

	mov	eax, DWORD PTR $T12[rbp-121]
	vunpcklps xmm0, xmm2, xmm1
	vmovsd	QWORD PTR [r15], xmm0
	mov	DWORD PTR [r15+8], eax

; 314  : 	
; 315  : 	return TRUE;

	mov	eax, 1
	vmovss	xmm0, DWORD PTR [rdi+108]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm2, xmm0, DWORD PTR [r13]
	vmulss	xmm1, xmm0, DWORD PTR [r13+4]
	vmulss	xmm0, xmm0, DWORD PTR [r13+8]
	vmovss	DWORD PTR $T11[rbp-121], xmm0
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 313  : 	dpdx = dpdx * filtering; dpdy = dpdy * filtering;

	mov	ecx, DWORD PTR $T11[rbp-121]
	vunpcklps xmm0, xmm2, xmm1
	vmovsd	QWORD PTR [r13], xmm0
	mov	DWORD PTR [r13+8], ecx
$LN1@get:

; 316  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-129]
	xor	rcx, rsp
	call	__security_check_cookie
	vmovaps	xmm6, XMMWORD PTR [rsp+112]
	add	rsp, 136				; 00000088H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN20@get:

; 298  : 		case 3: {
; 299  : 			p = transform * sc.PointTo(sc.P(),REF_WORLD);

	mov	rbx, QWORD PTR [rdx]
	mov	rcx, r14
	lea	rdx, QWORD PTR $T5[rbp-129]
	call	QWORD PTR [rbx+208]
	mov	r9d, 1
	lea	rdx, QWORD PTR $T17[rbp-129]
	mov	r8, rax
	mov	rcx, r14
	call	QWORD PTR [rbx+416]
	mov	rdx, r12
	lea	rcx, QWORD PTR $T27[rbp-129]
	mov	r8, rax
	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z

; 300  : 			sc.DP(dpdx, dpdy);	

	mov	r8, r13
	mov	rdx, r15
	mov	rcx, r14
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rsi], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rsi+8], eax
	mov	rax, QWORD PTR [r14]
	call	QWORD PTR [rax+216]

; 301  : 			dpdx = VectorTransform(transform, sc.VectorTo(dpdx, REF_WORLD));

	mov	rax, QWORD PTR [r14]
	lea	rdx, QWORD PTR $T4[rbp-129]
	mov	r9d, 1
	mov	r8, r15
	mov	rcx, r14
	call	QWORD PTR [rax+432]
	mov	rdx, r12
	lea	rcx, QWORD PTR $T16[rbp-129]
	mov	r8, rax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 302  : 			dpdy = VectorTransform(transform, sc.VectorTo(dpdy, REF_WORLD));

	mov	r9d, 1

; 303  : 			break;}

	jmp	$LN61@get
$LN19@get:

; 291  : 			break;
; 292  : 		case 2: {
; 293  : 			p = transform * sc.PointTo(sc.P(),REF_OBJECT);

	mov	rbx, QWORD PTR [rdx]
	mov	rcx, r14
	lea	rdx, QWORD PTR $T8[rbp-129]
	call	QWORD PTR [rbx+208]
	mov	r9d, 2
	lea	rdx, QWORD PTR $T20[rbp-129]
	mov	r8, rax
	mov	rcx, r14
	call	QWORD PTR [rbx+416]
	mov	rdx, r12
	lea	rcx, QWORD PTR $T28[rbp-129]
	mov	r8, rax
	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z

; 294  : 			sc.DP(dpdx, dpdy);	

	mov	r8, r13
	mov	rdx, r15
	mov	rcx, r14
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rsi], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rsi+8], eax
	mov	rax, QWORD PTR [r14]
	call	QWORD PTR [rax+216]

; 295  : 			dpdx = VectorTransform(transform, sc.VectorTo(dpdx, REF_OBJECT));

	mov	rax, QWORD PTR [r14]
	lea	rdx, QWORD PTR $T7[rbp-129]
	mov	r9d, 2
	mov	r8, r15
	mov	rcx, r14
	call	QWORD PTR [rax+432]
	mov	rdx, r12
	lea	rcx, QWORD PTR $T19[rbp-129]
	mov	r8, rax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 296  : 			dpdy = VectorTransform(transform, sc.VectorTo(dpdy, REF_OBJECT));

	mov	r9d, 2
$LN61@get:

; 295  : 			dpdx = VectorTransform(transform, sc.VectorTo(dpdx, REF_OBJECT));

	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r15], xmm0
	mov	eax, DWORD PTR [rax+8]

; 296  : 			dpdy = VectorTransform(transform, sc.VectorTo(dpdy, REF_OBJECT));

	lea	rdx, QWORD PTR $T6[rbp-129]
	mov	DWORD PTR [r15+8], eax
	mov	r8, r13
	mov	rax, QWORD PTR [r14]
	mov	rcx, r14
	call	QWORD PTR [rax+432]
	mov	r8, rax
	lea	rcx, QWORD PTR $T18[rbp-129]

; 297  : 			break;}

	jmp	$LN62@get
$LN4@get:

; 274  : 		case 0:
; 275  : 		case 1:
; 276  : 			if (mappingType)
; 277  : 				p = transform * sc.UVW(mappingChannel);			

	mov	r8d, DWORD PTR [rcx+4]
	test	eax, eax
	mov	rax, QWORD PTR [rdx]
	mov	rcx, r14
	vmovaps	XMMWORD PTR [rsp+96], xmm7
	lea	rdx, QWORD PTR $T10[rbp-129]
	vxorps	xmm7, xmm7, xmm7
	je	SHORT $LN5@get
	call	QWORD PTR [rax+296]
	mov	rdx, r12
	lea	rcx, QWORD PTR $T25[rbp-129]
	mov	r8, rax
	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rsi], xmm0
	mov	eax, DWORD PTR [rax+8]

; 278  : 			else

	jmp	SHORT $LN57@get
$LN5@get:

; 279  : 				p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;

	call	QWORD PTR [rax+296]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 293  :    return(Point3(x-b.x,y-b.y,z-b.z));

	vmovss	xmm6, DWORD PTR __real@3f000000
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 279  : 				p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;

	lea	r8, QWORD PTR $T24[rbp-129]
	mov	rdx, r12
	lea	rcx, QWORD PTR $T30[rbp-129]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 293  :    return(Point3(x-b.x,y-b.y,z-b.z));

	vmovss	xmm0, DWORD PTR [rax+8]
	vmovss	xmm1, DWORD PTR [rax+4]
	vsubss	xmm3, xmm0, xmm7
	vmovss	xmm0, DWORD PTR [rax]
	vsubss	xmm2, xmm1, xmm6
	vsubss	xmm1, xmm0, xmm6
	vmovss	DWORD PTR $T24[rbp-129], xmm1

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T24[rbp-125], xmm2
	vmovss	DWORD PTR $T24[rbp-121], xmm3
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 279  : 				p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;

	call	QWORD PTR __imp_??D@YA?AVPoint3@@AEBVMatrix3@@AEBV0@@Z
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 297  :    return(Point3(x+b.x,y+b.y,z+b.z));

	vaddss	xmm0, xmm7, DWORD PTR [rax+8]
	vaddss	xmm3, xmm6, DWORD PTR [rax]
	vaddss	xmm2, xmm6, DWORD PTR [rax+4]
	vmovss	DWORD PTR $T23[rbp-121], xmm0
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 279  : 				p = transform * (sc.UVW(mappingChannel) - OFFSET_5) + OFFSET_5;

	mov	eax, DWORD PTR $T23[rbp-121]
	vunpcklps xmm0, xmm3, xmm2
	vmovsd	QWORD PTR [rsi], xmm0
$LN57@get:
	mov	DWORD PTR [rsi+8], eax

; 280  : 			{
; 281  : 			Point3 duvw = VectorTransform(transform, sc.DUVW(mappingChannel));

	lea	rdx, QWORD PTR $T9[rbp-129]
	mov	rax, QWORD PTR [r14]
	mov	rcx, r14
	mov	r8d, DWORD PTR [rdi+4]
	call	QWORD PTR [rax+304]
	mov	rdx, r12
	lea	rcx, QWORD PTR duvw$22[rbp-129]
	mov	r8, rax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 284  : 			}
; 285  : 			if (flips) { if (!tiling(tileX, p.x, flips[0])) return FALSE; }

	mov	rdx, rsi
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR duvw$22[rbp-129]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 282  : 			dpdx = Point3(duvw.x, 0.f, 0.f);

	vunpcklps xmm0, xmm0, xmm7
	vmovsd	QWORD PTR [r15], xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR duvw$22[rbp-125]
	vmovss	DWORD PTR $T29[rbp-121], xmm7
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 282  : 			dpdx = Point3(duvw.x, 0.f, 0.f);

	mov	eax, DWORD PTR $T29[rbp-121]
	mov	DWORD PTR [r15+8], eax

; 283  : 			dpdy = Point3(0.f, duvw.y, 0.f);

	vunpcklps xmm0, xmm7, xmm0
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T21[rbp-121], xmm7
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 283  : 			dpdy = Point3(0.f, duvw.y, 0.f);

	mov	eax, DWORD PTR $T21[rbp-121]
	vmovaps	xmm7, XMMWORD PTR [rsp+96]
	vmovsd	QWORD PTR [r13], xmm0
	mov	DWORD PTR [r13+8], eax

; 284  : 			}
; 285  : 			if (flips) { if (!tiling(tileX, p.x, flips[0])) return FALSE; }

	mov	ecx, DWORD PTR [rdi+44]
	test	rbx, rbx
	je	SHORT $LN7@get
	mov	r8, rbx
	call	?tiling@@YAHHAEAMAEAH@Z			; tiling
	test	eax, eax
	je	SHORT $LN59@get

; 287  : 			if (flips) { if (!tiling(tileY, p.y, flips[1])) return FALSE; }

	mov	ecx, DWORD PTR [rdi+48]
	lea	r8, QWORD PTR [rbx+4]
	lea	rdx, QWORD PTR [rsi+4]
	call	?tiling@@YAHHAEAMAEAH@Z			; tiling
	test	eax, eax
	je	SHORT $LN59@get

; 289  : 			if (flips) { if (!tiling(tileZ, p.z, flips[2])) return FALSE; }

	mov	ecx, DWORD PTR [rdi+52]
	lea	r8, QWORD PTR [rbx+8]
	lea	rdx, QWORD PTR [rsi+8]
	call	?tiling@@YAHHAEAMAEAH@Z			; tiling
	test	eax, eax
	jne	$LN18@get
$LN59@get:
	xor	eax, eax
	jmp	$LN1@get
$LN7@get:

; 286  : 			else { if (!tiling(tileX, p.x)) return FALSE; }

	call	?tiling@@YAHHAEAM@Z			; tiling
	test	eax, eax
	je	SHORT $LN59@get

; 288  : 			else { if (!tiling(tileY, p.y)) return FALSE; }

	mov	ecx, DWORD PTR [rdi+48]
	lea	rdx, QWORD PTR [rsi+4]
	call	?tiling@@YAHHAEAM@Z			; tiling
	test	eax, eax
	je	SHORT $LN59@get

; 290  : 			else { if (!tiling(tileZ, p.z)) return FALSE; }

	mov	ecx, DWORD PTR [rdi+52]
	lea	rdx, QWORD PTR [rsi+8]
	call	?tiling@@YAHHAEAM@Z			; tiling
	test	eax, eax
	jne	$LN18@get
	jmp	$LN1@get
?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z ENDP ; BerconXYZ::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z
_TEXT	SEGMENT
transform$2$ = 48
$T1 = 48
$T2 = 48
$T3 = 48
$T4 = 64
$T5 = 64
$T6 = 64
$T7 = 80
$T8 = 80
$T9 = 80
$T10 = 144
$T11 = 144
$T12 = 144
transform$13 = 144
inv$14 = 208
transform$1$ = 264
dp$15 = 264
$T16 = 264
__$ArrayPad$ = 320
this$ = 400
sc$ = 408
p$ = 416
basis$ = 424
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z PROC ; BerconXYZ::get, COMDAT

; 401  : int BerconXYZ::get(ShadeContext& sc, Point3& p, Point3* basis) {	

$LN43:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-80]
	sub	rsp, 336				; 00000150H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	cmp	DWORD PTR [rcx], 1
	mov	r14, r9
	mov	rsi, r8
	mov	r15, rdx
	mov	rbx, rcx
	ja	$LN5@get

; 402  : 	/*int* flips = NULL;
; 403  : 	if (mappingType == 0) {
; 404  : 		flips = new int[3];
; 405  : 		flips[0]=0;flips[1]=0;flips[2]=0;
; 406  : 	}*/
; 407  : 
; 408  : 	if ((mappingType == 0 || mappingType == 1) && mode2D) {

	cmp	DWORD PTR [rcx+260], 0
	je	$LN5@get
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h

; 172  :    Matrix3(){ flags = 0; }

	xor	edi, edi
	mov	DWORD PTR inv$14[rbp-208], edi
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 410  : 		Matrix3 transform = variance?random(sc, &inv):tm;

	cmp	BYTE PTR [rcx+116], dil
	je	SHORT $LN16@get
	mov	r8, rdx
	lea	r9, QWORD PTR inv$14[rbp-256]
	lea	rdx, QWORD PTR $T9[rsp]
	call	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
	jmp	SHORT $LN17@get
$LN16@get:
	mov	eax, DWORD PTR [rcx+204]
	vmovups	ymm0, YMMWORD PTR [rcx+156]
	vmovups	xmm1, XMMWORD PTR [rcx+188]
	mov	DWORD PTR $T16[rbp-208], eax
	lea	rax, QWORD PTR $T16[rbp-256]
	vmovups	YMMWORD PTR $T16[rbp-256], ymm0
	vmovups	XMMWORD PTR $T16[rbp-224], xmm1
$LN17@get:
	vmovups	ymm2, YMMWORD PTR [rax]
	vmovups	YMMWORD PTR transform$13[rbp-256], ymm2
	vmovups	xmm3, XMMWORD PTR [rax+32]
	vmovups	XMMWORD PTR transform$13[rbp-224], xmm3
	mov	ecx, DWORD PTR [rax+48]
	mov	DWORD PTR transform$13[rbp-208], ecx

; 411  : 		if (!variance) inv = invNoScaleTm;

	cmp	BYTE PTR [rbx+116], dil
	jne	SHORT $LN8@get
	vmovups	ymm0, YMMWORD PTR [rbx+208]
	vmovups	xmm1, XMMWORD PTR [rbx+240]
	mov	eax, DWORD PTR [rbx+256]
	vmovups	YMMWORD PTR inv$14[rbp-256], ymm0
	vmovups	XMMWORD PTR inv$14[rbp-224], xmm1
	mov	DWORD PTR inv$14[rbp-208], eax
$LN8@get:

; 412  : 		
; 413  : 		if (!get(sc, p, transform)) {return FALSE;}

	mov	DWORD PTR $T8[rbp-208], ecx
	lea	r9, QWORD PTR $T8[rsp]
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], rdi
	vmovups	YMMWORD PTR $T8[rsp], ymm2
	vmovups	XMMWORD PTR $T8[rsp+32], xmm3
	mov	r8, rsi
	mov	rdx, r15
	vzeroupper
	call	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z ; BerconXYZ::get
	test	eax, eax
	jne	SHORT $LN9@get
$LN41@get:
	xor	eax, eax
	jmp	$LN1@get
$LN9@get:

; 414  : 		Point3 dp[3];				

	mov	edi, 3
	lea	rsi, QWORD PTR dp$15[rbp-256]
	npad	4
$LL23@get:
	mov	rcx, rsi
	call	QWORD PTR __imp_??0Point3@@QEAA@XZ
	add	rsi, 12
	sub	rdi, 1
	jne	SHORT $LL23@get

; 415  : 				 
; 416  : 		if (sc.BumpBasisVectors(dp, AXIS_UV, mappingChannel)) {

	mov	rax, QWORD PTR [r15]
	lea	rdx, QWORD PTR dp$15[rbp-256]
	mov	r9d, DWORD PTR [rbx+4]
	xor	r8d, r8d
	mov	rcx, r15
	call	QWORD PTR [rax+320]
	test	eax, eax
	je	SHORT $LN10@get

; 417  : 			basis[0] = VectorTransform(inv, dp[0]);

	lea	r8, QWORD PTR dp$15[rbp-256]
	lea	rdx, QWORD PTR inv$14[rbp-256]
	lea	rcx, QWORD PTR $T6[rsp]
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 418  : 			basis[1] = VectorTransform(inv, dp[1]);

	lea	r8, QWORD PTR dp$15[rbp-244]
	lea	rdx, QWORD PTR inv$14[rbp-256]
	lea	rcx, QWORD PTR $T5[rsp]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r14+8], eax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 419  : 			basis[2] = VectorTransform(inv, dp[0]^dp[1]);

	lea	r8, QWORD PTR dp$15[rbp-244]
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR dp$15[rbp-256]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14+12], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r14+20], eax
	call	QWORD PTR __imp_??TPoint3@@QEBA?AV0@AEBV0@@Z
	mov	r8, rax
$LN40@get:
	lea	rdx, QWORD PTR inv$14[rbp-256]
	lea	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14+24], xmm0
	mov	eax, DWORD PTR [rax+8]

; 420  : 		} else {

	jmp	$LN39@get
$LN10@get:

; 421  : 			sc.DPdUVW(dp, mappingChannel);

	mov	rax, QWORD PTR [r15]
	lea	rdx, QWORD PTR dp$15[rbp-256]
	mov	r8d, DWORD PTR [rbx+4]
	mov	rcx, r15
	call	QWORD PTR [rax+312]

; 422  : 			transform.Invert();

	lea	rcx, QWORD PTR transform$13[rbp-256]
	call	QWORD PTR __imp_?Invert@Matrix3@@QEAAXXZ

; 423  : 			basis[0] = VectorTransform(inv, dp[0]);

	lea	r8, QWORD PTR dp$15[rbp-256]
	lea	rdx, QWORD PTR inv$14[rbp-256]
	lea	rcx, QWORD PTR $T2[rsp]
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 424  : 			basis[1] = VectorTransform(inv, dp[1]);

	lea	r8, QWORD PTR dp$15[rbp-244]
	lea	rdx, QWORD PTR inv$14[rbp-256]
	lea	rcx, QWORD PTR $T1[rsp]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r14+8], eax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 425  : 			basis[2] = VectorTransform(inv, dp[2]);			

	lea	r8, QWORD PTR dp$15[rbp-232]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14+12], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r14+20], eax

; 426  : 		 }
; 427  : 
; 428  : 	} else {

	jmp	$LN40@get
$LN5@get:

; 429  : 		Matrix3 transform = variance?random(sc):tm;

	cmp	BYTE PTR [rcx+116], 0
	je	SHORT $LN18@get
	xor	r9d, r9d
	lea	rdx, QWORD PTR $T12[rbp-256]
	mov	r8, r15
	call	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
	jmp	SHORT $LN19@get
$LN18@get:
	mov	eax, DWORD PTR [rcx+204]
	vmovups	ymm0, YMMWORD PTR [rcx+156]
	vmovups	xmm1, XMMWORD PTR [rcx+188]
	mov	DWORD PTR $T11[rbp-208], eax
	lea	rax, QWORD PTR $T11[rbp-256]
	vmovups	YMMWORD PTR $T11[rbp-256], ymm0
	vmovups	XMMWORD PTR $T11[rbp-224], xmm1
$LN19@get:
	vmovups	ymm0, YMMWORD PTR [rax]
	vmovups	xmm1, XMMWORD PTR [rax+32]
	mov	r12d, DWORD PTR [rax+48]

; 430  : 		if (!get(sc, p, transform)) {return FALSE;}

	lea	r9, QWORD PTR $T7[rsp]
	xor	edi, edi
	mov	DWORD PTR $T7[rbp-208], r12d
	vmovups	YMMWORD PTR transform$1$[rbp-256], ymm0
	vmovups	XMMWORD PTR transform$2$[rsp], xmm1
	vmovups	YMMWORD PTR $T7[rsp], ymm0
	vmovups	XMMWORD PTR $T7[rsp+32], xmm1
	mov	QWORD PTR [rsp+32], rdi
	mov	r8, rsi
	mov	rdx, r15
	mov	rcx, rbx
	vzeroupper
	call	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z ; BerconXYZ::get
	test	eax, eax
	je	$LN41@get

; 431  : 		if (variance)

	cmp	BYTE PTR [rbx+116], dil
	je	SHORT $LN13@get

; 432  : 			getBasis(transform, basis);

	vmovups	ymm0, YMMWORD PTR transform$1$[rbp-256]
	vmovups	xmm1, XMMWORD PTR transform$2$[rsp]
	vmovups	YMMWORD PTR $T10[rbp-256], ymm0
	vmovups	XMMWORD PTR $T10[rbp-224], xmm1
	mov	DWORD PTR $T10[rbp-208], r12d
	lea	rdx, QWORD PTR $T10[rbp-256]
	mov	r8, r14
	mov	rcx, rbx
	vzeroupper
	call	?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z ; BerconXYZ::getBasis

; 433  : 		else

	jmp	SHORT $LN33@get
$LN13@get:

; 434  : 			for (int i=0; i<3; i++)
; 435  : 				basis[i] = b[i];

	vmovsd	xmm0, QWORD PTR [rbx+120]
	vmovsd	QWORD PTR [r14], xmm0
	mov	eax, DWORD PTR [rbx+128]
	mov	DWORD PTR [r14+8], eax
	vmovsd	xmm0, QWORD PTR [rbx+132]
	vmovsd	QWORD PTR [r14+12], xmm0
	mov	eax, DWORD PTR [rbx+140]
	mov	DWORD PTR [r14+20], eax
	vmovsd	xmm0, QWORD PTR [rbx+144]
	vmovsd	QWORD PTR [r14+24], xmm0
	mov	eax, DWORD PTR [rbx+152]
$LN39@get:
	mov	DWORD PTR [r14+32], eax
$LN33@get:

; 436  : 	}
; 437  : 
; 438  : 	/*if (flips) {
; 439  : 		if (flips[0]) basis[0] *= -1;
; 440  : 		if (flips[1]) basis[1] *= -1;
; 441  : 		if (flips[2]) basis[2] *= -1;
; 442  : 	}
; 443  : 	delete[] flips;*/
; 444  : 
; 445  : 	return TRUE;

	mov	eax, 1
$LN1@get:

; 446  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 336				; 00000150H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@PEAV3@@Z ENDP ; BerconXYZ::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
$T3 = 112
this$ = 192
sc$ = 200
p$ = 208
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z PROC ; BerconXYZ::get, COMDAT

; 351  : int BerconXYZ::get(ShadeContext& sc, Point3& p) {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H

; 352  : 	return get(sc, p, variance?random(sc):tm);

	cmp	BYTE PTR [rcx+116], 0
	mov	rsi, r8
	mov	rdi, rdx
	mov	rbx, rcx
	je	SHORT $LN3@get
	mov	r8, rdx
	xor	r9d, r9d
	lea	rdx, QWORD PTR $T2[rsp]
	call	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
	jmp	SHORT $LN4@get
$LN3@get:
	mov	eax, DWORD PTR [rcx+204]
	vmovups	ymm0, YMMWORD PTR [rcx+156]
	vmovups	xmm1, XMMWORD PTR [rcx+188]
	mov	DWORD PTR $T1[rsp+48], eax
	lea	rax, QWORD PTR $T1[rsp]
	vmovups	YMMWORD PTR $T1[rsp], ymm0
	vmovups	XMMWORD PTR $T1[rsp+32], xmm1
$LN4@get:
	vmovups	ymm0, YMMWORD PTR [rax]
	vmovups	YMMWORD PTR $T3[rsp], ymm0
	vmovups	xmm1, XMMWORD PTR [rax+32]
	vmovups	XMMWORD PTR $T3[rsp+32], xmm1
	mov	eax, DWORD PTR [rax+48]
	lea	r9, QWORD PTR $T3[rsp]
	mov	DWORD PTR $T3[rsp+48], eax
	mov	r8, rsi
	mov	QWORD PTR [rsp+32], 0
	mov	rdx, rdi
	mov	rcx, rbx
	vzeroupper
	call	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@VMatrix3@@PEAH@Z ; BerconXYZ::get

; 353  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@@Z ENDP ; BerconXYZ::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z
_TEXT	SEGMENT
transform$3$ = 64
transform$2$ = 72
$T1 = 72
$T2 = 72
$T3 = 72
$T4 = 88
$T5 = 88
$T6 = 88
$T7 = 112
$T8 = 112
$T9 = 112
$T10 = 176
$T11 = 176
$T12 = 176
transform$13 = 176
inv$14 = 240
transform$1$ = 296
dp$15 = 296
$T16 = 296
__$ArrayPad$ = 352
this$ = 448
sc$ = 456
p$ = 464
dpdx$ = 472
dpdy$ = 480
basis$ = 488
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z PROC ; BerconXYZ::get, COMDAT

; 355  : int BerconXYZ::get(ShadeContext& sc, Point3& p, Point3& dpdx, Point3& dpdy, Point3* basis) {

$LN43:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-120]
	sub	rsp, 376				; 00000178H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	cmp	DWORD PTR [rcx], 1
	mov	r12, r9
	mov	r14, QWORD PTR basis$[rbp-256]
	mov	rsi, r8
	mov	r13, QWORD PTR dpdy$[rbp-256]
	mov	r15, rdx
	mov	rbx, rcx
	ja	$LN5@get

; 356  : 	/*int* flips = NULL;
; 357  : 	if (mappingType == 0) {
; 358  : 		flips = new int[3];
; 359  : 		flips[0]=0;flips[1]=0;flips[2]=0;
; 360  : 	}*/
; 361  : 
; 362  : 	if ((mappingType == 0 || mappingType == 1) && mode2D) {

	cmp	DWORD PTR [rcx+260], 0
	je	$LN5@get
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h

; 172  :    Matrix3(){ flags = 0; }

	xor	edi, edi
	mov	DWORD PTR inv$14[rbp-208], edi
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 364  : 		Matrix3 transform = variance?random(sc, &inv):tm;

	cmp	BYTE PTR [rcx+116], dil
	je	SHORT $LN16@get
	mov	r8, rdx
	lea	r9, QWORD PTR inv$14[rbp-256]
	lea	rdx, QWORD PTR $T9[rsp]
	call	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
	jmp	SHORT $LN17@get
$LN16@get:
	mov	eax, DWORD PTR [rcx+204]
	vmovups	ymm0, YMMWORD PTR [rcx+156]
	vmovups	xmm1, XMMWORD PTR [rcx+188]
	mov	DWORD PTR $T16[rbp-208], eax
	lea	rax, QWORD PTR $T16[rbp-256]
	vmovups	YMMWORD PTR $T16[rbp-256], ymm0
	vmovups	XMMWORD PTR $T16[rbp-224], xmm1
$LN17@get:
	vmovups	ymm2, YMMWORD PTR [rax]
	vmovups	YMMWORD PTR transform$13[rbp-256], ymm2
	vmovups	xmm3, XMMWORD PTR [rax+32]
	vmovups	XMMWORD PTR transform$13[rbp-224], xmm3
	mov	ecx, DWORD PTR [rax+48]
	mov	DWORD PTR transform$13[rbp-208], ecx

; 365  : 		if (!variance) inv = invNoScaleTm;

	cmp	BYTE PTR [rbx+116], dil
	jne	SHORT $LN8@get
	vmovups	ymm0, YMMWORD PTR [rbx+208]
	vmovups	xmm1, XMMWORD PTR [rbx+240]
	mov	eax, DWORD PTR [rbx+256]
	vmovups	YMMWORD PTR inv$14[rbp-256], ymm0
	vmovups	XMMWORD PTR inv$14[rbp-224], xmm1
	mov	DWORD PTR inv$14[rbp-208], eax
$LN8@get:

; 366  : 		
; 367  : 		if (!get(sc, p, dpdx, dpdy, transform)) {return FALSE;}

	mov	QWORD PTR [rsp+48], rdi
	lea	rax, QWORD PTR $T8[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	r9, r12
	mov	DWORD PTR $T8[rbp-208], ecx
	mov	r8, rsi
	mov	QWORD PTR [rsp+32], r13
	mov	rdx, r15
	vmovups	YMMWORD PTR $T8[rsp], ymm2
	vmovups	XMMWORD PTR $T8[rbp-224], xmm3
	mov	rcx, rbx
	vzeroupper
	call	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z ; BerconXYZ::get
	test	eax, eax
	jne	SHORT $LN9@get
$LN41@get:
	xor	eax, eax
	jmp	$LN1@get
$LN9@get:

; 368  : 		Point3 dp[3];				

	mov	edi, 3
	lea	rsi, QWORD PTR dp$15[rbp-256]
	npad	8
$LL23@get:
	mov	rcx, rsi
	call	QWORD PTR __imp_??0Point3@@QEAA@XZ
	add	rsi, 12
	sub	rdi, 1
	jne	SHORT $LL23@get

; 369  : 				 
; 370  : 		if (sc.BumpBasisVectors(dp, AXIS_UV, mappingChannel)) {

	mov	rax, QWORD PTR [r15]
	lea	rdx, QWORD PTR dp$15[rbp-256]
	mov	r9d, DWORD PTR [rbx+4]
	xor	r8d, r8d
	mov	rcx, r15
	call	QWORD PTR [rax+320]
	test	eax, eax
	je	SHORT $LN10@get

; 371  : 			basis[0] = VectorTransform(inv, dp[0]);

	lea	r8, QWORD PTR dp$15[rbp-256]
	lea	rdx, QWORD PTR inv$14[rbp-256]
	lea	rcx, QWORD PTR $T6[rsp]
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 372  : 			basis[1] = VectorTransform(inv, dp[1]);

	lea	r8, QWORD PTR dp$15[rbp-244]
	lea	rdx, QWORD PTR inv$14[rbp-256]
	lea	rcx, QWORD PTR $T5[rsp]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r14+8], eax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 373  : 			basis[2] = VectorTransform(inv, dp[0]^dp[1]);

	lea	r8, QWORD PTR dp$15[rbp-244]
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR dp$15[rbp-256]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14+12], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r14+20], eax
	call	QWORD PTR __imp_??TPoint3@@QEBA?AV0@AEBV0@@Z
	mov	r8, rax
$LN40@get:
	lea	rdx, QWORD PTR inv$14[rbp-256]
	lea	rcx, QWORD PTR $T3[rsp]
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14+24], xmm0
	mov	eax, DWORD PTR [rax+8]

; 374  : 		} else {

	jmp	$LN39@get
$LN10@get:

; 375  : 			sc.DPdUVW(dp, mappingChannel);

	mov	rax, QWORD PTR [r15]
	lea	rdx, QWORD PTR dp$15[rbp-256]
	mov	r8d, DWORD PTR [rbx+4]
	mov	rcx, r15
	call	QWORD PTR [rax+312]

; 376  : 			transform.Invert();

	lea	rcx, QWORD PTR transform$13[rbp-256]
	call	QWORD PTR __imp_?Invert@Matrix3@@QEAAXXZ

; 377  : 			basis[0] = VectorTransform(inv, dp[0]);

	lea	r8, QWORD PTR dp$15[rbp-256]
	lea	rdx, QWORD PTR inv$14[rbp-256]
	lea	rcx, QWORD PTR $T2[rsp]
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 378  : 			basis[1] = VectorTransform(inv, dp[1]);

	lea	r8, QWORD PTR dp$15[rbp-244]
	lea	rdx, QWORD PTR inv$14[rbp-256]
	lea	rcx, QWORD PTR $T1[rsp]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r14+8], eax
	call	QWORD PTR __imp_?VectorTransform@@YA?AVPoint3@@AEBVMatrix3@@AEBV1@@Z

; 379  : 			basis[2] = VectorTransform(inv, dp[2]);			

	lea	r8, QWORD PTR dp$15[rbp-232]
	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [r14+12], xmm0
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [r14+20], eax

; 380  : 		 }		
; 381  : 	} else {	

	jmp	$LN40@get
$LN5@get:

; 382  : 		Matrix3 transform = variance?random(sc):tm;

	cmp	BYTE PTR [rcx+116], 0
	je	SHORT $LN18@get
	xor	r9d, r9d
	lea	rdx, QWORD PTR $T12[rbp-256]
	mov	r8, r15
	call	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
	jmp	SHORT $LN19@get
$LN18@get:
	mov	eax, DWORD PTR [rcx+204]
	vmovups	ymm0, YMMWORD PTR [rcx+156]
	vmovups	xmm1, XMMWORD PTR [rcx+188]
	mov	DWORD PTR $T11[rbp-208], eax
	lea	rax, QWORD PTR $T11[rbp-256]
	vmovups	YMMWORD PTR $T11[rbp-256], ymm0
	vmovups	XMMWORD PTR $T11[rbp-224], xmm1
$LN19@get:
	vmovups	ymm0, YMMWORD PTR [rax]
	vmovups	xmm1, XMMWORD PTR [rax+32]
	mov	ecx, DWORD PTR [rax+48]

; 383  : 		if (!get(sc, p, dpdx, dpdy, transform)) {return FALSE;}

	xor	edi, edi
	mov	QWORD PTR [rsp+48], rdi
	lea	rax, QWORD PTR $T7[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	r9, r12
	mov	DWORD PTR transform$3$[rsp], ecx
	mov	r8, rsi
	mov	DWORD PTR $T7[rbp-208], ecx
	mov	rdx, r15
	mov	QWORD PTR [rsp+32], r13
	mov	rcx, rbx
	vmovups	YMMWORD PTR transform$1$[rbp-256], ymm0
	vmovups	XMMWORD PTR transform$2$[rsp], xmm1
	vmovups	YMMWORD PTR $T7[rsp], ymm0
	vmovups	XMMWORD PTR $T7[rbp-224], xmm1
	vzeroupper
	call	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z ; BerconXYZ::get
	test	eax, eax
	je	$LN41@get

; 384  : 		if (variance)

	cmp	BYTE PTR [rbx+116], dil
	je	SHORT $LN13@get

; 385  : 			getBasis(transform, basis);

	vmovups	ymm0, YMMWORD PTR transform$1$[rbp-256]
	vmovups	xmm1, XMMWORD PTR transform$2$[rsp]
	mov	eax, DWORD PTR transform$3$[rsp]
	lea	rdx, QWORD PTR $T10[rbp-256]
	vmovups	YMMWORD PTR $T10[rbp-256], ymm0
	vmovups	XMMWORD PTR $T10[rbp-224], xmm1
	mov	DWORD PTR $T10[rbp-208], eax
	mov	r8, r14
	mov	rcx, rbx
	vzeroupper
	call	?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z ; BerconXYZ::getBasis

; 386  : 		else

	jmp	SHORT $LN33@get
$LN13@get:

; 387  : 			for (int i=0; i<3; i++)
; 388  : 				basis[i] = b[i];

	vmovsd	xmm0, QWORD PTR [rbx+120]
	vmovsd	QWORD PTR [r14], xmm0
	mov	eax, DWORD PTR [rbx+128]
	mov	DWORD PTR [r14+8], eax
	vmovsd	xmm0, QWORD PTR [rbx+132]
	vmovsd	QWORD PTR [r14+12], xmm0
	mov	eax, DWORD PTR [rbx+140]
	mov	DWORD PTR [r14+20], eax
	vmovsd	xmm0, QWORD PTR [rbx+144]
	vmovsd	QWORD PTR [r14+24], xmm0
	mov	eax, DWORD PTR [rbx+152]
$LN39@get:
	mov	DWORD PTR [r14+32], eax
$LN33@get:

; 389  : 	}
; 390  : 
; 391  : 	/*if (flips) {
; 392  : 		if (flips[0]) basis[0] *= -1;
; 393  : 		if (flips[1]) basis[1] *= -1;
; 394  : 		if (flips[2]) basis[2] *= -1;
; 395  : 	}
; 396  : 	delete[] flips;*/
; 397  : 
; 398  : 	return TRUE;

	mov	eax, 1
$LN1@get:

; 399  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 376				; 00000178H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11PEAV3@@Z ENDP ; BerconXYZ::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z
_TEXT	SEGMENT
$T1 = 64
$T2 = 64
$T3 = 128
this$ = 208
sc$ = 216
p$ = 224
dpdx$ = 232
dpdy$ = 240
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z PROC ; BerconXYZ::get, COMDAT

; 347  : int BerconXYZ::get(ShadeContext& sc, Point3& p, Point3& dpdx, Point3& dpdy) {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 348  : 	return get(sc, p, dpdx, dpdy, variance?random(sc):tm);

	cmp	BYTE PTR [rcx+116], 0
	mov	rsi, r9
	mov	rbp, r8
	mov	rdi, rdx
	mov	rbx, rcx
	je	SHORT $LN3@get
	mov	r8, rdx
	xor	r9d, r9d
	lea	rdx, QWORD PTR $T2[rsp]
	call	?random@BerconXYZ@@AEAA?AVMatrix3@@AEAVShadeContext@@PEAV2@@Z ; BerconXYZ::random
	jmp	SHORT $LN4@get
$LN3@get:
	mov	eax, DWORD PTR [rcx+204]
	vmovups	ymm0, YMMWORD PTR [rcx+156]
	vmovups	xmm1, XMMWORD PTR [rcx+188]
	mov	DWORD PTR $T1[rsp+48], eax
	lea	rax, QWORD PTR $T1[rsp]
	vmovups	YMMWORD PTR $T1[rsp], ymm0
	vmovups	XMMWORD PTR $T1[rsp+32], xmm1
$LN4@get:
	vmovups	ymm0, YMMWORD PTR [rax]
	vmovups	YMMWORD PTR $T3[rsp], ymm0
	vmovups	xmm1, XMMWORD PTR [rax+32]
	mov	QWORD PTR [rsp+48], 0
	mov	r9, rsi
	vmovups	XMMWORD PTR $T3[rsp+32], xmm1
	mov	eax, DWORD PTR [rax+48]
	mov	r8, rbp
	mov	DWORD PTR $T3[rsp+48], eax
	mov	rdx, rdi
	lea	rax, QWORD PTR $T3[rsp]
	mov	rcx, rbx
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR dpdy$[rsp]
	mov	QWORD PTR [rsp+32], rax
	vzeroupper
	call	?get@BerconXYZ@@AEAAHAEAVShadeContext@@AEAVPoint3@@11VMatrix3@@PEAH@Z ; BerconXYZ::get

; 349  : }

	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?get@BerconXYZ@@QEAAHAEAVShadeContext@@AEAVPoint3@@11@Z ENDP ; BerconXYZ::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.h
;	COMDAT ?isRealworld@BerconXYZ@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?isRealworld@BerconXYZ@@QEAAHXZ PROC			; BerconXYZ::isRealworld, COMDAT

; 356  : 	int isRealworld() { return mappingType == 0 || mappingType == 4 ? 0 : 1; }

	test	DWORD PTR [rcx], -5			; fffffffbH
	mov	eax, 0
	setne	al
	ret	0
?isRealworld@BerconXYZ@@QEAAHXZ ENDP			; BerconXYZ::isRealworld
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\interval.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z
_TEXT	SEGMENT
this$ = 80
pblock$ = 88
ivalid$ = 96
type$ = 104
x$ = 112
y$ = 120
z$ = 128
?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z PROC ; BerconXYZ::reset, COMDAT

; 29   : void BerconXYZ::reset(IParamBlock2* pblock, Interval& ivalid, int type, int x, int y, int z) {

$LN8:

; 30   : 	if (!pblock) return;

	test	rdx, rdx
	je	$LN6@reset
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR [rsp+80], rbx

; 29   : void BerconXYZ::reset(IParamBlock2* pblock, Interval& ivalid, int type, int x, int y, int z) {

	mov	ebp, r9d
	mov	QWORD PTR [rsp+88], r14
	mov	rsi, r8
	vmovaps	XMMWORD PTR [rsp+48], xmm6
	mov	rdi, rdx

; 31   : 	//if (!pblock->GetMap()) return;
; 32   : 
; 33   : 	TimeValue t = GetCOREInterface()->GetTime();

	call	QWORD PTR __imp_?GetCOREInterface@@YAPEAVInterface@@XZ
	mov	rcx, rax
	mov	r10, QWORD PTR [rax]
	call	QWORD PTR [r10+1448]

; 34   : 
; 35   : 	pblockSetValue(xyz_offset_x, 0.f);	

	mov	r10, QWORD PTR [rdi]
	xor	r14d, r14d
	mov	edx, 2
	mov	DWORD PTR [rsp+32], r14d
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, eax
	mov	rcx, rdi
	mov	ebx, eax
	call	QWORD PTR [r10+1584]

; 36   : 	pblockSetValue(xyz_offset_y, 0.f);	

	mov	r9, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+3]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [r9+1584]

; 37   : 	pblockSetValue(xyz_offset_z, 0.f);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+4]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 38   : 	pblockSetValue(xyz_size_x, 1.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+5]
	vmovss	xmm6, DWORD PTR __real@3f800000
	vmovaps	xmm3, xmm6
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 39   : 	pblockSetValue(xyz_size_y, 1.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+6]
	vmovaps	xmm3, xmm6
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 40   : 	pblockSetValue(xyz_size_z, 1.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+7]
	vmovaps	xmm3, xmm6
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 41   : 	pblockSetValue(xyz_angle_x, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+8]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 42   : 	pblockSetValue(xyz_angle_y, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+9]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 43   : 	pblockSetValue(xyz_angle_z, 0.f);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+10]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 44   : 
; 45   : 	pblockSetValue(xyz_offset_x2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+14]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 46   : 	pblockSetValue(xyz_offset_y2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+15]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 47   : 	pblockSetValue(xyz_offset_z2, 0.f);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+16]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 48   : 	pblockSetValue(xyz_size_x2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+17]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 49   : 	pblockSetValue(xyz_size_y2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+18]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 50   : 	pblockSetValue(xyz_size_z2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+19]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 51   : 	pblockSetValue(xyz_angle_x2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+20]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 52   : 	pblockSetValue(xyz_angle_y2, 0.f);	

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+21]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 53   : 	pblockSetValue(xyz_angle_z2, 0.f);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+22]
	vxorps	xmm3, xmm3, xmm3
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]

; 54   : 
; 55   : 	pblockSetValue(xyz_tile_x, x);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+11]
	mov	r9d, DWORD PTR x$[rsp]
	mov	r8d, ebx
	mov	rcx, rdi
	mov	DWORD PTR [rsp+32], r14d
	call	QWORD PTR [rax+1576]

; 56   : 	pblockSetValue(xyz_tile_y, y);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+12]
	mov	r9d, DWORD PTR y$[rsp]
	mov	r8d, ebx
	mov	rcx, rdi
	mov	DWORD PTR [rsp+32], r14d
	call	QWORD PTR [rax+1576]

; 57   : 	pblockSetValue(xyz_tile_z, z);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+13]
	mov	r9d, DWORD PTR z$[rsp]
	mov	r8d, ebx
	mov	rcx, rdi
	mov	DWORD PTR [rsp+32], r14d
	call	QWORD PTR [rax+1576]

; 58   : 
; 59   : 	pblockSetValue(xyz_seed, 12345);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+23]
	mov	r9d, 12345				; 00003039H
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 60   : 	pblockSetValue(xyz_rand_obj, TRUE);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+25]
	lea	r9d, QWORD PTR [r14+1]
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 61   : 	pblockSetValue(xyz_rand_mat, FALSE);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+24]
	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 62   : 	pblockSetValue(xyz_rand_par, FALSE);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+26]
	xor	r9d, r9d
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 63   : 
; 64   : 	pblockSetValue(xyz_map, type);

	mov	rax, QWORD PTR [rdi]
	xor	edx, edx
	mov	r9d, ebp
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 65   : 	pblockSetValue(xyz_chan, 1);

	mov	rax, QWORD PTR [rdi]
	mov	edx, 1
	mov	r9d, edx
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 66   : 
; 67   : 	pblockSetValue(xyz_lock, TRUE);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+27]
	lea	r9d, QWORD PTR [r14+1]
	mov	DWORD PTR [rsp+32], r14d
	mov	r8d, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+1576]

; 68   : 
; 69   : 	pblockSetValue(xyz_filtering, 1.f);

	mov	rax, QWORD PTR [rdi]
	lea	edx, QWORD PTR [r14+28]
	vmovaps	xmm3, xmm6
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], r14d
	mov	rcx, rdi
	call	QWORD PTR [rax+1584]
	vmovaps	xmm6, XMMWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]

; 72   : }

	mov	rbp, QWORD PTR [rsp+96]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\interval.h

; 118  : 		void SetEmpty() { start = TIME_NegInfinity; end = TIME_NegInfinity; }

	mov	DWORD PTR [rsi], -2147483648		; ffffffff80000000H
	mov	DWORD PTR [rsi+4], -2147483648		; ffffffff80000000H
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 72   : }

	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
$LN6@reset:
	ret	0
?reset@BerconXYZ@@QEAAXPEAVIParamBlock2@@AEAVInterval@@HHHH@Z ENDP ; BerconXYZ::reset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?update@BerconXYZ@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 48
this$ = 128
?update@BerconXYZ@@QEAAXXZ PROC				; BerconXYZ::update, COMDAT

; 167  : void BerconXYZ::update() {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 112				; 00000070H

; 168  : 	tm.IdentityMatrix();

	lea	rbx, QWORD PTR [rcx+156]
	mov	rdi, rcx
	mov	rcx, rbx
	call	QWORD PTR __imp_?IdentityMatrix@Matrix3@@QEAAXXZ
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	xmm0, DWORD PTR [rdi+8]
	vmovss	xmm1, DWORD PTR [rdi+12]
	vmovss	DWORD PTR $T2[rsp], xmm0
	vmovss	xmm0, DWORD PTR [rdi+16]
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 169  : 	tm.Translate(Point3(offX, offY, offZ));

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rbx
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR $T2[rsp+8], xmm0
	vmovss	DWORD PTR $T2[rsp+4], xmm1
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp

; 169  : 	tm.Translate(Point3(offX, offY, offZ));

	call	QWORD PTR __imp_?Translate@Matrix3@@QEAAXAEBVPoint3@@@Z

; 170  :  	tm.RotateX(angX);

	vmovss	xmm1, DWORD PTR [rdi+32]
	mov	rcx, rbx
	call	QWORD PTR __imp_?RotateX@Matrix3@@QEAAXM@Z

; 171  : 	tm.RotateY(angY);

	vmovss	xmm1, DWORD PTR [rdi+36]
	mov	rcx, rbx
	call	QWORD PTR __imp_?RotateY@Matrix3@@QEAAXM@Z

; 172  : 	tm.RotateZ(angZ);

	vmovss	xmm1, DWORD PTR [rdi+40]
	mov	rcx, rbx
	call	QWORD PTR __imp_?RotateZ@Matrix3@@QEAAXM@Z

; 173  : 
; 174  : 	invNoScaleTm = tm;

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	xmm1, XMMWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rbx+48]
	lea	rcx, QWORD PTR [rdi+208]
	vmovups	YMMWORD PTR [rcx], ymm0
	vmovups	XMMWORD PTR [rcx+32], xmm1
	mov	DWORD PTR [rcx+48], eax
	vzeroupper

; 175  : 	invNoScaleTm.Invert();

	call	QWORD PTR __imp_?Invert@Matrix3@@QEAAXXZ

; 176  : 
; 177  : 	tm.Scale(Point3(1.f/sizeX, 1.f/sizeY, 1.f/sizeZ));

	vmovss	xmm2, DWORD PTR __real@3f800000
	vdivss	xmm0, xmm2, DWORD PTR [rdi+20]
	vdivss	xmm1, xmm2, DWORD PTR [rdi+24]
	vmovss	DWORD PTR $T1[rsp], xmm0
	vdivss	xmm0, xmm2, DWORD PTR [rdi+28]
	xor	r8d, r8d
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	vmovss	DWORD PTR $T1[rsp+8], xmm0
	vmovss	DWORD PTR $T1[rsp+4], xmm1
	call	QWORD PTR __imp_?Scale@Matrix3@@QEAAXAEBVPoint3@@H@Z

; 178  : 
; 179  : 	getBasis(tm, b);

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	xmm1, XMMWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rbx+48]
	lea	r8, QWORD PTR [rdi+120]
	vmovups	YMMWORD PTR $T3[rsp], ymm0
	vmovups	XMMWORD PTR $T3[rsp+32], xmm1
	mov	DWORD PTR $T3[rsp+48], eax
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rdi
	vzeroupper
	call	?getBasis@BerconXYZ@@AEAAXVMatrix3@@PEAVPoint3@@@Z ; BerconXYZ::getBasis

; 180  : 	
; 181  : 	variance = NZERO(offX2) || NZERO(offY2) || NZERO(offZ2) || NZERO(sizeX2) || NZERO(sizeY2) || NZERO(sizeZ2) || NZERO(angX2) || NZERO(angY2) || NZERO(angZ2);

	vmovss	xmm0, DWORD PTR [rdi+56]
	vmovss	xmm1, DWORD PTR __real@38d1b717
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+60]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+64]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+68]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+72]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+76]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+80]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+84]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	vmovss	xmm0, DWORD PTR [rdi+88]
	vcomiss	xmm0, xmm1
	ja	SHORT $LN3@update
	mov	BYTE PTR [rdi+116], 0

; 182  : }

	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
$LN3@update:

; 180  : 	
; 181  : 	variance = NZERO(offX2) || NZERO(offY2) || NZERO(offZ2) || NZERO(sizeX2) || NZERO(sizeY2) || NZERO(sizeZ2) || NZERO(angX2) || NZERO(angY2) || NZERO(angZ2);

	mov	BYTE PTR [rdi+116], 1

; 182  : }

	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
?update@BerconXYZ@@QEAAXXZ ENDP				; BerconXYZ::update
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z
_TEXT	SEGMENT
this$ = 112
pblock$ = 120
t$ = 128
ivalid$ = 136
?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z PROC ; BerconXYZ::update, COMDAT

; 74   : void BerconXYZ::update(IParamBlock2* pblock, TimeValue t, Interval& ivalid) {

$LN6:

; 75   : 	if (!pblock) return;

	test	rdx, rdx
	je	$LN4@update

; 74   : void BerconXYZ::update(IParamBlock2* pblock, TimeValue t, Interval& ivalid) {

	mov	r11, rsp
	mov	QWORD PTR [r11+32], r9
	mov	DWORD PTR [r11+24], r8d
	push	rbx
	push	rdi
	push	r12
	push	r13
	sub	rsp, 72					; 00000048H

; 76   : 	//if (!pblock->GetMap()) return;
; 77   : 
; 78   : 	pblockGetValue(xyz_offset_x, offX);	

	mov	rax, QWORD PTR [rdx]
	mov	rdi, r9
	mov	QWORD PTR [r11+8], rbp
	lea	r9, QWORD PTR [rcx+8]
	mov	QWORD PTR [r11-40], rsi
	mov	r12, rdx
	mov	r13, rcx
	mov	QWORD PTR [r11-48], r14
	xor	esi, esi
	mov	QWORD PTR [r11-56], r15
	mov	DWORD PTR [rsp+40], esi
	mov	edx, 2
	mov	rcx, r12
	mov	QWORD PTR [r11-72], rdi
	mov	ebx, r8d
	call	QWORD PTR [rax+1712]

; 79   : 	pblockGetValue(xyz_offset_y, offY);	

	mov	rax, QWORD PTR [r12]
	lea	r9, QWORD PTR [r13+12]
	lea	edx, QWORD PTR [rsi+3]
	mov	DWORD PTR [rsp+40], esi
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 80   : 	pblockGetValue(xyz_offset_z, offZ);

	mov	rax, QWORD PTR [r12]
	lea	r9, QWORD PTR [r13+16]
	lea	edx, QWORD PTR [rsi+4]
	mov	DWORD PTR [rsp+40], esi
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 81   : 	pblockGetValue(xyz_size_x, sizeX);	

	mov	rax, QWORD PTR [r12]
	lea	r9, QWORD PTR [r13+20]
	lea	edx, QWORD PTR [rsi+5]
	mov	DWORD PTR [rsp+40], esi
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 82   : 	pblockGetValue(xyz_size_y, sizeY);	

	mov	rax, QWORD PTR [r12]
	lea	r9, QWORD PTR [r13+24]
	lea	edx, QWORD PTR [rsi+6]
	mov	DWORD PTR [rsp+40], esi
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 83   : 	pblockGetValue(xyz_size_z, sizeZ);	

	mov	rax, QWORD PTR [r12]
	lea	r9, QWORD PTR [r13+28]
	lea	edx, QWORD PTR [rsi+7]
	mov	DWORD PTR [rsp+40], esi
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 84   : 	pblockGetValue(xyz_angle_x, angX);	

	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+8]
	mov	DWORD PTR [rsp+40], esi
	lea	r9, QWORD PTR [r13+32]
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 85   : 	pblockGetValue(xyz_angle_y, angY);	

	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+9]
	mov	DWORD PTR [rsp+40], esi
	lea	r9, QWORD PTR [r13+36]
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 86   : 	pblockGetValue(xyz_angle_z, angZ);

	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+10]
	mov	DWORD PTR [rsp+40], esi
	lea	r9, QWORD PTR [r13+40]
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 87   : 
; 88   : 	pblockGetValue(xyz_offset_x2, offX2);	

	mov	rax, QWORD PTR [r12]
	lea	r9, QWORD PTR [r13+56]
	mov	DWORD PTR [rsp+40], esi
	lea	edx, QWORD PTR [rsi+14]
	mov	QWORD PTR [rsp+32], rdi
	mov	r8d, ebx
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 89   : 	pblockGetValue(xyz_offset_y2, offY2);	

	mov	rax, QWORD PTR [r12]
	lea	r9, QWORD PTR [r13+60]
	lea	edx, QWORD PTR [rsi+15]
	mov	DWORD PTR [rsp+40], esi
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 90   : 	pblockGetValue(xyz_offset_z2, offZ2);

	mov	rax, QWORD PTR [r12]
	lea	r9, QWORD PTR [r13+64]
	lea	edx, QWORD PTR [rsi+16]
	mov	DWORD PTR [rsp+40], esi
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 91   : 	pblockGetValue(xyz_size_x2, sizeX2);	

	mov	rax, QWORD PTR [r12]
	lea	r9, QWORD PTR [r13+68]
	lea	edx, QWORD PTR [rsi+17]
	mov	DWORD PTR [rsp+40], esi
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 92   : 	pblockGetValue(xyz_size_y2, sizeY2);	

	mov	rax, QWORD PTR [r12]
	lea	r9, QWORD PTR [r13+72]
	lea	edx, QWORD PTR [rsi+18]
	mov	DWORD PTR [rsp+40], esi
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 93   : 	pblockGetValue(xyz_size_z2, sizeZ2);	

	mov	rax, QWORD PTR [r12]
	lea	r9, QWORD PTR [r13+76]
	lea	edx, QWORD PTR [rsi+19]
	mov	DWORD PTR [rsp+40], esi
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 94   : 	pblockGetValue(xyz_angle_x2, angX2);	

	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+20]
	mov	DWORD PTR [rsp+40], esi
	lea	r9, QWORD PTR [r13+80]
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rdi
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 95   : 	pblockGetValue(xyz_angle_y2, angY2);	

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rsi+21]
	mov	rax, QWORD PTR [r12]
	lea	r9, QWORD PTR [r13+84]
	mov	DWORD PTR [rsp+40], esi
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 96   : 	pblockGetValue(xyz_angle_z2, angZ2);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	edx, QWORD PTR [rsi+22]
	mov	rax, QWORD PTR [r12]
	lea	r9, QWORD PTR [r13+88]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], esi
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 97   : 
; 98   : 	pblockGetValue(xyz_tile_x, tileX);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	r9, QWORD PTR [r13+44]
	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+11]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], esi
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r12
	call	QWORD PTR [rax+1704]

; 99   : 	pblockGetValue(xyz_tile_y, tileY);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	r9, QWORD PTR [r13+48]
	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+12]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], esi
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r12
	call	QWORD PTR [rax+1704]

; 100  : 	pblockGetValue(xyz_tile_z, tileZ);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	r9, QWORD PTR [r13+52]
	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+13]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], esi
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r12
	call	QWORD PTR [rax+1704]

; 101  : 
; 102  : 	pblockGetValue(xyz_seed, p_seed);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	r9, QWORD PTR [r13+92]
	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+23]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], esi
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r12
	call	QWORD PTR [rax+1704]

; 103  : 	pblockGetValue(xyz_rand_obj, p_randObj);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	r9, QWORD PTR [r13+96]
	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+25]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], esi
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r12
	call	QWORD PTR [rax+1704]

; 104  : 	pblockGetValue(xyz_rand_mat, p_randMat);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	r9, QWORD PTR [r13+100]
	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+24]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], esi
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r12
	call	QWORD PTR [rax+1704]

; 105  : 	pblockGetValue(xyz_rand_par, p_randPar);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	r9, QWORD PTR [r13+104]
	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+26]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], esi
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r12
	call	QWORD PTR [rax+1704]

; 106  : 
; 107  : 	pblockGetValue(xyz_map, mappingType);

	mov	rcx, QWORD PTR ivalid$[rsp]
	xor	edx, edx
	mov	rax, QWORD PTR [r12]
	mov	r9, r13
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], edx
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r12
	call	QWORD PTR [rax+1704]

; 108  : 	pblockGetValue(xyz_chan, mappingChannel);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	r9, QWORD PTR [r13+4]
	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+1]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], esi
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r12
	call	QWORD PTR [rax+1704]

; 109  : 
; 110  : 	pblockGetValue(xyz_lock, lock);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	r9, QWORD PTR [r13+112]
	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+27]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], esi
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r12
	call	QWORD PTR [rax+1704]

; 111  : 
; 112  : 	pblockGetValue(xyz_filtering, filtering);

	mov	rcx, QWORD PTR ivalid$[rsp]
	lea	r9, QWORD PTR [r13+108]
	mov	rax, QWORD PTR [r12]
	lea	edx, QWORD PTR [rsi+28]
	mov	r8d, DWORD PTR t$[rsp]
	mov	DWORD PTR [rsp+40], esi
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r12
	call	QWORD PTR [rax+1712]

; 113  : 	
; 114  : 
; 115  : 	angX *= DEG_TO_RAD; angY *= DEG_TO_RAD; angZ *= DEG_TO_RAD;

	vmovss	xmm3, DWORD PTR __real@3c8efa35
	vmulss	xmm0, xmm3, DWORD PTR [r13+32]
	vmulss	xmm2, xmm3, DWORD PTR [r13+36]
	vmulss	xmm1, xmm3, DWORD PTR [r13+40]

; 116  : 	angX2 *= DEG_TO_RAD; angY2 *= DEG_TO_RAD; angZ2 *= DEG_TO_RAD;
; 117  : 
; 118  : 	EnableStuff(pblock, t);

	mov	r8d, DWORD PTR t$[rsp]
	mov	rdx, r12
	vmovss	DWORD PTR [r13+32], xmm0
	vmulss	xmm0, xmm3, DWORD PTR [r13+80]
	vmovss	DWORD PTR [r13+36], xmm2
	vmulss	xmm2, xmm3, DWORD PTR [r13+84]
	vmovss	DWORD PTR [r13+40], xmm1
	vmulss	xmm1, xmm3, DWORD PTR [r13+88]
	mov	rcx, r13
	vmovss	DWORD PTR [r13+80], xmm0
	vmovss	DWORD PTR [r13+84], xmm2
	vmovss	DWORD PTR [r13+88], xmm1
	call	?EnableStuff@BerconXYZ@@AEAAXPEAVIParamBlock2@@H@Z ; BerconXYZ::EnableStuff

; 119  : 	update();

	mov	rcx, r13
	call	?update@BerconXYZ@@QEAAXXZ		; BerconXYZ::update
	mov	r15, QWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+112]

; 120  : }

	add	rsp, 72					; 00000048H
	pop	r13
	pop	r12
	pop	rdi
	pop	rbx
$LN4@update:
	ret	0
?update@BerconXYZ@@QEAAXPEAVIParamBlock2@@HAEAVInterval@@@Z ENDP ; BerconXYZ::update
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.h
;	COMDAT ?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z
_TEXT	SEGMENT
$T1 = 64
val$ = 72
__$ArrayPad$ = 80
map$ = 160
t$ = 168
pb_id$ = 176
edit_id$ = 184
spin_id$ = 192
spinnerTypeWorld$ = 200
allowNegative$ = 208
?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z PROC	; setSpinnerType, COMDAT

; 85   :  static void setSpinnerType(IParamMap2 *map, TimeValue t, int pb_id, int edit_id, int spin_id, int spinnerTypeWorld = 1, bool allowNegative = false) {

	push	rbx
	push	rbp
	push	rsi
	push	r12
	push	r14
	push	r15
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 86   : 	HWND hWnd = map->GetHWnd();

	mov	rax, QWORD PTR [rcx]
	mov	ebp, r9d
	mov	r14d, DWORD PTR spin_id$[rsp]
	mov	r12d, r8d
	mov	r15d, edx
	mov	rbx, rcx
	call	QWORD PTR [rax+112]
	mov	rsi, rax

; 87   : 	if (!hWnd) return;

	test	rax, rax
	je	$LN1@setSpinner

; 88   : 
; 89   : 	float val;
; 90   : 	map->GetParamBlock()->GetValue(pb_id, t, val, FOREVER);

	mov	r9, QWORD PTR [rbx]
	mov	rcx, rbx
	mov	QWORD PTR [rsp+96], rdi
	call	QWORD PTR [r9+136]
	mov	edx, -2147483648			; ffffffff80000000H
	lea	rcx, QWORD PTR $T1[rsp]
	mov	r8d, 2147483647				; 7fffffffH
	mov	rbx, rax
	mov	rdi, QWORD PTR [rax]
	call	QWORD PTR __imp_??0Interval@@QEAA@HH@Z
	lea	r9, QWORD PTR val$[rsp]
	mov	DWORD PTR [rsp+40], 0
	mov	r8d, r15d
	mov	QWORD PTR [rsp+32], rax
	movzx	edx, r12w
	mov	rcx, rbx
	call	QWORD PTR [rdi+1712]

; 91   : 
; 92   : 	float minVal = allowNegative ? -1000000.f : 0.f;

	cmp	BYTE PTR allowNegative$[rsp], 0
	mov	rdi, QWORD PTR [rsp+96]
	je	SHORT $LN6@setSpinner
	vmovss	xmm3, DWORD PTR __real@c9742400
	jmp	SHORT $LN7@setSpinner
$LN6@setSpinner:
	vxorps	xmm3, xmm3, xmm3
$LN7@setSpinner:

; 93   : 
; 94   : 	ISpinnerControl* spin;
; 95   : 	if (spinnerTypeWorld)

	cmp	DWORD PTR spinnerTypeWorld$[rsp], 0

; 96   : 		spin = SetupUniverseSpinner(hWnd, spin_id, edit_id, minVal, 1000000.f, val);

	mov	r8d, ebp
	vmovss	xmm0, DWORD PTR __real@3dcccccd
	vmovss	xmm1, DWORD PTR val$[rsp]
	vmovss	DWORD PTR [rsp+48], xmm0
	vmovss	xmm0, DWORD PTR __real@49742400
	vmovss	DWORD PTR [rsp+40], xmm1
	vmovss	DWORD PTR [rsp+32], xmm0
	mov	edx, r14d
	mov	rcx, rsi
	je	SHORT $LN3@setSpinner
	call	QWORD PTR __imp_?SetupUniverseSpinner@@YAPEAVISpinnerControl@@PEAUHWND__@@HHMMMM@Z

; 97   : 	else

	jmp	SHORT $LN8@setSpinner
$LN3@setSpinner:

; 98   : 		spin = SetupFloatSpinner(hWnd, spin_id, edit_id, minVal, 1000000.f, val);

	call	QWORD PTR __imp_?SetupFloatSpinner@@YAPEAVISpinnerControl@@PEAUHWND__@@HHMMMM@Z
$LN8@setSpinner:
	mov	rbx, rax

; 99   : 	spin->SetAutoScale(TRUE);

	mov	edx, 1
	mov	rax, QWORD PTR [rax]
	mov	rcx, rbx
	call	QWORD PTR [rax+88]

; 100  : 	ReleaseISpinner(spin);

	mov	rcx, rbx
	call	QWORD PTR __imp_?ReleaseISpinner@@YAXPEAVISpinnerControl@@@Z
$LN1@setSpinner:

; 101  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	pop	r15
	pop	r14
	pop	r12
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?setSpinnerType@@YAXPEAVIParamMap2@@HHHHH_N@Z ENDP	; setSpinnerType
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?GetString@@YAPEA_WH@Z
_TEXT	SEGMENT
id$ = 48
?GetString@@YAPEA_WH@Z PROC				; GetString, COMDAT

; 21   : TCHAR *GetString(int id) {

$LN5:
	sub	rsp, 40					; 00000028H
	mov	edx, ecx

; 22   : 	static TCHAR buf[256];
; 23   : 
; 24   : 	if (hInstance)

	mov	rcx, QWORD PTR ?hInstance@@3PEAUHINSTANCE__@@EA ; hInstance
	test	rcx, rcx
	je	SHORT $LN2@GetString

; 25   : 		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	mov	QWORD PTR [rsp+32], rbx
	mov	r9d, 512				; 00000200H
	lea	rbx, OFFSET FLAT:?buf@?1??GetString@@YAPEA_WH@Z@4PA_WA
	mov	r8, rbx
	call	QWORD PTR __imp_LoadStringW
	xor	ecx, ecx
	test	eax, eax
	cmovne	rcx, rbx
	mov	rbx, QWORD PTR [rsp+32]
	mov	rax, rcx

; 27   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@GetString:

; 26   : 	return NULL;

	xor	eax, eax

; 27   : }

	add	rsp, 40					; 00000028H
	ret	0
?GetString@@YAPEA_WH@Z ENDP				; GetString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\interval.h
;	COMDAT ?SetEmpty@Interval@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?SetEmpty@Interval@@QEAAXXZ PROC			; Interval::SetEmpty, COMDAT

; 118  : 		void SetEmpty() { start = TIME_NegInfinity; end = TIME_NegInfinity; }

	mov	DWORD PTR [rcx], -2147483648		; ffffffff80000000H
	mov	DWORD PTR [rcx+4], -2147483648		; ffffffff80000000H
	ret	0
?SetEmpty@Interval@@QEAAXXZ ENDP			; Interval::SetEmpty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
;	COMDAT ?GetRow@Matrix3@@QEBA?AVPoint3@@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
i$ = 24
?GetRow@Matrix3@@QEBA?AVPoint3@@H@Z PROC		; Matrix3::GetRow, COMDAT

; 118  :    const Point3& operator[](int i) const { return((Point3&)(*m[i])); }

	movsxd	rax, r8d
	lea	r8, QWORD PTR [rax+rax*2]
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h

; 73   : 		 x = a.x; y = a.y; z = a.z; 

	mov	eax, DWORD PTR [rcx+r8*4]
	mov	DWORD PTR [rdx], eax
	mov	eax, DWORD PTR [rcx+r8*4+4]
	mov	DWORD PTR [rdx+4], eax
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rdx+8], eax
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h

; 260  :    Point3 GetRow(int i) const { return (*this)[i]; }

	mov	rax, rdx
	ret	0
?GetRow@Matrix3@@QEBA?AVPoint3@@H@Z ENDP		; Matrix3::GetRow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
;	COMDAT ??0Matrix3@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Matrix3@@QEAA@XZ PROC				; Matrix3::Matrix3, COMDAT

; 172  :    Matrix3(){ flags = 0; }

	mov	DWORD PTR [rcx+48], 0
	mov	rax, rcx
	ret	0
??0Matrix3@@QEAA@XZ ENDP				; Matrix3::Matrix3
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\matrix3.h
;	COMDAT ??AMatrix3@@QEBAAEBVPoint3@@H@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??AMatrix3@@QEBAAEBVPoint3@@H@Z PROC			; Matrix3::operator[], COMDAT

; 118  :    const Point3& operator[](int i) const { return((Point3&)(*m[i])); }

	movsxd	rax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	lea	rax, QWORD PTR [rcx+rdx*4]
	ret	0
??AMatrix3@@QEBAAEBVPoint3@@H@Z ENDP			; Matrix3::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ
text$di	SEGMENT
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ PROC	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId'', COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR ?kInvalidId@AssetManagement@MaxSDK@@3UAssetId@12@A, xmm0

; 32   : 		static AssetId kInvalidId;

	ret	0
??__EkInvalidId@AssetManagement@MaxSDK@@YAXXZ ENDP	; MaxSDK::AssetManagement::`dynamic initializer for 'kInvalidId''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\assetmanagement\assetid.h
;	COMDAT ??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ PROC		; MaxSDK::AssetManagement::AssetId::AssetId, COMDAT

; 29   : 			AssetId() { *static_cast<GUID*>(this) = CLSID_NULL; }

	vmovups	xmm0, XMMWORD PTR GUID_NULL
	vmovups	XMMWORD PTR [rcx], xmm0
	mov	rax, rcx
	ret	0
??0AssetId@AssetManagement@MaxSDK@@QEAA@XZ ENDP		; MaxSDK::AssetManagement::AssetId::AssetId
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\point3.h
;	COMDAT ??D@YA?AVPoint3@@AEBV0@M@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
a$ = 16
f$ = 24
??D@YA?AVPoint3@@AEBV0@M@Z PROC				; operator*, COMDAT

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm0, xmm2, DWORD PTR [rdx]
	vmulss	xmm1, xmm2, DWORD PTR [rdx+4]

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR [rcx], xmm0

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	vmulss	xmm0, xmm2, DWORD PTR [rdx+8]

; 61   : 		 x = X; y = Y; z = Z; 

	vmovss	DWORD PTR [rcx+8], xmm0
	vmovss	DWORD PTR [rcx+4], xmm1

; 327  :    return(Point3(a.x*f, a.y*f, a.z*f));

	mov	rax, rcx

; 328  :    }

	ret	0
??D@YA?AVPoint3@@AEBV0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files\autodesk\3ds max 2019 sdk\maxsdk\include\maxtypes.h
;	COMDAT ??0Class_ID@@QEAA@KK@Z
_TEXT	SEGMENT
this$ = 8
aa$ = 16
bb$ = 24
??0Class_ID@@QEAA@KK@Z PROC				; Class_ID::Class_ID, COMDAT

; 160  : 	Class_ID(ulong aa, ulong bb) { a = aa; b = bb; }

	mov	DWORD PTR [rcx], edx
	mov	rax, rcx
	mov	DWORD PTR [rcx+4], r8d
	ret	0
??0Class_ID@@QEAA@KK@Z ENDP				; Class_ID::Class_ID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\berconcommon.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 8
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

; 450  : //out->printf("Val: %d\n", mappingChannel);

	ret	0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_H@YAXPEAX_K1P6APEAX0@Z@Z
_TEXT	SEGMENT
__t$ = 48
__s$ = 56
__n$ = 64
__f$ = 72
??_H@YAXPEAX_K1P6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN12:
	test	r8, r8
	je	SHORT $LN10@vector
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r9
	mov	rbx, r8
	mov	rbp, rdx
	mov	rdi, rcx
$LL2@vector:
	mov	rcx, rdi
	call	rsi
	add	rdi, rbp
	sub	rbx, 1
	jne	SHORT $LL2@vector
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN10@vector:
	ret	0
??_H@YAXPEAX_K1P6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
END
