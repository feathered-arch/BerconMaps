; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24234.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?noise@Perlin@@SAMM@Z				; Perlin::noise
PUBLIC	?noise@Perlin@@SAMMM@Z				; Perlin::noise
PUBLIC	?noise@Perlin@@SAMMMM@Z				; Perlin::noise
PUBLIC	?noise@Perlin@@SAMMMMM@Z			; Perlin::noise
PUBLIC	?snoise@Perlin@@SAMM@Z				; Perlin::snoise
PUBLIC	?snoise@Perlin@@SAMMM@Z				; Perlin::snoise
PUBLIC	?snoise@Perlin@@SAMMMM@Z			; Perlin::snoise
PUBLIC	?snoise@Perlin@@SAMMMMM@Z			; Perlin::snoise
PUBLIC	?fnoise2D@Perlin@@SAMMMM@Z			; Perlin::fnoise2D
PUBLIC	?fnoise3D@Perlin@@SAMMMMM@Z			; Perlin::fnoise3D
PUBLIC	?fnoise4D@Perlin@@SAMMMMMM@Z			; Perlin::fnoise4D
PUBLIC	?fsnoise2D@Perlin@@SAMMMM@Z			; Perlin::fsnoise2D
PUBLIC	?fsnoise3D@Perlin@@SAMMMMM@Z			; Perlin::fsnoise3D
PUBLIC	?fsnoise4D@Perlin@@SAMMMMMM@Z			; Perlin::fsnoise4D
PUBLIC	?grad@Perlin@@CAMHM@Z				; Perlin::grad
PUBLIC	?grad@Perlin@@CAMHMM@Z				; Perlin::grad
PUBLIC	?grad@Perlin@@CAMHMMM@Z				; Perlin::grad
PUBLIC	?grad@Perlin@@CAMHMMMM@Z			; Perlin::grad
PUBLIC	?point@Perlin@@CAMMMHH@Z			; Perlin::point
PUBLIC	?point@Perlin@@CAMMMMHHH@Z			; Perlin::point
PUBLIC	?point@Perlin@@CAMMMMMHHHH@Z			; Perlin::point
PUBLIC	?lerp2@@YAMMMM@Z				; lerp2
PUBLIC	__real@3e0d8369
PUBLIC	__real@3e2aaaab
PUBLIC	__real@3e408312
PUBLIC	__real@3e58658c
PUBLIC	__real@3e8d8369
PUBLIC	__real@3e9e377a
PUBLIC	__real@3eaaaaab
PUBLIC	__real@3ebb67ae
PUBLIC	__real@3eca4588
PUBLIC	__real@3ed4451e
PUBLIC	__real@3ed8658c
PUBLIC	__real@3ee4f92e
PUBLIC	__real@3f000000
PUBLIC	__real@3f01cac1
PUBLIC	__real@3f19999a
PUBLIC	__real@3f5eb852
PUBLIC	__real@3f6f9db2
PUBLIC	__real@3f7ff972
PUBLIC	__real@3f800000
PUBLIC	__real@3f99999a
PUBLIC	__real@400ccccd
PUBLIC	__real@40c00000
PUBLIC	__real@41200000
PUBLIC	__real@41700000
PUBLIC	__real@41d80000
PUBLIC	__real@42000000
PUBLIC	__real@42200000
PUBLIC	__real@c0000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	?smooth@@YAMMMM@Z:PROC				; smooth
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?noise@Perlin@@SAMM@Z DD imagerel $LN14
	DD	imagerel $LN14+235
	DD	imagerel $unwind$?noise@Perlin@@SAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?noise@Perlin@@SAMMM@Z DD imagerel $LN54
	DD	imagerel $LN54+603
	DD	imagerel $unwind$?noise@Perlin@@SAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?noise@Perlin@@SAMMMM@Z DD imagerel $LN128
	DD	imagerel $LN128+1202
	DD	imagerel $unwind$?noise@Perlin@@SAMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?noise@Perlin@@SAMMMMM@Z DD imagerel $LN266
	DD	imagerel $LN266+2395
	DD	imagerel $unwind$?noise@Perlin@@SAMMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?snoise@Perlin@@SAMM@Z DD imagerel $LN16
	DD	imagerel $LN16+229
	DD	imagerel $unwind$?snoise@Perlin@@SAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?snoise@Perlin@@SAMMM@Z DD imagerel $LN12
	DD	imagerel $LN12+355
	DD	imagerel $unwind$?snoise@Perlin@@SAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?snoise@Perlin@@SAMMMM@Z DD imagerel $LN24
	DD	imagerel $LN24+716
	DD	imagerel $unwind$?snoise@Perlin@@SAMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?snoise@Perlin@@SAMMMMM@Z DD imagerel $LN16
	DD	imagerel $LN16+1142
	DD	imagerel $unwind$?snoise@Perlin@@SAMMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fnoise2D@Perlin@@SAMMMM@Z DD imagerel $LN7
	DD	imagerel $LN7+128
	DD	imagerel $unwind$?fnoise2D@Perlin@@SAMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fnoise3D@Perlin@@SAMMMMM@Z DD imagerel $LN7
	DD	imagerel $LN7+149
	DD	imagerel $unwind$?fnoise3D@Perlin@@SAMMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fnoise4D@Perlin@@SAMMMMMM@Z DD imagerel $LN7
	DD	imagerel $LN7+179
	DD	imagerel $unwind$?fnoise4D@Perlin@@SAMMMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fsnoise2D@Perlin@@SAMMMM@Z DD imagerel $LN7
	DD	imagerel $LN7+128
	DD	imagerel $unwind$?fsnoise2D@Perlin@@SAMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fsnoise3D@Perlin@@SAMMMMM@Z DD imagerel $LN7
	DD	imagerel $LN7+149
	DD	imagerel $unwind$?fsnoise3D@Perlin@@SAMMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fsnoise4D@Perlin@@SAMMMMMM@Z DD imagerel $LN7
	DD	imagerel $LN7+179
	DD	imagerel $unwind$?fsnoise4D@Perlin@@SAMMMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?point@Perlin@@CAMMMMHHH@Z DD imagerel $LN18
	DD	imagerel $LN18+187
	DD	imagerel $unwind$?point@Perlin@@CAMMMMHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?point@Perlin@@CAMMMMMHHHH@Z DD imagerel $LN19
	DD	imagerel $LN19+208
	DD	imagerel $unwind$?point@Perlin@@CAMMMMMHHHH@Z
pdata	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@42000000
CONST	SEGMENT
__real@42000000 DD 042000000r			; 32
CONST	ENDS
;	COMDAT __real@41d80000
CONST	SEGMENT
__real@41d80000 DD 041d80000r			; 27
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@400ccccd
CONST	SEGMENT
__real@400ccccd DD 0400ccccdr			; 2.2
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7ff972
CONST	SEGMENT
__real@3f7ff972 DD 03f7ff972r			; 0.9999
CONST	ENDS
;	COMDAT __real@3f6f9db2
CONST	SEGMENT
__real@3f6f9db2 DD 03f6f9db2r			; 0.936
CONST	ENDS
;	COMDAT __real@3f5eb852
CONST	SEGMENT
__real@3f5eb852 DD 03f5eb852r			; 0.87
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f01cac1
CONST	SEGMENT
__real@3f01cac1 DD 03f01cac1r			; 0.507
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ee4f92e
CONST	SEGMENT
__real@3ee4f92e DD 03ee4f92er			; 0.447214
CONST	ENDS
;	COMDAT __real@3ed8658c
CONST	SEGMENT
__real@3ed8658c DD 03ed8658cr			; 0.42265
CONST	ENDS
;	COMDAT __real@3ed4451e
CONST	SEGMENT
__real@3ed4451e DD 03ed4451er			; 0.41459
CONST	ENDS
;	COMDAT __real@3eca4588
CONST	SEGMENT
__real@3eca4588 DD 03eca4588r			; 0.395062
CONST	ENDS
;	COMDAT __real@3ebb67ae
CONST	SEGMENT
__real@3ebb67ae DD 03ebb67aer			; 0.366025
CONST	ENDS
;	COMDAT __real@3eaaaaab
CONST	SEGMENT
__real@3eaaaaab DD 03eaaaaabr			; 0.333333
CONST	ENDS
;	COMDAT __real@3e9e377a
CONST	SEGMENT
__real@3e9e377a DD 03e9e377ar			; 0.309017
CONST	ENDS
;	COMDAT __real@3e8d8369
CONST	SEGMENT
__real@3e8d8369 DD 03e8d8369r			; 0.276393
CONST	ENDS
;	COMDAT __real@3e58658c
CONST	SEGMENT
__real@3e58658c DD 03e58658cr			; 0.211325
CONST	ENDS
;	COMDAT __real@3e408312
CONST	SEGMENT
__real@3e408312 DD 03e408312r			; 0.188
CONST	ENDS
;	COMDAT __real@3e2aaaab
CONST	SEGMENT
__real@3e2aaaab DD 03e2aaaabr			; 0.166667
CONST	ENDS
;	COMDAT __real@3e0d8369
CONST	SEGMENT
__real@3e0d8369 DD 03e0d8369r			; 0.138197
CONST	ENDS
_DATA	SEGMENT
?perm@@3PAEA DB	097H					; perm
	DB	0a0H
	DB	089H
	DB	05bH
	DB	05aH
	DB	0fH
	DB	083H
	DB	0dH
	DB	0c9H
	DB	05fH
	DB	060H
	DB	035H
	DB	0c2H
	DB	0e9H
	DB	07H
	DB	0e1H
	DB	08cH
	DB	024H
	DB	067H
	DB	01eH
	DB	045H
	DB	08eH
	DB	08H
	DB	063H
	DB	025H
	DB	0f0H
	DB	015H
	DB	0aH
	DB	017H
	DB	0beH
	DB	06H
	DB	094H
	DB	0f7H
	DB	078H
	DB	0eaH
	DB	04bH
	DB	00H
	DB	01aH
	DB	0c5H
	DB	03eH
	DB	05eH
	DB	0fcH
	DB	0dbH
	DB	0cbH
	DB	075H
	DB	023H
	DB	0bH
	DB	020H
	DB	039H
	DB	0b1H
	DB	021H
	DB	058H
	DB	0edH
	DB	095H
	DB	038H
	DB	057H
	DB	0aeH
	DB	014H
	DB	07dH
	DB	088H
	DB	0abH
	DB	0a8H
	DB	044H
	DB	0afH
	DB	04aH
	DB	0a5H
	DB	047H
	DB	086H
	DB	08bH
	DB	030H
	DB	01bH
	DB	0a6H
	DB	04dH
	DB	092H
	DB	09eH
	DB	0e7H
	DB	053H
	DB	06fH
	DB	0e5H
	DB	07aH
	DB	03cH
	DB	0d3H
	DB	085H
	DB	0e6H
	DB	0dcH
	DB	069H
	DB	05cH
	DB	029H
	DB	037H
	DB	02eH
	DB	0f5H
	DB	028H
	DB	0f4H
	DB	066H
	DB	08fH
	DB	036H
	DB	041H
	DB	019H
	DB	03fH
	DB	0a1H
	DB	01H
	DB	0d8H
	DB	050H
	DB	049H
	DB	0d1H
	DB	04cH
	DB	084H
	DB	0bbH
	DB	0d0H
	DB	059H
	DB	012H
	DB	0a9H
	DB	0c8H
	DB	0c4H
	DB	087H
	DB	082H
	DB	074H
	DB	0bcH
	DB	09fH
	DB	056H
	DB	0a4H
	DB	064H
	DB	06dH
	DB	0c6H
	DB	0adH
	DB	0baH
	DB	03H
	DB	040H
	DB	034H
	DB	0d9H
	DB	0e2H
	DB	0faH
	DB	07cH
	DB	07bH
	DB	05H
	DB	0caH
	DB	026H
	DB	093H
	DB	076H
	DB	07eH
	DB	0ffH
	DB	052H
	DB	055H
	DB	0d4H
	DB	0cfH
	DB	0ceH
	DB	03bH
	DB	0e3H
	DB	02fH
	DB	010H
	DB	03aH
	DB	011H
	DB	0b6H
	DB	0bdH
	DB	01cH
	DB	02aH
	DB	0dfH
	DB	0b7H
	DB	0aaH
	DB	0d5H
	DB	077H
	DB	0f8H
	DB	098H
	DB	02H
	DB	02cH
	DB	09aH
	DB	0a3H
	DB	046H
	DB	0ddH
	DB	099H
	DB	065H
	DB	09bH
	DB	0a7H
	DB	02bH
	DB	0acH
	DB	09H
	DB	081H
	DB	016H
	DB	027H
	DB	0fdH
	DB	013H
	DB	062H
	DB	06cH
	DB	06eH
	DB	04fH
	DB	071H
	DB	0e0H
	DB	0e8H
	DB	0b2H
	DB	0b9H
	DB	070H
	DB	068H
	DB	0daH
	DB	0f6H
	DB	061H
	DB	0e4H
	DB	0fbH
	DB	022H
	DB	0f2H
	DB	0c1H
	DB	0eeH
	DB	0d2H
	DB	090H
	DB	0cH
	DB	0bfH
	DB	0b3H
	DB	0a2H
	DB	0f1H
	DB	051H
	DB	033H
	DB	091H
	DB	0ebH
	DB	0f9H
	DB	0eH
	DB	0efH
	DB	06bH
	DB	031H
	DB	0c0H
	DB	0d6H
	DB	01fH
	DB	0b5H
	DB	0c7H
	DB	06aH
	DB	09dH
	DB	0b8H
	DB	054H
	DB	0ccH
	DB	0b0H
	DB	073H
	DB	079H
	DB	032H
	DB	02dH
	DB	07fH
	DB	04H
	DB	096H
	DB	0feH
	DB	08aH
	DB	0ecH
	DB	0cdH
	DB	05dH
	DB	0deH
	DB	072H
	DB	043H
	DB	01dH
	DB	018H
	DB	048H
	DB	0f3H
	DB	08dH
	DB	080H
	DB	0c3H
	DB	04eH
	DB	042H
	DB	0d7H
	DB	03dH
	DB	09cH
	DB	0b4H
	DB	097H
	DB	0a0H
	DB	089H
	DB	05bH
	DB	05aH
	DB	0fH
	DB	083H
	DB	0dH
	DB	0c9H
	DB	05fH
	DB	060H
	DB	035H
	DB	0c2H
	DB	0e9H
	DB	07H
	DB	0e1H
	DB	08cH
	DB	024H
	DB	067H
	DB	01eH
	DB	045H
	DB	08eH
	DB	08H
	DB	063H
	DB	025H
	DB	0f0H
	DB	015H
	DB	0aH
	DB	017H
	DB	0beH
	DB	06H
	DB	094H
	DB	0f7H
	DB	078H
	DB	0eaH
	DB	04bH
	DB	00H
	DB	01aH
	DB	0c5H
	DB	03eH
	DB	05eH
	DB	0fcH
	DB	0dbH
	DB	0cbH
	DB	075H
	DB	023H
	DB	0bH
	DB	020H
	DB	039H
	DB	0b1H
	DB	021H
	DB	058H
	DB	0edH
	DB	095H
	DB	038H
	DB	057H
	DB	0aeH
	DB	014H
	DB	07dH
	DB	088H
	DB	0abH
	DB	0a8H
	DB	044H
	DB	0afH
	DB	04aH
	DB	0a5H
	DB	047H
	DB	086H
	DB	08bH
	DB	030H
	DB	01bH
	DB	0a6H
	DB	04dH
	DB	092H
	DB	09eH
	DB	0e7H
	DB	053H
	DB	06fH
	DB	0e5H
	DB	07aH
	DB	03cH
	DB	0d3H
	DB	085H
	DB	0e6H
	DB	0dcH
	DB	069H
	DB	05cH
	DB	029H
	DB	037H
	DB	02eH
	DB	0f5H
	DB	028H
	DB	0f4H
	DB	066H
	DB	08fH
	DB	036H
	DB	041H
	DB	019H
	DB	03fH
	DB	0a1H
	DB	01H
	DB	0d8H
	DB	050H
	DB	049H
	DB	0d1H
	DB	04cH
	DB	084H
	DB	0bbH
	DB	0d0H
	DB	059H
	DB	012H
	DB	0a9H
	DB	0c8H
	DB	0c4H
	DB	087H
	DB	082H
	DB	074H
	DB	0bcH
	DB	09fH
	DB	056H
	DB	0a4H
	DB	064H
	DB	06dH
	DB	0c6H
	DB	0adH
	DB	0baH
	DB	03H
	DB	040H
	DB	034H
	DB	0d9H
	DB	0e2H
	DB	0faH
	DB	07cH
	DB	07bH
	DB	05H
	DB	0caH
	DB	026H
	DB	093H
	DB	076H
	DB	07eH
	DB	0ffH
	DB	052H
	DB	055H
	DB	0d4H
	DB	0cfH
	DB	0ceH
	DB	03bH
	DB	0e3H
	DB	02fH
	DB	010H
	DB	03aH
	DB	011H
	DB	0b6H
	DB	0bdH
	DB	01cH
	DB	02aH
	DB	0dfH
	DB	0b7H
	DB	0aaH
	DB	0d5H
	DB	077H
	DB	0f8H
	DB	098H
	DB	02H
	DB	02cH
	DB	09aH
	DB	0a3H
	DB	046H
	DB	0ddH
	DB	099H
	DB	065H
	DB	09bH
	DB	0a7H
	DB	02bH
	DB	0acH
	DB	09H
	DB	081H
	DB	016H
	DB	027H
	DB	0fdH
	DB	013H
	DB	062H
	DB	06cH
	DB	06eH
	DB	04fH
	DB	071H
	DB	0e0H
	DB	0e8H
	DB	0b2H
	DB	0b9H
	DB	070H
	DB	068H
	DB	0daH
	DB	0f6H
	DB	061H
	DB	0e4H
	DB	0fbH
	DB	022H
	DB	0f2H
	DB	0c1H
	DB	0eeH
	DB	0d2H
	DB	090H
	DB	0cH
	DB	0bfH
	DB	0b3H
	DB	0a2H
	DB	0f1H
	DB	051H
	DB	033H
	DB	091H
	DB	0ebH
	DB	0f9H
	DB	0eH
	DB	0efH
	DB	06bH
	DB	031H
	DB	0c0H
	DB	0d6H
	DB	01fH
	DB	0b5H
	DB	0c7H
	DB	06aH
	DB	09dH
	DB	0b8H
	DB	054H
	DB	0ccH
	DB	0b0H
	DB	073H
	DB	079H
	DB	032H
	DB	02dH
	DB	07fH
	DB	04H
	DB	096H
	DB	0feH
	DB	08aH
	DB	0ecH
	DB	0cdH
	DB	05dH
	DB	0deH
	DB	072H
	DB	043H
	DB	01dH
	DB	018H
	DB	048H
	DB	0f3H
	DB	08dH
	DB	080H
	DB	0c3H
	DB	04eH
	DB	042H
	DB	0d7H
	DB	03dH
	DB	09cH
	DB	0b4H
?simplex@@3PAY03EA DB 00H				; simplex
	DB	01H
	DB	02H
	DB	03H
	DB	00H
	DB	01H
	DB	03H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	03H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	00H
	DB	00H
	DB	02H
	DB	01H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	DB	01H
	DB	02H
	DB	00H
	DB	03H
	DB	02H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	03H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	02H
	DB	00H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	03H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	03H
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	02H
	DB	03H
	DB	01H
	DB	00H
	DB	03H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	00H
	DB	03H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	01H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	00H
	DB	01H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	00H
	DB	02H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	DB	01H
	DB	02H
	DB	00H
	DB	02H
	DB	01H
	DB	00H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	DB	01H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	DB	02H
	DB	00H
	DB	01H
	DB	03H
	DB	02H
	DB	01H
	DB	00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?point@Perlin@@CAMMMMMHHHH@Z DD 030d01H
	DD	0680dH
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?point@Perlin@@CAMMMMHHH@Z DD 032101H
	DD	06821H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fsnoise4D@Perlin@@SAMMMMMM@Z DD 0b4301H
	DD	02a843H
	DD	039825H
	DD	04881fH
	DD	057819H
	DD	066813H
	DD	0e204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fsnoise3D@Perlin@@SAMMMMM@Z DD 093401H
	DD	029834H
	DD	038816H
	DD	047810H
	DD	05680aH
	DD	0c204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fsnoise2D@Perlin@@SAMMMM@Z DD 072201H
	DD	028822H
	DD	037810H
	DD	04680aH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fnoise4D@Perlin@@SAMMMMMM@Z DD 0b4301H
	DD	02a843H
	DD	039825H
	DD	04881fH
	DD	057819H
	DD	066813H
	DD	0e204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fnoise3D@Perlin@@SAMMMMM@Z DD 093401H
	DD	029834H
	DD	038816H
	DD	047810H
	DD	05680aH
	DD	0c204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fnoise2D@Perlin@@SAMMMM@Z DD 072201H
	DD	028822H
	DD	037810H
	DD	04680aH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?snoise@Perlin@@SAMMMMM@Z DD 0165d01H
	DD	05b85dH
	DD	06a835H
	DD	07982bH
	DD	088825H
	DD	097820H
	DD	0a681bH
	DD	0170116H
	DD	0e00df00fH
	DD	0c009d00bH
	DD	060067007H
	DD	030045005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?snoise@Perlin@@SAMMMM@Z DD 0144001H
	DD	03a840H
	DD	049833H
	DD	05882eH
	DD	067825H
	DD	076820H
	DD	016641bH
	DD	015541bH
	DD	014341bH
	DD	0f014f21bH
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?snoise@Perlin@@SAMMM@Z DD 0a3801H
	DD	028838H
	DD	037826H
	DD	046810H
	DD	0c340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?snoise@Perlin@@SAMM@Z DD 051701H
	DD	07817H
	DD	016812H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?noise@Perlin@@SAMMMMM@Z DD 01b5301H
	DD	02f853H
	DD	03e849H
	DD	04d83bH
	DD	05c835H
	DD	06b82fH
	DD	07a829H
	DD	089824H
	DD	09881fH
	DD	0a781aH
	DD	0b6815H
	DD	0180110H
	DD	07007e009H
	DD	050056006H
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?noise@Perlin@@SAMMMM@Z DD 0194f01H
	DD	0f84fH
	DD	01e84aH
	DD	02d838H
	DD	03c832H
	DD	04b82dH
	DD	05a828H
	DD	069823H
	DD	07881eH
	DD	087819H
	DD	096814H
	DD	019340fH
	DD	014010fH
	DD	07008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?noise@Perlin@@SAMMM@Z DD 0f3901H
	DD	0c839H
	DD	01b834H
	DD	02a822H
	DD	03981cH
	DD	048816H
	DD	057810H
	DD	06680aH
	DD	0e204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?noise@Perlin@@SAMM@Z DD 051701H
	DD	07817H
	DD	016812H
	DD	04204H
xdata	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?lerp2@@YAMMMM@Z
_TEXT	SEGMENT
t$ = 8
a$ = 16
b$ = 24
?lerp2@@YAMMMM@Z PROC					; lerp2, COMDAT

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm2, xmm2, xmm1
	vmulss	xmm0, xmm2, xmm0
	vaddss	xmm0, xmm0, xmm1
	ret	0
?lerp2@@YAMMMM@Z ENDP					; lerp2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?point@Perlin@@CAMMMMMHHHH@Z
_TEXT	SEGMENT
x$ = 32
y$ = 40
z$ = 48
w$ = 56
i$ = 64
j$ = 72
k$ = 80
l$ = 88
?point@Perlin@@CAMMMMMHHHH@Z PROC			; Perlin::point, COMDAT

; 231  : inline float Perlin::point(float x, float y, float z, float w, int i, int j, int k, int l) {

$LN19:
	sub	rsp, 24

; 232  : 	float t = 0.6f - x*x - y*y - z*z - w*w;

	vmulss	xmm4, xmm0, xmm0
	vmovaps	XMMWORD PTR [rsp], xmm6
	vmovaps	xmm6, xmm0
	vmovss	xmm0, DWORD PTR __real@3f19999a
	vsubss	xmm5, xmm0, xmm4
	vmulss	xmm0, xmm2, xmm2
	vmulss	xmm4, xmm1, xmm1
	vsubss	xmm4, xmm5, xmm4
	vsubss	xmm5, xmm4, xmm0
	vmulss	xmm4, xmm3, xmm3
	vsubss	xmm4, xmm5, xmm4
	vxorps	xmm0, xmm0, xmm0

; 233  : 	if(t < 0.0f)

	vcomiss	xmm0, xmm4
	ja	$LN1@point

; 234  : 		return 0.0f;	
; 235  : 	t *= t;
; 236  : 	return t * t * grad(perm[i+perm[j+perm[k+perm[l]]]], x, y, z, w);	

	movsxd	rax, DWORD PTR l$[rsp]
	lea	rdx, OFFSET FLAT:?perm@@3PAEA
	vmulss	xmm4, xmm4, xmm4
	movzx	eax, BYTE PTR [rax+rdx]
	add	eax, DWORD PTR k$[rsp]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+rdx]
	add	eax, DWORD PTR j$[rsp]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+rdx]
	add	eax, DWORD PTR i$[rsp]
	movsxd	rcx, eax

; 89   : 	int h = hash & 31;

	movzx	eax, BYTE PTR [rcx+rdx]
	and	eax, 31
	cmp	eax, 24

; 90   :     float i = h<24 ? x : y;

	jb	SHORT $LN7@point
	vmovaps	xmm6, xmm1
$LN7@point:
	cmp	eax, 16

; 91   :     float j = h<16 ? y : z;

	jb	SHORT $LN9@point
	vmovaps	xmm1, xmm2
$LN9@point:
	cmp	eax, 8

; 92   :     float k = h<8 ? z : w;

	jb	SHORT $LN11@point
	vmovaps	xmm2, xmm3
$LN11@point:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	vmovss	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	test	al, 1
	je	SHORT $LN12@point
	vxorps	xmm6, xmm6, xmm0
$LN12@point:
	test	al, 2
	je	SHORT $LN14@point
	vxorps	xmm1, xmm1, xmm0
$LN14@point:
	test	al, 4
	je	SHORT $LN16@point
	vxorps	xmm2, xmm2, xmm0
$LN16@point:
	vaddss	xmm0, xmm1, xmm6
	vaddss	xmm2, xmm0, xmm2

; 234  : 		return 0.0f;	
; 235  : 	t *= t;
; 236  : 	return t * t * grad(perm[i+perm[j+perm[k+perm[l]]]], x, y, z, w);	

	vmulss	xmm1, xmm4, xmm4
	vmulss	xmm0, xmm2, xmm1
$LN1@point:

; 237  : }

	vmovaps	xmm6, XMMWORD PTR [rsp]
	add	rsp, 24
	ret	0
?point@Perlin@@CAMMMMMHHHH@Z ENDP			; Perlin::point
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?point@Perlin@@CAMMMMHHH@Z
_TEXT	SEGMENT
x$ = 32
y$ = 40
z$ = 48
i$ = 56
j$ = 64
k$ = 72
?point@Perlin@@CAMMMMHHH@Z PROC				; Perlin::point, COMDAT

; 223  : inline float Perlin::point(float x, float y, float z, int i, int j, int k) {

$LN18:
	sub	rsp, 24

; 224  : 	float t = 0.6f - x*x - y*y - z*z;

	vmovss	xmm3, DWORD PTR __real@3f19999a
	vmulss	xmm4, xmm0, xmm0
	vsubss	xmm5, xmm3, xmm4
	vmulss	xmm4, xmm1, xmm1
	vsubss	xmm4, xmm5, xmm4
	vmovaps	XMMWORD PTR [rsp], xmm6
	vmulss	xmm3, xmm2, xmm2
	vmovaps	xmm6, xmm0
	vsubss	xmm5, xmm4, xmm3
	vxorps	xmm0, xmm0, xmm0

; 225  : 	if(t < 0.0f) 

	vcomiss	xmm0, xmm5
	ja	SHORT $LN1@point

; 226  : 		return 0.0f;
; 227  : 	t *= t;
; 228  : 	return t * t * grad(perm[i+perm[j+perm[k]]], x, y, z);

	movsxd	rax, DWORD PTR k$[rsp]
	lea	rdx, OFFSET FLAT:?perm@@3PAEA
	vmulss	xmm3, xmm5, xmm5
	movzx	eax, BYTE PTR [rax+rdx]
	add	eax, DWORD PTR j$[rsp]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+rdx]
	add	eax, r9d
	movsxd	rcx, eax

; 82   :     int h = hash & 15;

	movzx	edx, BYTE PTR [rcx+rdx]
	and	edx, 15
	cmp	edx, 8

; 83   :     float i = h<8 ? x : y;

	jae	SHORT $LN6@point
	vmovaps	xmm0, xmm6
	jmp	SHORT $LN7@point
$LN6@point:
	vmovaps	xmm0, xmm1
$LN7@point:
	cmp	edx, 4

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jb	SHORT $LN9@point
	lea	eax, DWORD PTR [rdx-12]
	test	eax, -3					; fffffffdH
	je	SHORT $LN8@point
	vmovaps	xmm1, xmm2
	jmp	SHORT $LN9@point
$LN8@point:
	vmovaps	xmm1, xmm6
$LN9@point:

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	vmovss	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	test	dl, 1
	je	SHORT $LN12@point
	vxorps	xmm0, xmm0, xmm2
$LN12@point:
	test	dl, 2
	je	SHORT $LN14@point
	vxorps	xmm1, xmm1, xmm2
$LN14@point:
	vaddss	xmm1, xmm1, xmm0

; 226  : 		return 0.0f;
; 227  : 	t *= t;
; 228  : 	return t * t * grad(perm[i+perm[j+perm[k]]], x, y, z);

	vmulss	xmm0, xmm3, xmm3
	vmulss	xmm0, xmm1, xmm0
$LN1@point:

; 229  : }

	vmovaps	xmm6, XMMWORD PTR [rsp]
	add	rsp, 24
	ret	0
?point@Perlin@@CAMMMMHHH@Z ENDP				; Perlin::point
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?point@Perlin@@CAMMMHH@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
i$ = 24
j$ = 32
?point@Perlin@@CAMMMHH@Z PROC				; Perlin::point, COMDAT

; 216  :     float t = 0.5f - x*x - y*y;

	vmovss	xmm2, DWORD PTR __real@3f000000
	vmulss	xmm3, xmm0, xmm0
	vsubss	xmm4, xmm2, xmm3
	vmulss	xmm3, xmm1, xmm1
	vmovaps	xmm5, xmm0
	vsubss	xmm2, xmm4, xmm3
	vxorps	xmm0, xmm0, xmm0

; 217  :     if(t < 0.0f) 

	vcomiss	xmm0, xmm2
	ja	SHORT $LN1@point

; 218  : 		return 0.0f;
; 219  :     t *= t;
; 220  :     return t * t * grad(perm[i+perm[j]], x, y);

	lea	rdx, OFFSET FLAT:?perm@@3PAEA
	movsxd	rax, r9d
	vmulss	xmm3, xmm2, xmm2
	movzx	eax, BYTE PTR [rax+rdx]
	add	eax, r8d
	movsxd	rcx, eax

; 75   :     int h = hash & 7;

	movzx	eax, BYTE PTR [rcx+rdx]
	and	eax, 7
	cmp	eax, 4

; 76   :     float i = h<4 ? x : y;

	jae	SHORT $LN6@point
	vmovaps	xmm0, xmm5
	jmp	SHORT $LN7@point
$LN6@point:
	vmovaps	xmm0, xmm1
$LN7@point:
	cmp	eax, 4

; 77   :     float j = h<4 ? y : x;

	jb	SHORT $LN9@point
	vmovaps	xmm1, xmm5
$LN9@point:

; 78   :     return ((h&1)? -i : i) + ((h&2)? -2.f*j : 2.f*j);

	test	al, 1
	je	SHORT $LN11@point
	vxorps	xmm0, xmm0, DWORD PTR __xmm@80000000800000008000000080000000
$LN11@point:
	test	al, 2
	je	SHORT $LN12@point
	vmulss	xmm2, xmm1, DWORD PTR __real@c0000000
	vaddss	xmm1, xmm2, xmm0

; 218  : 		return 0.0f;
; 219  :     t *= t;
; 220  :     return t * t * grad(perm[i+perm[j]], x, y);

	vmulss	xmm0, xmm3, xmm3
	vmulss	xmm0, xmm1, xmm0

; 221  : }

	ret	0
$LN12@point:

; 78   :     return ((h&1)? -i : i) + ((h&2)? -2.f*j : 2.f*j);

	vaddss	xmm2, xmm1, xmm1
	vaddss	xmm1, xmm2, xmm0

; 218  : 		return 0.0f;
; 219  :     t *= t;
; 220  :     return t * t * grad(perm[i+perm[j]], x, y);

	vmulss	xmm0, xmm3, xmm3
	vmulss	xmm0, xmm1, xmm0
$LN1@point:

; 221  : }

	ret	0
?point@Perlin@@CAMMMHH@Z ENDP				; Perlin::point
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?point@Perlin@@CAMMH@Z
_TEXT	SEGMENT
x$ = 8
i$ = 16
?point@Perlin@@CAMMH@Z PROC				; Perlin::point, COMDAT

; 210  : 	float t = 1.0f - x*x;

	vmovss	xmm2, DWORD PTR __real@3f800000
	vmulss	xmm1, xmm0, xmm0

; 212  : 	return t * t * grad(perm[i & 255], x);

	movzx	ecx, dl
	lea	rax, OFFSET FLAT:?perm@@3PAEA
	vmovaps	xmm4, xmm0
	vsubss	xmm1, xmm2, xmm1
	vxorps	xmm0, xmm0, xmm0

; 68   :     int h = hash & 15;

	movzx	edx, BYTE PTR [rcx+rax]
	and	edx, 15

; 69   :     float grad = 1.0f + (h & 7);

	mov	eax, edx
	and	eax, 7
	vcvtsi2ss xmm0, xmm0, eax

; 211  : 	t *= t;

	vmulss	xmm3, xmm1, xmm1

; 69   :     float grad = 1.0f + (h & 7);

	vaddss	xmm1, xmm0, xmm2

; 70   :     if (h&8) grad = -grad;

	test	dl, 8
	je	SHORT $LN4@point
	vxorps	xmm1, xmm1, DWORD PTR __xmm@80000000800000008000000080000000
$LN4@point:

; 71   :     return ( grad * x );

	vmulss	xmm1, xmm1, xmm4

; 212  : 	return t * t * grad(perm[i & 255], x);

	vmulss	xmm0, xmm3, xmm3
	vmulss	xmm0, xmm1, xmm0

; 213  : }

	ret	0
?point@Perlin@@CAMMH@Z ENDP				; Perlin::point
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?grad@Perlin@@CAMHMMMM@Z
_TEXT	SEGMENT
hash$ = 8
x$ = 16
y$ = 24
z$ = 32
w$ = 40
?grad@Perlin@@CAMHMMMM@Z PROC				; Perlin::grad, COMDAT

; 89   : 	int h = hash & 31;

	and	ecx, 31
	cmp	ecx, 24

; 90   :     float i = h<24 ? x : y;

	jb	SHORT $LN4@grad
	vmovaps	xmm1, xmm2
$LN4@grad:
	cmp	ecx, 16

; 91   :     float j = h<16 ? y : z;

	jb	SHORT $LN6@grad
	vmovaps	xmm2, xmm3
$LN6@grad:
	cmp	ecx, 8

; 92   :     float k = h<8 ? z : w;

	jb	SHORT $LN8@grad
	vmovss	xmm3, DWORD PTR w$[rsp]
$LN8@grad:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	vmovss	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	test	cl, 1
	je	SHORT $LN10@grad
	vxorps	xmm1, xmm1, xmm0
$LN10@grad:
	test	cl, 2
	je	SHORT $LN12@grad
	vxorps	xmm2, xmm2, xmm0
$LN12@grad:
	test	cl, 4
	je	SHORT $LN14@grad
	vxorps	xmm3, xmm3, xmm0
$LN14@grad:
	vaddss	xmm0, xmm2, xmm1
	vaddss	xmm0, xmm0, xmm3

; 94   : }

	ret	0
?grad@Perlin@@CAMHMMMM@Z ENDP				; Perlin::grad
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?grad@Perlin@@CAMHMMM@Z
_TEXT	SEGMENT
hash$ = 8
x$ = 16
y$ = 24
z$ = 32
?grad@Perlin@@CAMHMMM@Z PROC				; Perlin::grad, COMDAT

; 82   :     int h = hash & 15;

	and	ecx, 15
	cmp	ecx, 8

; 83   :     float i = h<8 ? x : y;

	jae	SHORT $LN3@grad
	vmovaps	xmm4, xmm1
	jmp	SHORT $LN4@grad
$LN3@grad:
	vmovaps	xmm4, xmm2
$LN4@grad:
	cmp	ecx, 4

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jb	SHORT $LN6@grad
	lea	eax, DWORD PTR [rcx-12]
	test	eax, -3					; fffffffdH
	je	SHORT $LN5@grad
	vmovaps	xmm2, xmm3
	jmp	SHORT $LN6@grad
$LN5@grad:
	vmovaps	xmm2, xmm1
$LN6@grad:

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	vmovss	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	test	cl, 1
	je	SHORT $LN10@grad
	vxorps	xmm4, xmm4, xmm0
$LN10@grad:
	test	cl, 2
	je	SHORT $LN11@grad
	vxorps	xmm0, xmm2, xmm0
	vaddss	xmm0, xmm0, xmm4

; 86   : }

	ret	0
$LN11@grad:

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	vaddss	xmm0, xmm2, xmm4

; 86   : }

	ret	0
?grad@Perlin@@CAMHMMM@Z ENDP				; Perlin::grad
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?grad@Perlin@@CAMHMM@Z
_TEXT	SEGMENT
hash$ = 8
x$ = 16
y$ = 24
?grad@Perlin@@CAMHMM@Z PROC				; Perlin::grad, COMDAT

; 75   :     int h = hash & 7;

	and	ecx, 7
	cmp	ecx, 4

; 76   :     float i = h<4 ? x : y;

	jae	SHORT $LN3@grad
	vmovaps	xmm3, xmm1
	jmp	SHORT $LN4@grad
$LN3@grad:
	vmovaps	xmm3, xmm2
$LN4@grad:
	cmp	ecx, 4

; 77   :     float j = h<4 ? y : x;

	jb	SHORT $LN6@grad
	vmovaps	xmm2, xmm1
$LN6@grad:

; 78   :     return ((h&1)? -i : i) + ((h&2)? -2.f*j : 2.f*j);

	test	cl, 1
	je	SHORT $LN8@grad
	vxorps	xmm3, xmm3, DWORD PTR __xmm@80000000800000008000000080000000
$LN8@grad:
	test	cl, 2
	je	SHORT $LN9@grad
	vmulss	xmm0, xmm2, DWORD PTR __real@c0000000
	vaddss	xmm0, xmm0, xmm3

; 79   : }

	ret	0
$LN9@grad:

; 78   :     return ((h&1)? -i : i) + ((h&2)? -2.f*j : 2.f*j);

	vaddss	xmm0, xmm2, xmm2
	vaddss	xmm0, xmm0, xmm3

; 79   : }

	ret	0
?grad@Perlin@@CAMHMM@Z ENDP				; Perlin::grad
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?grad@Perlin@@CAMHM@Z
_TEXT	SEGMENT
hash$ = 8
x$ = 16
?grad@Perlin@@CAMHM@Z PROC				; Perlin::grad, COMDAT

; 68   :     int h = hash & 15;

	and	ecx, 15

; 69   :     float grad = 1.0f + (h & 7);

	mov	eax, ecx
	and	eax, 7
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vaddss	xmm2, xmm0, DWORD PTR __real@3f800000

; 70   :     if (h&8) grad = -grad;

	test	cl, 8
	je	SHORT $LN4@grad
	vxorps	xmm0, xmm2, DWORD PTR __xmm@80000000800000008000000080000000

; 71   :     return ( grad * x );

	vmulss	xmm0, xmm0, xmm1

; 72   : }

	ret	0
$LN4@grad:

; 71   :     return ( grad * x );

	vmulss	xmm0, xmm2, xmm1

; 72   : }

	ret	0
?grad@Perlin@@CAMHM@Z ENDP				; Perlin::grad
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?fsnoise4D@Perlin@@SAMMMMMM@Z
_TEXT	SEGMENT
x$ = 128
y$ = 136
z$ = 144
w$ = 152
d$ = 160
?fsnoise4D@Perlin@@SAMMMMMM@Z PROC			; Perlin::fsnoise4D, COMDAT

; 431  : float Perlin::fsnoise4D(float x, float y, float z, float w, float d) {

$LN7:
	sub	rsp, 120				; 00000078H

; 432  : 	FILTER(d)

	vmovss	xmm4, DWORD PTR d$[rsp]
	vmovaps	XMMWORD PTR [rsp+96], xmm6
	vmovaps	XMMWORD PTR [rsp+80], xmm7
	vmovaps	XMMWORD PTR [rsp+64], xmm8
	vmovaps	XMMWORD PTR [rsp+48], xmm9
	vmovaps	xmm9, xmm1
	vmovss	xmm1, DWORD PTR __real@3f99999a
	vmovaps	xmm8, xmm2
	vmovss	xmm2, DWORD PTR __real@400ccccd
	vmovaps	XMMWORD PTR [rsp+32], xmm10
	vmovaps	xmm10, xmm0
	vdivss	xmm0, xmm4, xmm1
	vmovaps	xmm7, xmm3
	call	?smooth@@YAMMMM@Z			; smooth
	vcomiss	xmm0, DWORD PTR __real@3f7ff972
	vmovaps	xmm6, xmm0
	jb	SHORT $LN2@fsnoise4D
	vxorps	xmm0, xmm0, xmm0
	jmp	SHORT $LN1@fsnoise4D
$LN2@fsnoise4D:

; 433  : 	return lerp2(d, snoise(x,y,z,w), 0.f);

	vmovaps	xmm3, xmm7
	vmovaps	xmm2, xmm8
	vmovaps	xmm1, xmm9
	vmovaps	xmm0, xmm10
	call	?snoise@Perlin@@SAMMMMM@Z		; Perlin::snoise
	vxorps	xmm1, xmm1, xmm1

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm2, xmm1, xmm0
	vmulss	xmm3, xmm2, xmm6
	vaddss	xmm0, xmm3, xmm0
$LN1@fsnoise4D:

; 434  : }	

	vmovaps	xmm6, XMMWORD PTR [rsp+96]
	vmovaps	xmm7, XMMWORD PTR [rsp+80]
	vmovaps	xmm8, XMMWORD PTR [rsp+64]
	vmovaps	xmm9, XMMWORD PTR [rsp+48]
	vmovaps	xmm10, XMMWORD PTR [rsp+32]
	add	rsp, 120				; 00000078H
	ret	0
?fsnoise4D@Perlin@@SAMMMMMM@Z ENDP			; Perlin::fsnoise4D
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?fsnoise3D@Perlin@@SAMMMMM@Z
_TEXT	SEGMENT
x$ = 112
y$ = 120
z$ = 128
d$ = 136
?fsnoise3D@Perlin@@SAMMMMM@Z PROC			; Perlin::fsnoise3D, COMDAT

; 426  : float Perlin::fsnoise3D(float x, float y, float z, float d) {

$LN7:
	sub	rsp, 104				; 00000068H
	vmovaps	XMMWORD PTR [rsp+80], xmm6
	vmovaps	XMMWORD PTR [rsp+64], xmm7
	vmovaps	XMMWORD PTR [rsp+48], xmm8
	vmovaps	xmm8, xmm1

; 427  : 	FILTER(d)

	vmovss	xmm1, DWORD PTR __real@3f99999a
	vmovaps	xmm7, xmm2
	vmovss	xmm2, DWORD PTR __real@400ccccd
	vmovaps	XMMWORD PTR [rsp+32], xmm9
	vmovaps	xmm9, xmm0
	vdivss	xmm0, xmm3, xmm1
	call	?smooth@@YAMMMM@Z			; smooth
	vcomiss	xmm0, DWORD PTR __real@3f7ff972
	vmovaps	xmm6, xmm0
	jb	SHORT $LN2@fsnoise3D
	vxorps	xmm0, xmm0, xmm0
	jmp	SHORT $LN1@fsnoise3D
$LN2@fsnoise3D:

; 428  : 	return lerp2(d, snoise(x,y,z), 0.f);

	vmovaps	xmm2, xmm7
	vmovaps	xmm1, xmm8
	vmovaps	xmm0, xmm9
	call	?snoise@Perlin@@SAMMMM@Z		; Perlin::snoise
	vxorps	xmm1, xmm1, xmm1

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm2, xmm1, xmm0
	vmulss	xmm3, xmm2, xmm6
	vaddss	xmm0, xmm3, xmm0
$LN1@fsnoise3D:

; 429  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+80]
	vmovaps	xmm7, XMMWORD PTR [rsp+64]
	vmovaps	xmm8, XMMWORD PTR [rsp+48]
	vmovaps	xmm9, XMMWORD PTR [rsp+32]
	add	rsp, 104				; 00000068H
	ret	0
?fsnoise3D@Perlin@@SAMMMMM@Z ENDP			; Perlin::fsnoise3D
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?fsnoise2D@Perlin@@SAMMMM@Z
_TEXT	SEGMENT
x$ = 96
y$ = 104
d$ = 112
?fsnoise2D@Perlin@@SAMMMM@Z PROC			; Perlin::fsnoise2D, COMDAT

; 421  : float Perlin::fsnoise2D(float x, float y, float d) {

$LN7:
	sub	rsp, 88					; 00000058H
	vmovaps	XMMWORD PTR [rsp+64], xmm6
	vmovaps	XMMWORD PTR [rsp+48], xmm7
	vmovaps	xmm7, xmm1

; 422  : 	FILTER(d)

	vmovss	xmm1, DWORD PTR __real@3f99999a
	vmovaps	XMMWORD PTR [rsp+32], xmm8
	vmovaps	xmm8, xmm0
	vdivss	xmm0, xmm2, xmm1
	vmovss	xmm2, DWORD PTR __real@400ccccd
	call	?smooth@@YAMMMM@Z			; smooth
	vcomiss	xmm0, DWORD PTR __real@3f7ff972
	vmovaps	xmm6, xmm0
	jb	SHORT $LN2@fsnoise2D
	vxorps	xmm0, xmm0, xmm0
	jmp	SHORT $LN1@fsnoise2D
$LN2@fsnoise2D:

; 423  : 	return lerp2(d, snoise(x,y), 0.f);

	vmovaps	xmm1, xmm7
	vmovaps	xmm0, xmm8
	call	?snoise@Perlin@@SAMMM@Z			; Perlin::snoise
	vxorps	xmm1, xmm1, xmm1

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm2, xmm1, xmm0
	vmulss	xmm3, xmm2, xmm6
	vaddss	xmm0, xmm3, xmm0
$LN1@fsnoise2D:

; 424  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+64]
	vmovaps	xmm7, XMMWORD PTR [rsp+48]
	vmovaps	xmm8, XMMWORD PTR [rsp+32]
	add	rsp, 88					; 00000058H
	ret	0
?fsnoise2D@Perlin@@SAMMMM@Z ENDP			; Perlin::fsnoise2D
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?fnoise4D@Perlin@@SAMMMMMM@Z
_TEXT	SEGMENT
x$ = 128
y$ = 136
z$ = 144
w$ = 152
d$ = 160
?fnoise4D@Perlin@@SAMMMMMM@Z PROC			; Perlin::fnoise4D, COMDAT

; 416  : float Perlin::fnoise4D(float x, float y, float z, float w, float d) {

$LN7:
	sub	rsp, 120				; 00000078H

; 417  : 	FILTER(d)

	vmovss	xmm4, DWORD PTR d$[rsp]
	vmovaps	XMMWORD PTR [rsp+96], xmm6
	vmovaps	XMMWORD PTR [rsp+80], xmm7
	vmovaps	XMMWORD PTR [rsp+64], xmm8
	vmovaps	XMMWORD PTR [rsp+48], xmm9
	vmovaps	xmm9, xmm1
	vmovss	xmm1, DWORD PTR __real@3f99999a
	vmovaps	xmm8, xmm2
	vmovss	xmm2, DWORD PTR __real@400ccccd
	vmovaps	XMMWORD PTR [rsp+32], xmm10
	vmovaps	xmm10, xmm0
	vdivss	xmm0, xmm4, xmm1
	vmovaps	xmm7, xmm3
	call	?smooth@@YAMMMM@Z			; smooth
	vcomiss	xmm0, DWORD PTR __real@3f7ff972
	vmovaps	xmm6, xmm0
	jb	SHORT $LN2@fnoise4D
	vxorps	xmm0, xmm0, xmm0
	jmp	SHORT $LN1@fnoise4D
$LN2@fnoise4D:

; 418  : 	return lerp2(d, noise(x,y,z,w), 0.f);

	vmovaps	xmm3, xmm7
	vmovaps	xmm2, xmm8
	vmovaps	xmm1, xmm9
	vmovaps	xmm0, xmm10
	call	?noise@Perlin@@SAMMMMM@Z		; Perlin::noise
	vxorps	xmm1, xmm1, xmm1

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm2, xmm1, xmm0
	vmulss	xmm3, xmm2, xmm6
	vaddss	xmm0, xmm3, xmm0
$LN1@fnoise4D:

; 419  : }	

	vmovaps	xmm6, XMMWORD PTR [rsp+96]
	vmovaps	xmm7, XMMWORD PTR [rsp+80]
	vmovaps	xmm8, XMMWORD PTR [rsp+64]
	vmovaps	xmm9, XMMWORD PTR [rsp+48]
	vmovaps	xmm10, XMMWORD PTR [rsp+32]
	add	rsp, 120				; 00000078H
	ret	0
?fnoise4D@Perlin@@SAMMMMMM@Z ENDP			; Perlin::fnoise4D
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?fnoise3D@Perlin@@SAMMMMM@Z
_TEXT	SEGMENT
x$ = 112
y$ = 120
z$ = 128
d$ = 136
?fnoise3D@Perlin@@SAMMMMM@Z PROC			; Perlin::fnoise3D, COMDAT

; 411  : float Perlin::fnoise3D(float x, float y, float z, float d) {

$LN7:
	sub	rsp, 104				; 00000068H
	vmovaps	XMMWORD PTR [rsp+80], xmm6
	vmovaps	XMMWORD PTR [rsp+64], xmm7
	vmovaps	XMMWORD PTR [rsp+48], xmm8
	vmovaps	xmm8, xmm1

; 412  : 	FILTER(d)

	vmovss	xmm1, DWORD PTR __real@3f99999a
	vmovaps	xmm7, xmm2
	vmovss	xmm2, DWORD PTR __real@400ccccd
	vmovaps	XMMWORD PTR [rsp+32], xmm9
	vmovaps	xmm9, xmm0
	vdivss	xmm0, xmm3, xmm1
	call	?smooth@@YAMMMM@Z			; smooth
	vcomiss	xmm0, DWORD PTR __real@3f7ff972
	vmovaps	xmm6, xmm0
	jb	SHORT $LN2@fnoise3D
	vxorps	xmm0, xmm0, xmm0
	jmp	SHORT $LN1@fnoise3D
$LN2@fnoise3D:

; 413  : 	return lerp2(d, noise(x,y,z), 0.f);

	vmovaps	xmm2, xmm7
	vmovaps	xmm1, xmm8
	vmovaps	xmm0, xmm9
	call	?noise@Perlin@@SAMMMM@Z			; Perlin::noise
	vxorps	xmm1, xmm1, xmm1

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm2, xmm1, xmm0
	vmulss	xmm3, xmm2, xmm6
	vaddss	xmm0, xmm3, xmm0
$LN1@fnoise3D:

; 414  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+80]
	vmovaps	xmm7, XMMWORD PTR [rsp+64]
	vmovaps	xmm8, XMMWORD PTR [rsp+48]
	vmovaps	xmm9, XMMWORD PTR [rsp+32]
	add	rsp, 104				; 00000068H
	ret	0
?fnoise3D@Perlin@@SAMMMMM@Z ENDP			; Perlin::fnoise3D
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?fnoise2D@Perlin@@SAMMMM@Z
_TEXT	SEGMENT
x$ = 96
y$ = 104
d$ = 112
?fnoise2D@Perlin@@SAMMMM@Z PROC				; Perlin::fnoise2D, COMDAT

; 406  : float Perlin::fnoise2D(float x, float y, float d) {

$LN7:
	sub	rsp, 88					; 00000058H
	vmovaps	XMMWORD PTR [rsp+64], xmm6
	vmovaps	XMMWORD PTR [rsp+48], xmm7
	vmovaps	xmm7, xmm1

; 407  : 	FILTER(d)

	vmovss	xmm1, DWORD PTR __real@3f99999a
	vmovaps	XMMWORD PTR [rsp+32], xmm8
	vmovaps	xmm8, xmm0
	vdivss	xmm0, xmm2, xmm1
	vmovss	xmm2, DWORD PTR __real@400ccccd
	call	?smooth@@YAMMMM@Z			; smooth
	vcomiss	xmm0, DWORD PTR __real@3f7ff972
	vmovaps	xmm6, xmm0
	jb	SHORT $LN2@fnoise2D
	vxorps	xmm0, xmm0, xmm0
	jmp	SHORT $LN1@fnoise2D
$LN2@fnoise2D:

; 408  : 	return lerp2(d, noise(x,y), 0.f);

	vmovaps	xmm1, xmm7
	vmovaps	xmm0, xmm8
	call	?noise@Perlin@@SAMMM@Z			; Perlin::noise
	vxorps	xmm1, xmm1, xmm1

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm2, xmm1, xmm0
	vmulss	xmm3, xmm2, xmm6
	vaddss	xmm0, xmm3, xmm0
$LN1@fnoise2D:

; 409  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+64]
	vmovaps	xmm7, XMMWORD PTR [rsp+48]
	vmovaps	xmm8, XMMWORD PTR [rsp+32]
	add	rsp, 88					; 00000058H
	ret	0
?fnoise2D@Perlin@@SAMMMM@Z ENDP				; Perlin::fnoise2D
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?snoise@Perlin@@SAMMMMM@Z
_TEXT	SEGMENT
j3$1$ = 64
l1$1$ = 256
x$ = 256
l2$1$ = 264
y$ = 264
k2$1$ = 272
z$ = 272
k3$1$ = 280
w$ = 280
?snoise@Perlin@@SAMMMMM@Z PROC				; Perlin::snoise, COMDAT

; 331  : float Perlin::snoise(float x, float y, float z, float w) {

$LN16:
	mov	rax, rsp
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 184				; 000000b8H
	vmovaps	XMMWORD PTR [rax-88], xmm6
	vmovaps	XMMWORD PTR [rax-104], xmm7
	vmovaps	XMMWORD PTR [rax-120], xmm8
	vmovaps	XMMWORD PTR [rsp+112], xmm9

; 332  :   
; 333  : 	#define F4 0.309016994f // F4 = (Math.sqrt(5.0)-1.0)/4.0
; 334  : 	#define G4 0.138196601f // G4 = (5.0-Math.sqrt(5.0))/20.0
; 335  : 	#define G4a (G4*2.f)
; 336  : 	#define G4b (G4*3.f)
; 337  : 	#define G4c (G4*4.f-1.f)
; 338  : 
; 339  :     float s = (x + y + z + w) * F4;

	vaddss	xmm4, xmm0, xmm1
	vmovaps	XMMWORD PTR [rsp+96], xmm10
	vmovaps	xmm10, xmm2
	vaddss	xmm5, xmm4, xmm10
	vaddss	xmm4, xmm5, xmm3
	vmulss	xmm5, xmm4, DWORD PTR __real@3e9e377a

; 340  :     float xs = x + s;

	vaddss	xmm8, xmm5, xmm0
	vxorps	xmm4, xmm4, xmm4

; 341  :     float ys = y + s;
; 342  :     float zs = z + s;
; 343  :     float ws = w + s;
; 344  :     int i = FASTFLOOR(xs);

	vcomiss	xmm4, xmm8
	vmovaps	XMMWORD PTR [rsp+80], xmm11
	vaddss	xmm6, xmm5, xmm1
	vaddss	xmm7, xmm5, xmm10
	vmovaps	xmm9, xmm3
	vmovaps	xmm11, xmm1
	vmovaps	xmm2, xmm0
	vaddss	xmm5, xmm5, xmm3
	vcvttss2si r14d, xmm8
	jbe	SHORT $LN4@snoise
	dec	r14d
$LN4@snoise:

; 345  :     int j = FASTFLOOR(ys);

	vcomiss	xmm4, xmm6
	vcvttss2si esi, xmm6
	jbe	SHORT $LN6@snoise
	dec	esi
$LN6@snoise:

; 346  :     int k = FASTFLOOR(zs);

	vcomiss	xmm4, xmm7
	vcvttss2si edi, xmm7
	jbe	SHORT $LN8@snoise
	dec	edi
$LN8@snoise:

; 347  :     int l = FASTFLOOR(ws);

	vcomiss	xmm4, xmm5
	vcvttss2si ebx, xmm5
	jbe	SHORT $LN10@snoise
	dec	ebx
$LN10@snoise:

; 348  : 
; 349  :     float t = (i + j + k + l) * G4;

	vmovss	xmm6, DWORD PTR __real@3e0d8369

; 350  :     float X0 = i - t; 
; 351  :     float Y0 = j - t;
; 352  :     float Z0 = k - t;
; 353  :     float W0 = l - t;
; 354  : 
; 355  :     float x0 = x - X0;
; 356  :     float y0 = y - Y0;
; 357  :     float z0 = z - Z0;
; 358  :     float w0 = w - W0;
; 359  : 
; 360  :     int c1 = (x0 > y0) ? 32 : 0;
; 361  :     int c2 = (x0 > z0) ? 16 : 0;
; 362  :     int c3 = (y0 > z0) ? 8 : 0;
; 363  :     int c4 = (x0 > w0) ? 4 : 0;
; 364  :     int c5 = (y0 > w0) ? 2 : 0;
; 365  :     int c6 = (z0 > w0) ? 1 : 0;

	xor	ebp, ebp
	lea	eax, DWORD PTR [rbx+rdi]
	add	eax, esi

; 366  :     int c = c1 + c2 + c3 + c4 + c5 + c6;
; 367  : 
; 368  :     int i1, j1, k1, l1;
; 369  :     int i2, j2, k2, l2;
; 370  :     int i3, j3, k3, l3;
; 371  : 
; 372  :     i1 = simplex[c][0]>=3 ? 1 : 0; i2 = simplex[c][0]>=2 ? 1 : 0; i3 = simplex[c][0]>=1 ? 1 : 0;

	lea	r8, OFFSET FLAT:?simplex@@3PAY03EA
	add	eax, r14d
	mov	ecx, ebp
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vmulss	xmm3, xmm0, xmm6
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, r14d
	vsubss	xmm1, xmm0, xmm3
	vsubss	xmm8, xmm2, xmm1
	mov	edx, 2
	mov	eax, ebp
	vxorps	xmm2, xmm2, xmm2
	vcvtsi2ss xmm2, xmm2, esi
	vsubss	xmm0, xmm2, xmm3
	vsubss	xmm11, xmm11, xmm0
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, edi
	vsubss	xmm2, xmm1, xmm3
	vsubss	xmm10, xmm10, xmm2
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, ebx
	vsubss	xmm1, xmm0, xmm3
	vsubss	xmm9, xmm9, xmm1
	vcomiss	xmm10, xmm9
	mov	r9d, ebp
	mov	r15d, ebp
	seta	cl
	mov	r12d, ebp
	vcomiss	xmm11, xmm9

; 373  :     j1 = simplex[c][1]>=3 ? 1 : 0; j2 = simplex[c][1]>=2 ? 1 : 0; j3 = simplex[c][1]>=1 ? 1 : 0;

	mov	r10d, ebp
	mov	r13d, ebp
	cmova	eax, edx

; 374  :     k1 = simplex[c][2]>=3 ? 1 : 0; k2 = simplex[c][2]>=2 ? 1 : 0; k3 = simplex[c][2]>=1 ? 1 : 0;

	mov	r11d, ebp
	add	ecx, eax
	mov	edx, 4
	vcomiss	xmm8, xmm9
	mov	eax, ebp
	cmova	eax, edx
	mov	edx, 8
	add	ecx, eax
	mov	eax, ebp
	vcomiss	xmm11, xmm10
	cmova	eax, edx
	mov	edx, 16
	add	ecx, eax
	mov	eax, ebp
	vcomiss	xmm8, xmm10
	cmova	eax, edx
	mov	edx, 32					; 00000020H
	add	ecx, eax
	mov	eax, ebp
	vcomiss	xmm8, xmm11
	cmova	eax, edx
	add	ecx, eax
	mov	edx, ecx
	movzx	eax, BYTE PTR [r8+rcx*4]
	cmp	al, 3
	setae	r9b
	cmp	al, 2
	setae	r15b
	cmp	al, 1
	movzx	eax, BYTE PTR [r8+rcx*4+1]
	mov	ecx, ebp
	setae	r12b
	cmp	al, 3
	setae	r10b
	cmp	al, 2
	setae	r13b
	cmp	al, 1
	movzx	eax, BYTE PTR [r8+rdx*4+2]
	setae	cl
	cmp	al, 3
	mov	DWORD PTR j3$1$[rsp], ecx
	mov	ecx, ebp
	setae	r11b
	cmp	al, 2
	setae	cl
	cmp	al, 1
	movzx	eax, BYTE PTR [r8+rdx*4+3]

; 375  :     l1 = simplex[c][3]>=3 ? 1 : 0; l2 = simplex[c][3]>=2 ? 1 : 0; l3 = simplex[c][3]>=1 ? 1 : 0;

	mov	edx, ebp
	mov	DWORD PTR k2$1$[rsp], ecx
	mov	ecx, ebp
	setae	cl
	cmp	al, 3
	mov	DWORD PTR k3$1$[rsp], ecx
	mov	ecx, ebp
	setae	cl
	cmp	al, 2
	mov	DWORD PTR l1$1$[rsp], ecx
	setae	dl
	cmp	al, 1
	mov	DWORD PTR l2$1$[rsp], edx
	setae	bpl

; 381  : 
; 382  :     int ii = i % 256;

	and	r14d, -2147483393			; ffffffff800000ffH
	jge	SHORT $LN14@snoise
	dec	r14d
	or	r14d, -256				; ffffffffffffff00H
	inc	r14d
$LN14@snoise:

; 383  :     int jj = j % 256;

	and	esi, -2147483393			; ffffffff800000ffH
	jge	SHORT $LN13@snoise
	dec	esi
	or	esi, -256				; ffffffffffffff00H
	inc	esi
$LN13@snoise:

; 384  :     int kk = k % 256;

	and	edi, -2147483393			; ffffffff800000ffH
	jge	SHORT $LN12@snoise
	dec	edi
	or	edi, -256				; ffffffffffffff00H
	inc	edi
$LN12@snoise:

; 385  :     int ll = l % 256;

	and	ebx, -2147483393			; ffffffff800000ffH
	jge	SHORT $LN11@snoise
	dec	ebx
	or	ebx, -256				; ffffffffffffff00H
	inc	ebx
$LN11@snoise:

; 376  : 
; 377  : 	float x1 = x0 - i1 + G4,  x2 = x0 - i2 + G4a,  x3 = x0 - i3 + G4b,  x4 = x0 + G4c;
; 378  :     float y1 = y0 - j1 + G4,  y2 = y0 - j2 + G4a,  y3 = y0 - j3 + G4b,  y4 = y0 + G4c;
; 379  :     float z1 = z0 - k1 + G4,  z2 = z0 - k2 + G4a,  z3 = z0 - k3 + G4b,  z4 = z0 + G4c;
; 380  :     float w1 = w0 - l1 + G4,  w2 = w0 - l2 + G4a,  w3 = w0 - l3 + G4b,  w4 = w0 + G4c;

	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, DWORD PTR l1$1$[rsp]
	vsubss	xmm1, xmm9, xmm0
	vaddss	xmm3, xmm1, xmm6
	vxorps	xmm2, xmm2, xmm2
	vcvtsi2ss xmm2, xmm2, r11d
	vsubss	xmm0, xmm10, xmm2
	vaddss	xmm2, xmm0, xmm6
	vxorps	xmm0, xmm0, xmm0
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm0, xmm0, r9d

; 386  : 
; 387  : 	return 27.0f * (point(x0, y0, z0, w0, ii,    jj,    kk,    ll) +

	lea	eax, DWORD PTR [rbx+rcx]
	mov	DWORD PTR [rsp+56], eax
	lea	ecx, DWORD PTR [rdi+r11]
	vcvtsi2ss xmm1, xmm1, r10d
	mov	DWORD PTR [rsp+48], ecx
	lea	edx, DWORD PTR [rsi+r10]
	vsubss	xmm5, xmm8, xmm0
	vsubss	xmm4, xmm11, xmm1
	lea	r8d, DWORD PTR [r14+r9]
	mov	DWORD PTR [rsp+40], edx
	vaddss	xmm0, xmm5, xmm6
	vaddss	xmm1, xmm4, xmm6
	mov	DWORD PTR [rsp+32], r8d
	call	?point@Perlin@@CAMMMMMHHHH@Z		; Perlin::point
	mov	DWORD PTR [rsp+56], ebx
	vmovaps	xmm6, xmm0
	mov	DWORD PTR [rsp+48], edi
	mov	DWORD PTR [rsp+40], esi
	vmovaps	xmm0, xmm8
	vmovaps	xmm3, xmm9
	vmovaps	xmm2, xmm10
	vmovaps	xmm1, xmm11
	mov	DWORD PTR [rsp+32], r14d
	call	?point@Perlin@@CAMMMMMHHHH@Z		; Perlin::point
	mov	r10d, DWORD PTR l2$1$[rsp]
	lea	edx, DWORD PTR [rsi+r13]
	mov	r9d, DWORD PTR k2$1$[rsp]
	lea	r8d, DWORD PTR [r14+r15]
	vaddss	xmm7, xmm6, xmm0
	vmovss	xmm6, DWORD PTR __real@3e8d8369
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, r10d
	vsubss	xmm1, xmm9, xmm0
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, r9d
	vxorps	xmm4, xmm4, xmm4
	vaddss	xmm3, xmm1, xmm6
	vsubss	xmm1, xmm10, xmm0
	vcvtsi2ss xmm4, xmm4, r13d
	vsubss	xmm0, xmm11, xmm4
	vxorps	xmm5, xmm5, xmm5
	lea	eax, DWORD PTR [rbx+r10]
	mov	DWORD PTR [rsp+56], eax
	lea	ecx, DWORD PTR [rdi+r9]
	mov	DWORD PTR [rsp+48], ecx
	vcvtsi2ss xmm5, xmm5, r15d
	vaddss	xmm2, xmm1, xmm6
	vsubss	xmm4, xmm8, xmm5
	vaddss	xmm1, xmm0, xmm6
	mov	DWORD PTR [rsp+40], edx
	vaddss	xmm0, xmm4, xmm6
	mov	DWORD PTR [rsp+32], r8d
	call	?point@Perlin@@CAMMMMMHHHH@Z		; Perlin::point
	mov	r10d, DWORD PTR k3$1$[rsp]
	lea	eax, DWORD PTR [rbx+rbp]
	vmovss	xmm6, DWORD PTR __real@3ed4451e
	mov	r9d, DWORD PTR j3$1$[rsp]
	lea	r8d, DWORD PTR [r14+r12]
	vaddss	xmm7, xmm7, xmm0
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, ebp
	vsubss	xmm1, xmm9, xmm0
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, r10d
	vaddss	xmm3, xmm1, xmm6
	vsubss	xmm1, xmm10, xmm0
	vaddss	xmm2, xmm1, xmm6
	lea	ecx, DWORD PTR [rdi+r10]
	lea	edx, DWORD PTR [rsi+r9]
	vxorps	xmm4, xmm4, xmm4
	mov	DWORD PTR [rsp+56], eax
	vcvtsi2ss xmm4, xmm4, r9d
	vsubss	xmm0, xmm11, xmm4
	mov	DWORD PTR [rsp+48], ecx
	vxorps	xmm5, xmm5, xmm5
	vcvtsi2ss xmm5, xmm5, r12d
	vsubss	xmm4, xmm8, xmm5
	vaddss	xmm1, xmm0, xmm6
	mov	DWORD PTR [rsp+40], edx
	vaddss	xmm0, xmm4, xmm6
	mov	DWORD PTR [rsp+32], r8d
	call	?point@Perlin@@CAMMMMMHHHH@Z		; Perlin::point
	vaddss	xmm6, xmm7, xmm0
	vmovss	xmm0, DWORD PTR __real@3ee4f92e
	lea	eax, DWORD PTR [rbx+1]
	mov	DWORD PTR [rsp+56], eax
	lea	ecx, DWORD PTR [rdi+1]
	mov	DWORD PTR [rsp+48], ecx
	lea	edx, DWORD PTR [rsi+1]
	vsubss	xmm3, xmm9, xmm0
	vsubss	xmm2, xmm10, xmm0
	vsubss	xmm1, xmm11, xmm0
	lea	r8d, DWORD PTR [r14+1]
	mov	DWORD PTR [rsp+40], edx
	vsubss	xmm0, xmm8, xmm0
	mov	DWORD PTR [rsp+32], r8d
	call	?point@Perlin@@CAMMMMMHHHH@Z		; Perlin::point

; 388  : 					point(x1, y1, z1, w1, ii+i1, jj+j1, kk+k1, ll+l1) +
; 389  : 					point(x2, y2, z2, w2, ii+i2, jj+j2, kk+k2, ll+l2) +
; 390  : 					point(x3, y3, z3, w3, ii+i3, jj+j3, kk+k3, ll+l3) +
; 391  : 					point(x4, y4, z4, w4, ii+1,  jj+1,  kk+1,  ll+1));
; 392  : }

	lea	r11, QWORD PTR [rsp+184]
	vmovaps	xmm7, XMMWORD PTR [r11-40]
	vmovaps	xmm8, XMMWORD PTR [r11-56]
	vmovaps	xmm9, XMMWORD PTR [r11-72]
	vmovaps	xmm10, XMMWORD PTR [r11-88]
	vmovaps	xmm11, XMMWORD PTR [r11-104]
	vaddss	xmm1, xmm6, xmm0
	vmulss	xmm0, xmm1, DWORD PTR __real@41d80000
	vmovaps	xmm6, XMMWORD PTR [r11-24]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?snoise@Perlin@@SAMMMMM@Z ENDP				; Perlin::snoise
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?snoise@Perlin@@SAMMMM@Z
_TEXT	SEGMENT
x$ = 160
y$ = 168
z$ = 176
?snoise@Perlin@@SAMMMM@Z PROC				; Perlin::snoise, COMDAT

; 281  : float Perlin::snoise(float x, float y, float z) {

$LN24:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 128				; 00000080H
	vmovaps	XMMWORD PTR [rax-40], xmm6
	vmovaps	XMMWORD PTR [rax-56], xmm7
	vmovaps	xmm7, xmm2
	vmovaps	XMMWORD PTR [rax-72], xmm8
	vmovaps	XMMWORD PTR [rax-88], xmm9

; 282  : 
; 283  : 	#define F3 0.333333333f
; 284  : 	#define G3 0.166666667f
; 285  : 	#define G3a	(2.0f * G3)
; 286  : 	#define G3b (3.0f * G3 - 1.0f)
; 287  : 
; 288  :     float s = (x+y+z)*F3;

	vaddss	xmm3, xmm0, xmm1
	vaddss	xmm4, xmm3, xmm7
	vmovaps	XMMWORD PTR [rax-104], xmm10
	vmovss	xmm10, DWORD PTR __real@3eaaaaab
	vmulss	xmm5, xmm4, xmm10

; 289  :     float xs = x+s;

	vaddss	xmm6, xmm5, xmm0

; 290  :     float ys = y+s;

	vaddss	xmm3, xmm5, xmm1

; 291  :     float zs = z+s;

	vaddss	xmm4, xmm5, xmm7
	vxorps	xmm5, xmm5, xmm5

; 292  :     int i = FASTFLOOR(xs);

	vcomiss	xmm5, xmm6
	vmovaps	xmm9, xmm1
	vmovaps	xmm2, xmm0
	vcvttss2si esi, xmm6
	jbe	SHORT $LN14@snoise
	dec	esi
$LN14@snoise:

; 293  :     int j = FASTFLOOR(ys);

	vcomiss	xmm5, xmm3
	vcvttss2si edi, xmm3
	jbe	SHORT $LN16@snoise
	dec	edi
$LN16@snoise:

; 294  :     int k = FASTFLOOR(zs);

	vcomiss	xmm5, xmm4
	vcvttss2si ebx, xmm4
	jbe	SHORT $LN18@snoise
	dec	ebx
$LN18@snoise:

; 295  : 
; 296  :     float t = (float)(i+j+k)*G3; 

	vmovss	xmm5, DWORD PTR __real@3e2aaaab
	vxorps	xmm0, xmm0, xmm0
	lea	eax, DWORD PTR [rbx+rdi]
	add	eax, esi
	vcvtsi2ss xmm0, xmm0, eax
	vmulss	xmm3, xmm0, xmm5
	vxorps	xmm0, xmm0, xmm0

; 297  :     float X0 = i-t;

	vcvtsi2ss xmm0, xmm0, esi
	vsubss	xmm1, xmm0, xmm3

; 298  :     float Y0 = j-t;
; 299  :     float Z0 = k-t;
; 300  :     float x0 = x-X0;

	vsubss	xmm8, xmm2, xmm1
	vxorps	xmm2, xmm2, xmm2
	vcvtsi2ss xmm2, xmm2, edi
	vsubss	xmm0, xmm2, xmm3
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, ebx

; 301  :     float y0 = y-Y0;

	vsubss	xmm9, xmm9, xmm0

; 302  :     float z0 = z-Z0;
; 303  : 
; 304  :     int i1, j1, k1;
; 305  :     int i2, j2, k2;
; 306  : 
; 307  :     if(x0>=y0) {

	vcomiss	xmm8, xmm9
	vsubss	xmm2, xmm1, xmm3
	vsubss	xmm7, xmm7, xmm2
	jb	SHORT $LN2@snoise

; 308  : 		if(y0>=z0)		{ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }

	vcomiss	xmm9, xmm7
	jb	SHORT $LN4@snoise
	mov	edx, 1
	xor	r8d, r8d
	xor	r14d, r14d
	mov	ebp, edx
	xor	r10d, r10d
	mov	r15d, edx

; 311  : 	} else {

	jmp	SHORT $LN11@snoise
$LN4@snoise:

; 309  :         else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }

	vcomiss	xmm8, xmm7
	jb	SHORT $LN6@snoise
	mov	edx, 1
	xor	r8d, r8d

; 310  :         else			{ i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }

	xor	ebp, ebp
	mov	r14d, edx
	xor	r10d, r10d
	mov	r15d, edx

; 311  : 	} else {

	jmp	SHORT $LN11@snoise
$LN6@snoise:

; 310  :         else			{ i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }

	mov	r8d, 1
	xor	edx, edx
	xor	ebp, ebp
	mov	r14d, r8d
	xor	r10d, r10d
	mov	r15d, r8d

; 311  : 	} else {

	jmp	SHORT $LN11@snoise
$LN2@snoise:

; 312  : 		if(y0<z0)		{ i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }

	xor	edx, edx
	vcomiss	xmm7, xmm9
	jbe	SHORT $LN8@snoise
	mov	r8d, 1
	xor	r10d, r10d
	xor	r15d, r15d
	mov	ebp, r8d
	mov	r14d, r8d
	jmp	SHORT $LN11@snoise
$LN8@snoise:

; 313  : 		else if(x0<z0)	{ i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }

	xor	r8d, r8d
	mov	r10d, 1
	vcomiss	xmm7, xmm8
	mov	ebp, r10d
	jbe	SHORT $LN10@snoise
	xor	r15d, r15d
	mov	r14d, r10d
	jmp	SHORT $LN11@snoise
$LN10@snoise:

; 314  : 		else			{ i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }

	mov	r15d, ebp
	xor	r14d, r14d
$LN11@snoise:

; 320  : 
; 321  :     int ii = i % 256;

	and	esi, -2147483393			; ffffffff800000ffH
	jge	SHORT $LN21@snoise
	dec	esi
	or	esi, -256				; ffffffffffffff00H
	inc	esi
$LN21@snoise:

; 322  :     int jj = j % 256;

	and	edi, -2147483393			; ffffffff800000ffH
	jge	SHORT $LN20@snoise
	dec	edi
	or	edi, -256				; ffffffffffffff00H
	inc	edi
$LN20@snoise:

; 323  :     int kk = k % 256;

	and	ebx, -2147483393			; ffffffff800000ffH
	jge	SHORT $LN19@snoise
	dec	ebx
	or	ebx, -256				; ffffffffffffff00H
	inc	ebx
$LN19@snoise:

; 315  :     }
; 316  : 
; 317  :     float x1 = x0 - i1 + G3,  x2 = x0 - i2 + G3a,  x3 = x0 + G3b;
; 318  :     float y1 = y0 - j1 + G3,  y2 = y0 - j2 + G3a,  y3 = y0 + G3b;
; 319  :     float z1 = z0 - k1 + G3,  z2 = z0 - k2 + G3a,  z3 = z0 + G3b;

	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, r8d
	vsubss	xmm1, xmm7, xmm0
	vxorps	xmm3, xmm3, xmm3
	vcvtsi2ss xmm3, xmm3, r10d
	vsubss	xmm0, xmm9, xmm3
	vxorps	xmm4, xmm4, xmm4
	vcvtsi2ss xmm4, xmm4, edx
	vaddss	xmm2, xmm1, xmm5
	vsubss	xmm3, xmm8, xmm4

; 324  : 
; 325  : 	return 32.0f * (point(x0, y0, z0, ii,    jj,    kk) +

	lea	eax, DWORD PTR [rbx+r8]
	vaddss	xmm1, xmm0, xmm5
	lea	ecx, DWORD PTR [rdi+r10]
	mov	DWORD PTR [rsp+40], eax
	vaddss	xmm0, xmm3, xmm5
	lea	r9d, DWORD PTR [rsi+rdx]
	mov	DWORD PTR [rsp+32], ecx
	call	?point@Perlin@@CAMMMMHHH@Z		; Perlin::point
	vmovaps	xmm6, xmm0
	vmovaps	xmm0, xmm8
	mov	DWORD PTR [rsp+40], ebx
	mov	r9d, esi
	vmovaps	xmm2, xmm7
	vmovaps	xmm1, xmm9
	mov	DWORD PTR [rsp+32], edi
	call	?point@Perlin@@CAMMMMHHH@Z		; Perlin::point
	vaddss	xmm6, xmm6, xmm0
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, r14d
	vsubss	xmm1, xmm7, xmm0
	vxorps	xmm3, xmm3, xmm3
	vcvtsi2ss xmm3, xmm3, ebp
	vsubss	xmm0, xmm9, xmm3
	vxorps	xmm4, xmm4, xmm4
	vcvtsi2ss xmm4, xmm4, r15d
	vaddss	xmm2, xmm1, xmm10
	vsubss	xmm3, xmm8, xmm4
	lea	eax, DWORD PTR [rbx+r14]
	vaddss	xmm1, xmm0, xmm10
	lea	ecx, DWORD PTR [rdi+rbp]
	mov	DWORD PTR [rsp+40], eax
	vaddss	xmm0, xmm3, xmm10
	lea	r9d, DWORD PTR [rsi+r15]
	mov	DWORD PTR [rsp+32], ecx
	call	?point@Perlin@@CAMMMMHHH@Z		; Perlin::point
	vaddss	xmm6, xmm6, xmm0
	vmovss	xmm0, DWORD PTR __real@3f000000
	lea	eax, DWORD PTR [rbx+1]
	vsubss	xmm2, xmm7, xmm0
	vsubss	xmm1, xmm9, xmm0
	lea	ecx, DWORD PTR [rdi+1]
	mov	DWORD PTR [rsp+40], eax
	vsubss	xmm0, xmm8, xmm0
	lea	r9d, DWORD PTR [rsi+1]
	mov	DWORD PTR [rsp+32], ecx
	call	?point@Perlin@@CAMMMMHHH@Z		; Perlin::point

; 326  : 					point(x1, y1, z1, ii+i1, jj+j1, kk+k1) +
; 327  : 					point(x2, y2, z2, ii+i2, jj+j2, kk+k2) +
; 328  : 					point(x3, y3, z3, ii+1,  jj+1,  kk+1));
; 329  : }

	vmovaps	xmm7, XMMWORD PTR [rsp+96]
	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm9, XMMWORD PTR [r11-64]
	vmovaps	xmm10, XMMWORD PTR [r11-80]
	vaddss	xmm1, xmm6, xmm0
	vmulss	xmm0, xmm1, DWORD PTR __real@42000000
	vmovaps	xmm6, XMMWORD PTR [rsp+112]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?snoise@Perlin@@SAMMMM@Z ENDP				; Perlin::snoise
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?snoise@Perlin@@SAMMM@Z
_TEXT	SEGMENT
x$ = 96
y$ = 104
?snoise@Perlin@@SAMMM@Z PROC				; Perlin::snoise, COMDAT

; 249  : float Perlin::snoise(float x, float y) {

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 80					; 00000050H
	vmovaps	XMMWORD PTR [rsp+64], xmm6

; 250  : 
; 251  : 	#define F2 0.366025403f // F2 = 0.5*(sqrt(3.0)-1.0)
; 252  : 	#define G2 0.211324865f // G2 = (3.0-Math.sqrt(3.0))/6.0
; 253  : 
; 254  :     float s = (x+y)*F2;

	vaddss	xmm2, xmm0, xmm1
	vmulss	xmm3, xmm2, DWORD PTR __real@3ebb67ae

; 255  :     float xs = x + s;

	vaddss	xmm5, xmm3, xmm0
	vmovaps	XMMWORD PTR [rsp+48], xmm7
	vmovaps	xmm7, xmm0
	vxorps	xmm0, xmm0, xmm0

; 256  :     float ys = y + s;
; 257  :     int i = FASTFLOOR(xs);

	vcomiss	xmm0, xmm5
	vmovaps	XMMWORD PTR [rsp+32], xmm8
	vmovaps	xmm6, xmm1
	vaddss	xmm4, xmm3, xmm1
	vcvttss2si edi, xmm5
	jbe	SHORT $LN6@snoise
	dec	edi
$LN6@snoise:

; 258  :     int j = FASTFLOOR(ys);

	vcomiss	xmm0, xmm4
	vcvttss2si ebx, xmm4
	jbe	SHORT $LN8@snoise
	dec	ebx
$LN8@snoise:

; 259  : 
; 260  :     float t = (float)(i+j)*G2;

	vmovss	xmm4, DWORD PTR __real@3e58658c
	vxorps	xmm0, xmm0, xmm0
	lea	eax, DWORD PTR [rbx+rdi]
	vcvtsi2ss xmm0, xmm0, eax
	vmulss	xmm3, xmm0, xmm4
	vxorps	xmm0, xmm0, xmm0

; 261  :     float X0 = i-t;

	vcvtsi2ss xmm0, xmm0, edi
	vsubss	xmm1, xmm0, xmm3
	vxorps	xmm2, xmm2, xmm2

; 262  :     float Y0 = j-t;

	vcvtsi2ss xmm2, xmm2, ebx
	vsubss	xmm0, xmm2, xmm3

; 263  :     float x0 = x-X0;
; 264  :     float y0 = y-Y0;

	vsubss	xmm8, xmm6, xmm0
	vsubss	xmm7, xmm7, xmm1

; 265  : 
; 266  :     int i1, j1;
; 267  :     if(x0>y0) {i1=1; j1=0;}

	xor	eax, eax
	vcomiss	xmm7, xmm8
	jbe	SHORT $LN2@snoise
	lea	ecx, QWORD PTR [rax+1]
	jmp	SHORT $LN3@snoise
$LN2@snoise:

; 268  :     else {i1=0; j1=1;}

	mov	ecx, eax
	mov	eax, 1
$LN3@snoise:

; 272  : 
; 273  :     int ii = i % 256;

	and	edi, -2147483393			; ffffffff800000ffH
	jge	SHORT $LN10@snoise
	dec	edi
	or	edi, -256				; ffffffffffffff00H
	inc	edi
$LN10@snoise:

; 274  :     int jj = j % 256;

	and	ebx, -2147483393			; ffffffff800000ffH
	jge	SHORT $LN9@snoise
	dec	ebx
	or	ebx, -256				; ffffffffffffff00H
	inc	ebx
$LN9@snoise:

; 269  : 
; 270  :     float x1 = x0 - i1 + G2, x2 = x0 - 1.0f + 2.0f * G2;
; 271  :     float y1 = y0 - j1 + G2, y2 = y0 - 1.0f + 2.0f * G2;     

	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vsubss	xmm1, xmm8, xmm0
	vxorps	xmm2, xmm2, xmm2
	vcvtsi2ss xmm2, xmm2, ecx
	vsubss	xmm0, xmm7, xmm2
	vaddss	xmm0, xmm0, xmm4

; 275  : 
; 276  :     return 40.0f * (point(x0, y0, ii,    jj) +

	lea	r9d, DWORD PTR [rbx+rax]
	lea	r8d, DWORD PTR [rdi+rcx]
	vaddss	xmm1, xmm1, xmm4
	call	?point@Perlin@@CAMMMHH@Z		; Perlin::point
	vmovaps	xmm6, xmm0
	vmovaps	xmm0, xmm7
	mov	r9d, ebx
	mov	r8d, edi
	vmovaps	xmm1, xmm8
	call	?point@Perlin@@CAMMMHH@Z		; Perlin::point
	vaddss	xmm6, xmm6, xmm0
	vsubss	xmm0, xmm8, DWORD PTR __real@3f800000
	vaddss	xmm1, xmm0, DWORD PTR __real@3ed8658c
	vsubss	xmm0, xmm7, DWORD PTR __real@3f800000
	vaddss	xmm0, xmm0, DWORD PTR __real@3ed8658c
	lea	r9d, DWORD PTR [rbx+1]
	lea	r8d, DWORD PTR [rdi+1]
	call	?point@Perlin@@CAMMMHH@Z		; Perlin::point

; 277  : 					point(x1, y1, ii+i1, jj+j1) +
; 278  : 					point(x2, y2, ii+1,  jj+1));
; 279  : }

	mov	rbx, QWORD PTR [rsp+96]
	vmovaps	xmm7, XMMWORD PTR [rsp+48]
	vmovaps	xmm8, XMMWORD PTR [rsp+32]
	vaddss	xmm1, xmm6, xmm0
	vmulss	xmm0, xmm1, DWORD PTR __real@42200000
	vmovaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?snoise@Perlin@@SAMMM@Z ENDP				; Perlin::snoise
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?snoise@Perlin@@SAMM@Z
_TEXT	SEGMENT
x$ = 48
?snoise@Perlin@@SAMM@Z PROC				; Perlin::snoise, COMDAT

; 241  : float Perlin::snoise(float x) {

$LN16:
	sub	rsp, 40					; 00000028H
	vxorps	xmm1, xmm1, xmm1

; 242  : 	int i0 = FASTFLOOR(x);

	vcomiss	xmm1, xmm0
	vmovaps	XMMWORD PTR [rsp+16], xmm6
	vmovaps	XMMWORD PTR [rsp], xmm7
	vmovaps	xmm2, xmm0
	vcvttss2si eax, xmm0
	jbe	SHORT $LN4@snoise
	dec	eax
$LN4@snoise:

; 245  : 	float x1 = x0 - 1.0f;

	vmovss	xmm1, DWORD PTR __real@3f800000

; 70   :     if (h&8) grad = -grad;

	vmovss	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	vxorps	xmm0, xmm0, xmm0

; 244  : 	float x0 = x - i0;

	vcvtsi2ss xmm0, xmm0, eax
	vsubss	xmm6, xmm2, xmm0

; 212  : 	return t * t * grad(perm[i & 255], x);

	movzx	ecx, al

; 243  : 	int i1 = i0 + 1;

	lea	r8d, DWORD PTR [rax+1]

; 210  : 	float t = 1.0f - x*x;

	vmulss	xmm0, xmm6, xmm6
	vsubss	xmm0, xmm1, xmm0

; 211  : 	t *= t;

	vmulss	xmm7, xmm0, xmm0

; 212  : 	return t * t * grad(perm[i & 255], x);

	lea	r9, OFFSET FLAT:?perm@@3PAEA

; 68   :     int h = hash & 15;

	movzx	edx, BYTE PTR [rcx+r9]
	and	edx, 15

; 69   :     float grad = 1.0f + (h & 7);

	mov	eax, edx
	and	eax, 7
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vaddss	xmm2, xmm0, xmm1

; 245  : 	float x1 = x0 - 1.0f;

	vsubss	xmm5, xmm6, xmm1

; 70   :     if (h&8) grad = -grad;

	test	dl, 8
	je	SHORT $LN8@snoise
	vxorps	xmm2, xmm2, xmm3
$LN8@snoise:

; 210  : 	float t = 1.0f - x*x;

	vmulss	xmm0, xmm5, xmm5
	vsubss	xmm0, xmm1, xmm0

; 211  : 	t *= t;

	vmulss	xmm4, xmm0, xmm0

; 212  : 	return t * t * grad(perm[i & 255], x);

	movzx	ecx, r8b
	vxorps	xmm0, xmm0, xmm0

; 68   :     int h = hash & 15;

	movzx	edx, BYTE PTR [rcx+r9]
	and	edx, 15

; 69   :     float grad = 1.0f + (h & 7);

	mov	eax, edx
	and	eax, 7
	vcvtsi2ss xmm0, xmm0, eax
	vaddss	xmm1, xmm0, xmm1

; 70   :     if (h&8) grad = -grad;

	test	dl, 8
	je	SHORT $LN13@snoise
	vxorps	xmm1, xmm1, xmm3
$LN13@snoise:

; 71   :     return ( grad * x );

	vmulss	xmm2, xmm2, xmm6

; 247  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+16]

; 71   :     return ( grad * x );

	vmulss	xmm1, xmm1, xmm5

; 212  : 	return t * t * grad(perm[i & 255], x);

	vmulss	xmm0, xmm4, xmm4
	vmulss	xmm3, xmm1, xmm0
	vmulss	xmm1, xmm7, xmm7

; 247  : }

	vmovaps	xmm7, XMMWORD PTR [rsp]

; 212  : 	return t * t * grad(perm[i & 255], x);

	vmulss	xmm0, xmm2, xmm1

; 246  : 	return (1.f/2.53125f) * (point(x0, i0) + point(x1, i1));

	vaddss	xmm2, xmm3, xmm0
	vmulss	xmm0, xmm2, DWORD PTR __real@3eca4588

; 247  : }

	add	rsp, 40					; 00000028H
	ret	0
?snoise@Perlin@@SAMM@Z ENDP				; Perlin::snoise
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?noise@Perlin@@SAMMMMM@Z
_TEXT	SEGMENT
j$1$ = 0
l4$1$ = 4
l3$1$ = 8
k$1$ = 12
l$1$ = 16
i$1$ = 240
x$ = 240
wf1$1$ = 248
y$ = 248
l2$1$ = 256
z$ = 256
l1$1$ = 264
w$ = 264
?noise@Perlin@@SAMMMMM@Z PROC				; Perlin::noise, COMDAT

; 155  : float Perlin::noise(float x, float y, float z, float w) {

$LN266:
	mov	rax, rsp
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 192				; 000000c0H
	vmovaps	XMMWORD PTR [rax-56], xmm6
	vmovaps	XMMWORD PTR [rax-72], xmm7
	vmovaps	XMMWORD PTR [rax-88], xmm8
	vmovaps	XMMWORD PTR [rax-104], xmm9
	vmovaps	XMMWORD PTR [rax-120], xmm10
	vmovaps	XMMWORD PTR [rsp+96], xmm11
	vmovaps	XMMWORD PTR [rsp+80], xmm12
	vmovaps	XMMWORD PTR [rsp+64], xmm13
	vxorps	xmm4, xmm4, xmm4

; 156  :     int xi = FASTFLOOR(x);

	vcomiss	xmm4, xmm0
	vmovaps	XMMWORD PTR [rsp+48], xmm14
	vmovaps	xmm5, xmm1
	vmovaps	XMMWORD PTR [rsp+32], xmm15
	vmovaps	xmm1, xmm0
	vcvttss2si ecx, xmm0
	jbe	SHORT $LN4@noise
	dec	ecx
$LN4@noise:

; 157  : 	int yi = FASTFLOOR(y);

	vcomiss	xmm4, xmm5
	vcvttss2si edx, xmm5
	jbe	SHORT $LN6@noise
	dec	edx
$LN6@noise:

; 158  : 	int zi = FASTFLOOR(z);

	vcomiss	xmm4, xmm2
	vcvttss2si r10d, xmm2
	jbe	SHORT $LN8@noise
	dec	r10d
$LN8@noise:

; 159  : 	int wi = FASTFLOOR(w);

	vcomiss	xmm4, xmm3
	vcvttss2si eax, xmm3
	jbe	SHORT $LN10@noise
	dec	eax
$LN10@noise:

; 160  :     float xf0 = x - xi;
; 161  :     float yf0 = y - yi;
; 162  : 	float zf0 = z - zi;
; 163  : 	float wf0 = w - wi;
; 164  :     float xf1 = xf0 - 1.0f;
; 165  :     float yf1 = yf0 - 1.0f;
; 166  : 	float zf1 = zf0 - 1.0f;
; 167  : 	float wf1 = wf0 - 1.0f;
; 168  :     xi = xi & 255;
; 169  :     yi = yi & 255;   
; 170  : 	zi = zi & 255;
; 171  : 	wi = wi & 255;
; 172  :     float i = FADE(xf0);

	vmovss	xmm6, DWORD PTR __real@40c00000
	vmovss	xmm4, DWORD PTR __real@41200000
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, ecx
	vsubss	xmm13, xmm1, xmm0
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, r10d
	vsubss	xmm7, xmm2, xmm0
	vmovss	xmm0, DWORD PTR __real@3f800000
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, edx
	vsubss	xmm8, xmm5, xmm1
	vmovss	xmm5, DWORD PTR __real@41700000
	vsubss	xmm14, xmm13, xmm0
	vsubss	xmm10, xmm8, xmm0
	vsubss	xmm9, xmm7, xmm0

; 173  :     float j = FADE(yf0);
; 174  : 	float k = FADE(zf0);
; 175  : 	float l = FADE(wf0);
; 176  : 
; 177  : 	int A = perm[xi]  +yi, AA = perm[A]  +zi, AAA = perm[AA]  +wi,

	lea	r14, OFFSET FLAT:?perm@@3PAEA
	movzx	r8d, cl
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	vsubss	xmm11, xmm3, xmm1
	vsubss	xmm15, xmm11, xmm0
	movzx	r11d, al
	movzx	r9d, dl
	movzx	edx, BYTE PTR [r8+r14]
	add	edx, r9d
	movzx	r10d, r10b
	vmulss	xmm0, xmm13, xmm6
	vsubss	xmm0, xmm0, xmm5
	vmulss	xmm1, xmm0, xmm13
	movzx	ecx, BYTE PTR [rdx+r14]
	vaddss	xmm2, xmm1, xmm4
	add	ecx, r10d
	vmulss	xmm0, xmm13, xmm13
	vmulss	xmm1, xmm0, xmm13
	vmulss	xmm0, xmm2, xmm1
	movzx	ebx, BYTE PTR [rcx+r14]

; 178  :                                               AAB = perm[AA+1]+wi,

	lea	eax, DWORD PTR [rcx+1]
	movzx	esi, BYTE PTR [rax+r14]
	add	ebx, r11d
	vmovss	DWORD PTR i$1$[rsp], xmm0

; 179  : 		                   AB = perm[A+1]+zi, ABA = perm[AB]  +wi,

	lea	eax, DWORD PTR [rdx+1]
	add	esi, r11d
	movzx	ecx, BYTE PTR [rax+r14]
	add	ecx, r10d
	vmulss	xmm2, xmm8, xmm6
	vsubss	xmm0, xmm2, xmm5
	vmulss	xmm1, xmm0, xmm8
	movzx	edi, BYTE PTR [rcx+r14]

; 180  :                                               ABB = perm[AB+1]+wi;

	lea	eax, DWORD PTR [rcx+1]
	movzx	ebp, BYTE PTR [rax+r14]
	add	edi, r11d
	vaddss	xmm3, xmm1, xmm4
	vmulss	xmm2, xmm8, xmm8
	vmulss	xmm0, xmm2, xmm8
	vmulss	xmm1, xmm3, xmm0
	vmovss	DWORD PTR j$1$[rsp], xmm1
	vmulss	xmm1, xmm7, xmm6
	vsubss	xmm2, xmm1, xmm5
	vmulss	xmm0, xmm2, xmm7
	vaddss	xmm3, xmm0, xmm4
	vmulss	xmm1, xmm7, xmm7
	vmulss	xmm2, xmm1, xmm7
	vmulss	xmm0, xmm3, xmm2
	vmovss	DWORD PTR k$1$[rsp], xmm0

; 181  : 	int B = perm[xi+1]+yi, BA = perm[B]  +zi, BAA = perm[BA]  +wi,

	lea	eax, DWORD PTR [r8+1]
	add	ebp, r11d
	movzx	edx, BYTE PTR [rax+r14]
	add	edx, r9d
	vmulss	xmm0, xmm11, xmm6
	vsubss	xmm1, xmm0, xmm5
	vmulss	xmm2, xmm1, xmm11
	movzx	ecx, BYTE PTR [rdx+r14]
	vmulss	xmm0, xmm11, xmm11
	add	ecx, r10d
	vaddss	xmm3, xmm2, xmm4
	vmulss	xmm1, xmm0, xmm11
	vmulss	xmm0, xmm3, xmm1
	movzx	r8d, BYTE PTR [rcx+r14]
	vmovss	DWORD PTR l$1$[rsp], xmm0
	vmovss	DWORD PTR wf1$1$[rsp], xmm15

; 182  :                                               BAB = perm[BA+1]+wi,

	lea	eax, DWORD PTR [rcx+1]
	add	r8d, r11d
	movzx	r9d, BYTE PTR [rax+r14]

; 183  : 		                   BB = perm[B+1]+zi, BBA = perm[BB]  +wi,

	lea	eax, DWORD PTR [rdx+1]
	movzx	ecx, BYTE PTR [rax+r14]
	add	r9d, r11d
	add	ecx, r10d
	movzx	edx, BYTE PTR [rcx+r14]

; 184  :                                               BBB = perm[BB+1]+wi;

	lea	eax, DWORD PTR [rcx+1]
	movzx	r10d, BYTE PTR [rax+r14]
	add	edx, r11d

; 89   : 	int h = hash & 31;

	movzx	ecx, BYTE PTR [r8+r14]

; 184  :                                               BBB = perm[BB+1]+wi;

	add	r10d, r11d

; 89   : 	int h = hash & 31;

	and	ecx, 31
	cmp	ecx, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN13@noise
	vmovaps	xmm12, xmm14
	jmp	SHORT $LN14@noise
$LN13@noise:
	vmovaps	xmm12, xmm8
$LN14@noise:
	cmp	ecx, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN15@noise
	vmovaps	xmm6, xmm8
	jmp	SHORT $LN16@noise
$LN15@noise:
	vmovaps	xmm6, xmm7
$LN16@noise:
	cmp	ecx, 8

; 92   :     float k = h<8 ? z : w;

	jae	SHORT $LN17@noise
	vmovaps	xmm3, xmm7
	jmp	SHORT $LN18@noise
$LN17@noise:
	vmovaps	xmm3, xmm11
$LN18@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	vmovss	xmm5, DWORD PTR __xmm@80000000800000008000000080000000
	test	cl, 1
	je	SHORT $LN19@noise
	vxorps	xmm12, xmm12, xmm5
$LN19@noise:
	test	cl, 2
	je	SHORT $LN21@noise
	vxorps	xmm6, xmm6, xmm5
$LN21@noise:
	test	cl, 4
	je	SHORT $LN23@noise
	vxorps	xmm3, xmm3, xmm5
$LN23@noise:

; 89   : 	int h = hash & 31;

	movzx	ecx, BYTE PTR [rbx+r14]
	and	ecx, 31
	cmp	ecx, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN27@noise
	vmovaps	xmm2, xmm13
	jmp	SHORT $LN28@noise
$LN27@noise:
	vmovaps	xmm2, xmm8
$LN28@noise:
	cmp	ecx, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN29@noise
	vmovaps	xmm0, xmm8
	jmp	SHORT $LN30@noise
$LN29@noise:
	vmovaps	xmm0, xmm7
$LN30@noise:
	cmp	ecx, 8

; 92   :     float k = h<8 ? z : w;

	jae	SHORT $LN31@noise
	vmovaps	xmm1, xmm7
	jmp	SHORT $LN32@noise
$LN31@noise:
	vmovaps	xmm1, xmm11
$LN32@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	cl, 1
	je	SHORT $LN33@noise
	vxorps	xmm2, xmm2, xmm5
$LN33@noise:
	test	cl, 2
	je	SHORT $LN35@noise
	vxorps	xmm0, xmm0, xmm5
$LN35@noise:
	test	cl, 4
	je	SHORT $LN37@noise
	vxorps	xmm1, xmm1, xmm5
$LN37@noise:

; 89   : 	int h = hash & 31;

	movzx	ecx, BYTE PTR [rdx+r14]

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	vaddss	xmm0, xmm0, xmm2
	vaddss	xmm4, xmm0, xmm1
	vaddss	xmm1, xmm6, xmm12
	vaddss	xmm2, xmm1, xmm3

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm0, xmm2, xmm4
	vmulss	xmm3, xmm0, DWORD PTR i$1$[rsp]

; 89   : 	int h = hash & 31;

	and	ecx, 31

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vaddss	xmm1, xmm3, xmm4
	vmovss	DWORD PTR l1$1$[rsp], xmm1
	cmp	ecx, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN43@noise
	vmovaps	xmm12, xmm14
	jmp	SHORT $LN44@noise
$LN43@noise:
	vmovaps	xmm12, xmm10
$LN44@noise:
	cmp	ecx, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN45@noise
	vmovaps	xmm6, xmm10
	jmp	SHORT $LN46@noise
$LN45@noise:
	vmovaps	xmm6, xmm7
$LN46@noise:
	cmp	ecx, 8

; 92   :     float k = h<8 ? z : w;

	jae	SHORT $LN47@noise
	vmovaps	xmm3, xmm7
	jmp	SHORT $LN48@noise
$LN47@noise:
	vmovaps	xmm3, xmm11
$LN48@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	cl, 1
	je	SHORT $LN49@noise
	vxorps	xmm12, xmm12, xmm5
$LN49@noise:
	test	cl, 2
	je	SHORT $LN51@noise
	vxorps	xmm6, xmm6, xmm5
$LN51@noise:
	test	cl, 4
	je	SHORT $LN53@noise
	vxorps	xmm3, xmm3, xmm5
$LN53@noise:

; 89   : 	int h = hash & 31;

	movzx	ecx, BYTE PTR [rdi+r14]
	and	ecx, 31
	cmp	ecx, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN57@noise
	vmovaps	xmm2, xmm13
	jmp	SHORT $LN58@noise
$LN57@noise:
	vmovaps	xmm2, xmm10
$LN58@noise:
	cmp	ecx, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN59@noise
	vmovaps	xmm0, xmm10
	jmp	SHORT $LN60@noise
$LN59@noise:
	vmovaps	xmm0, xmm7
$LN60@noise:
	cmp	ecx, 8

; 92   :     float k = h<8 ? z : w;

	jae	SHORT $LN61@noise
	vmovaps	xmm1, xmm7
	jmp	SHORT $LN62@noise
$LN61@noise:
	vmovaps	xmm1, xmm11
$LN62@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	cl, 1
	je	SHORT $LN63@noise
	vxorps	xmm2, xmm2, xmm5
$LN63@noise:
	test	cl, 2
	je	SHORT $LN65@noise
	vxorps	xmm0, xmm0, xmm5
$LN65@noise:
	test	cl, 4
	je	SHORT $LN67@noise
	vxorps	xmm1, xmm1, xmm5
$LN67@noise:

; 89   : 	int h = hash & 31;

	movzx	ecx, BYTE PTR [r9+r14]

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	vaddss	xmm0, xmm0, xmm2
	vaddss	xmm4, xmm0, xmm1
	vaddss	xmm1, xmm6, xmm12
	vaddss	xmm2, xmm1, xmm3

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm0, xmm2, xmm4
	vmulss	xmm3, xmm0, DWORD PTR i$1$[rsp]

; 89   : 	int h = hash & 31;

	and	ecx, 31

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vaddss	xmm0, xmm3, xmm4
	vmovss	DWORD PTR l2$1$[rsp], xmm0
	cmp	ecx, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN73@noise
	vmovaps	xmm12, xmm14
	jmp	SHORT $LN74@noise
$LN73@noise:
	vmovaps	xmm12, xmm8
$LN74@noise:
	cmp	ecx, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN75@noise
	vmovaps	xmm6, xmm8
	jmp	SHORT $LN76@noise
$LN75@noise:
	vmovaps	xmm6, xmm9
$LN76@noise:
	cmp	ecx, 8

; 92   :     float k = h<8 ? z : w;

	jae	SHORT $LN77@noise
	vmovaps	xmm3, xmm9
	jmp	SHORT $LN78@noise
$LN77@noise:
	vmovaps	xmm3, xmm11
$LN78@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	cl, 1
	je	SHORT $LN79@noise
	vxorps	xmm12, xmm12, xmm5
$LN79@noise:
	test	cl, 2
	je	SHORT $LN81@noise
	vxorps	xmm6, xmm6, xmm5
$LN81@noise:
	test	cl, 4
	je	SHORT $LN83@noise
	vxorps	xmm3, xmm3, xmm5
$LN83@noise:

; 89   : 	int h = hash & 31;

	movzx	ecx, BYTE PTR [rsi+r14]
	and	ecx, 31
	cmp	ecx, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN87@noise
	vmovaps	xmm2, xmm13
	jmp	SHORT $LN88@noise
$LN87@noise:
	vmovaps	xmm2, xmm8
$LN88@noise:
	cmp	ecx, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN89@noise
	vmovaps	xmm0, xmm8
	jmp	SHORT $LN90@noise
$LN89@noise:
	vmovaps	xmm0, xmm9
$LN90@noise:
	cmp	ecx, 8

; 92   :     float k = h<8 ? z : w;

	jae	SHORT $LN91@noise
	vmovaps	xmm1, xmm9
	jmp	SHORT $LN92@noise
$LN91@noise:
	vmovaps	xmm1, xmm11
$LN92@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	cl, 1
	je	SHORT $LN93@noise
	vxorps	xmm2, xmm2, xmm5
$LN93@noise:
	test	cl, 2
	je	SHORT $LN95@noise
	vxorps	xmm0, xmm0, xmm5
$LN95@noise:
	test	cl, 4
	je	SHORT $LN97@noise
	vxorps	xmm1, xmm1, xmm5
$LN97@noise:

; 89   : 	int h = hash & 31;

	movzx	ecx, BYTE PTR [r10+r14]

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	vaddss	xmm0, xmm0, xmm2
	vaddss	xmm4, xmm0, xmm1
	vaddss	xmm1, xmm6, xmm12

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vmovss	xmm12, DWORD PTR i$1$[rsp]

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	vaddss	xmm2, xmm1, xmm3

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm0, xmm2, xmm4
	vmulss	xmm3, xmm0, xmm12

; 89   : 	int h = hash & 31;

	and	ecx, 31

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vaddss	xmm0, xmm3, xmm4
	vmovss	DWORD PTR l3$1$[rsp], xmm0
	cmp	ecx, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN103@noise
	vmovaps	xmm6, xmm14
	jmp	SHORT $LN104@noise
$LN103@noise:
	vmovaps	xmm6, xmm10
$LN104@noise:
	cmp	ecx, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN105@noise
	vmovaps	xmm3, xmm10
	jmp	SHORT $LN106@noise
$LN105@noise:
	vmovaps	xmm3, xmm9
$LN106@noise:
	cmp	ecx, 8

; 92   :     float k = h<8 ? z : w;

	jae	SHORT $LN107@noise
	vmovaps	xmm2, xmm9
	jmp	SHORT $LN108@noise
$LN107@noise:
	vmovaps	xmm2, xmm11
$LN108@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	cl, 1
	je	SHORT $LN109@noise
	vxorps	xmm6, xmm6, xmm5
$LN109@noise:
	test	cl, 2
	je	SHORT $LN111@noise
	vxorps	xmm3, xmm3, xmm5
$LN111@noise:
	test	cl, 4
	je	SHORT $LN113@noise
	vxorps	xmm2, xmm2, xmm5
$LN113@noise:

; 89   : 	int h = hash & 31;

	movzx	ecx, BYTE PTR [rbp+r14]
	and	ecx, 31
	cmp	ecx, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN117@noise
	vmovaps	xmm1, xmm13
	jmp	SHORT $LN118@noise
$LN117@noise:
	vmovaps	xmm1, xmm10
$LN118@noise:
	cmp	ecx, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN119@noise
	vmovaps	xmm0, xmm10
	jmp	SHORT $LN120@noise
$LN119@noise:
	vmovaps	xmm0, xmm9
$LN120@noise:
	cmp	ecx, 8

; 92   :     float k = h<8 ? z : w;

	jae	SHORT $LN121@noise
	vmovaps	xmm11, xmm9
$LN121@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	cl, 1
	je	SHORT $LN123@noise
	vxorps	xmm1, xmm1, xmm5
$LN123@noise:
	test	cl, 2
	je	SHORT $LN125@noise
	vxorps	xmm0, xmm0, xmm5
$LN125@noise:
	test	cl, 4
	je	SHORT $LN127@noise
	vxorps	xmm11, xmm11, xmm5
$LN127@noise:
	vaddss	xmm0, xmm0, xmm1
	vaddss	xmm1, xmm3, xmm6
	vaddss	xmm4, xmm0, xmm11
	vaddss	xmm2, xmm1, xmm2

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm0, xmm2, xmm4

; 185  : 											  
; 186  : 	
; 187  : 	float l1 = lerp2(i, grad(perm[AAA  ], xf0, yf0, zf0, wf0), grad(perm[BAA  ], xf1, yf0, zf0, wf0));
; 188  : 	float l2 = lerp2(i, grad(perm[ABA  ], xf0, yf1, zf0, wf0), grad(perm[BBA  ], xf1, yf1, zf0, wf0));
; 189  : 	float l3 = lerp2(i, grad(perm[AAB  ], xf0, yf0, zf1, wf0), grad(perm[BAB  ], xf1, yf0, zf1, wf0));
; 190  : 	float l4 = lerp2(i, grad(perm[ABB  ], xf0, yf1, zf1, wf0), grad(perm[BBB  ], xf1, yf1, zf1, wf0));
; 191  : 	float l5 = lerp2(i, grad(perm[AAA+1], xf0, yf0, zf0, wf1), grad(perm[BAA+1], xf1, yf0, zf0, wf1));

	lea	eax, DWORD PTR [r8+1]

; 89   : 	int h = hash & 31;

	movzx	eax, BYTE PTR [rax+r14]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vmulss	xmm3, xmm0, xmm12

; 89   : 	int h = hash & 31;

	and	eax, 31

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vaddss	xmm0, xmm3, xmm4
	vmovss	DWORD PTR l4$1$[rsp], xmm0
	cmp	eax, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN133@noise
	vmovaps	xmm11, xmm14
	jmp	SHORT $LN134@noise
$LN133@noise:
	vmovaps	xmm11, xmm8
$LN134@noise:
	cmp	eax, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN135@noise
	vmovaps	xmm6, xmm8
	jmp	SHORT $LN136@noise
$LN135@noise:
	vmovaps	xmm6, xmm7
$LN136@noise:
	cmp	eax, 8

; 92   :     float k = h<8 ? z : w;

	jae	SHORT $LN137@noise
	vmovaps	xmm3, xmm7
	jmp	SHORT $LN138@noise
$LN137@noise:
	vmovaps	xmm3, xmm15
$LN138@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	al, 1
	je	SHORT $LN139@noise
	vxorps	xmm11, xmm11, xmm5
$LN139@noise:
	test	al, 2
	je	SHORT $LN141@noise
	vxorps	xmm6, xmm6, xmm5
$LN141@noise:
	test	al, 4
	je	SHORT $LN143@noise
	vxorps	xmm3, xmm3, xmm5
$LN143@noise:

; 185  : 											  
; 186  : 	
; 187  : 	float l1 = lerp2(i, grad(perm[AAA  ], xf0, yf0, zf0, wf0), grad(perm[BAA  ], xf1, yf0, zf0, wf0));
; 188  : 	float l2 = lerp2(i, grad(perm[ABA  ], xf0, yf1, zf0, wf0), grad(perm[BBA  ], xf1, yf1, zf0, wf0));
; 189  : 	float l3 = lerp2(i, grad(perm[AAB  ], xf0, yf0, zf1, wf0), grad(perm[BAB  ], xf1, yf0, zf1, wf0));
; 190  : 	float l4 = lerp2(i, grad(perm[ABB  ], xf0, yf1, zf1, wf0), grad(perm[BBB  ], xf1, yf1, zf1, wf0));
; 191  : 	float l5 = lerp2(i, grad(perm[AAA+1], xf0, yf0, zf0, wf1), grad(perm[BAA+1], xf1, yf0, zf0, wf1));

	lea	eax, DWORD PTR [rbx+1]

; 89   : 	int h = hash & 31;

	movzx	eax, BYTE PTR [rax+r14]
	and	eax, 31
	cmp	eax, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN147@noise
	vmovaps	xmm2, xmm13
	jmp	SHORT $LN148@noise
$LN147@noise:
	vmovaps	xmm2, xmm8
$LN148@noise:
	cmp	eax, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN149@noise
	vmovaps	xmm0, xmm8
	jmp	SHORT $LN150@noise
$LN149@noise:
	vmovaps	xmm0, xmm7
$LN150@noise:
	cmp	eax, 8

; 92   :     float k = h<8 ? z : w;

	jae	SHORT $LN151@noise
	vmovaps	xmm1, xmm7
	jmp	SHORT $LN152@noise
$LN151@noise:
	vmovaps	xmm1, xmm15
$LN152@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	al, 1
	je	SHORT $LN153@noise
	vxorps	xmm2, xmm2, xmm5
$LN153@noise:
	test	al, 2
	je	SHORT $LN155@noise
	vxorps	xmm0, xmm0, xmm5
$LN155@noise:
	test	al, 4
	je	SHORT $LN157@noise
	vxorps	xmm1, xmm1, xmm5
$LN157@noise:
	vaddss	xmm0, xmm0, xmm2
	vaddss	xmm4, xmm0, xmm1
	vaddss	xmm1, xmm6, xmm11
	vaddss	xmm2, xmm1, xmm3

; 192  : 	float l6 = lerp2(i, grad(perm[ABA+1], xf0, yf1, zf0, wf1), grad(perm[BBA+1], xf1, yf1, zf0, wf1));

	lea	eax, DWORD PTR [rdx+1]

; 89   : 	int h = hash & 31;

	movzx	eax, BYTE PTR [rax+r14]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm0, xmm2, xmm4

; 89   : 	int h = hash & 31;

	and	eax, 31

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vmulss	xmm3, xmm0, xmm12
	vaddss	xmm15, xmm3, xmm4
	cmp	eax, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN163@noise
	vmovaps	xmm6, xmm14
	jmp	SHORT $LN164@noise
$LN163@noise:
	vmovaps	xmm6, xmm10
$LN164@noise:
	cmp	eax, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN165@noise
	vmovaps	xmm3, xmm10
	jmp	SHORT $LN166@noise
$LN165@noise:
	vmovaps	xmm3, xmm7
$LN166@noise:

; 92   :     float k = h<8 ? z : w;

	vmovss	xmm11, DWORD PTR wf1$1$[rsp]
	cmp	eax, 8
	jae	SHORT $LN167@noise
	vmovaps	xmm2, xmm7
	jmp	SHORT $LN168@noise
$LN167@noise:
	vmovaps	xmm2, xmm11
$LN168@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	al, 1
	je	SHORT $LN169@noise
	vxorps	xmm6, xmm6, xmm5
$LN169@noise:
	test	al, 2
	je	SHORT $LN171@noise
	vxorps	xmm3, xmm3, xmm5
$LN171@noise:
	test	al, 4
	je	SHORT $LN173@noise
	vxorps	xmm2, xmm2, xmm5
$LN173@noise:

; 192  : 	float l6 = lerp2(i, grad(perm[ABA+1], xf0, yf1, zf0, wf1), grad(perm[BBA+1], xf1, yf1, zf0, wf1));

	lea	eax, DWORD PTR [rdi+1]

; 89   : 	int h = hash & 31;

	movzx	eax, BYTE PTR [rax+r14]
	and	eax, 31
	cmp	eax, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN177@noise
	vmovaps	xmm1, xmm13
	jmp	SHORT $LN178@noise
$LN177@noise:
	vmovaps	xmm1, xmm10
$LN178@noise:
	cmp	eax, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN179@noise
	vmovaps	xmm0, xmm10
	jmp	SHORT $LN180@noise
$LN179@noise:
	vmovaps	xmm0, xmm7
$LN180@noise:
	cmp	eax, 8

; 92   :     float k = h<8 ? z : w;

	jb	SHORT $LN182@noise
	vmovaps	xmm7, xmm11
$LN182@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	al, 1
	je	SHORT $LN183@noise
	vxorps	xmm1, xmm1, xmm5
$LN183@noise:
	test	al, 2
	je	SHORT $LN185@noise
	vxorps	xmm0, xmm0, xmm5
$LN185@noise:
	test	al, 4
	je	SHORT $LN187@noise
	vxorps	xmm7, xmm7, xmm5
$LN187@noise:
	vaddss	xmm0, xmm0, xmm1
	vaddss	xmm1, xmm3, xmm6
	vaddss	xmm4, xmm0, xmm7

; 193  : 	float l7 = lerp2(i, grad(perm[AAB+1], xf0, yf0, zf1, wf1), grad(perm[BAB+1], xf1, yf0, zf1, wf1));

	lea	eax, DWORD PTR [r9+1]

; 89   : 	int h = hash & 31;

	movzx	eax, BYTE PTR [rax+r14]

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	vaddss	xmm2, xmm1, xmm2

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm0, xmm2, xmm4

; 89   : 	int h = hash & 31;

	and	eax, 31

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vmulss	xmm3, xmm0, xmm12
	vaddss	xmm12, xmm3, xmm4
	cmp	eax, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN193@noise
	vmovaps	xmm6, xmm14
	jmp	SHORT $LN194@noise
$LN193@noise:
	vmovaps	xmm6, xmm8
$LN194@noise:
	cmp	eax, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN195@noise
	vmovaps	xmm3, xmm8
	jmp	SHORT $LN196@noise
$LN195@noise:
	vmovaps	xmm3, xmm9
$LN196@noise:
	cmp	eax, 8

; 92   :     float k = h<8 ? z : w;

	jae	SHORT $LN197@noise
	vmovaps	xmm2, xmm9
	jmp	SHORT $LN198@noise
$LN197@noise:
	vmovaps	xmm2, xmm11
$LN198@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	al, 1
	je	SHORT $LN199@noise
	vxorps	xmm6, xmm6, xmm5
$LN199@noise:
	test	al, 2
	je	SHORT $LN201@noise
	vxorps	xmm3, xmm3, xmm5
$LN201@noise:
	test	al, 4
	je	SHORT $LN203@noise
	vxorps	xmm2, xmm2, xmm5
$LN203@noise:

; 193  : 	float l7 = lerp2(i, grad(perm[AAB+1], xf0, yf0, zf1, wf1), grad(perm[BAB+1], xf1, yf0, zf1, wf1));

	lea	eax, DWORD PTR [rsi+1]

; 89   : 	int h = hash & 31;

	movzx	eax, BYTE PTR [rax+r14]
	and	eax, 31
	cmp	eax, 24

; 90   :     float i = h<24 ? x : y;

	jae	SHORT $LN207@noise
	vmovaps	xmm0, xmm13
	jmp	SHORT $LN208@noise
$LN207@noise:
	vmovaps	xmm0, xmm8
$LN208@noise:
	cmp	eax, 16

; 91   :     float j = h<16 ? y : z;

	jb	SHORT $LN210@noise
	vmovaps	xmm8, xmm9
$LN210@noise:
	cmp	eax, 8

; 92   :     float k = h<8 ? z : w;

	jae	SHORT $LN211@noise
	vmovaps	xmm1, xmm9
	jmp	SHORT $LN212@noise
$LN211@noise:
	vmovaps	xmm1, xmm11
$LN212@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	al, 1
	je	SHORT $LN213@noise
	vxorps	xmm0, xmm0, xmm5
$LN213@noise:
	test	al, 2
	je	SHORT $LN215@noise
	vxorps	xmm8, xmm8, xmm5
$LN215@noise:
	test	al, 4
	je	SHORT $LN217@noise
	vxorps	xmm1, xmm1, xmm5
$LN217@noise:
	vaddss	xmm0, xmm8, xmm0
	vaddss	xmm4, xmm0, xmm1
	vaddss	xmm1, xmm3, xmm6

; 194  : 	float l8 = lerp2(i, grad(perm[ABB+1], xf0, yf1, zf1, wf1), grad(perm[BBB+1], xf1, yf1, zf1, wf1));

	lea	eax, DWORD PTR [r10+1]

; 89   : 	int h = hash & 31;

	movzx	eax, BYTE PTR [rax+r14]

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	vaddss	xmm2, xmm1, xmm2

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm0, xmm2, xmm4
	vmulss	xmm3, xmm0, DWORD PTR i$1$[rsp]

; 89   : 	int h = hash & 31;

	and	eax, 31

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vaddss	xmm11, xmm3, xmm4
	cmp	eax, 24

; 90   :     float i = h<24 ? x : y;

	jb	SHORT $LN224@noise
	vmovaps	xmm14, xmm10
$LN224@noise:
	cmp	eax, 16

; 91   :     float j = h<16 ? y : z;

	jae	SHORT $LN225@noise
	vmovaps	xmm8, xmm10
	jmp	SHORT $LN226@noise
$LN225@noise:
	vmovaps	xmm8, xmm9
$LN226@noise:

; 92   :     float k = h<8 ? z : w;

	vmovss	xmm0, DWORD PTR wf1$1$[rsp]
	cmp	eax, 8
	jae	SHORT $LN227@noise
	vmovaps	xmm7, xmm9
	jmp	SHORT $LN228@noise
$LN227@noise:
	vmovaps	xmm7, xmm0
$LN228@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	al, 1
	je	SHORT $LN229@noise
	vxorps	xmm14, xmm14, xmm5
$LN229@noise:
	test	al, 2
	je	SHORT $LN231@noise
	vxorps	xmm8, xmm8, xmm5
$LN231@noise:
	test	al, 4
	je	SHORT $LN233@noise
	vxorps	xmm7, xmm7, xmm5
$LN233@noise:

; 194  : 	float l8 = lerp2(i, grad(perm[ABB+1], xf0, yf1, zf1, wf1), grad(perm[BBB+1], xf1, yf1, zf1, wf1));

	lea	eax, DWORD PTR [rbp+1]

; 89   : 	int h = hash & 31;

	movzx	eax, BYTE PTR [rax+r14]
	and	eax, 31
	cmp	eax, 24

; 90   :     float i = h<24 ? x : y;

	jb	SHORT $LN238@noise
	vmovaps	xmm13, xmm10
$LN238@noise:
	cmp	eax, 16

; 91   :     float j = h<16 ? y : z;

	jb	SHORT $LN240@noise
	vmovaps	xmm10, xmm9
$LN240@noise:
	cmp	eax, 8

; 92   :     float k = h<8 ? z : w;

	jb	SHORT $LN242@noise
	vmovaps	xmm9, xmm0
$LN242@noise:

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	test	al, 1
	je	SHORT $LN243@noise
	vxorps	xmm13, xmm13, xmm5
$LN243@noise:
	test	al, 2
	je	SHORT $LN245@noise
	vxorps	xmm10, xmm10, xmm5
$LN245@noise:
	test	al, 4
	je	SHORT $LN247@noise
	vxorps	xmm9, xmm9, xmm5
$LN247@noise:

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vmovss	xmm1, DWORD PTR l2$1$[rsp]
	vsubss	xmm1, xmm1, DWORD PTR l1$1$[rsp]

; 205  : }

	lea	r11, QWORD PTR [rsp+192]

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	vaddss	xmm0, xmm10, xmm13

; 205  : }

	vmovaps	xmm10, XMMWORD PTR [r11-80]
	vmovaps	xmm13, XMMWORD PTR [r11-128]

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	vaddss	xmm6, xmm0, xmm9

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vmovss	xmm9, DWORD PTR j$1$[rsp]
	vmovss	xmm0, DWORD PTR l4$1$[rsp]
	vsubss	xmm0, xmm0, DWORD PTR l3$1$[rsp]
	vmulss	xmm2, xmm1, xmm9

; 195  : 
; 196  : 	l1 = lerp2(j, l1, l2);

	vaddss	xmm4, xmm2, DWORD PTR l1$1$[rsp]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vmulss	xmm1, xmm0, xmm9
	vaddss	xmm3, xmm1, DWORD PTR l3$1$[rsp]
	vsubss	xmm1, xmm3, xmm4
	vsubss	xmm2, xmm12, xmm15

; 205  : }

	vmovaps	xmm12, XMMWORD PTR [r11-112]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vmulss	xmm0, xmm2, xmm9
	vmulss	xmm2, xmm1, DWORD PTR k$1$[rsp]
	vaddss	xmm5, xmm0, xmm15

; 205  : }

	vmovaps	xmm15, XMMWORD PTR [rsp+32]
	vaddss	xmm4, xmm4, xmm2

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	vaddss	xmm0, xmm8, xmm14

; 205  : }

	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm14, XMMWORD PTR [rsp+48]

; 93   :     return ((h&1)? -i : i) + ((h&2)? -j : j) + ((h&4)? -k : k);

	vaddss	xmm1, xmm0, xmm7

; 205  : }

	vmovaps	xmm7, XMMWORD PTR [r11-32]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm2, xmm1, xmm6
	vmulss	xmm3, xmm2, DWORD PTR i$1$[rsp]
	vaddss	xmm0, xmm3, xmm6

; 205  : }

	vmovaps	xmm6, XMMWORD PTR [r11-16]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm1, xmm0, xmm11
	vmulss	xmm2, xmm1, xmm9

; 205  : }

	vmovaps	xmm9, XMMWORD PTR [r11-64]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vaddss	xmm3, xmm2, xmm11

; 205  : }

	vmovaps	xmm11, XMMWORD PTR [r11-96]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm0, xmm3, xmm5
	vmulss	xmm1, xmm0, DWORD PTR k$1$[rsp]
	vaddss	xmm2, xmm1, xmm5
	vsubss	xmm3, xmm2, xmm4
	vmulss	xmm0, xmm3, DWORD PTR l$1$[rsp]
	vaddss	xmm1, xmm0, xmm4

; 197  : 	l2 = lerp2(j, l3, l4);
; 198  : 	l3 = lerp2(j, l5, l6);
; 199  : 	l4 = lerp2(j, l7, l8);
; 200  : 
; 201  : 	l1 = lerp2(k, l1, l2);
; 202  : 	l2 = lerp2(k, l3, l4);
; 203  : 
; 204  : 	return lerp2(l, l1, l2) * 0.87f;

	vmulss	xmm0, xmm1, DWORD PTR __real@3f5eb852

; 205  : }

	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?noise@Perlin@@SAMMMMM@Z ENDP				; Perlin::noise
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?noise@Perlin@@SAMMMM@Z
_TEXT	SEGMENT
i$1$ = 176
x$ = 176
j$1$ = 184
y$ = 184
k$1$ = 192
z$ = 192
?noise@Perlin@@SAMMMM@Z PROC				; Perlin::noise, COMDAT

; 129  : float Perlin::noise(float x, float y, float z) {

$LN128:
	mov	rax, rsp
	mov	QWORD PTR [rax+32], rbx
	push	rdi
	sub	rsp, 160				; 000000a0H
	vmovaps	XMMWORD PTR [rax-24], xmm6
	vmovaps	XMMWORD PTR [rax-40], xmm7
	vmovaps	XMMWORD PTR [rax-56], xmm8
	vmovaps	XMMWORD PTR [rax-72], xmm9
	vmovaps	XMMWORD PTR [rax-88], xmm10
	vmovaps	XMMWORD PTR [rax-104], xmm11
	vmovaps	XMMWORD PTR [rax-120], xmm12
	vmovaps	XMMWORD PTR [rsp+32], xmm13
	vmovaps	xmm3, xmm1
	vxorps	xmm1, xmm1, xmm1

; 130  : 	int xi = FASTFLOOR(x);

	vcomiss	xmm1, xmm0
	vmovaps	XMMWORD PTR [rsp+16], xmm14
	vmovaps	XMMWORD PTR [rsp], xmm15
	vmovaps	xmm4, xmm0
	vcvttss2si ecx, xmm0
	jbe	SHORT $LN4@noise
	dec	ecx
$LN4@noise:

; 131  : 	int yi = FASTFLOOR(y);

	vcomiss	xmm1, xmm3
	vcvttss2si r8d, xmm3
	jbe	SHORT $LN6@noise
	dec	r8d
$LN6@noise:

; 132  : 	int zi = FASTFLOOR(z);

	vcomiss	xmm1, xmm2
	vcvttss2si eax, xmm2
	jbe	SHORT $LN8@noise
	dec	eax
$LN8@noise:

; 133  : 	float xf = x - (float)xi;
; 134  : 	float yf = y - (float)yi;
; 135  : 	float zf = z - (float)zi;
; 136  : 	xi = xi & 255;
; 137  : 	yi = yi & 255;
; 138  : 	zi = zi & 255;
; 139  : 	float i = FADE(xf);

	vmovss	xmm6, DWORD PTR __real@40c00000
	vmovss	xmm5, DWORD PTR __real@41700000
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, ecx
	vsubss	xmm8, xmm4, xmm0
	vmovss	xmm4, DWORD PTR __real@41200000
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vsubss	xmm9, xmm2, xmm0
	movzx	r9d, al

; 142  : 	int A = perm[xi  ]+yi, AA = perm[A]+zi, AB = perm[A+1]+zi;

	lea	rdi, OFFSET FLAT:?perm@@3PAEA
	movzx	edx, cl
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, r8d
	vsubss	xmm7, xmm3, xmm1
	movzx	ecx, BYTE PTR [rdx+rdi]
	movzx	r8d, r8b
	add	ecx, r8d
	vmulss	xmm0, xmm8, xmm6
	vsubss	xmm0, xmm0, xmm5
	vmulss	xmm1, xmm0, xmm8
	movzx	ebx, BYTE PTR [rcx+rdi]
	lea	eax, DWORD PTR [rcx+1]
	movzx	r10d, BYTE PTR [rax+rdi]
	add	ebx, r9d
	vaddss	xmm2, xmm1, xmm4

; 143  : 	int B = perm[xi+1]+yi, BA = perm[B]+zi, BB = perm[B+1]+zi;

	lea	eax, DWORD PTR [rdx+1]
	add	r10d, r9d
	movzx	ecx, BYTE PTR [rax+rdi]
	add	ecx, r8d
	vmulss	xmm0, xmm8, xmm8
	vmulss	xmm1, xmm0, xmm8
	vmulss	xmm11, xmm2, xmm1
	movzx	r11d, BYTE PTR [rcx+rdi]
	lea	eax, DWORD PTR [rcx+1]
	movzx	r8d, BYTE PTR [rax+rdi]
	add	r11d, r9d
	vmulss	xmm2, xmm7, xmm6
	vsubss	xmm0, xmm2, xmm5
	vmulss	xmm1, xmm0, xmm7
	vaddss	xmm3, xmm1, xmm4
	vmulss	xmm1, xmm9, xmm6
	vmulss	xmm2, xmm7, xmm7
	vmulss	xmm0, xmm2, xmm7
	vmulss	xmm0, xmm3, xmm0
	vsubss	xmm2, xmm1, xmm5
	add	r8d, r9d
	vmovss	DWORD PTR j$1$[rsp], xmm0
	vmulss	xmm0, xmm2, xmm9
	vaddss	xmm3, xmm0, xmm4

; 144  : 
; 145  : 	return lerp2(k, lerp2(j, lerp2(i, grad(perm[AA  ], xf  , yf  , zf   ),

	lea	eax, DWORD PTR [r8+1]

; 82   :     int h = hash & 15;

	movzx	edx, BYTE PTR [rax+rdi]

; 140  : 	float j = FADE(yf);
; 141  : 	float k = FADE(zf);

	vmulss	xmm1, xmm9, xmm9
	vmulss	xmm2, xmm1, xmm9
	vmulss	xmm0, xmm3, xmm2

; 144  : 
; 145  : 	return lerp2(k, lerp2(j, lerp2(i, grad(perm[AA  ], xf  , yf  , zf   ),

	vmovss	xmm3, DWORD PTR __real@3f800000

; 82   :     int h = hash & 15;

	and	edx, 15

; 133  : 	float xf = x - (float)xi;
; 134  : 	float yf = y - (float)yi;
; 135  : 	float zf = z - (float)zi;
; 136  : 	xi = xi & 255;
; 137  : 	yi = yi & 255;
; 138  : 	zi = zi & 255;
; 139  : 	float i = FADE(xf);

	vmovss	DWORD PTR i$1$[rsp], xmm11

; 140  : 	float j = FADE(yf);
; 141  : 	float k = FADE(zf);

	vmovss	DWORD PTR k$1$[rsp], xmm0

; 144  : 
; 145  : 	return lerp2(k, lerp2(j, lerp2(i, grad(perm[AA  ], xf  , yf  , zf   ),

	vsubss	xmm5, xmm7, xmm3
	vsubss	xmm6, xmm8, xmm3
	cmp	edx, 8

; 83   :     float i = h<8 ? x : y;

	jae	SHORT $LN11@noise
	vmovaps	xmm14, xmm6
	jmp	SHORT $LN12@noise
$LN11@noise:
	vmovaps	xmm14, xmm5
$LN12@noise:
	cmp	edx, 4

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jae	SHORT $LN15@noise
	vmovaps	xmm12, xmm5
	jmp	SHORT $LN14@noise
$LN15@noise:
	lea	eax, DWORD PTR [rdx-12]
	test	eax, -3					; fffffffdH
	je	SHORT $LN13@noise

; 144  : 
; 145  : 	return lerp2(k, lerp2(j, lerp2(i, grad(perm[AA  ], xf  , yf  , zf   ),

	vsubss	xmm12, xmm9, xmm3

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jmp	SHORT $LN14@noise
$LN13@noise:
	vmovaps	xmm12, xmm6
$LN14@noise:

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	vmovss	xmm4, DWORD PTR __xmm@80000000800000008000000080000000
	test	dl, 1
	je	SHORT $LN17@noise
	vxorps	xmm14, xmm14, xmm4
$LN17@noise:
	test	dl, 2
	je	SHORT $LN19@noise
	vxorps	xmm12, xmm12, xmm4
$LN19@noise:

; 144  : 
; 145  : 	return lerp2(k, lerp2(j, lerp2(i, grad(perm[AA  ], xf  , yf  , zf   ),

	lea	eax, DWORD PTR [r10+1]

; 82   :     int h = hash & 15;

	movzx	edx, BYTE PTR [rax+rdi]
	and	edx, 15
	cmp	edx, 8

; 83   :     float i = h<8 ? x : y;

	jae	SHORT $LN23@noise
	vmovaps	xmm1, xmm8
	jmp	SHORT $LN24@noise
$LN23@noise:
	vmovaps	xmm1, xmm5
$LN24@noise:
	cmp	edx, 4

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jae	SHORT $LN27@noise
	vmovaps	xmm0, xmm5
	jmp	SHORT $LN26@noise
$LN27@noise:
	lea	eax, DWORD PTR [rdx-12]
	test	eax, -3					; fffffffdH
	je	SHORT $LN25@noise

; 144  : 
; 145  : 	return lerp2(k, lerp2(j, lerp2(i, grad(perm[AA  ], xf  , yf  , zf   ),

	vsubss	xmm0, xmm9, xmm3

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jmp	SHORT $LN26@noise
$LN25@noise:
	vmovaps	xmm0, xmm8
$LN26@noise:

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	test	dl, 1
	je	SHORT $LN29@noise
	vxorps	xmm1, xmm1, xmm4
$LN29@noise:
	test	dl, 2
	je	SHORT $LN31@noise
	vxorps	xmm0, xmm0, xmm4
$LN31@noise:

; 144  : 
; 145  : 	return lerp2(k, lerp2(j, lerp2(i, grad(perm[AA  ], xf  , yf  , zf   ),

	lea	eax, DWORD PTR [r11+1]

; 82   :     int h = hash & 15;

	movzx	edx, BYTE PTR [rax+rdi]
	and	edx, 15

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	vaddss	xmm15, xmm0, xmm1
	cmp	edx, 8

; 83   :     float i = h<8 ? x : y;

	jae	SHORT $LN37@noise
	vmovaps	xmm10, xmm6
	jmp	SHORT $LN38@noise
$LN37@noise:
	vmovaps	xmm10, xmm7
$LN38@noise:
	cmp	edx, 4

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jae	SHORT $LN41@noise
	vmovaps	xmm1, xmm7
	jmp	SHORT $LN40@noise
$LN41@noise:
	lea	eax, DWORD PTR [rdx-12]
	test	eax, -3					; fffffffdH
	je	SHORT $LN39@noise

; 144  : 
; 145  : 	return lerp2(k, lerp2(j, lerp2(i, grad(perm[AA  ], xf  , yf  , zf   ),

	vsubss	xmm1, xmm9, xmm3

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jmp	SHORT $LN40@noise
$LN39@noise:
	vmovaps	xmm1, xmm6
$LN40@noise:

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	test	dl, 1
	je	SHORT $LN43@noise
	vxorps	xmm10, xmm10, xmm4
$LN43@noise:
	test	dl, 2
	je	SHORT $LN45@noise
	vxorps	xmm1, xmm1, xmm4
$LN45@noise:

; 144  : 
; 145  : 	return lerp2(k, lerp2(j, lerp2(i, grad(perm[AA  ], xf  , yf  , zf   ),

	lea	eax, DWORD PTR [rbx+1]

; 82   :     int h = hash & 15;

	movzx	edx, BYTE PTR [rax+rdi]
	and	edx, 15
	cmp	edx, 8

; 83   :     float i = h<8 ? x : y;

	jae	SHORT $LN49@noise
	vmovaps	xmm2, xmm8
	jmp	SHORT $LN50@noise
$LN49@noise:
	vmovaps	xmm2, xmm7
$LN50@noise:
	cmp	edx, 4

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jae	SHORT $LN53@noise
	vmovaps	xmm0, xmm7
	jmp	SHORT $LN52@noise
$LN53@noise:
	lea	eax, DWORD PTR [rdx-12]
	test	eax, -3					; fffffffdH
	je	SHORT $LN51@noise

; 144  : 
; 145  : 	return lerp2(k, lerp2(j, lerp2(i, grad(perm[AA  ], xf  , yf  , zf   ),

	vsubss	xmm0, xmm9, xmm3

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jmp	SHORT $LN52@noise
$LN51@noise:
	vmovaps	xmm0, xmm8
$LN52@noise:

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	test	dl, 1
	je	SHORT $LN55@noise
	vxorps	xmm2, xmm2, xmm4
$LN55@noise:
	test	dl, 2
	je	SHORT $LN57@noise
	vxorps	xmm0, xmm0, xmm4
$LN57@noise:

; 82   :     int h = hash & 15;

	movzx	ecx, BYTE PTR [r8+rdi]

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	vaddss	xmm3, xmm0, xmm2
	vaddss	xmm0, xmm1, xmm10

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm1, xmm0, xmm3

; 82   :     int h = hash & 15;

	and	ecx, 15

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vmulss	xmm2, xmm1, xmm11
	vaddss	xmm13, xmm2, xmm3
	cmp	ecx, 8

; 83   :     float i = h<8 ? x : y;

	jae	SHORT $LN65@noise
	vmovaps	xmm11, xmm6
	jmp	SHORT $LN66@noise
$LN65@noise:
	vmovaps	xmm11, xmm5
$LN66@noise:
	cmp	ecx, 4

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jae	SHORT $LN69@noise
	vmovaps	xmm10, xmm5
	jmp	SHORT $LN68@noise
$LN69@noise:
	lea	eax, DWORD PTR [rcx-12]
	test	eax, -3					; fffffffdH
	je	SHORT $LN67@noise
	vmovaps	xmm10, xmm9
	jmp	SHORT $LN68@noise
$LN67@noise:
	vmovaps	xmm10, xmm6
$LN68@noise:

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	test	cl, 1
	je	SHORT $LN71@noise
	vxorps	xmm11, xmm11, xmm4
$LN71@noise:
	test	cl, 2
	je	SHORT $LN73@noise
	vxorps	xmm10, xmm10, xmm4
$LN73@noise:

; 82   :     int h = hash & 15;

	movzx	ecx, BYTE PTR [r10+rdi]
	and	ecx, 15
	cmp	ecx, 8

; 83   :     float i = h<8 ? x : y;

	jae	SHORT $LN77@noise
	vmovaps	xmm0, xmm8
	jmp	SHORT $LN78@noise
$LN77@noise:
	vmovaps	xmm0, xmm5
$LN78@noise:
	cmp	ecx, 4

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jb	SHORT $LN80@noise
	lea	eax, DWORD PTR [rcx-12]
	test	eax, -3					; fffffffdH
	je	SHORT $LN79@noise
	vmovaps	xmm5, xmm9
	jmp	SHORT $LN80@noise
$LN79@noise:
	vmovaps	xmm5, xmm8
$LN80@noise:

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	test	cl, 1
	je	SHORT $LN83@noise
	vxorps	xmm0, xmm0, xmm4
$LN83@noise:
	test	cl, 2
	je	SHORT $LN85@noise
	vxorps	xmm5, xmm5, xmm4
$LN85@noise:

; 82   :     int h = hash & 15;

	movzx	ecx, BYTE PTR [r11+rdi]
	and	ecx, 15

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	vaddss	xmm5, xmm5, xmm0
	cmp	ecx, 8

; 83   :     float i = h<8 ? x : y;

	jae	SHORT $LN91@noise
	vmovaps	xmm1, xmm6
	jmp	SHORT $LN92@noise
$LN91@noise:
	vmovaps	xmm1, xmm7
$LN92@noise:
	cmp	ecx, 4

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jae	SHORT $LN95@noise
	vmovaps	xmm6, xmm7
	jmp	SHORT $LN93@noise
$LN95@noise:
	lea	eax, DWORD PTR [rcx-12]
	test	eax, -3					; fffffffdH
	je	SHORT $LN93@noise
	vmovaps	xmm6, xmm9
$LN93@noise:

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	test	cl, 1
	je	SHORT $LN97@noise
	vxorps	xmm1, xmm1, xmm4
$LN97@noise:
	test	cl, 2
	je	SHORT $LN99@noise
	vxorps	xmm6, xmm6, xmm4
$LN99@noise:

; 82   :     int h = hash & 15;

	movzx	ecx, BYTE PTR [rbx+rdi]
	and	ecx, 15
	cmp	ecx, 8

; 83   :     float i = h<8 ? x : y;

	jae	SHORT $LN103@noise
	vmovaps	xmm0, xmm8
	jmp	SHORT $LN104@noise
$LN103@noise:
	vmovaps	xmm0, xmm7
$LN104@noise:
	cmp	ecx, 4

; 84   :     float j = h<4 ? y : h==12||h==14 ? x : z;

	jb	SHORT $LN106@noise
	lea	eax, DWORD PTR [rcx-12]
	test	eax, -3					; fffffffdH
	je	SHORT $LN105@noise
	vmovaps	xmm7, xmm9
	jmp	SHORT $LN106@noise
$LN105@noise:
	vmovaps	xmm7, xmm8
$LN106@noise:

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	test	cl, 1
	je	SHORT $LN109@noise
	vxorps	xmm0, xmm0, xmm4
$LN109@noise:
	test	cl, 2
	je	SHORT $LN111@noise
	vxorps	xmm7, xmm7, xmm4
$LN111@noise:
	vaddss	xmm3, xmm7, xmm0

; 146  : 								   grad(perm[BA  ], xf-1, yf  , zf   )),
; 147  : 						   lerp2(i, grad(perm[AB  ], xf  , yf-1, zf   ),
; 148  : 								   grad(perm[BB  ], xf-1, yf-1, zf   ))),
; 149  : 				   lerp2(j, lerp2(i, grad(perm[AA+1], xf  , yf  , zf-1 ),
; 150  : 								   grad(perm[BA+1], xf-1, yf  , zf-1 )),
; 151  : 						   lerp2(i, grad(perm[AB+1], xf  , yf-1, zf-1 ),
; 152  : 								   grad(perm[BB+1], xf-1, yf-1, zf-1 )))) * 0.936f;
; 153  : }

	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+40]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm9, XMMWORD PTR [r11-64]

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	vaddss	xmm0, xmm6, xmm1

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vmovss	xmm6, DWORD PTR i$1$[rsp]
	vsubss	xmm1, xmm0, xmm3
	vmulss	xmm2, xmm1, xmm6
	vaddss	xmm4, xmm2, xmm3

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	vaddss	xmm0, xmm10, xmm11

; 146  : 								   grad(perm[BA  ], xf-1, yf  , zf   )),
; 147  : 						   lerp2(i, grad(perm[AB  ], xf  , yf-1, zf   ),
; 148  : 								   grad(perm[BB  ], xf-1, yf-1, zf   ))),
; 149  : 				   lerp2(j, lerp2(i, grad(perm[AA+1], xf  , yf  , zf-1 ),
; 150  : 								   grad(perm[BA+1], xf-1, yf  , zf-1 )),
; 151  : 						   lerp2(i, grad(perm[AB+1], xf  , yf-1, zf-1 ),
; 152  : 								   grad(perm[BB+1], xf-1, yf-1, zf-1 )))) * 0.936f;
; 153  : }

	vmovaps	xmm10, XMMWORD PTR [r11-80]
	vmovaps	xmm11, XMMWORD PTR [r11-96]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm1, xmm0, xmm5
	vmulss	xmm2, xmm1, xmm6
	vaddss	xmm3, xmm2, xmm5
	vsubss	xmm0, xmm3, xmm4
	vmulss	xmm1, xmm0, DWORD PTR j$1$[rsp]

; 85   :     return ((h&1) ? -i : i) + ((h&2) ? -j : j);

	vaddss	xmm2, xmm12, xmm14

; 146  : 								   grad(perm[BA  ], xf-1, yf  , zf   )),
; 147  : 						   lerp2(i, grad(perm[AB  ], xf  , yf-1, zf   ),
; 148  : 								   grad(perm[BB  ], xf-1, yf-1, zf   ))),
; 149  : 				   lerp2(j, lerp2(i, grad(perm[AA+1], xf  , yf  , zf-1 ),
; 150  : 								   grad(perm[BA+1], xf-1, yf  , zf-1 )),
; 151  : 						   lerp2(i, grad(perm[AB+1], xf  , yf-1, zf-1 ),
; 152  : 								   grad(perm[BB+1], xf-1, yf-1, zf-1 )))) * 0.936f;
; 153  : }

	vmovaps	xmm12, XMMWORD PTR [r11-112]
	vmovaps	xmm14, XMMWORD PTR [rsp+16]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm0, xmm2, xmm15
	vaddss	xmm5, xmm1, xmm4
	vmulss	xmm1, xmm0, xmm6

; 146  : 								   grad(perm[BA  ], xf-1, yf  , zf   )),
; 147  : 						   lerp2(i, grad(perm[AB  ], xf  , yf-1, zf   ),
; 148  : 								   grad(perm[BB  ], xf-1, yf-1, zf   ))),
; 149  : 				   lerp2(j, lerp2(i, grad(perm[AA+1], xf  , yf  , zf-1 ),
; 150  : 								   grad(perm[BA+1], xf-1, yf  , zf-1 )),
; 151  : 						   lerp2(i, grad(perm[AB+1], xf  , yf-1, zf-1 ),
; 152  : 								   grad(perm[BB+1], xf-1, yf-1, zf-1 )))) * 0.936f;
; 153  : }

	vmovaps	xmm6, XMMWORD PTR [r11-16]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vaddss	xmm3, xmm1, xmm15

; 146  : 								   grad(perm[BA  ], xf-1, yf  , zf   )),
; 147  : 						   lerp2(i, grad(perm[AB  ], xf  , yf-1, zf   ),
; 148  : 								   grad(perm[BB  ], xf-1, yf-1, zf   ))),
; 149  : 				   lerp2(j, lerp2(i, grad(perm[AA+1], xf  , yf  , zf-1 ),
; 150  : 								   grad(perm[BA+1], xf-1, yf  , zf-1 )),
; 151  : 						   lerp2(i, grad(perm[AB+1], xf  , yf-1, zf-1 ),
; 152  : 								   grad(perm[BB+1], xf-1, yf-1, zf-1 )))) * 0.936f;
; 153  : }

	vmovaps	xmm15, XMMWORD PTR [rsp]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm2, xmm3, xmm13
	vmulss	xmm0, xmm2, DWORD PTR j$1$[rsp]
	vaddss	xmm1, xmm0, xmm13

; 146  : 								   grad(perm[BA  ], xf-1, yf  , zf   )),
; 147  : 						   lerp2(i, grad(perm[AB  ], xf  , yf-1, zf   ),
; 148  : 								   grad(perm[BB  ], xf-1, yf-1, zf   ))),
; 149  : 				   lerp2(j, lerp2(i, grad(perm[AA+1], xf  , yf  , zf-1 ),
; 150  : 								   grad(perm[BA+1], xf-1, yf  , zf-1 )),
; 151  : 						   lerp2(i, grad(perm[AB+1], xf  , yf-1, zf-1 ),
; 152  : 								   grad(perm[BB+1], xf-1, yf-1, zf-1 )))) * 0.936f;
; 153  : }

	vmovaps	xmm13, XMMWORD PTR [r11-128]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm3, xmm1, xmm5
	vmulss	xmm2, xmm3, DWORD PTR k$1$[rsp]
	vaddss	xmm0, xmm2, xmm5

; 144  : 
; 145  : 	return lerp2(k, lerp2(j, lerp2(i, grad(perm[AA  ], xf  , yf  , zf   ),

	vmulss	xmm0, xmm0, DWORD PTR __real@3f6f9db2

; 146  : 								   grad(perm[BA  ], xf-1, yf  , zf   )),
; 147  : 						   lerp2(i, grad(perm[AB  ], xf  , yf-1, zf   ),
; 148  : 								   grad(perm[BB  ], xf-1, yf-1, zf   ))),
; 149  : 				   lerp2(j, lerp2(i, grad(perm[AA+1], xf  , yf  , zf-1 ),
; 150  : 								   grad(perm[BA+1], xf-1, yf  , zf-1 )),
; 151  : 						   lerp2(i, grad(perm[AB+1], xf  , yf-1, zf-1 ),
; 152  : 								   grad(perm[BB+1], xf-1, yf-1, zf-1 )))) * 0.936f;
; 153  : }

	mov	rsp, r11
	pop	rdi
	ret	0
?noise@Perlin@@SAMMMM@Z ENDP				; Perlin::noise
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?noise@Perlin@@SAMMM@Z
_TEXT	SEGMENT
x$ = 128
y$ = 136
?noise@Perlin@@SAMMM@Z PROC				; Perlin::noise, COMDAT

; 109  : float Perlin::noise(float x, float y) {    

$LN54:
	sub	rsp, 120				; 00000078H
	vmovaps	XMMWORD PTR [rsp+96], xmm6
	vmovaps	XMMWORD PTR [rsp+80], xmm7
	vmovaps	XMMWORD PTR [rsp+64], xmm8
	vmovaps	XMMWORD PTR [rsp+48], xmm9
	vmovaps	XMMWORD PTR [rsp+32], xmm10
	vmovaps	xmm2, xmm1
	vxorps	xmm1, xmm1, xmm1

; 110  :     int xi = FASTFLOOR(x);

	vcomiss	xmm1, xmm0
	vmovaps	XMMWORD PTR [rsp+16], xmm11
	vmovaps	XMMWORD PTR [rsp], xmm12
	vmovaps	xmm3, xmm0
	vcvttss2si ecx, xmm0
	jbe	SHORT $LN4@noise
	dec	ecx
$LN4@noise:

; 111  : 	int yi = FASTFLOOR(y);

	vcomiss	xmm1, xmm2
	vcvttss2si eax, xmm2
	jbe	SHORT $LN6@noise
	dec	eax
$LN6@noise:
	vxorps	xmm0, xmm0, xmm0

; 112  :     float xf0 = x - xi;

	vcvtsi2ss xmm0, xmm0, ecx
	vsubss	xmm9, xmm3, xmm0

; 113  :     float yf0 = y - yi;
; 114  :     float xf1 = xf0 - 1.0f;
; 115  :     float yf1 = yf0 - 1.0f;
; 116  :     xi = xi & 255;
; 117  :     yi = yi & 255;       
; 118  :     float i = FADE(xf0);

	vmulss	xmm0, xmm9, DWORD PTR __real@40c00000
	vsubss	xmm0, xmm0, DWORD PTR __real@41700000
	vsubss	xmm8, xmm9, DWORD PTR __real@3f800000
	movzx	edx, al

; 120  : 	int A = perm[xi  ] + yi;

	lea	r10, OFFSET FLAT:?perm@@3PAEA
	vxorps	xmm1, xmm1, xmm1
	vcvtsi2ss xmm1, xmm1, eax
	vsubss	xmm7, xmm2, xmm1
	vsubss	xmm6, xmm7, DWORD PTR __real@3f800000
	vmulss	xmm1, xmm0, xmm9
	vaddss	xmm2, xmm1, DWORD PTR __real@41200000
	movzx	ecx, cl
	vmulss	xmm0, xmm9, xmm9
	vmulss	xmm1, xmm0, xmm9
	vmulss	xmm11, xmm2, xmm1
	vmulss	xmm2, xmm7, DWORD PTR __real@40c00000
	vsubss	xmm0, xmm2, DWORD PTR __real@41700000
	movzx	r8d, BYTE PTR [rcx+r10]

; 121  : 	int B = perm[xi+1] + yi;

	lea	eax, DWORD PTR [rcx+1]
	movzx	r9d, BYTE PTR [rax+r10]
	add	r8d, edx
	add	r9d, edx
	vmulss	xmm1, xmm0, xmm7
	vaddss	xmm3, xmm1, DWORD PTR __real@41200000
	vmulss	xmm2, xmm7, xmm7

; 122  : 
; 123  :     return lerp2(j, lerp2(i, grad(perm[A  ], xf0, yf0),

	lea	eax, DWORD PTR [r9+1]

; 75   :     int h = hash & 7;

	movzx	eax, BYTE PTR [rax+r10]
	and	eax, 7

; 119  : 	float j = FADE(yf0);

	vmulss	xmm0, xmm2, xmm7
	vmulss	xmm12, xmm3, xmm0
	cmp	eax, 4

; 76   :     float i = h<4 ? x : y;

	jae	SHORT $LN9@noise
	vmovaps	xmm5, xmm8
	jmp	SHORT $LN10@noise
$LN9@noise:
	vmovaps	xmm5, xmm6
$LN10@noise:
	cmp	eax, 4

; 77   :     float j = h<4 ? y : x;

	jae	SHORT $LN11@noise
	vmovaps	xmm0, xmm6
	jmp	SHORT $LN12@noise
$LN11@noise:
	vmovaps	xmm0, xmm8
$LN12@noise:

; 78   :     return ((h&1)? -i : i) + ((h&2)? -2.f*j : 2.f*j);

	vmovss	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	test	al, 1
	je	SHORT $LN13@noise
	vxorps	xmm5, xmm5, xmm3
$LN13@noise:
	vmovss	xmm2, DWORD PTR __real@c0000000
	test	al, 2
	je	SHORT $LN15@noise
	vmulss	xmm10, xmm0, xmm2
	jmp	SHORT $LN16@noise
$LN15@noise:
	vaddss	xmm10, xmm0, xmm0
$LN16@noise:

; 122  : 
; 123  :     return lerp2(j, lerp2(i, grad(perm[A  ], xf0, yf0),

	lea	eax, DWORD PTR [r8+1]

; 75   :     int h = hash & 7;

	movzx	eax, BYTE PTR [rax+r10]
	and	eax, 7
	cmp	eax, 4

; 76   :     float i = h<4 ? x : y;

	jae	SHORT $LN19@noise
	vmovaps	xmm0, xmm9
	jmp	SHORT $LN20@noise
$LN19@noise:
	vmovaps	xmm0, xmm6
$LN20@noise:
	cmp	eax, 4

; 77   :     float j = h<4 ? y : x;

	jb	SHORT $LN22@noise
	vmovaps	xmm6, xmm9
$LN22@noise:

; 78   :     return ((h&1)? -i : i) + ((h&2)? -2.f*j : 2.f*j);

	test	al, 1
	je	SHORT $LN23@noise
	vxorps	xmm0, xmm0, xmm3
$LN23@noise:
	test	al, 2
	je	SHORT $LN25@noise
	vmulss	xmm1, xmm6, xmm2
	jmp	SHORT $LN26@noise
$LN25@noise:
	vaddss	xmm1, xmm6, xmm6
$LN26@noise:

; 75   :     int h = hash & 7;

	movzx	ecx, BYTE PTR [r9+r10]
	and	ecx, 7

; 78   :     return ((h&1)? -i : i) + ((h&2)? -2.f*j : 2.f*j);

	vaddss	xmm6, xmm1, xmm0
	cmp	ecx, 4

; 76   :     float i = h<4 ? x : y;

	jae	SHORT $LN31@noise
	vmovaps	xmm1, xmm8
	jmp	SHORT $LN32@noise
$LN31@noise:
	vmovaps	xmm1, xmm7
$LN32@noise:
	cmp	ecx, 4

; 77   :     float j = h<4 ? y : x;

	jae	SHORT $LN33@noise
	vmovaps	xmm8, xmm7
$LN33@noise:

; 78   :     return ((h&1)? -i : i) + ((h&2)? -2.f*j : 2.f*j);

	test	cl, 1
	je	SHORT $LN35@noise
	vxorps	xmm1, xmm1, xmm3
$LN35@noise:
	test	cl, 2
	je	SHORT $LN37@noise
	vmulss	xmm4, xmm8, xmm2
	jmp	SHORT $LN38@noise
$LN37@noise:
	vaddss	xmm4, xmm8, xmm8
$LN38@noise:

; 75   :     int h = hash & 7;

	movzx	ecx, BYTE PTR [r8+r10]
	and	ecx, 7
	cmp	ecx, 4

; 76   :     float i = h<4 ? x : y;

	jae	SHORT $LN41@noise
	vmovaps	xmm0, xmm9
	jmp	SHORT $LN42@noise
$LN41@noise:
	vmovaps	xmm0, xmm7
$LN42@noise:
	cmp	ecx, 4

; 77   :     float j = h<4 ? y : x;

	jb	SHORT $LN44@noise
	vmovaps	xmm7, xmm9
$LN44@noise:

; 78   :     return ((h&1)? -i : i) + ((h&2)? -2.f*j : 2.f*j);

	test	cl, 1
	je	SHORT $LN45@noise
	vxorps	xmm0, xmm0, xmm3
$LN45@noise:
	test	cl, 2
	je	SHORT $LN47@noise
	vmulss	xmm3, xmm7, xmm2
	jmp	SHORT $LN48@noise
$LN47@noise:
	vaddss	xmm3, xmm7, xmm7
$LN48@noise:

; 124  : 		                   grad(perm[B  ], xf1, yf0)),
; 125  : 		           lerp2(i, grad(perm[A+1], xf0, yf1),
; 126  : 		                   grad(perm[B+1], xf1, yf1))) * 0.507f;
; 127  : }

	vmovaps	xmm7, XMMWORD PTR [rsp+80]
	vmovaps	xmm8, XMMWORD PTR [rsp+64]
	vmovaps	xmm9, XMMWORD PTR [rsp+48]

; 78   :     return ((h&1)? -i : i) + ((h&2)? -2.f*j : 2.f*j);

	vaddss	xmm3, xmm3, xmm0
	vaddss	xmm0, xmm4, xmm1

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm1, xmm0, xmm3
	vmulss	xmm2, xmm1, xmm11
	vaddss	xmm4, xmm2, xmm3

; 78   :     return ((h&1)? -i : i) + ((h&2)? -2.f*j : 2.f*j);

	vaddss	xmm0, xmm10, xmm5

; 124  : 		                   grad(perm[B  ], xf1, yf0)),
; 125  : 		           lerp2(i, grad(perm[A+1], xf0, yf1),
; 126  : 		                   grad(perm[B+1], xf1, yf1))) * 0.507f;
; 127  : }

	vmovaps	xmm10, XMMWORD PTR [rsp+32]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm1, xmm0, xmm6
	vmulss	xmm2, xmm1, xmm11

; 124  : 		                   grad(perm[B  ], xf1, yf0)),
; 125  : 		           lerp2(i, grad(perm[A+1], xf0, yf1),
; 126  : 		                   grad(perm[B+1], xf1, yf1))) * 0.507f;
; 127  : }

	vmovaps	xmm11, XMMWORD PTR [rsp+16]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vaddss	xmm3, xmm2, xmm6

; 124  : 		                   grad(perm[B  ], xf1, yf0)),
; 125  : 		           lerp2(i, grad(perm[A+1], xf0, yf1),
; 126  : 		                   grad(perm[B+1], xf1, yf1))) * 0.507f;
; 127  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+96]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm0, xmm3, xmm4
	vmulss	xmm1, xmm0, xmm12

; 124  : 		                   grad(perm[B  ], xf1, yf0)),
; 125  : 		           lerp2(i, grad(perm[A+1], xf0, yf1),
; 126  : 		                   grad(perm[B+1], xf1, yf1))) * 0.507f;
; 127  : }

	vmovaps	xmm12, XMMWORD PTR [rsp]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vaddss	xmm2, xmm1, xmm4

; 122  : 
; 123  :     return lerp2(j, lerp2(i, grad(perm[A  ], xf0, yf0),

	vmulss	xmm0, xmm2, DWORD PTR __real@3f01cac1

; 124  : 		                   grad(perm[B  ], xf1, yf0)),
; 125  : 		           lerp2(i, grad(perm[A+1], xf0, yf1),
; 126  : 		                   grad(perm[B+1], xf1, yf1))) * 0.507f;
; 127  : }

	add	rsp, 120				; 00000078H
	ret	0
?noise@Perlin@@SAMMM@Z ENDP				; Perlin::noise
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File g:\dropbox\github\berconmaps\src\perlin.cpp
;	COMDAT ?noise@Perlin@@SAMM@Z
_TEXT	SEGMENT
x$ = 48
?noise@Perlin@@SAMM@Z PROC				; Perlin::noise, COMDAT

; 98   : float Perlin::noise(float x) {    

$LN14:
	sub	rsp, 40					; 00000028H
	vxorps	xmm1, xmm1, xmm1

; 99   :     int ix0 = FASTFLOOR(x);		

	vcomiss	xmm1, xmm0
	vmovaps	XMMWORD PTR [rsp+16], xmm6
	vmovaps	XMMWORD PTR [rsp], xmm7
	vmovaps	xmm2, xmm0
	vcvttss2si eax, xmm0
	jbe	SHORT $LN4@noise
	dec	eax
$LN4@noise:

; 100  : 	int ix1 = (ix0+1) & 255;
; 101  :     float xf0 = x - ix0;
; 102  : 	float xf1 = xf0 - 1.0f;   

	vmovss	xmm5, DWORD PTR __real@3f800000
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vsubss	xmm4, xmm2, xmm0

; 103  : 	ix0 = ix0 & 0xff;    // Wrap to 0..255
; 104  :     float s = FADE(xf0);

	vmulss	xmm0, xmm4, DWORD PTR __real@40c00000
	vsubss	xmm1, xmm0, DWORD PTR __real@41700000
	movzx	r8d, al

; 105  :     return lerp2(s, grad(perm[ix0], xf0),

	lea	r9, OFFSET FLAT:?perm@@3PAEA
	inc	eax
	movzx	ecx, al
	vmulss	xmm2, xmm1, xmm4
	vaddss	xmm3, xmm2, DWORD PTR __real@41200000
	vmulss	xmm0, xmm4, xmm4

; 68   :     int h = hash & 15;

	movzx	edx, BYTE PTR [rcx+r9]

; 103  : 	ix0 = ix0 & 0xff;    // Wrap to 0..255
; 104  :     float s = FADE(xf0);

	vmulss	xmm1, xmm0, xmm4

; 68   :     int h = hash & 15;

	and	edx, 15

; 69   :     float grad = 1.0f + (h & 7);

	mov	eax, edx
	and	eax, 7
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax

; 103  : 	ix0 = ix0 & 0xff;    // Wrap to 0..255
; 104  :     float s = FADE(xf0);

	vmulss	xmm7, xmm3, xmm1

; 70   :     if (h&8) grad = -grad;

	vmovss	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	vaddss	xmm2, xmm0, xmm5

; 100  : 	int ix1 = (ix0+1) & 255;
; 101  :     float xf0 = x - ix0;
; 102  : 	float xf1 = xf0 - 1.0f;   

	vsubss	xmm6, xmm4, xmm5

; 70   :     if (h&8) grad = -grad;

	test	dl, 8
	je	SHORT $LN6@noise
	vxorps	xmm2, xmm2, xmm3
$LN6@noise:

; 68   :     int h = hash & 15;

	movzx	ecx, BYTE PTR [r8+r9]
	and	ecx, 15

; 69   :     float grad = 1.0f + (h & 7);

	mov	eax, ecx
	and	eax, 7
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, eax
	vaddss	xmm1, xmm0, xmm5

; 70   :     if (h&8) grad = -grad;

	test	cl, 8
	je	SHORT $LN9@noise
	vxorps	xmm1, xmm1, xmm3
$LN9@noise:

; 71   :     return ( grad * x );

	vmulss	xmm0, xmm2, xmm6

; 106  : 				   grad(perm[ix1], xf1)) * 0.188f;
; 107  : }

	vmovaps	xmm6, XMMWORD PTR [rsp+16]

; 71   :     return ( grad * x );

	vmulss	xmm3, xmm1, xmm4

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vsubss	xmm1, xmm0, xmm3
	vmulss	xmm2, xmm1, xmm7

; 106  : 				   grad(perm[ix1], xf1)) * 0.188f;
; 107  : }

	vmovaps	xmm7, XMMWORD PTR [rsp]

; 63   : float lerp2(float t, float a,float b) {return a+t*(b-a);}

	vaddss	xmm3, xmm2, xmm3

; 105  :     return lerp2(s, grad(perm[ix0], xf0),

	vmulss	xmm0, xmm3, DWORD PTR __real@3e408312

; 106  : 				   grad(perm[ix1], xf1)) * 0.188f;
; 107  : }

	add	rsp, 40					; 00000028H
	ret	0
?noise@Perlin@@SAMM@Z ENDP				; Perlin::noise
_TEXT	ENDS
END
